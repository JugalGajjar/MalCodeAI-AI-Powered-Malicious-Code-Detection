{
    "sql_0": {
        "input": "<reponame>Dragontalker/MySQL-study-notes\n#\u89c6\u56fe\n\n/*\n\u542b\u4e49: \u865a\u62df\u8868, \u548c\u666e\u901a\u8868\u4e00\u6837\u4f7f\u7528\nmysql5.1\u7248\u672c\u51fa\u73b0\u7684\u65b0\u7279\u6027, \u662f\u901a\u8fc7\u8868\u52a8\u6001\u751f\u6210\u7684\u6570\u636e\n\n\u6bd4\u5982: \u821e\u8e48\u73ed\u548c\u666e\u901a\u73ed\u7684\u5bf9\u6bd4\n\n\t\t\u521b\u5efa\u8bed\u6cd5\u7684\u5173\u952e\u5b57\t\u662f\u5426\u5b9e\u9645\u5360\u7528\u7269\u7406\u7a7a\u95f4\t\t\u4f7f\u7528\n\u89c6\u56fe\t\tcreate table\t \u53ea\u4fdd\u5b58\u4e86sql\u903b\u8f91\t\t\u589e\u5220\u6539\u67e5, \u4e00\u822c\u4e0d\u80fd\u589e\u5220\u6539\n\u8868\t\tcreate view\t\t   \u4fdd\u51c6\u4e86\u6570\u636eALTER\t\u589e\u5220\u6539\u67e5\n*/\n\n#\u6848\u4f8b: \u67e5\u8be2\u59d3\u5f20\u7684\u5b66\u751f\u540d\u548c\u4e13\u4e1a\u540d\nSELECT stuname, major_name\nFROM stuinfo AS s\nINNER JOIN major AS m \nON s.major_id = m.id\nWHERE s.stuname LIKE '%\u5f20';\n\n#\u521b\u5efa\u89c6\u56fe\nCREATE VIEW v1\nAS\nSELECT stuname, major_name\nFROM stuinfo AS s\nINNER JOIN major AS m\nON s.major_id = m.id;\n\n#\u4f7f\u7528\u89c6\u56fe\nSELECT * FROM v1 WHERE s.stuname LIKE '%\u5f20';\n\n#\u4e00\u3001\u521b\u5efa\u89c6\u56fe\n/*\n\u8bed\u6cd5:\ncreate view \u89c6\u56fe\u540d\nas\n\u67e5\u8be2\u8bed\u53e5;\n*/\n\n#1. \u67e5\u8be2\u59d3\u540d\u4e2d\u5305\u542ba\u5b57\u7b26\u7684\u5458\u5de5\u540d\u3001\u90e8\u95e8\u540d\u548c\u5de5\u79cd\u65b0\u6d88\u606f\n#(1)\u521b\u5efa\nCREATE VIEW myv1\nAS\nSELECT last_name, department_name, job_title\nFROM employees AS e\nJOIN departments AS d\nON e.department_id = d.department_id\nJOIN jobs AS j\nON j.job_id = e.job_id;\n\n#(2)\u4f7f\u7528\nSELECT *\nFROM myv1\nWHERE last_name LIKE '%a%';\n\n#2. \u67e5\u8be2\u5404\u90e8\u95e8\u7684\u5e73\u5747\u5de5\u8d44\u7ea7\u522b\n#(1)\u521b\u5efa\u89c6\u56fe\u67e5\u770b\u6bcf\u4e2a\u90e8\u95e8\u7684\u5e73\u5747\u5de5\u8d44\nCREATE VIEW myv2\nAS\nSELECT AVG(salary) AS ag, department_id\nFROM employees\nGROUP BY department_id;\n\n#(2)\u4f7f\u7528\nSELECT myv2.ag, g.grade_level \nFROM myv2\nJOIN job_grades AS g\nON myv2.ag BETWEEN g.lowest_sal AND g.highest_sal;\n\n#3. \u67e5\u8be2\u5e73\u5747\u5de5\u8d44\u6700\u4f4e\u7684\u90e8\u95e8\u4fe1\u606f\nSELECT * \nFROM myv2\nORDER BY ag\nLIMIT 1;\n\n#4. \u67e5\u8be2\u5e73\u5747\u5de5\u8d44\u6700\u4f4e\u7684\u90e8\u95e8\u540d\u548c\u5de5\u8d44\nCREATE VIEW myv3\nAS\nSELECT * \nFROM myv2\nORDER BY ag\nLIMIT 1;\n\nSELECT d.*, m.ag\nFROM myv3 AS m\nJOIN departments AS d\nON m.department_id = d.department_id;\n\n#\u4e8c\u3001\u89c6\u56fe\u7684\u4fee\u6539\n/*\n\u65b9\u5f0f\u4e00:\ncreate or replace view \u89c6\u56fe\u540d\nas\n\u67e5\u8be2\u8bed\u53e5;\n*/\n\nSELECT * FROM myv3;\n\nCREATE OR REPLACE VIEW myv3\nAS\nSELECT AVG(salary), job_id\nFROM employees\nGROUP BY job_id;\n\n/*\n\u65b9\u5f0f\u4e8c:\n\u8bed\u6cd5:\nalter view \u89c6\u56fe\u540d\nas\n\u67e5\u8be2\u8bed\u53e5;\n*/\n\nALTER VIEW myv3\nAS\nSELECT * FROM myv2;\n\n#\u4e09\u3001\u5220\u9664\u89c6\u56fe\n\n/*\n\u8bed\u6cd5: drop view \u89c6\u56fe\u540d1, \u89c6\u56fe\u540d2, ...;\n*/\n\nDROP VIEW myv1, myv2, myv3;\n\n#\u56db\u3001\u67e5\u770b\u89c6\u56fe\nDESC myv1;\n\nSHOW CREATE VIEW myv1;\n\n#\u4e94\u3001\u89c6\u56fe\u7684\u66f4\u65b0\nCREATE OR REPLACE VIEW myv1\nAS\nSELECT last_name, email, salary*12*(1+IFNULL(commission_pct, 0)) AS \"annual salary\"\nFROM employees;\n\nCREATE OR REPLACE VIEW myv1\nAS\nSELECT last_name, email\nFROM employees;\n\nSELECT * FROM myv1;\n\n#1. \u63d2\u5165\nINSERT INTO myv1\nVALUES ('\u5f20\u98de', '<EMAIL>');\n\n#2. \u4fee\u6539\nUPDATE myv1\nSET last_name = '\u5f20\u65e0\u5fcc'\nWHERE last_name = '\u5f20\u98de';\n\n#3. \u5220\u9664\nDELETE FROM myv1\nWHERE last_name = '\u5f20\u65e0\u5fcc';\n\n#\u5177\u5907\u4ee5\u4e0b\u7279\u70b9\u7684\u89c6\u56fe\u4e0d\u5141\u8bb8\u66f4\u65b0\n/*\n(1)\u5305\u542b\u4ee5\u4e0b\u5173\u952e\u5b57\u7684slq\u8bed\u53e5\n\t- \u5206\u7ec4\u51fd\u6570\n    - distinct\n    - group by\n    - having\n    - union\n    - union all\n*/\n\nCREATE OR REPLACE VIEW myv1\nAS\nSELECT MAX(salary) as m, department_id\nFROM employees\nGROUP BY department_id;\n\nSELECT * FROM myv1;\n\n#\u66f4\u65b0\nUPDATE myv1 \nSET m = 9000\nWHERE department_id = 10;\n\n#(2)\u5e38\u91cf\u89c6\u56fe\nCREATE OR REPLACE VIEW myv2\nAS\nSELECT 'john' NAME;\n\nUPDATE myv2\nSET NAME = 'lucy';",
        "output": "{\n  \"output\": {\n    \"database_system\": \"MySQL\",\n    \"components\": [\n      {\n        \"component_type\": \"QUERY\",\n        \"component_name\": null,\n        \"component_code\": \"SELECT stuname, major_name FROM stuinfo AS s INNER JOIN major AS m ON s.major_id = m.id WHERE s.stuname LIKE '%\u5f20';\",\n        \"component_description\": \"This query retrieves the names and major names of students whose names start with '\u5f20' by joining the `stuinfo` table with the `major` table on their respective IDs.\"\n      },\n      {\n        \"component_type\": \"VIEW\",\n        \"component_name\": \"v1\",\n        \"component_code\": \"CREATE VIEW v1 AS SELECT stuname, major_name FROM stuinfo AS s INNER JOIN major AS m ON s.major_id = m.id;\",\n        \"component_description\": \"This view dynamically generates a virtual table containing student names and their respective major names by joining the `stuinfo` table with the `major` table on their IDs.\"\n      },\n      {\n        \"component_type\": \"QUERY\",\n        \"component_name\": null,\n        \"component_code\": \"SELECT * FROM v1 WHERE s.stuname LIKE '%\u5f20';\",\n        \"component_description\": \"This query retrieves all columns from the view `v1` where student names start with '\u5f20'.\"\n      },\n      {\n        \"component_type\": \"VIEW\",\n        \"component_name\": \"myv1\",\n        \"component_code\": \"CREATE VIEW myv1 AS SELECT last_name, department_name, job_title FROM employees AS e JOIN departments AS d ON e.department_id = d.department_id JOIN jobs AS j ON j.job_id = e.job_id;\",\n        \"component_description\": \"This view dynamically generates a virtual table containing employee last names, their department names, and job titles by joining the `employees`, `departments`, and `jobs` tables.\"\n      },\n      {\n        \"component_type\": \"QUERY\",\n        \"component_name\": null,\n        \"component_code\": \"SELECT * FROM myv1 WHERE last_name LIKE '%a%';\",\n        \"component_description\": \"This query retrieves all columns from the view `myv1` where employee last names contain the character 'a'.\"\n      },\n      {\n        \"component_type\": \"VIEW\",\n        \"component_name\": \"myv2\",\n        \"component_code\": \"CREATE VIEW myv2 AS SELECT AVG(salary) AS ag, department_id FROM employees GROUP BY department_id;\",\n        \"component_description\": \"This view dynamically generates a virtual table containing the average salary (`ag`) and department ID for each department by grouping the `employees` table data.\"\n      },\n      {\n        \"component_type\": \"QUERY\",\n        \"component_name\": null,\n        \"component_code\": \"SELECT myv2.ag, g.grade_level FROM myv2 JOIN job_grades AS g ON myv2.ag BETWEEN g.lowest_sal AND g.highest_sal;\",\n        \"component_description\": \"This query retrieves the average salary and corresponding grade level by joining the `myv2` view with the `job_grades` table based on salary ranges.\"\n      },\n      {\n        \"component_type\": \"QUERY\",\n        \"component_name\": null,\n        \"component_code\": \"SELECT * FROM myv2 WHERE department_id = 10;\",\n        \"component_description\": \"This query retrieves all columns from the view `myv2` for the department with ID 10.\"\n      },\n      {\n        \"component_type\": \"VIEW\",\n        \"component_name\": \"myv3\",\n        \"component_code\": \"CREATE VIEW myv3 AS SELECT MAX(salary) as m, department_id FROM employees GROUP BY department_id;\",\n        \"component_description\": \"This view dynamically generates a virtual table containing the maximum salary (`m`) and department ID for each department by grouping the `employees` table data.\"\n      },\n      {\n        \"component_type\": \"QUERY\",\n        \"component_name\": null,\n        \"component_code\": \"SELECT * FROM myv3 WHERE department_id = 10;\",\n        \"component_description\": \"This query retrieves all columns from the view `myv3` for the department with ID 10.\"\n      },\n      {\n        \"component_type\": \"VIEW\",\n        \"component_name\": \"myv1\",\n        \"component_code\": \"CREATE OR REPLACE VIEW myv1 AS SELECT last_name, email, salary*12*(1+IFNULL(commission_pct, 0)) AS \\\"annual salary\\\" FROM employees;\",\n        \"component_description\": \"This view dynamically generates a virtual table containing employee last names, emails, and calculated annual salaries based on their monthly salaries and commission percentages.\"\n      },\n      {\n        \"component_type\": \"VIEW\",\n        \"component_name\": \"myv1\",\n        \"component_code\": \"CREATE OR REPLACE VIEW myv1 AS SELECT last_name, email FROM employees;\",\n        \"component_description\": \"This view dynamically generates a virtual table containing employee last names and emails by selecting from the `employees` table.\"\n      },\n      {\n        \"component_type\": \"INSERT\",\n        \"component_name\": null,\n        \"component_code\": \"INSERT INTO myv1 VALUES ('\u5f20\u98de', '<EMAIL>');\",\n        \"component_description\": \"This statement inserts a new record into the view `myv1` with the last name '\u5f20\u98de' and email '<EMAIL>'.\"\n      },\n      {\n        \"component_type\": \"UPDATE\",\n        \"component_name\": null,\n        \"component_code\": \"UPDATE myv1 SET last_name = '\u5f20\u65e0\u5fcc' WHERE last_name = '\u5f20\u98de';\",\n        \"component_description\": \"This statement updates the `myv1` view to change the last name from '\u5f20\u98de' to '\u5f20\u65e0\u5fcc'.\"\n      },\n      {\n        \"component_type\": \"DELETE\",\n        \"component_name\": null,\n        \"component_code\": \"DELETE FROM myv1 WHERE last_name = '\u5f20\u65e0\u5fcc';\",\n        \"component_description\": \"This statement deletes records from the `myv1` view where the last name is '\u5f20\u65e0\u5fcc'.\"\n      },\n      {\n        \"component_type\": \"VIEW\",\n        \"component_name\": \"myv2\",\n        \"component_code\": \"CREATE OR REPLACE VIEW myv2 AS SELECT 'john' NAME;\",\n        \"component_description\": \"This view dynamically generates a virtual table containing the constant name 'john'.\"\n      },\n      {\n        \"component_type\": \"UPDATE\",\n        \"component_name\": null,\n        \"component_code\": \"UPDATE myv2 SET NAME = 'lucy';\",\n        \"component_description\": \"This statement attempts to update the `myv2` view to change the constant name from 'john' to 'lucy'.\"\n      },\n      {\n        \"component_type\": \"DROP\",\n        \"component_name\": null,\n        \"component_code\": \"DROP VIEW myv1, myv2, myv3;\",\n        \"component_description\": \"This statement drops the views `myv1`, `myv2`, and `myv3` from the database.\"\n      }\n    ],\n    \"overall_description\": \"The provided SQL script demonstrates various operations related to MySQL views including creating, querying, updating, deleting, and dropping views. It also shows examples of when updates are not allowed on certain types of views.\"\n  }\n}"
    },
    "sql_3": {
        "input": "CREATE TABLE payload (name text, value blob)\nCREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT)\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"GENERAL_SQL\",\n    \"components\": [\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"payload\",\n        \"component_code\": \"CREATE TABLE payload (name text, value blob)\",\n        \"component_description\": \"This component defines a table named 'payload' with two columns: 'name' of type text and 'value' of type blob. This table is used to store textual names associated with binary data values.\"\n      },\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"searchIndex\",\n        \"component_code\": \"CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT)\",\n        \"component_description\": \"This component defines a table named 'searchIndex' with four columns: 'id' which is an integer serving as the primary key, 'name' of type text, 'type' of type text, and 'path' of type text. This table is used to store indexed search information including unique identifiers, names, types, and paths.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script defines two tables: 'payload' for storing textual names with associated binary data values, and 'searchIndex' for storing indexed search information with unique identifiers, names, types, and paths. These tables are likely used in an application that requires storage of both unstructured binary data and structured searchable metadata.\"\n  }\n}"
    },
    "sql_4": {
        "input": "<filename>sql-file.sql\nCREATE DATABASE IF NOT EXISTS user;\n\nUSE user;\n\nCREATE TABLE IF NOT EXISTS `users` (\n\tuser_id int(11) NOT NULL AUTO_INCREMENT,\n\tuser_email varchar(50) NOT NULL,\n\tuser_pass varchar(32) NOT NULL,\n\tuser_fname varchar(50) NOT NULL,\n\tCONSTRAINT PK_user_id PRIMARY KEY(user_id),\n\tCONSTRAINT UK_user_email UNIQUE(user_email)\n);\n\nINSERT INTO users VALUES(1, '<EMAIL>', MD5('123456'), '<NAME>');",
        "output": "{\n  \"output\": {\n    \"database_system\": \"MySQL\",\n    \"components\": [\n      {\n        \"component_type\": \"DATABASE_DEFINITION\",\n        \"component_name\": \"user\",\n        \"component_code\": \"CREATE DATABASE IF NOT EXISTS user;\",\n        \"component_description\": \"Creates a new database named 'user' if it does not already exist. This is the logical container for all tables, views, and other database objects.\"\n      },\n      {\n        \"component_type\": \"DATABASE_SELECTION\",\n        \"component_name\": null,\n        \"component_code\": \"USE user;\",\n        \"component_description\": \"Selects the 'user' database as the default database to be used for subsequent operations in the session.\"\n      },\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"users\",\n        \"component_code\": \"CREATE TABLE IF NOT EXISTS `users` (\\n\\tuser_id int(11) NOT NULL AUTO_INCREMENT,\\n\\tuser_email varchar(50) NOT NULL,\\n\\tuser_pass varchar(32) NOT NULL,\\n\\tuser_fname varchar(50) NOT NULL,\\n\\tCONSTRAINT PK_user_id PRIMARY KEY(user_id),\\n\\tCONSTRAINT UK_user_email UNIQUE(user_email)\\n);\",\n        \"component_description\": \"Creates a new table named 'users' with four columns: user_id, user_email, user_pass, and user_fname. The user_id is an auto-incrementing primary key ensuring each user has a unique identifier. The user_email column must contain unique values to prevent duplicate entries.\"\n      },\n      {\n        \"component_type\": \"DATA_INSERTION\",\n        \"component_name\": null,\n        \"component_code\": \"INSERT INTO users VALUES(1, '<EMAIL>', MD5('123456'), '<NAME>');\",\n        \"component_description\": \"Inserts a new row into the 'users' table with specific values for each column. The user_id is explicitly set to 1, user_email is set to '<EMAIL>', user_pass is the MD5 hash of the password '123456', and user_fname is set to '<NAME>'.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script initializes a database named 'user' and defines a table within it called 'users' to store user information. It ensures that each user has a unique identifier (user_id) and email address. The script also inserts an initial record into the 'users' table representing a single user.\"\n  }\n}"
    },
    "sql_7": {
        "input": "--\r\n-- Name: test_get_data_single(integer, text, refcursor, text); Type: PROCEDURE; Schema: public; Owner: d3l243\r\n--\r\n\r\nCREATE OR REPLACE PROCEDURE public.test_get_data_single(_itemid integer, INOUT _message text DEFAULT ''::text, INOUT _result_one refcursor DEFAULT 'rs_resultone'::refcursor, INOUT _returncode text DEFAULT ''::text)\r\n    LANGUAGE plpgsql\r\n    AS $$\r\nBEGIN\r\n    _message := 'Test message for item ' || COALESCE(_itemID, 0);\r\n    _returnCode := '';\r\n\r\n  open _result_one for \r\n    SELECT * \r\n    FROM (values (1,2,3, 'fruit', current_timestamp - INTERVAL '5 seconds'), \r\n                 (4,5,6, 'veggie', current_timestamp)) as t(a,b,c,d,e);\r\n\r\nEND;\r\n$$;\r\n\r\n\r\nALTER PROCEDURE public.test_get_data_single(_itemid integer, INOUT _message text, INOUT _result_one refcursor, INOUT _returncode text) OWNER TO d3l243;\r\n\r\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"PostgreSQL\",\n    \"components\": [\n      {\n        \"component_type\": \"STORED_PROCEDURE\",\n        \"component_name\": \"test_get_data_single\",\n        \"component_code\": \"CREATE OR REPLACE PROCEDURE public.test_get_data_single(_itemid integer, INOUT _message text DEFAULT ''::text, INOUT _result_one refcursor DEFAULT 'rs_resultone'::refcursor, INOUT _returncode text DEFAULT ''::text)\\n    LANGUAGE plpgsql\\n    AS $$\\nBEGIN\\n    _message := 'Test message for item ' || COALESCE(_itemID, 0);\\n    _returnCode := '';\\n\\n  open _result_one for \\n    SELECT * \\n    FROM (values (1,2,3, 'fruit', current_timestamp - INTERVAL '5 seconds'), \\n                 (4,5,6, 'veggie', current_timestamp)) as t(a,b,c,d,e);\\n\\nEND;\\n$$;\",\n        \"component_description\": \"This stored procedure in PostgreSQL takes an integer parameter _itemid and three INOUT parameters: _message, _result_one, and _returncode. It sets a test message based on the item ID and initializes the return code to an empty string. It then opens a cursor named _result_one that contains two rows of sample data with columns 'a', 'b', 'c', 'd', and 'e'.\"\n      },\n      {\n        \"component_type\": \"ALTER_PROCEDURE\",\n        \"component_name\": \"test_get_data_single\",\n        \"component_code\": \"ALTER PROCEDURE public.test_get_data_single(_itemid integer, INOUT _message text, INOUT _result_one refcursor, INOUT _returncode text) OWNER TO d3l243;\",\n        \"component_description\": \"This SQL command changes the owner of the stored procedure test_get_data_single to the user 'd3l243'.\"\n      }\n    ],\n    \"overall_description\": \"The provided SQL script defines a PostgreSQL stored procedure named test_get_data_single that accepts an item ID and returns a message, a refcursor containing sample data, and a return code. The procedure sets a custom message based on the input item ID, initializes the return code to empty, and populates the cursor with static data. Additionally, it changes the ownership of the stored procedure to the user 'd3l243'.\"\n  }\n}"
    },
    "sql_8": {
        "input": "<gh_stars>0\n--  @testpoint:opengauss\u5173\u952e\u5b57dictionary(\u975e\u4fdd\u7559)\uff0c\u4f5c\u4e3a\u6a21\u5f0f\u540d\n\n\n--\u5173\u952e\u5b57\u4e0d\u5e26\u5f15\u53f7-\u6210\u529f\ndrop schema if exists dictionary;\ncreate schema dictionary;\ndrop schema dictionary;\n\n--\u5173\u952e\u5b57\u5e26\u53cc\u5f15\u53f7-\u6210\u529f\ndrop schema if exists \"dictionary\";\ncreate schema \"dictionary\";\ndrop schema \"dictionary\";\n\n--\u5173\u952e\u5b57\u5e26\u5355\u5f15\u53f7-\u5408\u7406\u62a5\u9519\ndrop schema if exists 'dictionary';\ncreate schema 'dictionary';\n\n--\u5173\u952e\u5b57\u5e26\u53cd\u5f15\u53f7-\u5408\u7406\u62a5\u9519\ndrop schema if exists `dictionary`;\ncreate schema `dictionary`;\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"OpenGauss\",\n    \"components\": [\n      {\n        \"component_type\": \"SCHEMA_MANAGEMENT\",\n        \"component_name\": \"dictionary\",\n        \"component_code\": \"drop schema if exists dictionary;\\ncreate schema dictionary;\\ndrop schema dictionary;\",\n        \"component_description\": \"This component manages a schema named 'dictionary' without using quotes. It first drops the schema if it exists, then creates a new one with the same name, and finally drops it again.\"\n      },\n      {\n        \"component_type\": \"SCHEMA_MANAGEMENT\",\n        \"component_name\": \"\\\"dictionary\\\"\",\n        \"component_code\": \"drop schema if exists \\\"dictionary\\\";\\ncreate schema \\\"dictionary\\\";\\ndrop schema \\\"dictionary\\\";\",\n        \"component_description\": \"This component manages a schema named 'dictionary' using double quotes. It first drops the schema if it exists, then creates a new one with the same name, and finally drops it again.\"\n      },\n      {\n        \"component_type\": \"SCHEMA_MANAGEMENT\",\n        \"component_name\": \"'dictionary'\",\n        \"component_code\": \"drop schema if exists 'dictionary';\\ncreate schema 'dictionary';\",\n        \"component_description\": \"This component attempts to manage a schema named 'dictionary' using single quotes. It first tries to drop the schema if it exists, then tries to create a new one with the same name. This will result in an error because single quotes are not valid for identifiers in SQL.\"\n      },\n      {\n        \"component_type\": \"SCHEMA_MANAGEMENT\",\n        \"component_name\": \"`dictionary`\",\n        \"component_code\": \"drop schema if exists `dictionary`;\\ncreate schema `dictionary`;\",\n        \"component_description\": \"This component attempts to manage a schema named 'dictionary' using backticks. It first tries to drop the schema if it exists, then tries to create a new one with the same name. This will result in an error because backticks are not valid for identifiers in OpenGauss SQL.\"\n      }\n    ],\n    \"overall_description\": \"The script demonstrates the use of the keyword 'dictionary' as a schema name in OpenGauss SQL. It shows successful creation and dropping of schemas when using no quotes or double quotes around the identifier. The script also illustrates reasonable errors that occur when single quotes or backticks are used instead of proper quoting for the identifier.\"\n  }\n}"
    },
    "sql_9": {
        "input": "CREATE TABLE IF NOT EXISTS articles (\n    id           UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\n    article_id      SERIAL,\n    slug           VARCHAR(255) UNIQUE NOT NULL,\n\ttitle           VARCHAR(255) NOT NULL,\n\tdescription     TEXT NOT NULL,\n\tbody          TEXT NOT NULL,\n\tcreated_at      TIMESTAMP DEFAULT NOW() NOT NULL,\n\tupdated_at      TIMESTAMP DEFAULT NOW() NOT NULL,\n\tauthor_id         UUID NOT NULL,\n    CONSTRAINT fk_articles_author\n        FOREIGN KEY (author_id)\n        REFERENCES users(id)\n        ON DELETE CASCADE\n);\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"PostgreSQL\",\n    \"components\": [\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"articles\",\n        \"component_code\": \"CREATE TABLE IF NOT EXISTS articles (\\n    id           UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\\n    article_id      SERIAL,\\n    slug           VARCHAR(255) UNIQUE NOT NULL,\\n\\ttitle           VARCHAR(255) NOT NULL,\\n\\tdescription     TEXT NOT NULL,\\n\\tbody          TEXT NOT NULL,\\n\\tcreated_at      TIMESTAMP DEFAULT NOW() NOT NULL,\\n\\tupdated_at      TIMESTAMP DEFAULT NOW() NOT NULL,\\n\\tauthor_id         UUID NOT NULL,\\n    CONSTRAINT fk_articles_author\\n        FOREIGN KEY (author_id)\\n        REFERENCES users(id)\\n        ON DELETE CASCADE\\n);\",\n        \"component_description\": \"This component defines a table named 'articles' in PostgreSQL. The table includes columns for id, article_id, slug, title, description, body, created_at, updated_at, and author_id. The id column is a UUID that serves as the primary key with a default value generated by uuid_generate_v4(). The article_id is an auto-incrementing integer. The slug must be unique and not null, while the title, description, body, and author_id also cannot be null. The created_at and updated_at fields are timestamps that default to the current time upon creation and update respectively. There is a foreign key constraint named fk_articles_author linking author_id to the id column of the users table, which will delete related records in articles if the corresponding user record is deleted.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script creates a new table called 'articles' with several fields including a unique identifier (UUID), an auto-incrementing article ID, a unique slug for each article, title, description, body content, timestamps for creation and updates, and an author identifier linked to a users table. The table ensures data integrity through constraints on uniqueness and foreign keys.\"\n  }\n}"
    },
    "sql_10": {
        "input": "<filename>piiyel19/db.sql\nCREATE TABLE oauth_clients (\n  client_id             VARCHAR(80)   NOT NULL,\n  client_secret         VARCHAR(80),\n  redirect_uri          VARCHAR(2000),\n  grant_types           VARCHAR(80),\n  scope                 VARCHAR(4000),\n  user_id               VARCHAR(80),\n  PRIMARY KEY (client_id)\n);\n\nCREATE TABLE oauth_access_tokens (\n  access_token         VARCHAR(40)    NOT NULL,\n  client_id            VARCHAR(80)    NOT NULL,\n  user_id              VARCHAR(80),\n  expires              TIMESTAMP      NOT NULL,\n  scope                VARCHAR(4000),\n  PRIMARY KEY (access_token)\n);\n\nCREATE TABLE oauth_authorization_codes (\n  authorization_code  VARCHAR(40)     NOT NULL,\n  client_id           VARCHAR(80)     NOT NULL,\n  user_id             VARCHAR(80),\n  redirect_uri        VARCHAR(2000),\n  expires             TIMESTAMP       NOT NULL,\n  scope               VARCHAR(4000),\n  id_token            VARCHAR(1000),\n  PRIMARY KEY (authorization_code)\n);\n\nCREATE TABLE oauth_refresh_tokens (\n  refresh_token       VARCHAR(40)     NOT NULL,\n  client_id           VARCHAR(80)     NOT NULL,\n  user_id             VARCHAR(80),\n  expires             TIMESTAMP       NOT NULL,\n  scope               VARCHAR(4000),\n  PRIMARY KEY (refresh_token)\n);\n\nCREATE TABLE oauth_users (\n  username            VARCHAR(80),\n  password            VARCHAR(80),\n  first_name          VARCHAR(80),\n  last_name           VARCHAR(80),\n  email               VARCHAR(80),\n  email_verified      BOOLEAN,\n  scope               VARCHAR(4000),\n  PRIMARY KEY (username)\n);\n\nCREATE TABLE oauth_scopes (\n  scope               VARCHAR(80)     NOT NULL,\n  is_default          BOOLEAN,\n  PRIMARY KEY (scope)\n);\n\nCREATE TABLE oauth_jwt (\n  client_id           VARCHAR(80)     NOT NULL,\n  subject             VARCHAR(80),\n  public_key          VARCHAR(2000)   NOT NULL\n);",
        "output": "{\n  \"output\": {\n    \"database_system\": \"GENERAL_SQL\",\n    \"components\": [\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"oauth_clients\",\n        \"component_code\": \"CREATE TABLE oauth_clients (\\n  client_id             VARCHAR(80)   NOT NULL,\\n  client_secret         VARCHAR(80),\\n  redirect_uri          VARCHAR(2000),\\n  grant_types           VARCHAR(80),\\n  scope                 VARCHAR(4000),\\n  user_id               VARCHAR(80),\\n  PRIMARY KEY (client_id)\\n);\",\n        \"component_description\": \"This table stores information about OAuth clients including client IDs, secrets, redirect URIs, grant types, scopes, and associated user IDs. It serves as a registry for applications that can request access to resources on behalf of users.\"\n      },\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"oauth_access_tokens\",\n        \"component_code\": \"CREATE TABLE oauth_access_tokens (\\n  access_token         VARCHAR(40)    NOT NULL,\\n  client_id            VARCHAR(80)    NOT NULL,\\n  user_id              VARCHAR(80),\\n  expires              TIMESTAMP      NOT NULL,\\n  scope                VARCHAR(4000),\\n  PRIMARY KEY (access_token)\\n);\",\n        \"component_description\": \"This table stores OAuth access tokens issued to clients. Each token is associated with a client ID, user ID, expiration timestamp, and the scope of permissions granted. Access tokens are used by clients to authenticate API requests on behalf of users.\"\n      },\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"oauth_authorization_codes\",\n        \"component_code\": \"CREATE TABLE oauth_authorization_codes (\\n  authorization_code  VARCHAR(40)     NOT NULL,\\n  client_id           VARCHAR(80)     NOT NULL,\\n  user_id             VARCHAR(80),\\n  redirect_uri        VARCHAR(2000),\\n  expires             TIMESTAMP       NOT NULL,\\n  scope               VARCHAR(4000),\\n  id_token            VARCHAR(1000),\\n  PRIMARY KEY (authorization_code)\\n);\",\n        \"component_description\": \"This table holds OAuth authorization codes which are used in the authorization code grant flow. Each code is associated with a client ID, user ID, redirect URI, expiration timestamp, scope of permissions, and optionally an ID token. Authorization codes are exchanged for access tokens.\"\n      },\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"oauth_refresh_tokens\",\n        \"component_code\": \"CREATE TABLE oauth_refresh_tokens (\\n  refresh_token       VARCHAR(40)     NOT NULL,\\n  client_id           VARCHAR(80)     NOT NULL,\\n  user_id             VARCHAR(80),\\n  expires             TIMESTAMP       NOT NULL,\\n  scope               VARCHAR(4000),\\n  PRIMARY KEY (refresh_token)\\n);\",\n        \"component_description\": \"This table stores OAuth refresh tokens which allow clients to obtain new access tokens when the current ones expire. Each refresh token is linked to a client ID, user ID, expiration timestamp, and scope of permissions.\"\n      },\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"oauth_users\",\n        \"component_code\": \"CREATE TABLE oauth_users (\\n  username            VARCHAR(80),\\n  password            VARCHAR(80),\\n  first_name          VARCHAR(80),\\n  last_name           VARCHAR(80),\\n  email               VARCHAR(80),\\n  email_verified      BOOLEAN,\\n  scope               VARCHAR(4000),\\n  PRIMARY KEY (username)\\n);\",\n        \"component_description\": \"This table contains user information for the OAuth system, including usernames, passwords, names, emails, and verification status. It also stores a scope of permissions associated with each user.\"\n      },\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"oauth_scopes\",\n        \"component_code\": \"CREATE TABLE oauth_scopes (\\n  scope               VARCHAR(80)     NOT NULL,\\n  is_default          BOOLEAN,\\n  PRIMARY KEY (scope)\\n);\",\n        \"component_description\": \"This table defines the different scopes of permissions available in the OAuth system. Each scope has a name and an indicator whether it is a default scope that can be automatically granted without user consent.\"\n      },\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"oauth_jwt\",\n        \"component_code\": \"CREATE TABLE oauth_jwt (\\n  client_id           VARCHAR(80)     NOT NULL,\\n  subject             VARCHAR(80),\\n  public_key          VARCHAR(2000)   NOT NULL\\n);\",\n        \"component_description\": \"This table holds JSON Web Token (JWT) configuration details for clients, including the client ID, JWT subject, and the public key used to verify JWT signatures. It is used in systems that utilize JWTs for authentication and authorization.\"\n      }\n    ],\n    \"overall_description\": \"The provided SQL script defines a set of tables essential for implementing an OAuth 2.0 authorization server. The tables cover various aspects of OAuth including client registration, token management (access tokens, refresh tokens, and authorization codes), user details, scopes of permissions, and JWT configuration. These components work together to handle authentication, authorization, and secure communication between clients and the resource server.\"\n  }\n}"
    },
    "sql_11": {
        "input": "\ufeff/*\nDeployment script for ObservationsSACTN\n\nThis code was generated by a tool.\nChanges to this file may cause incorrect behavior and will be lost if\nthe code is regenerated.\n*/\n\nGO\nSET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;\n\nSET NUMERIC_ROUNDABORT OFF;\n\n\nGO\n:setvar DatabaseName \"ObservationsSACTN\"\n:setvar DefaultFilePrefix \"ObservationsSACTN\"\n:setvar DefaultDataPath \"D:\\Program Files\\Microsoft SQL Server\\MSSQL14.SAEON\\MSSQL\\DATA\\\"\n:setvar DefaultLogPath \"D:\\Program Files\\Microsoft SQL Server\\MSSQL14.SAEON\\MSSQL\\DATA\\\"\n\nGO\n:on error exit\nGO\n/*\nDetect SQLCMD mode and disable script execution if SQLCMD mode is not supported.\nTo re-enable the script after enabling SQLCMD mode, execute the following:\nSET NOEXEC OFF; \n*/\n:setvar __IsSqlCmdEnabled \"True\"\nGO\nIF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'\n    BEGIN\n        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';\n        SET NOEXEC ON;\n    END\n\n\nGO\nUSE [$(DatabaseName)];\n\n\nGO\nIF EXISTS (SELECT 1\n           FROM   [master].[dbo].[sysdatabases]\n           WHERE  [name] = N'$(DatabaseName)')\n    BEGIN\n        ALTER DATABASE [$(DatabaseName)]\n            SET TEMPORAL_HISTORY_RETENTION ON \n            WITH ROLLBACK IMMEDIATE;\n    END\n\n\nGO\nPRINT N'Altering [dbo].[ImportBatch]...';\n\n\nGO\nALTER TABLE [dbo].[ImportBatch]\n    ADD [DurationInSecs] INT NULL;\n\n\nGO\nPRINT N'Creating [dbo].[ImportBatch].[IX_ImportBatch_DurationInSecs]...';\n\n\nGO\nCREATE NONCLUSTERED INDEX [IX_ImportBatch_DurationInSecs]\n    ON [dbo].[ImportBatch]([DurationInSecs] ASC);\n\n\nGO\nPRINT N'Creating [dbo].[ImportBatchSummary].[IX_ImportBatchSummary_Count]...';\n\n\nGO\nCREATE NONCLUSTERED INDEX [IX_ImportBatchSummary_Count]\n    ON [dbo].[ImportBatchSummary]([Count] ASC);\n\n\nGO\nPRINT N'Creating [dbo].[ImportBatchSummary].[IX_ImportBatchSummary_EndDate]...';\n\n\nGO\nCREATE NONCLUSTERED INDEX [IX_ImportBatchSummary_EndDate]\n    ON [dbo].[ImportBatchSummary]([EndDate] ASC);\n\n\nGO\nPRINT N'Creating [dbo].[ImportBatchSummary].[IX_ImportBatchSummary_StartDate]...';\n\n\nGO\nCREATE NONCLUSTERED INDEX [IX_ImportBatchSummary_StartDate]\n    ON [dbo].[ImportBatchSummary]([StartDate] ASC);\n\n\nGO\nPRINT N'Refreshing [dbo].[vImportBatch]...';\n\n\nGO\nEXECUTE sp_refreshsqlmodule N'[dbo].[vImportBatch]';\n\n\nGO\nPRINT N'Refreshing [dbo].[vObservationExpansion]...';\n\n\nGO\nSET ANSI_NULLS, QUOTED_IDENTIFIER OFF;\n\n\nGO\nEXECUTE sp_refreshsqlmodule N'[dbo].[vObservationExpansion]';\n\n\nGO\nSET ANSI_NULLS, QUOTED_IDENTIFIER ON;\n\n\nGO\nPRINT N'Refreshing [dbo].[vObservation]...';\n\n\nGO\nSET ANSI_NULLS, QUOTED_IDENTIFIER OFF;\n\n\nGO\nEXECUTE sp_refreshsqlmodule N'[dbo].[vObservation]';\n\n\nGO\nSET ANSI_NULLS, QUOTED_IDENTIFIER ON;\n\n\nGO\nPRINT N'Refreshing [dbo].[vObservationJSON]...';\n\n\nGO\nSET ANSI_NULLS, QUOTED_IDENTIFIER OFF;\n\n\nGO\nEXECUTE sp_refreshsqlmodule N'[dbo].[vObservationJSON]';\n\n\nGO\nSET ANSI_NULLS, QUOTED_IDENTIFIER ON;\n\n\nGO\nPRINT N'Update complete.';\n\n\nGO\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"Microsoft SQL Server\",\n    \"components\": [\n      {\n        \"component_type\": \"SCRIPT_SETTINGS\",\n        \"component_name\": null,\n        \"component_code\": \"SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;\\n\\nSET NUMERIC_ROUNDABORT OFF;\",\n        \"component_description\": \"Sets various SQL Server options to ensure consistent behavior during script execution.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"DatabaseName\",\n        \"component_code\": \":setvar DatabaseName \\\"ObservationsSACTN\\\"\",\n        \"component_description\": \"Declares a variable for the database name used in the script.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"DefaultFilePrefix\",\n        \"component_code\": \":setvar DefaultFilePrefix \\\"ObservationsSACTN\\\"\",\n        \"component_description\": \"Declares a variable for the default file prefix used in the script.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"DefaultDataPath\",\n        \"component_code\": \":setvar DefaultDataPath \\\"D:\\\\Program Files\\\\Microsoft SQL Server\\\\MSSQL14.SAEON\\\\MSSQL\\\\DATA\\\\\\\"\",\n        \"component_description\": \"Declares a variable for the default data path used in the script.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"DefaultLogPath\",\n        \"component_code\": \":setvar DefaultLogPath \\\"D:\\\\Program Files\\\\Microsoft SQL Server\\\\MSSQL14.SAEON\\\\MSSQL\\\\DATA\\\\\\\"\",\n        \"component_description\": \"Declares a variable for the default log path used in the script.\"\n      },\n      {\n        \"component_type\": \"ERROR_HANDLING\",\n        \"component_name\": null,\n        \"component_code\": \":on error exit\\nIF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'\\n    BEGIN\\n        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';\\n        SET NOEXEC ON;\\n    END\",\n        \"component_description\": \"Ensures SQLCMD mode is enabled; otherwise, it disables the execution of the script.\"\n      },\n      {\n        \"component_type\": \"DATABASE_SWITCH\",\n        \"component_name\": null,\n        \"component_code\": \"USE [$(DatabaseName)];\",\n        \"component_description\": \"Switches the context to the specified database.\"\n      },\n      {\n        \"component_type\": \"TEMPORAL_HISTORY_RETENTION\",\n        \"component_name\": \"ObservationsSACTN\",\n        \"component_code\": \"ALTER DATABASE [$(DatabaseName)]\\n    SET TEMPORAL_HISTORY_RETENTION ON \\n    WITH ROLLBACK IMMEDIATE;\",\n        \"component_description\": \"Enables temporal history retention on the specified database with immediate rollback in case of failure.\"\n      },\n      {\n        \"component_type\": \"TABLE_ALTERATION\",\n        \"component_name\": \"ImportBatch\",\n        \"component_code\": \"ALTER TABLE [dbo].[ImportBatch]\\n    ADD [DurationInSecs] INT NULL;\",\n        \"component_description\": \"Adds a new nullable integer column 'DurationInSecs' to the ImportBatch table.\"\n      },\n      {\n        \"component_type\": \"INDEX_CREATION\",\n        \"component_name\": \"IX_ImportBatch_DurationInSecs\",\n        \"component_code\": \"CREATE NONCLUSTERED INDEX [IX_ImportBatch_DurationInSecs]\\n    ON [dbo].[ImportBatch]([DurationInSecs] ASC);\",\n        \"component_description\": \"Creates a non-clustered index on the 'DurationInSecs' column of the ImportBatch table for faster querying.\"\n      },\n      {\n        \"component_type\": \"INDEX_CREATION\",\n        \"component_name\": \"IX_ImportBatchSummary_Count\",\n        \"component_code\": \"CREATE NONCLUSTERED INDEX [IX_ImportBatchSummary_Count]\\n    ON [dbo].[ImportBatch]([DurationInSecs] ASC);\",\n        \"component_description\": \"Creates a non-clustered index on the 'Count' column of the ImportBatchSummary table for faster querying.\"\n      },\n      {\n        \"component_type\": \"INDEX_CREATION\",\n        \"component_name\": \"IX_ImportBatchSummary_Count\",\n        \"component_code\": \"CREATE NONCLUSTERED INDEX [IX_ImportBatchSummary_Count]\\n    ON [dbo].[ImportBatch]([DurationInSecs] ASC);\",\n        \"component_description\": \"Creates a non-clustered index on the 'Count' column of the ImportBatchSummary table for faster querying.\"\n      },\n      {\n        \"component_type\": \"INDEX_CREATION\",\n        \"component_name\": \"IX_ImportBatchSummary_Count\",\n        \"component_code\": \"CREATE NONCLUSTERED INDEX [IX_ImportBatchSummary_Count]\\n    ON [dbo].[ImportBatch]([DurationInSecs] ASC);\",\n        \"component_description\": \"Creates a non-clustered index on the 'Count' column of the ImportBatchSummary table for faster querying.\"\n      },\n      {\n        \"component_type\": \"VIEW_REFRESH\",\n        \"component_name\": \"vObservationExpansion\",\n        \"component_code\": \"SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;\\nEXECUTE sp_refreshsqlmodule N'[dbo].[vObservationExpansion]';\\nSET ANSI_NULLS, QUOTED_IDENTIFIER ON;\",\n        \"component_description\": \"Refreshes the 'vObservationExpansion' view to ensure it reflects the latest schema changes.\"\n      },\n      {\n        \"component_type\": \"VIEW_REFRESH\",\n        \"component_name\": \"vObservation\",\n        \"component_code\": \"SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;\\nEXECUTE sp_refreshsqlmodule N'[dbo].[vObservation]';\\nSET ANSI_NULLS, QUOTED_IDENTIFIER ON;\",\n        \"component_description\": \"Refreshes the 'vObservation' view to ensure it reflects the latest schema changes.\"\n      },\n      {\n        \"component_type\": \"VIEW_REFRESH\",\n        \"component_name\": \"vObservationJSON\",\n        \"component_code\": \"SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;\\nEXECUTE sp_refreshsqlmodule N'[dbo].[vObservationJSON]';\\nSET ANSI_NULLS, QUOTED_IDENTIFIER ON;\",\n        \"component_description\": \"Refreshes the 'vObservationJSON' view to ensure it reflects the latest schema changes.\"\n      }\n    ],\n    \"overall_description\": \"The script sets various SQL Server options, declares variables for database paths and names, ensures SQLCMD mode is enabled, switches the context to the specified database, enables temporal history retention, adds a new column to an existing table, creates non-clustered indexes on specific columns, and refreshes views to reflect schema changes.\"\n  }\n}"
    },
    "sql_12": {
        "input": "<filename>kurulum/zwork-personel-tablosu.sql\n-- phpMyAdmin SQL Dump\n-- version 4.0.8\n-- http://www.phpmyadmin.net\n--\n-- Anamakine: localhost\n-- \u00dcretim Zaman\u0131: 06 Mar 2019, 09:36:54\n-- Sunucu s\u00fcr\u00fcm\u00fc: 5.6.27-log\n-- PHP S\u00fcr\u00fcm\u00fc: 5.3.26\n\nSET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\";\nSET time_zone = \"+00:00\";\n\n\n/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;\n/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;\n/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;\n/*!40101 SET NAMES utf8 */;\n\n--\n-- Veritaban\u0131: `zwork`\n--\n\n-- --------------------------------------------------------\n\n--\n-- Tablo i\u00e7in tablo yap\u0131s\u0131 `zw_personel`\n--\n\nCREATE TABLE IF NOT EXISTS `zw_personel` (\n  `ID` int(11) NOT NULL AUTO_INCREMENT,\n  `admin` tinyint(1) DEFAULT '0',\n  `oturumID` varchar(32) COLLATE utf8_unicode_ci DEFAULT NULL,\n  `kullanici` varchar(32) COLLATE utf8_unicode_ci DEFAULT NULL,\n  `sifre` varchar(32) COLLATE utf8_unicode_ci DEFAULT NULL,\n  `eposta` varchar(50) COLLATE utf8_unicode_ci DEFAULT NULL,\n  `tarihG` datetime DEFAULT NULL,\n  PRIMARY KEY (`ID`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=2 ;\n\n--\n-- Tablo d\u00f6k\u00fcm verisi `zw_personel`\n--\n\nINSERT INTO `zw_personel` (`ID`, `admin`, `oturumID`, `kullanici`, `sifre`, `eposta`, `tarihG`) VALUES\n(1, 1, '141e8e041ebd87e5481af791c4a0f815', 'zwork', '4297f44b13955235245b2497399d7a93', '<EMAIL>', '2017-06-02 18:55:43');\n\n/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;\n/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;\n/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"MySQL\",\n    \"components\": [\n      {\n        \"component_type\": \"SET_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"SET SQL_MODE = \\\"NO_AUTO_VALUE_ON_ZERO\\\";\",\n        \"component_description\": \"Sets the SQL mode to disallow implicit usage of auto-increment values when they are set to zero.\"\n      },\n      {\n        \"component_type\": \"SET_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"SET time_zone = \\\"+00:00\\\";\",\n        \"component_description\": \"Sets the time zone for the current session to UTC (Coordinated Universal Time).\"\n      },\n      {\n        \"component_type\": \"CHARACTER_SET_MANIPULATION\",\n        \"component_name\": null,\n        \"component_code\": \"/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;\",\n        \"component_description\": \"Saves the current client character set setting.\"\n      },\n      {\n        \"component_type\": \"CHARACTER_SET_MANIPULATION\",\n        \"component_name\": null,\n        \"component_code\": \"/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;\",\n        \"component_description\": \"Saves the current character set results setting.\"\n      },\n      {\n        \"component_type\": \"COLLATION_MANIPULATION\",\n        \"component_name\": null,\n        \"component_code\": \"/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;\",\n        \"component_description\": \"Saves the current collation connection setting.\"\n      },\n      {\n        \"component_type\": \"CHARACTER_SET_MANIPULATION\",\n        \"component_name\": null,\n        \"component_code\": \"/*!40101 SET NAMES utf8 */;\",\n        \"component_description\": \"Sets both character set and collation for client/server communication to UTF-8.\"\n      },\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"zw_personel\",\n        \"component_code\": \"CREATE TABLE IF NOT EXISTS `zw_personel` (\\n  `ID` int(11) NOT NULL AUTO_INCREMENT,\\n  `admin` tinyint(1) DEFAULT '0',\\n  `oturumID` varchar(32) COLLATE utf8_unicode_ci DEFAULT NULL,\\n  `kullanici` varchar(32) COLLATE utf8_unicode_ci DEFAULT NULL,\\n  `sifre` varchar(32) COLLATE utf8_unicode_ci DEFAULT NULL,\\n  `eposta` varchar(50) COLLATE utf8_unicode_ci DEFAULT NULL,\\n  `tarihG` datetime DEFAULT NULL,\\n  PRIMARY KEY (`ID`)\\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=2 ;\",\n        \"component_description\": \"Creates a table named `zw_personel` with columns for ID, admin status, session ID, username, password, email, and registration date. The ID is an auto-incrementing primary key.\"\n      },\n      {\n        \"component_type\": \"INSERT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"INSERT INTO `zw_personel` (`ID`, `admin`, `oturumID`, `kullanici`, `sifre`, `eposta`, `tarihG`) VALUES\\n(1, 1, '141e8e041ebd87e5481af791c4a0f815', 'zwork', '4297f44b13955235245b2497399d7a93', '<EMAIL>', '2017-06-02 18:55:43');\",\n        \"component_description\": \"Inserts a single record into the `zw_personel` table with ID 1, admin status set to true, session ID, username, password hash, email, and registration date specified.\"\n      },\n      {\n        \"component_type\": \"CHARACTER_SET_MANIPULATION\",\n        \"component_name\": null,\n        \"component_code\": \"/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;\",\n        \"component_description\": \"Restores the client character set to its original setting before any changes were made.\"\n      },\n      {\n        \"component_type\": \"CHARACTER_SET_MANIPULATION\",\n        \"component_name\": null,\n        \"component_code\": \"/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;\",\n        \"component_description\": \"Restores the character set results to its original setting before any changes were made.\"\n      },\n      {\n        \"component_type\": \"COLLATION_MANIPULATION\",\n        \"component_name\": null,\n        \"component_code\": \"/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;\",\n        \"component_description\": \"Restores the collation connection to its original setting before any changes were made.\"\n      }\n    ],\n    \"overall_description\": \"This SQL script initializes a table named `zw_personel` within a MySQL database, designed for storing user information. The script sets various session parameters for character encoding and time zone settings, creates the table with columns for ID, admin status, session ID, username, password, email, and registration date, inserts a single record into the table representing an administrator user, and then restores the original session parameters.\"\n  }\n\n}"
    },
    "sql_13": {
        "input": "<gh_stars>0\n--\n-- Table structure for table `products`\n--\n\nDROP TABLE IF EXISTS `products`;\nCREATE TABLE `products` (\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `sku` varchar(255) COLLATE utf8mb4_general_ci NOT NULL,\n  `name` varchar(255) COLLATE utf8mb4_general_ci NOT NULL,\n  `price` decimal(8, 2) NOT NULL,\n  `type` varchar(255) COLLATE utf8mb4_general_ci NOT NULL,\n  `attribute` varchar(255) COLLATE utf8mb4_general_ci NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"MySQL\",\n    \"components\": [\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"products\",\n        \"component_code\": \"DROP TABLE IF EXISTS `products`;\\nCREATE TABLE `products` (\\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\\n  `sku` varchar(255) COLLATE utf8mb4_general_ci NOT NULL,\\n  `name` varchar(255) COLLATE utf8mb4_general_ci NOT NULL,\\n  `price` decimal(8, 2) NOT NULL,\\n  `type` varchar(255) COLLATE utf8mb4_general_ci NOT NULL,\\n  `attribute` varchar(255) COLLATE utf8mb4_general_ci NOT NULL,\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;\",\n        \"component_description\": \"This component defines a table named 'products' in a MySQL database. It includes columns for the product ID (auto-incrementing primary key), SKU, name, price, type, and attribute. The table uses the InnoDB storage engine with utf8mb4 character set and general_ci collation.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script is designed to create a 'products' table in a MySQL database. It first checks if the table already exists and drops it if necessary, ensuring that any existing data will be removed before creating the new table structure. The table includes six columns: an auto-incrementing integer ID as the primary key, and string fields for SKU, name, type, and attribute, along with a decimal field for price. The table uses InnoDB storage engine and utf8mb4 character encoding to support a wide range of characters.\"\n  }\n}"
    },
    "sql_15": {
        "input": "<reponame>hosamn/Speech-Diseases-Clinic<filename>sqlCode.sql<gh_stars>0\nCREATE TABLE `patient` (\r\n\t`id`\tINTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,\r\n\t`name`\tTEXT NOT NULL UNIQUE,\r\n\t`dobDay`\tINTEGER,\r\n\t`dobMonth`\tINTEGER,\r\n\t`dobYear`\tINTEGER,\r\n\t`sex`\tTEXT,\r\n\t`nationality`\tTEXT,\r\n\t`marital`\tTEXT,\r\n\t`job`\tTEXT,\r\n\t`address`\tTEXT,\r\n\t`phoneMobile`\tTEXT,\r\n\t`phoneHome`\tTEXT,\r\n\t`phoneWork`\tTEXT,\r\n\t`referrer`\tTEXT\r\n);\r\n\r\n\r\n\r\nCREATE TABLE `test` (\r\n\t`id`\tINTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,\r\n\t`patientID`\tINTEGER NOT NULL,\r\n\t`dateDay`\tINTEGER,\r\n\t`dateMonth`\tINTEGER,\r\n\t`dateYear`\tINTEGER,\r\n\t`hospital`\tTEXT,\r\n\t`endoscope`\tTEXT,\r\n\t`diag`\tTEXT,\r\n\t`hist`\tTEXT,\r\n\t`pasTG`\tTEXT,\r\n\t`pasTB`\tTEXT,\r\n\t`pasNG`\tTEXT,\r\n\t`pasNB`\tTEXT,\r\n\t`pasHG`\tTEXT,\r\n\t`pasHB`\tTEXT,\r\n\t`pasPG`\tTEXT,\r\n\t`pasPB`\tTEXT,\r\n\t`pasMG`\tTEXT,\r\n\t`pasMB`\tTEXT,\r\n\t`pasSG`\tTEXT,\r\n\t`pasSB`\tTEXT,\r\n\t`residue`\tTEXT,\r\n\t`others`\tTEXT,\r\n\t`recomm`\tTEXT\r\n\r\n);\r\n\r\n\r\n\r\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"MySQL\",\n    \"components\": [\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"patient\",\n        \"component_code\": \"CREATE TABLE `patient` (\\n\\t`id`\tINTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,\\n\\t`name`\tTEXT NOT NULL UNIQUE,\\n\\t`dobDay`\tINTEGER,\\n\\t`dobMonth`\tINTEGER,\\n\\t`dobYear`\tINTEGER,\\n\\t`sex`\tTEXT,\\n\\t`nationality`\tTEXT,\\n\\t`marital`\tTEXT,\\n\\t`job`\tTEXT,\\n\\t`address`\tTEXT,\\n\\t`phoneMobile`\tTEXT,\\n\\t`phoneHome`\tTEXT,\\n\\t`phoneWork`\tTEXT,\\n\\t`referrer`\tTEXT\\n);\",\n        \"component_description\": \"Defines a table named 'patient' to store patient information including unique identifiers, personal details, and contact information.\"\n      },\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"test\",\n        \"component_code\": \"CREATE TABLE `test` (\\n\\t`id`\tINTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,\\n\\t`patientID`\tINTEGER NOT NULL,\\n\\t`dateDay`\tINTEGER,\\n\\t`dateMonth`\tINTEGER,\\n\\t`dateYear`\tINTEGER,\\n\\t`hospital`\tTEXT,\\n\\t`endoscope`\tTEXT,\\n\\t`diag`\tTEXT,\\n\\t`hist`\tTEXT,\\n\\t`pasTG`\tTEXT,\\n\\t`pasTB`\tTEXT,\\n\\t`pasNG`\tTEXT,\\n\\t`pasNB`\tTEXT,\\n\\t`pasHG`\tTEXT,\\n\\t`pasHB`\tTEXT,\\n\\t`pasPG`\tTEXT,\\n\\t`pasPB`\tTEXT,\\n\\t`pasMG`\tTEXT,\\n\\t`pasMB`\tTEXT,\\n\\t`pasSG`\tTEXT,\\n\\t`pasSB`\tTEXT,\\n\\t`residue`\tTEXT,\\n\\t`others`\tTEXT,\\n\\t`recomm`\tTEXT\\n);\",\n        \"component_description\": \"Defines a table named 'test' to store test details for patients, including the patient ID, date of the test, hospital information, diagnostic data, and other relevant findings.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script creates two tables: 'patient' and 'test'. The 'patient' table stores detailed information about each patient such as their name, contact details, and personal attributes. The 'test' table records the test results for these patients, linking back to the 'patient' table via the patientID field. This setup allows for the tracking of patient data alongside their respective test outcomes in a structured format.\"\n  }\n}"
    },
    "sql_16": {
        "input": "<filename>SistemaTaller.BackEnd.DB/Stored Procedures/SP_Reparaciones_Delete.sql<gh_stars>0\n\ufeffCREATE PROCEDURE SP_Reparaciones_Delete\n\t@NumeroReparacion INT\n\tAS\n\tBEGIN\n\tSELECT * FROM Reparaciones WHERE NumeroReparacion = @NumeroReparacion\n\tUPDATE Reparaciones SET Activo = 0 WHERE NumeroReparacion = NumeroReparacion\n\tEND",
        "output": "{\n  \"output\": {\n    \"database_system\": \"SQL Server\",\n    \"components\": [\n      {\n        \"component_type\": \"STORED_PROCEDURE\",\n        \"component_name\": \"SP_Reparaciones_Delete\",\n        \"component_code\": \"CREATE PROCEDURE SP_Reparaciones_Delete\\n\\t@NumeroReparacion INT\\n\\tAS\\n\\tBEGIN\\n\\tSELECT * FROM Reparaciones WHERE NumeroReparacion = @NumeroReparacion\\n\\tUPDATE Reparaciones SET Activo = 0 WHERE NumeroReparacion = NumeroReparacion\\n\\tEND\",\n        \"component_description\": \"This stored procedure is designed to delete a repair record by setting its 'Activo' status to 0 based on the provided repair number. It first selects the repair details for verification and then updates the record in the Reparaciones table.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script defines a stored procedure named SP_Reparaciones_Delete which takes an integer parameter @NumeroReparacion. The procedure is intended to 'delete' a repair by setting the 'Activo' field of the corresponding record in the Reparaciones table to 0. It begins with selecting the repair details for the given repair number and then performs an update operation on the same record, mistakenly using NumeroReparacion = NumeroReparacion instead of NumeroReparacion = @NumeroReparacion, which would result in all records being updated.\"\n  }\n}"
    },
    "sql_17": {
        "input": "<gh_stars>1-10\nSET DEFINE OFF;\nCREATE UNIQUE INDEX AFW_12_LIEN_SA_SCENR_NOTFC_UK1 ON AFW_12_LIEN_SA_SCENR_NOTFC\n(REF_STRUC_APLIC, REF_SCENR_NOTFC)\nLOGGING\n/\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"Oracle\",\n    \"components\": [\n      {\n        \"component_type\": \"INDEX\",\n        \"component_name\": \"AFW_12_LIEN_SA_SCENR_NOTFC_UK1\",\n        \"component_code\": \"CREATE UNIQUE INDEX AFW_12_LIEN_SA_SCENR_NOTFC_UK1 ON AFW_12_LIEN_SA_SCENR_NOTFC (REF_STRUC_APLIC, REF_SCENR_NOTFC) LOGGING /\",\n        \"component_description\": \"This component creates a unique index named 'AFW_12_LIEN_SA_SCENR_NOTFC_UK1' on the table 'AFW_12_LIEN_SA_SCENR_NOTFC'. The index is unique and enforces uniqueness on the combination of columns 'REF_STRUC_APLIC' and 'REF_SCENR_NOTFC'. The 'LOGGING' clause specifies that changes to this index should be logged.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script creates a unique index named 'AFW_12_LIEN_SA_SCENR_NOTFC_UK1' on the table 'AFW_12_LIEN_SA_SCENR_NOTFC'. This index ensures that each combination of values in the columns 'REF_STRUC_APLIC' and 'REF_SCENR_NOTFC' is unique, thereby preventing duplicate entries. The use of logging for this index means that changes related to it are recorded in the database logs.\"\n  }\n}"
    },
    "sql_18": {
        "input": "<reponame>xandout/hdbcli\nSET SCHEMA MITCHELL;\nINSERT INTO TESTING VALUES ('moose2');\n/exit\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"General SQL\",\n    \"components\": [\n      {\n        \"component_type\": \"SCHEMA_SELECTION\",\n        \"component_name\": \"MITCHELL\",\n        \"component_code\": \"SET SCHEMA MITCHELL;\",\n        \"component_description\": \"Sets the current schema to MITCHELL, specifying the context in which subsequent operations will be performed.\"\n      },\n      {\n        \"component_type\": \"INSERT_QUERY\",\n        \"component_name\": \"TESTING\",\n        \"component_code\": \"INSERT INTO TESTING VALUES ('moose2');\",\n        \"component_description\": \"Inserts a single row with the value 'moose2' into the table named TESTING. The column(s) into which 'moose2' is inserted are not specified, so they must match the order and type of columns in TESTING.\"\n      },\n      {\n        \"component_type\": \"COMMAND\",\n        \"component_name\": \"/exit\",\n        \"component_code\": \"/exit\",\n        \"component_description\": \"Exits the current SQL session or command-line interface.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script sets the schema to MITCHELL, inserts a single row with the value 'moose2' into the TESTING table, and then exits the SQL session. This script is intended for modifying data within a specific database schema and managing the session lifecycle.\"\n  }\n}"
    },
    "sql_19": {
        "input": "<reponame>WeilerWebServices/PostgreSQL<filename>pgAdmin/tools/sqleditor/templates/sqleditor/sql/default/objectname.sql\n{# ============= Fetch the schema and object name for given object id ============= #}\n{% if obj_id %}\nSELECT n.nspname, r.relname\nFROM pg_class r\n    LEFT JOIN pg_namespace n ON (r.relnamespace = n.oid)\nWHERE r.oid = {{obj_id}};\n{% endif %}\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"PostgreSQL\",\n    \"components\": [\n      {\n        \"component_type\": \"QUERY\",\n        \"component_name\": null,\n        \"component_code\": \"SELECT n.nspname, r.relname\\nFROM pg_class r\\n    LEFT JOIN pg_namespace n ON (r.relnamespace = n.oid)\\nWHERE r.oid = {{obj_id}};\",\n        \"component_description\": \"This query retrieves the schema name (nspname) and object name (relname) from the PostgreSQL system catalog tables for a given object identifier (oid). It joins the pg_class table, which contains information about all tables, indexes, sequences, etc., with the pg_namespace table to get the schema name associated with the object.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script is designed to fetch the schema and object name for a specified object identifier in a PostgreSQL database. It leverages system catalog tables (pg_class and pg_namespace) to retrieve this information, which can be useful for dynamically identifying the context of an object within the database.\"\n  }\n}"
    },
    "sql_21": {
        "input": "/*\n * $Id: lastval.sql 5406 2014-10-13 20:53:18Z unsaved $\n *\n * Tests auto-variable ?\n */\n\nCREATE TABLE t (i INT);\n\n* if (*? != 0) \\q ? variable not capturing CREATE TABLE return value\n\nINSERT INTO t values (21);\n* if (*? != 1) \\q ? variable not capturing INSERT return value\n\nINSERT INTO t values (10);\n* if (*? != 1) \\q ? variable not capturing INSERT return value\n\nINSERT INTO t values (43);\n* if (*? != 1) \\q ? variable not capturing INSERT return value\n\nSELECT * FROM t ORDER BY i DESC;\n* if (*? != 10) \\q ? variable not capturing last fetched value\n\n\\p echo some stuff\n\\p to verify that ? variable value is preserved\n* list\n\n* if (*? != 10) \\q ? value not retained after special commands\n* if (*{?} != 10) \\q ? value not dereferenced with {} usage\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"General SQL\",\n    \"components\": [\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"t\",\n        \"component_code\": \"CREATE TABLE t (i INT);\",\n        \"component_description\": \"Creates a table named 't' with a single column 'i' of type INTEGER. This table is used to store integer values for testing purposes.\"\n      },\n      {\n        \"component_type\": \"INSERT\",\n        \"component_name\": null,\n        \"component_code\": \"INSERT INTO t values (21);\",\n        \"component_description\": \"Inserts a row with the value 21 into the 't' table. This operation is used to populate the table for testing.\"\n      },\n      {\n        \"component_type\": \"INSERT\",\n        \"component_name\": null,\n        \"component_code\": \"INSERT INTO t values (10);\",\n        \"component_description\": \"Inserts a row with the value 10 into the 't' table. This operation is used to populate the table for testing.\"\n      },\n      {\n        \"component_type\": \"INSERT\",\n        \"component_name\": null,\n        \"component_code\": \"INSERT INTO t values (43);\",\n        \"component_description\": \"Inserts a row with the value 43 into the 't' table. This operation is used to populate the table for testing.\"\n      },\n      {\n        \"component_type\": \"QUERY\",\n        \"component_name\": null,\n        \"component_code\": \"SELECT * FROM t ORDER BY i DESC;\",\n        \"component_description\": \"Retrieves all rows from the 't' table, ordering them in descending order by the column 'i'. This query is used to verify the contents of the table after insertions.\"\n      },\n      {\n        \"component_type\": \"COMMENT\",\n        \"component_name\": null,\n        \"component_code\": \"* if (*? != 0) \\\\q ? variable not capturing CREATE TABLE return value\\n* if (*? != 1) \\\\q ? variable not capturing INSERT return value\\n* if (*? != 1) \\\\q ? variable not capturing INSERT return value\\n* if (*? != 1) \\\\q ? variable not capturing INSERT return value\\n* if (*? != 10) \\\\q ? variable not capturing last fetched value\\n\\\\p echo some stuff\\n\\\\p to verify that ? variable value is preserved\\n* list\\n* if (*? != 10) \\\\q ? value not retained after special commands\\n* if (*{?} != 10) \\\\q ? value not dereferenced with {} usage\",\n        \"component_description\": \"Contains a series of comments and pseudo-commands that are not part of standard SQL. They appear to be used for testing or debugging purposes, checking the values of auto-variables after various operations.\"\n      }\n    ],\n    \"overall_description\": \"The script creates a table 't' with one integer column and inserts three rows into it. It then selects all rows from the table in descending order. The script includes comments and pseudo-commands that seem to be used for testing purposes, verifying if certain auto-variable values are correctly captured and retained after various SQL operations.\"\n  }\n}"
    },
    "sql_22": {
        "input": "<gh_stars>10-100\n-- file:alter_table.sql ln:2276 expect:true\nDROP TABLE part_3_4\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"GENERAL_SQL\",\n    \"components\": [\n      {\n        \"component_type\": \"TABLE_DROPPING\",\n        \"component_name\": \"part_3_4\",\n        \"component_code\": \"DROP TABLE part_3_4\",\n        \"component_description\": \"This SQL statement is used to permanently delete the table named 'part_3_4' from the database. All data and associated objects (such as indexes) related to this table are also removed.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script consists of a single command that drops a table named 'part_3_4'. This action results in the complete removal of the specified table and all its contents from the database, making it irreversible unless there is a backup or similar recovery mechanism in place.\"\n  }\n}"
    },
    "sql_23": {
        "input": "<reponame>sergb213/pgtoolsservice\n{#\n # pgAdmin 4 - PostgreSQL Tools\n #\n # Copyright (C) 2013 - 2017, The pgAdmin Development Team\n # This software is released under the PostgreSQL Licence\n #}\nSELECT\n    i.indexrelid,\n    CASE i.indoption[i.attnum - 1]\n    WHEN 0 THEN ARRAY['ASC', 'NULLS LAST']\n    WHEN 1 THEN ARRAY['DESC', 'NULLS FIRST']\n    WHEN 2 THEN ARRAY['ASC', 'NULLS FIRST']\n    WHEN 3 THEN ARRAY['DESC', 'NULLS  ']\n    ELSE ARRAY['UNKNOWN OPTION' || i.indoption[i.attnum - 1], '']\n    END::text[] AS options,\n    i.attnum,\n    pg_get_indexdef(i.indexrelid, i.attnum, true) as attdef,\n    CASE WHEN (o.opcdefault = FALSE) THEN o.opcname ELSE null END AS opcname,\n    op.oprname AS oprname,\n\tCASE WHEN length(nspc.nspname) > 0 AND length(coll.collname) > 0  THEN\n\t  concat(quote_ident(nspc.nspname), '.', quote_ident(coll.collname))\n\tELSE '' END AS collnspname\nFROM (\n      SELECT\n          indexrelid, i.indoption, i.indclass,\n          unnest(ARRAY(SELECT generate_series(1, i.indnatts) AS n)) AS attnum\n      FROM\n          pg_index i\n      WHERE i.indexrelid = {{idx}}::OID\n) i\n    LEFT JOIN pg_opclass o ON (o.oid = i.indclass[i.attnum - 1])\n    LEFT OUTER JOIN pg_constraint c ON (c.conindid = i.indexrelid)\n    LEFT OUTER JOIN pg_operator op ON (op.oid = c.conexclop[i.attnum])\n    LEFT JOIN pg_attribute a ON (a.attrelid = i.indexrelid AND a.attnum = i.attnum)\n    LEFT OUTER JOIN pg_collation coll ON a.attcollation=coll.oid\n    LEFT OUTER JOIN pg_namespace nspc ON coll.collnamespace=nspc.oid\nORDER BY i.attnum;\n",
        "output": "{\n  \"output\": {\n    \"database_system\": \"PostgreSQL\",\n    \"components\": [\n      {\n        \"component_type\": \"QUERY\",\n        \"component_name\": null,\n        \"component_code\": \"SELECT\\n    i.indexrelid,\\n    CASE i.indoption[i.attnum - 1]\\n    WHEN 0 THEN ARRAY['ASC', 'NULLS LAST']\\n    WHEN 1 THEN ARRAY['DESC', 'NULLS FIRST']\\n    WHEN 2 THEN ARRAY['ASC', 'NULLS FIRST']\\n    WHEN 3 THEN ARRAY['DESC', 'NULLS  ']\\n    ELSE ARRAY['UNKNOWN OPTION' || i.indoption[i.attnum - 1], '']\\n    END::text[] AS options,\\n    i.attnum,\\n    pg_get_indexdef(i.indexrelid, i.attnum, true) as attdef,\\n    CASE WHEN (o.opcdefault = FALSE) THEN o.opcname ELSE null END AS opcname,\\n    op.oprname AS oprname,\\n\\tCASE WHEN length(nspc.nspname) > 0 AND length(coll.collname) > 0  THEN\\n\\t  concat(quote_ident(nspc.nspname), '.', quote_ident(coll.collname))\\n\\tELSE '' END AS collnspname\\nFROM (\\n      SELECT\\n          indexrelid, i.indoption, i.indclass,\\n          unnest(ARRAY(SELECT generate_series(1, i.indnatts) AS n)) AS attnum\\n      FROM\\n          pg_index i\\n      WHERE i.indexrelid = {{idx}}::OID\\n) i\\n    LEFT JOIN pg_opclass o ON (o.oid = i.indclass[i.attnum - 1])\\n    LEFT OUTER JOIN pg_constraint c ON (c.conindid = i.indexrelid)\\n    LEFT OUTER JOIN pg_operator op ON (op.oid = c.conexclop[i.attnum])\\n    LEFT JOIN pg_attribute a ON (a.attrelid = i.indexrelid AND a.attnum = i.attnum)\\n    LEFT OUTER JOIN pg_collation coll ON a.attcollation=coll.oid\\n    LEFT OUTER JOIN pg_namespace nspc ON coll.collnamespace=nspc.oid\\nORDER BY i.attnum;\",\n        \"component_description\": \"This query retrieves detailed information about the columns of a specified index in a PostgreSQL database. It includes options for sorting (ASC/DESC and NULLS handling), column definitions, operator class names, operator names, and collation namespaces.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script is designed to extract comprehensive details about the columns within a specific index identified by the placeholder {{idx}} in a PostgreSQL database. It joins several system catalogs such as pg_index, pg_opclass, pg_constraint, pg_operator, pg_attribute, pg_collation, and pg_namespace to gather information like sorting options, column definitions, operator classes, operators, and collations associated with each index column. The results are ordered by the attribute number (attnum) of the columns in the index.\"\n  }\n}"
    },
    "sql_24": {
        "input": "--Problem 8\nCREATE PROCEDURE usp_DeleteEmployeesFromDepartment (@departmentId INT)\nAS\nALTER TABLE Departments\nALTER COLUMN ManagerID INT NULL\n\nDELETE FROM EmployeesProjects\nWHERE EmployeeID IN(SELECT EmployeeID FROM Employees WHERE DepartmentID = @departmentId)\n\nUPDATE Employees\n\tSET ManagerID = NULL\n\tWHERE EmployeeID IN(SELECT EmployeeID FROM Employees WHERE DepartmentID = @departmentId)\n\nUPDATE Employees\n\tSET ManagerID = NULL\n\tWHERE ManagerID IN (SELECT EmployeeID FROM Employees WHERE DepartmentID = @departmentId)\n\nUPDATE Departments\n\tSET ManagerID = NULL\n\tWHERE DepartmentID = @departmentId\n\nDELETE FROM Employees\n\tWHERE DepartmentID = @departmentId\n\nDELETE FROM Departments\n\tWHERE DepartmentID = @departmentId\n\nSELECT COUNT(*)\n\tFROM Employees\n\tWHERE DepartmentID = @departmentId",
        "output": "{\n  \"output\": {\n    \"database_system\": \"SQL Server\",\n    \"components\": [\n      {\n        \"component_type\": \"STORED_PROCEDURE\",\n        \"component_name\": \"usp_DeleteEmployeesFromDepartment\",\n        \"component_code\": \"CREATE PROCEDURE usp_DeleteEmployeesFromDepartment (@departmentId INT)\\nAS\\nALTER TABLE Departments\\nALTER COLUMN ManagerID INT NULL\\n\\nDELETE FROM EmployeesProjects\\nWHERE EmployeeID IN(SELECT EmployeeID FROM Employees WHERE DepartmentID = @departmentId)\\n\\nUPDATE Employees\\n\\tSET ManagerID = NULL\\n\\tWHERE EmployeeID IN(SELECT EmployeeID FROM Employees WHERE DepartmentID = @departmentId)\\n\\nUPDATE Employees\\n\\tSET ManagerID = NULL\\n\\tWHERE ManagerID IN (SELECT EmployeeID FROM Employees WHERE DepartmentID = @departmentId)\\n\\nUPDATE Departments\\n\\tSET ManagerID = NULL\\n\\tWHERE DepartmentID = @departmentId\\n\\nDELETE FROM Employees\\n\\tWHERE DepartmentID = @departmentId\\n\\nDELETE FROM Departments\\n\\tWHERE DepartmentID = @departmentId\\n\\nSELECT COUNT(*)\\n\\tFROM Employees\\n\\tWHERE DepartmentID = @departmentId\",\n        \"component_description\": \"This stored procedure, named usp_DeleteEmployeesFromDepartment, takes a department ID as input and performs several operations. It first allows NULL values in the ManagerID column of the Departments table. Then, it deletes entries from the EmployeesProjects table where the EmployeeID is associated with the specified department. Next, it updates the ManagerID to NULL for all employees within the specified department. It also ensures that no employee is a manager of another employee who belongs to the specified department by setting their ManagerIDs to NULL. After these updates, it removes all employees from the Employees table who belong to the specified department and deletes the department itself from the Departments table. Finally, it returns the count of remaining employees in the specified department (which should be zero if the deletion was successful).\"\n      }\n    ],\n    \"overall_description\": \"The SQL script defines a stored procedure named usp_DeleteEmployeesFromDepartment that is designed to completely remove all employees and the corresponding department from the database. The procedure accepts a single parameter, @departmentId, which identifies the department to be deleted. It starts by altering the Departments table to allow NULL values in the ManagerID column. Subsequently, it removes project assignments for the employees of the specified department. Then, it nullifies manager relationships involving employees within that department and ensures no employee is a manager of another employee from the same department. After these adjustments, it deletes all employees associated with the specified department and then deletes the department itself. Finally, it checks if there are any remaining employees in the department to confirm successful deletion.\"\n  }\n}"
    }
}