{"prompt": "\nYou are an expert Kotlin code analyst. Your task is to dissect a given Kotlin code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Kotlin\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_KOTLIN_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_KOTLIN_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_KOTLIN_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Kotlin.\n2. Component Types: Use appropriate component types, for example, PACKAGE_DECLARATION, IMPORT_STATEMENT, CLASS_DEFINITION, DATA_CLASS_DEFINITION, FUNCTION_DEFINITION, EXTENSION_FUNCTION, PROPERTY_DECLARATION, CONSTRUCTOR, LAMBDA, NULL_SAFETY, SEALING_CLASS.\n3. Component Names: Provide the correct identifier for each component (function name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Kotlin code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including Kotlin-specific features like null safety, extension functions, coroutines, and data classes.\n6. Overall Description: Provide a detailed summary of the entire Kotlin code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Kotlin code properly and return ONLY the JSON response with no additional text:\n\n<gh_stars>0\npackage com.babestudios.hopin\n\nimport androidx.hilt.lifecycle.ViewModelInject\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport androidx.navigation.NavController\nimport com.babestudios.hopin.data.network.HopinRepositoryContract\nimport com.babestudios.hopin.model.GetSessionRequest\nimport com.babestudios.hopin.model.GetStageStatusResponse\nimport com.babestudios.hopin.model.GetStagesResponse\nimport com.babestudios.hopin.navigation.HopinNavigator\nimport kotlinx.coroutines.launch\nimport java.util.*\n\n\nclass HopinViewModel @ViewModelInject constructor(\n        private val hopinRepository: HopinRepositoryContract,\n        private val hopinNavigator: HopinNavigator,\n) : ViewModel() {\n\n    fun userTokenReceived(cookies: String) {\n        val sp = cookies.split(\"; \")\n        val spl = sp.filter { it.startsWith(\"user.token\") }\n        if (spl.isNotEmpty()) {\n            val userToken = spl[0].removePrefix(\"user.token=\")\n            viewModelScope.launch {\n                if (convertUserId(userToken))\n                    hopinNavigator.mainToStreamer()\n                else {\n                    //error handling\n                }\n            }\n        }\n    }\n\n    private suspend fun convertUserId(userToken: String): Boolean {\n        val getSessionRequest = GetSessionRequest(\"babe-project\")\n        return hopinRepository.convertUserId(\n                \"user.token=$userToken\",\n                getSessionRequest\n        )\n    }\n\n    suspend fun getStreamUrl(): String? {\n        val uuid = getStages().stages[0].uuid\n        val status = getStageStatus(uuid)\n        val broadcast = status.broadcasts.filter { it.broadcast_type == \"mixer\" }.getOrNull(0)\n        return broadcast?.stream_url\n    }\n\n    private suspend fun getStages(): GetStagesResponse {\n        return hopinRepository.getStages()\n    }\n\n    private suspend fun getStageStatus(uuid: String): GetStageStatusResponse {\n        return hopinRepository.getStageStatus(\n                UUID.fromString(uuid)\n        )\n    }\n\n    fun bindNavController(navController: NavController) {\n        hopinNavigator.bind(navController)\n    }\n}", "completion": "{\n    \"programming_language\": \"Kotlin\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": null,\n        \"component_code\": \"package com.babestudios.hopin\",\n        \"component_description\": \"Declares the package name for the file, which is 'com.babestudios.hopin'.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import androidx.hilt.lifecycle.ViewModelInject\\nimport androidx.lifecycle.ViewModel\\nimport androidx.lifecycle.viewModelScope\\nimport androidx.navigation.NavController\\nimport com.babestudios.hopin.data.network.HopinRepositoryContract\\nimport com.babestudios.hopin.model.GetSessionRequest\\nimport com.babestudios.hopin.model.GetStageStatusResponse\\nimport com.babestudios.hopin.model.GetStagesResponse\\nimport com.babestudios.hopin.navigation.HopinNavigator\\nimport kotlinx.coroutines.launch\\nimport java.util.*\",\n        \"component_description\": \"Imports necessary classes and packages required for the ViewModel, including Hilt for dependency injection, AndroidX lifecycle components, navigation, repository contract, models, and utility classes.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"HopinViewModel\",\n        \"component_code\": \"class HopinViewModel @ViewModelInject constructor(\\n        private val hopinRepository: HopinRepositoryContract,\\n        private val hopinNavigator: HopinNavigator,\\n) : ViewModel() {\\n\\n    fun userTokenReceived(cookies: String) {\\n        val sp = cookies.split(\\\"; \\\")\\n        val spl = sp.filter { it.startsWith(\\\"user.token\\\") }\\n        if (spl.isNotEmpty()) {\\n            val userToken = spl[0].removePrefix(\\\"user.token=\\\")\\n            viewModelScope.launch {\\n                if (convertUserId(userToken))\\n                    hopinNavigator.mainToStreamer()\\n                else {\\n                    //error handling\\n                }\\n            }\\n        }\\n    }\\n\\n    private suspend fun convertUserId(userToken: String): Boolean {\\n        val getSessionRequest = GetSessionRequest(\\\"babe-project\\\")\\n        return hopinRepository.convertUserId(\\n                \\\"user.token=$userToken\\\",\\n                getSessionRequest\\n        )\\n    }\\n\\n    suspend fun getStreamUrl(): String? {\\n        val uuid = getStages().stages[0].uuid\\n        val status = getStageStatus(uuid)\\n        val broadcast = status.broadcasts.filter { it.broadcast_type == \\\"mixer\\\" }.getOrNull(0)\\n        return broadcast?.stream_url\\n    }\\n\\n    private suspend fun getStages(): GetStagesResponse {\\n        return hopinRepository.getStages()\\n    }\\n\\n    private suspend fun getStageStatus(uuid: String): GetStageStatusResponse {\\n        return hopinRepository.getStageStatus(\\n                UUID.fromString(uuid)\\n        )\\n    }\\n\\n    fun bindNavController(navController: NavController) {\\n        hopinNavigator.bind(navController)\\n    }\\n}\",\n        \"component_description\": \"Defines a ViewModel class named 'HopinViewModel' that manages UI-related data and handles user interactions. It uses dependency injection via Hilt to receive instances of HopinRepositoryContract and HopinNavigator.\"\n      },\n      {\n        \"component_type\": \"CONSTRUCTOR\",\n        \"component_name\": \"HopinViewModel\",\n        \"component_code\": \"@ViewModelInject constructor(\\n        private val hopinRepository: HopinRepositoryContract,\\n        private val hopinNavigator: HopinNavigator,\\n)\",\n        \"component_description\": \"The primary constructor for the 'HopinViewModel' class, annotated with @ViewModelInject to enable Hilt dependency injection. It initializes two properties: 'hopinRepository' and 'hopinNavigator'.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"userTokenReceived\",\n        \"component_code\": \"fun userTokenReceived(cookies: String) {\\n        val sp = cookies.split(\\\"; \\\")\\n        val spl = sp.filter { it.startsWith(\\\"user.token\\\") }\\n        if (spl.isNotEmpty()) {\\n            val userToken = spl[0].removePrefix(\\\"user.token=\\\")\\n            viewModelScope.launch {\\n                if (convertUserId(userToken))\\n                    hopinNavigator.mainToStreamer()\\n                else {\\n                    //error handling\\n                }\\n            }\\n        }\\n    }\",\n        \"component_description\": \"A function that processes a string of cookies to extract the 'user.token', then launches a coroutine to convert the user token. If successful, it navigates to the streamer screen using HopinNavigator.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"convertUserId\",\n        \"component_code\": \"private suspend fun convertUserId(userToken: String): Boolean {\\n        val getSessionRequest = GetSessionRequest(\\\"babe-project\\\")\\n        return hopinRepository.convertUserId(\\n                \\\"user.token=$userToken\\\",\\n                getSessionRequest\\n        )\\n    }\",\n        \"component_description\": \"A private suspending function that creates a 'GetSessionRequest' object and calls the 'convertUserId' method on the repository, passing the user token. It returns a Boolean indicating success or failure of the conversion.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"getStreamUrl\",\n        \"component_code\": \"suspend fun getStreamUrl(): String? {\\n        val uuid = getStages().stages[0].uuid\\n        val status = getStageStatus(uuid)\\n        val broadcast = status.broadcasts.filter { it.broadcast_type == \\\"mixer\\\" }.getOrNull(0)\\n        return broadcast?.stream_url\\n    }\",\n        \"component_description\": \"A suspending function that retrieves the UUID of the first stage, fetches its status, filters broadcasts for type 'mixer', and returns the stream URL if available. It returns null if no suitable broadcast is found.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"getStages\",\n        \"component_code\": \"private suspend fun getStages(): GetStagesResponse {\\n        return hopinRepository.getStages()\\n    }\",\n        \"component_description\": \"A private suspending function that calls the 'getStages' method on the repository and returns a 'GetStagesResponse' object containing stage information.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"getStageStatus\",\n        \"component_code\": \"private suspend fun getStageStatus(uuid: String): GetStageStatusResponse {\\n        return hopinRepository.getStageStatus(\\n                UUID.fromString(uuid)\\n        )\\n    }\",\n        \"component_description\": \"A private suspending function that converts a string UUID to a UUID object and calls the 'getStageStatus' method on the repository, passing the UUID. It returns a 'GetStageStatusResponse' object containing stage status information.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"bindNavController\",\n        \"component_code\": \"fun bindNavController(navController: NavController) {\\n        hopinNavigator.bind(navController)\\n    }\",\n        \"component_description\": \"A function that binds a 'NavController' to the 'HopinNavigator', allowing it to perform navigation actions.\"\n      }\n    ],\n    \"overall_description\": \"The 'HopinViewModel' class is a ViewModel in an Android application, responsible for managing UI-related data and handling user interactions. It uses Hilt for dependency injection to receive instances of HopinRepositoryContract and HopinNavigator. The ViewModel processes user tokens, retrieves stage information, and manages navigation using coroutines and suspending functions.\"\n  }"}
{"prompt": "\nYou are an expert PHP code analyst. Your task is to dissect a given PHP code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"PHP\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_PHP_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_PHP_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_PHP_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in PHP.\n2. Component Types: Use appropriate component types, for example, VARIABLE_DECLARATION, FUNCTION_DEFINITION, CLASS_DEFINITION, METHOD_DEFINITION, CONDITIONAL_STATEMENT, LOOP, DATABASE_QUERY, FORM_HANDLING, ERROR_HANDLING, NAMESPACE_DECLARATION, USE_STATEMENT.\n3. Component Names: Provide the correct identifier for each component (function name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified PHP code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including server-side scripting, form validation, session management, and database interaction.\n6. Overall Description: Provide a detailed summary of the entire PHP code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following PHP code properly and return ONLY the JSON response with no additional text:\n\n<?php\n# Generated by the protocol buffer compiler.  DO NOT EDIT!\n# source: src/proto/grpc/testing/control.proto\n\nnamespace Grpc\\Testing;\n\nuse Google\\Protobuf\\Internal\\GPBType;\nuse Google\\Protobuf\\Internal\\RepeatedField;\nuse Google\\Protobuf\\Internal\\GPBUtil;\n\n/**\n * Request current stats\n *\n * Generated from protobuf message <code>grpc.testing.Mark</code>\n */\nclass Mark extends \\Google\\Protobuf\\Internal\\Message\n{\n    /**\n     * if true, the stats will be reset after taking their snapshot.\n     *\n     * Generated from protobuf field <code>bool reset = 1;</code>\n     */\n    protected $reset = false;\n\n    /**\n     * Constructor.\n     *\n     * @param array $data {\n     *     Optional. Data for populating the Message object.\n     *\n     *     @type bool $reset\n     *           if true, the stats will be reset after taking their snapshot.\n     * }\n     */\n    public function __construct($data = NULL) {\n        \\GPBMetadata\\Src\\Proto\\Grpc\\Testing\\Control::initOnce();\n        parent::__construct($data);\n    }\n\n    /**\n     * if true, the stats will be reset after taking their snapshot.\n     *\n     * Generated from protobuf field <code>bool reset = 1;</code>\n     * @return bool\n     */\n    public function getReset()\n    {\n        return $this->reset;\n    }\n\n    /**\n     * if true, the stats will be reset after taking their snapshot.\n     *\n     * Generated from protobuf field <code>bool reset = 1;</code>\n     * @param bool $var\n     * @return $this\n     */\n    public function setReset($var)\n    {\n        GPBUtil::checkBool($var);\n        $this->reset = $var;\n\n        return $this;\n    }\n\n}\n\n", "completion": "{\n    \"programming_language\": \"PHP\",\n    \"components\": [\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"Grpc\\\\Testing\",\n        \"component_code\": \"namespace Grpc\\\\Testing;\",\n        \"component_description\": \"Declares the namespace for the class definition and sets the scope of visibility to this namespace.\"\n      },\n      {\n        \"component_type\": \"USE_STATEMENT\",\n        \"component_name\": \"Google\\\\Protobuf\\\\Internal\\\\GPBType\",\n        \"component_code\": \"use Google\\\\Protobuf\\\\Internal\\\\GPBType;\",\n        \"component_description\": \"Imports the GPBType class from the specified namespace to be used within this script.\"\n      },\n      {\n        \"component_type\": \"USE_STATEMENT\",\n        \"component_name\": \"Google\\\\Protobuf\\\\Internal\\\\RepeatedField\",\n        \"component_code\": \"use Google\\\\Protobuf\\\\Internal\\\\RepeatedField;\",\n        \"component_description\": \"Imports the RepeatedField class from the specified namespace to be used within this script.\"\n      },\n      {\n        \"component_type\": \"USE_STATEMENT\",\n        \"component_name\": \"Google\\\\Protobuf\\\\Internal\\\\GPBUtil\",\n        \"component_code\": \"use Google\\\\Protobuf\\\\Internal\\\\GPBUtil;\",\n        \"component_description\": \"Imports the GPBUtil class from the specified namespace to be used within this script.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"Mark\",\n        \"component_code\": \"class Mark extends \\\\Google\\\\Protobuf\\\\Internal\\Message\\n{\\n    // Class content...\\n}\",\n        \"component_description\": \"Defines a class named 'Mark' that extends the Message class from the Google Protobuf Internal namespace. This class represents a request for current stats with an option to reset them.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"$reset\",\n        \"component_code\": \"protected $reset = false;\",\n        \"component_description\": \"Declares a protected variable '$reset' and initializes it to false. This variable indicates whether the stats should be reset after taking their snapshot.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"__construct\",\n        \"component_code\": \"public function __construct($data = NULL) {\\n    \\\\GPBMetadata\\\\Src\\\\Proto\\\\Grpc\\\\Testing\\\\Control::initOnce();\\n    parent::__construct($data);\\n}\",\n        \"component_description\": \"Defines the constructor method for the 'Mark' class. It initializes metadata using the initOnce() method from the GPBMetadata namespace and calls the parent constructor with optional data.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"getReset\",\n        \"component_code\": \"public function getReset()\\n{\\n    return $this->reset;\\n}\",\n        \"component_description\": \"Defines a method 'getReset' that returns the value of the '$reset' variable. This method is used to retrieve whether the stats should be reset.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"setReset\",\n        \"component_code\": \"public function setReset($var)\\n{\\n    GPBUtil::checkBool($var);\\n    $this->reset = $var;\\n\\n    return $this;\\n}\",\n        \"component_description\": \"Defines a method 'setReset' that sets the value of the '$reset' variable after checking if the provided value is a boolean using GPBUtil::checkBool(). This method is used to specify whether the stats should be reset.\"\n      }\n    ],\n    \"overall_description\": \"The PHP script defines a class named 'Mark' within the Grpc\\\\Testing namespace, which extends the Message class from Google's Protobuf library. The class includes a protected variable '$reset' to indicate if stats should be reset after being retrieved. It also provides a constructor for initializing metadata and methods 'getReset' and 'setReset' for accessing and modifying the '$reset' variable. This class is part of a generated codebase from a Protocol Buffers file, used for handling requests related to statistics in gRPC testing.\"\n  }"}
{"prompt": "\nYou are an expert Ruby code analyst. Your task is to dissect a given Ruby code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_RUBY_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_RUBY_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_RUBY_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Ruby.\n2. Component Types: Use appropriate component types, for example, CLASS_DEFINITION, METHOD_DEFINITION, MODULE_DEFINITION, VARIABLE_DECLARATION, IF_STATEMENT, LOOP, BLOCK, LAMBDA, PROC, CONSTANT_DEFINITION, INCLUDE, EXTEND.\n3. Component Names: Provide the correct identifier for each component (method name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Ruby code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including Ruby-specific features like blocks, procs, lambdas, and modules.\n6. Overall Description: Provide a detailed summary of the entire Ruby code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Ruby code properly and return ONLY the JSON response with no additional text:\n\n<reponame>nicchagil/spring-framework\nrequire 'erb'\nrequire 'ostruct'\nrequire 'java'\n\n# Renders an ERB template against a hashmap of variables.\ndef render(template, variables, renderingContext)\n  context = OpenStruct.new(variables).instance_eval do\n    variables.each do |k, v|\n      instance_variable_set(k, v) if k[0] == '@'\n    end\n\n    def partial(partial_name, options={})\n      new_variables = marshal_dump.merge(options[:locals] || {})\n      Java::Pavo::ERB.render(partial_name, new_variables)\n    end\n\n    binding\n  end\n  ERB.new(template).result(context);\nend", "completion": "{\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": \"erb\",\n        \"component_code\": \"require 'erb'\",\n        \"component_description\": \"This line includes the ERB library, which is used for templating in Ruby. It allows embedding Ruby code within plain text, typically HTML.\"\n      },\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": \"ostruct\",\n        \"component_code\": \"require 'ostruct'\",\n        \"component_description\": \"This line includes the ostruct library, which provides an easy way to create simple data objects in Ruby using OpenStruct. This is used here to create a dynamic object from the hashmap of variables.\"\n      },\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": \"java\",\n        \"component_code\": \"require 'java'\",\n        \"component_description\": \"This line includes the Java integration for Ruby, allowing the use of Java classes and methods within Ruby code. This is used here to call a Java method from within an ERB template rendering context.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"render\",\n        \"component_code\": \"def render(template, variables, renderingContext)\\n  context = OpenStruct.new(variables).instance_eval do\\n    variables.each do |k, v|\\n      instance_variable_set(k, v) if k[0] == '@'\\n    end\\n\\n    def partial(partial_name, options={})\\n      new_variables = marshal_dump.merge(options[:locals] || {})\\n      Java::Pavo::ERB.render(partial_name, new_variables)\\n    end\\n\\n    binding\\n  end\\n  ERB.new(template).result(context);\\nend\",\n        \"component_description\": \"This method defines a custom rendering function for ERB templates. It takes three parameters: 'template' (the ERB template string), 'variables' (a hashmap of variables to be available in the template), and 'renderingContext' (which is not used in this code snippet). Inside the method, an OpenStruct object is created from the 'variables' hash, and each key-value pair in the hash that starts with '@' is set as an instance variable. A custom 'partial' method is defined within this context to allow rendering of partial templates with optional local variables passed through options. The binding of this modified context is then used by ERB's 'result' method to render the template string.\"\n      }\n    ],\n    \"overall_description\": \"The Ruby code defines a custom function for rendering ERB templates against a set of variables. It leverages the ERB and ostruct libraries to dynamically create an object from a hashmap of variables, allowing these variables to be used within the ERB template. The code also integrates with Java by calling a Java method to render partial templates, showcasing Ruby's cross-language capabilities. This function can be used to generate dynamic content by embedding Ruby logic within plain text templates.\"\n  }"}
{"prompt": "\nYou are an expert C code analyst. Your task is to dissect a given C code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"C\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_C_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_C_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_C_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in C.\n2. Component Types: Use appropriate component types, for example, HEADER_INCLUDE, MACRO_DEFINITION, GLOBAL_VARIABLE, FUNCTION_DEFINITION, STRUCT_DEFINITION, MAIN_FUNCTION, LOOP, CONDITIONAL_STATEMENT.\n3. Component Names: Provide the correct identifier for each component (function name, variable name, struct name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified C code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including data structures, control flow, memory management, and function interactions.\n6. Overall Description: Provide a detailed summary of the entire C code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following C code properly and return ONLY the JSON response with no additional text:\n\n<reponame>EricRemmerswaal/tensorflow\n/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n/// \\file\n/// Memory management for TF Lite.\n#ifndef TENSORFLOW_LITE_ALLOCATION_H_\n#define TENSORFLOW_LITE_ALLOCATION_H_\n\n#include <stddef.h>\n\n#include <cstdio>\n#include <cstdlib>\n#include <memory>\n\n#include \"tensorflow/lite/core/api/error_reporter.h\"\n\nnamespace tflite {\n\n// A memory allocation handle. This could be a mmap or shared memory.\nclass Allocation {\n public:\n  virtual ~Allocation() {}\n\n  enum class Type {\n    kMMap,\n    kFileCopy,\n    kMemory,\n  };\n\n  // Base pointer of this allocation\n  virtual const void* base() const = 0;\n  // Size in bytes of the allocation\n  virtual size_t bytes() const = 0;\n  // Whether the allocation is valid\n  virtual bool valid() const = 0;\n  // Return the type of the Allocation.\n  Type type() const { return type_; }\n\n protected:\n  Allocation(ErrorReporter* error_reporter, Type type)\n      : error_reporter_(error_reporter), type_(type) {}\n  ErrorReporter* error_reporter_;\n\n private:\n  const Type type_;\n};\n\n// Note that not all platforms support MMAP-based allocation.\n// Use `IsSupported()` to check.\nclass MMAPAllocation : public Allocation {\n public:\n  // Loads and maps the provided file to a memory region.\n  MMAPAllocation(const char* filename, ErrorReporter* error_reporter);\n\n  // Maps the provided file descriptor to a memory region.\n  // Note: The provided file descriptor will be dup'ed for usage; the caller\n  // retains ownership of the provided descriptor and should close accordingly.\n  MMAPAllocation(int fd, ErrorReporter* error_reporter);\n\n  // Maps the provided file descriptor, with the given offset and length (both\n  // in bytes), to a memory region.\n  // Note: The provided file descriptor will be dup'ed for usage; the caller\n  // retains ownership of the provided descriptor and should close accordingly.\n  MMAPAllocation(int fd, size_t offset, size_t length,\n                 ErrorReporter* error_reporter);\n\n  virtual ~MMAPAllocation();\n  const void* base() const override;\n  size_t bytes() const override;\n  bool valid() const override;\n\n  int fd() const { return mmap_fd_; }\n\n  static bool IsSupported();\n\n protected:\n  // Data required for mmap.\n  int mmap_fd_ = -1;  // mmap file descriptor\n  const void* mmapped_buffer_;\n  size_t buffer_size_bytes_ = 0;\n  // Used when the address to mmap is not page-aligned.\n  size_t offset_in_buffer_ = 0;\n\n private:\n  // Assumes ownership of the provided `owned_fd` instance.\n  MMAPAllocation(ErrorReporter* error_reporter, int owned_fd);\n\n  // Assumes ownership of the provided `owned_fd` instance, and uses the given\n  // offset and length (both in bytes) for memory mapping.\n  MMAPAllocation(ErrorReporter* error_reporter, int owned_fd, size_t offset,\n                 size_t length);\n};\n\nclass FileCopyAllocation : public Allocation {\n public:\n  // Loads the provided file into a heap memory region.\n  FileCopyAllocation(const char* filename, ErrorReporter* error_reporter);\n  virtual ~FileCopyAllocation();\n  const void* base() const override;\n  size_t bytes() const override;\n  bool valid() const override;\n\n private:\n  std::unique_ptr<const char[]> copied_buffer_;\n  size_t buffer_size_bytes_ = 0;\n};\n\nclass MemoryAllocation : public Allocation {\n public:\n  // Provides a (read-only) view of the provided buffer region as an allocation.\n  // Note: The caller retains ownership of `ptr`, and must ensure it remains\n  // valid for the lifetime of the class instance.\n  MemoryAllocation(const void* ptr, size_t num_bytes,\n                   ErrorReporter* error_reporter);\n  virtual ~MemoryAllocation();\n  const void* base() const override;\n  size_t bytes() const override;\n  bool valid() const override;\n\n private:\n  const void* buffer_;\n  size_t buffer_size_bytes_ = 0;\n};\n\n}  // namespace tflite\n\n#endif  // TENSORFLOW_LITE_ALLOCATION_H_\n", "completion": "{\n    \"programming_language\": \"C\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <stddef.h>\",\n        \"component_description\": \"Includes the standard library header for type definitions, including size_t.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <cstdio>\",\n        \"component_description\": \"Includes the C standard I/O library header, though not used in this snippet.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <cstdlib>\",\n        \"component_description\": \"Includes the C standard general utilities library header, though not used in this snippet.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <memory>\",\n        \"component_description\": \"Includes the C++ memory management header for smart pointers like std::unique_ptr.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": \"error_reporter.h\",\n        \"component_code\": \"#include \\\"tensorflow/lite/core/api/error_reporter.h\\\"\",\n        \"component_description\": \"Includes a custom TensorFlow Lite error reporting utility header, providing functionality for logging errors.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"Allocation\",\n        \"component_code\": \"class Allocation {\\n public:\\n  virtual ~Allocation() {}\\n\\n  enum class Type {\\n    kMMap,\\n    kFileCopy,\\n    kMemory,\\n  };\\n\\n  // Base pointer of this allocation\\n  virtual const void* base() const = 0;\\n  // Size in bytes of the allocation\\n  virtual size_t bytes() const = 0;\\n  // Whether the allocation is valid\\n  virtual bool valid() const = 0;\\n  // Return the type of the Allocation.\\n  Type type() const { return type_; }\\n\\n protected:\\n  Allocation(ErrorReporter* error_reporter, Type type)\\n      : error_reporter_(error_reporter), type_(type) {}\\n  ErrorReporter* error_reporter_;\\n\\n private:\\n  const Type type_;\\n};\",\n        \"component_description\": \"An abstract base class representing a memory allocation. It includes virtual methods for obtaining the base pointer, size in bytes, and validity of the allocation. The Allocation class also holds an enum for different types of allocations (kMMap, kFileCopy, kMemory) and uses an ErrorReporter to log errors.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"MMAPAllocation\",\n        \"component_code\": \"class MMAPAllocation : public Allocation {\\n public:\\n  // Loads and maps the provided file to a memory region.\\n  MMAPAllocation(const char* filename, ErrorReporter* error_reporter);\\n\\n  // Maps the provided file descriptor to a memory region.\\n  MMAPAllocation(int fd, ErrorReporter* error_reporter);\\n\\n  virtual ~MMAPAllocation();\\n  const void* base() const override;\\n  size_t bytes() const override;\\n  bool valid() const override;\\n\\n private:\\n  int owned_fd_;\\n  const void* mmapped_buffer_;\\n  size_t buffer_size_bytes_ = 0;\\n};\",\n        \"component_description\": \"A derived class from Allocation that represents a memory-mapped allocation. It provides constructors to map either a file or a file descriptor into memory and implements the virtual methods for obtaining the base pointer, size in bytes, and validity of the allocation.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"FileCopyAllocation\",\n        \"component_code\": \"class FileCopyAllocation : public Allocation {\\n public:\\n  // Loads the provided file into a heap memory region.\\n  FileCopyAllocation(const char* filename, ErrorReporter* error_reporter);\\n\\n  virtual ~FileCopyAllocation();\\n  const void* base() const override;\\n  size_t bytes() const override;\\n  bool valid() const override;\\n\\n private:\\n  std::unique_ptr<const char[]> copied_buffer_;\\n  size_t buffer_size_bytes_ = 0;\\n};\",\n        \"component_description\": \"A derived class from Allocation that represents a file copy allocation. It loads the contents of a provided file into heap memory and implements the virtual methods for obtaining the base pointer, size in bytes, and validity of the allocation using std::unique_ptr for automatic memory management.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"MemoryAllocation\",\n        \"component_code\": \"class MemoryAllocation : public Allocation {\\n public:\\n  // Provides a (read-only) view of the provided buffer region as an allocation.\\n  MemoryAllocation(const void* ptr, size_t num_bytes,\\n                   ErrorReporter* error_reporter);\\n\\n  virtual ~MemoryAllocation();\\n  const void* base() const override;\\n  size_t bytes() const override;\\n  bool valid() const override;\\n\\n private:\\n  const void* buffer_;\\n  size_t buffer_size_bytes_ = 0;\\n};\",\n        \"component_description\": \"A derived class from Allocation that represents a read-only view of an existing memory buffer. It takes a pointer to the buffer and its size, and implements the virtual methods for obtaining the base pointer, size in bytes, and validity of the allocation.\"\n      }\n    ],\n    \"main_function\": null,\n    \"description\": \"This header file defines several classes related to different types of memory allocations used in TensorFlow Lite. The Allocation class is an abstract base class with pure virtual methods that must be implemented by derived classes. MMAPAllocation maps files or file descriptors into memory, FileCopyAllocation copies file contents into heap memory, and MemoryAllocation provides a read-only view of existing buffers.\"\n  }"}
{"prompt": "\nYou are an expert TypeScript code analyst. Your task is to dissect a given TypeScript code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"TypeScript\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_TYPESCRIPT_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_TYPESCRIPT_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_TYPESCRIPT_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in TypeScript.\n2. Component Types: Use appropriate component types, for example, INTERFACE_DEFINITION, TYPE_ALIAS, CLASS_DEFINITION, FUNCTION_DEFINITION, METHOD_DEFINITION, GENERIC_TYPE, MODULE_IMPORT, DECORATOR, VARIABLE_DECLARATION, ENUM_DEFINITION, ASYNC_FUNCTION, PROMISE, CONDITIONAL_TYPE.\n3. Component Names: Provide the correct identifier for each component (function name, class name, interface name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified TypeScript code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including TypeScript-specific features like static typing, interfaces, generics, and type inference.\n6. Overall Description: Provide a detailed summary of the entire TypeScript code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following TypeScript code properly and return ONLY the JSON response with no additional text:\n\nimport React from 'react';\nimport { useTranslation } from 'react-i18next';\n\nfunction Initial(\n  props: JSX.IntrinsicAttributes & React.SVGProps<SVGSVGElement>\n): JSX.Element {\n  const { t } = useTranslation();\n\n  return (\n    <svg\n      height='50'\n      viewBox='0 0 200 200'\n      width='50'\n      xmlns='http://www.w3.org/2000/svg'\n      {...props}\n    >\n      <g>\n        <title>{t('icons.initial')}</title>\n        <circle\n          cx='100'\n          cy='99'\n          fill='var(--primary-color)'\n          r='95'\n          stroke='var(--primary-color)'\n          strokeDasharray='null'\n        />\n        <svg\n          height='200'\n          viewBox='-13 -12 50 50'\n          width='200'\n          xmlns='http://www.w3.org/2000/svg'\n        >\n          <path\n            d={\n              'M8 1c0-.552.448-1 1-1h6c.553 0 1 .448 1 1s-.447 1-1 1h-6c-' +\n              '.552 0-1-.448-1-1zm13 20.554c0 1.284-1.023 2.446-2.424 ' +\n              '2.446h-13.153c-1.4 0-2.423-1.162-2.423-2.445 0-.35.076-.709.' +\n              '242-1.057l3.743-7.856c1.04-2.186 2.015-4.581 2.015-7.007v-1.' +\n              '635h2l-.006 2c-.087 2.623-1.09 5.092-1.973 7h3.682l4.377 9h1.' +\n              '496c.309 0 .52-.342.377-.644l-3.743-7.854c-1.046-2.197-2.12-4' +\n              '.791-2.21-7.502v-2h2v1.635c0 2.426.975 4.82 2.016 7.006l3.743' +\n              ' 7.856c.165.348.241.707.241 1.057zm-12-1.054c0-.829-.671-1.5-' +\n              '1.5-1.5s-1.5.671-1.5 1.5.671 1.5 1.5 1.5 1.5-.671 1.5-1.5zm2-' +\n              '3.5c0-.553-.448-1-1-1-.553 0-1 .447-1 1s.447 1 1 1c.552 0 1-.' +\n              '447 1-1zm3 3c0-.552-.448-1-1-1s-1 .448-1 1 .448 1 1 1 1-.448 ' +\n              '1-1z'\n            }\n            fill='var(--primary-background)'\n          />\n        </svg>\n      </g>\n    </svg>\n  );\n}\n\nInitial.displayName = 'Initial';\n\nexport default Initial;\n", "completion": "{\n    \"programming_language\": \"TypeScript\",\n    \"components\": [\n      {\n        \"component_type\": \"MODULE_IMPORT\",\n        \"component_name\": NULL,\n        \"component_code\": \"import React from 'react';\",\n        \"component_description\": \"Imports the React library which is essential for creating and managing UI components in a TypeScript or JavaScript application.\"\n      },\n      {\n        \"component_type\": \"MODULE_IMPORT\",\n        \"component_name\": NULL,\n        \"component_code\": \"import { useTranslation } from 'react-i18next';\",\n        \"component_description\": \"Imports the `useTranslation` hook from the 'react-i18next' library, which is used to manage translations in a React application.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"Initial\",\n        \"component_code\": \"function Initial(props: JSX.IntrinsicAttributes & React.SVGProps<SVGSVGElement>): JSX.Element { ... }\",\n        \"component_description\": \"Defines a functional component named 'Initial' that takes props of type `JSX.IntrinsicAttributes & React.SVGProps<SVGSVGElement>` and returns a JSX.Element. This component is designed to render an SVG graphic using the provided props.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"t\",\n        \"component_code\": \"const { t } = useTranslation();\",\n        \"component_description\": \"Declares a constant variable `t` by destructuring it from the result of the `useTranslation()` hook. The `t` function is used to translate text strings within the component.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": NULL,\n        \"component_code\": \"Initial.displayName = 'Initial';\",\n        \"component_description\": \"Sets the displayName property of the Initial component to the string 'Initial'. This is useful for debugging and identifying components in React DevTools.\"\n      }\n    ],\n    \"overall_description\": \"The provided TypeScript code defines a React functional component named 'Initial' that renders an SVG graphic. The component accepts props specific to SVG elements and uses the `useTranslation` hook from 'react-i18next' to handle text translations. The SVG includes a circle and a complex path that are styled with CSS variables for colors, making it adaptable to different themes. The component also has its displayName set for easier identification in React DevTools.\"\n  }"}
{"prompt": "\nYou are an expert SQL analyst. Your task is to dissect a given SQL script and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"database_system\": \"<DATABASE_SYSTEM_IF_SPECIFIED_OR_GENERAL_SQL>\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_SQL_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_SQL_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_SQL_SCRIPT_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the SQL Variant: Determine if the script is specific to MySQL, PostgreSQL, SQL Server, Oracle, etc., or general SQL.\n2. Component Types: Classify each component accurately, such as TABLE_DEFINITION, VIEW, STORED_PROCEDURE, FUNCTION, TRIGGER, INDEX, QUERY, etc.\n3. Component Names: Provide the correct identifier for each component (table name, procedure name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified SQL code for each component.\n5. Component Descriptions: Provide a technical explanation of what each component does, including its role in data storage, manipulation, or retrieval.\n6. Overall Description: Offer a detailed summary of the entire SQL script, its purpose, and how different components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following SQL script properly and return ONLY the JSON response with no additional text:\n\nCREATE TABLE payload (name text, value blob)\nCREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT)\n", "completion": "{\n    \"database_system\": \"GENERAL_SQL\",\n    \"components\": [\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"payload\",\n        \"component_code\": \"CREATE TABLE payload (name text, value blob)\",\n        \"component_description\": \"This component defines a table named 'payload' with two columns: 'name' of type text and 'value' of type blob. This table is used to store textual names associated with binary data values.\"\n      },\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"searchIndex\",\n        \"component_code\": \"CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT)\",\n        \"component_description\": \"This component defines a table named 'searchIndex' with four columns: 'id' which is an integer serving as the primary key, 'name' of type text, 'type' of type text, and 'path' of type text. This table is used to store indexed search information including unique identifiers, names, types, and paths.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script defines two tables: 'payload' for storing textual names with associated binary data values, and 'searchIndex' for storing indexed search information with unique identifiers, names, types, and paths. These tables are likely used in an application that requires storage of both unstructured binary data and structured searchable metadata.\"\n  }"}
{"prompt": "\nYou are an expert JavaScript code analyst. Your task is to dissect a given JavaScript code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"JavaScript\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_JS_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_JS_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_JS_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in JavaScript.\n2. Component Types: Use appropriate component types, for example, VARIABLE_DECLARATION, FUNCTION_DEFINITION, ARROW_FUNCTION, EVENT_HANDLER, CLASS_DEFINITION, MODULE_IMPORT, CONDITIONAL_STATEMENT, LOOP, PROMISE, ASYNC_FUNCTION, CALLBACK_FUNCTION.\n3. Component Names: Provide the correct identifier for each component (function name, variable name, class name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified JavaScript code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including handling DOM, async operations, functions, closures, and variable scoping.\n6. Overall Description: Provide a detailed summary of the entire JavaScript code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following JavaScript code properly and return ONLY the JSON response with no additional text:\n\n<gh_stars>1000+\nimport Vue from 'vue'\nimport { warn } from 'core/util/debug'\n\ndescribe('Global config', () => {\n  it('should warn replacing config object', () => {\n    const originalConfig = Vue.config\n    Vue.config = {}\n    expect(Vue.config).toBe(originalConfig)\n    expect('Do not replace the Vue.config object').toHaveBeenWarned()\n  })\n\n  describe('silent', () => {\n    it('should be false by default', () => {\n      warn('foo')\n      expect('foo').toHaveBeenWarned()\n    })\n\n    it('should work when set to true', () => {\n      Vue.config.silent = true\n      warn('foo')\n      expect('foo').not.toHaveBeenWarned()\n      Vue.config.silent = false\n    })\n  })\n\n  describe('optionMergeStrategies', () => {\n    it('should allow defining custom option merging strategies', () => {\n      const spy = jasmine.createSpy('option merging')\n      Vue.config.optionMergeStrategies.__test__ = (parent, child, vm) => {\n        spy(parent, child, vm)\n        return child + 1\n      }\n      const Test = Vue.extend({\n        __test__: 1\n      })\n      expect(spy.calls.count()).toBe(1)\n      expect(spy).toHaveBeenCalledWith(undefined, 1, undefined)\n      expect(Test.options.__test__).toBe(2)\n      const test = new Test({\n        __test__: 2\n      })\n      expect(spy.calls.count()).toBe(2)\n      expect(spy).toHaveBeenCalledWith(2, 2, test)\n      expect(test.$options.__test__).toBe(3)\n    })\n  })\n\n  describe('ignoredElements', () => {\n    it('should work', () => {\n      Vue.config.ignoredElements = ['foo', /^ion-/]\n      new Vue({\n        template: `<div><foo/><ion-foo/><ion-bar/></div>`\n      }).$mount()\n      expect('Unknown custom element').not.toHaveBeenWarned()\n      Vue.config.ignoredElements = []\n    })\n  })\n\n  describe('async', () => {\n    it('does not update synchronously when true', () => {\n      const spy = jasmine.createSpy()\n      const vm = new Vue({\n        template: `<div :class=\"value\"></div>`,\n        updated: spy,\n        data: { value: true }\n      }).$mount()\n      vm.value = false\n      expect(spy).not.toHaveBeenCalled()\n    })\n\n    it('updates synchronously when false', () => {\n      const spy = jasmine.createSpy()\n      Vue.config.async = false\n      const vm = new Vue({\n        template: `<div :class=\"value\"></div>`,\n        updated: spy,\n        data: { value: true }\n      }).$mount()\n      vm.value = false\n      expect(spy).toHaveBeenCalled()\n      Vue.config.async = true\n    })\n\n    it('runs watchers in correct order when false', () => {\n      Vue.config.async = false\n      const vm = new Vue({\n        template: `\n          <div id=\"app\">\n            {{ computed }}\n          </div>`,\n        props: ['prop'],\n        propsData: {\n          'prop': []\n        },\n        data: () => ({\n          data: ''\n        }),\n        computed: {\n          computed () {\n            return this.prop.join(',')\n          }\n        },\n        watch: {\n          prop: 'execute'\n        },\n        methods: {\n          execute () {\n            this.data = this.computed\n          }\n        }\n      }).$mount()\n      expect(vm.computed).toBe('')\n      expect(vm.data).toBe('')\n\n      vm.prop = [1, 2, 3]\n      expect(vm.computed).toBe('1,2,3')\n      expect(vm.data).toBe('1,2,3')\n\n      vm.prop.push(4, 5)\n      expect(vm.computed).toBe('1,2,3,4,5')\n      expect(vm.data).toBe('1,2,3,4,5')\n      Vue.config.async = true\n    })\n  })\n})\n", "completion": "{\n    \"programming_language\": \"JavaScript\",\n    \"components\": [\n      {\n        \"component_type\": \"MODULE_IMPORT\",\n        \"component_name\": null,\n        \"component_code\": \"import Vue from 'vue'\\nimport { warn } from 'core/util/debug'\",\n        \"component_description\": \"Imports the Vue library and a warn function from the specified module, which will be used for logging warnings during testing.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"describe\",\n        \"component_code\": \"describe('Global config', () => { ... })\",\n        \"component_description\": \"Defines a test suite named 'Global config' using Jasmine, containing multiple test cases to verify the behavior of Vue's global configuration options.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"it\",\n        \"component_code\": \"it('should warn replacing config object', () => { ... })\",\n        \"component_description\": \"A test case within the 'Global config' suite that verifies a warning is logged when attempting to replace Vue's configuration object.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"originalConfig\",\n        \"component_code\": \"const originalConfig = Vue.config\",\n        \"component_description\": \"Declares a constant 'originalConfig' and assigns it the current value of Vue's config object for comparison later in the test.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"warn\",\n        \"component_code\": \"warn('foo')\",\n        \"component_description\": \"A call to the warn function, used to simulate logging a warning message, which is then checked in the following assertions.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"expect\",\n        \"component_code\": \"expect(Vue.config).toBe(originalConfig)\\nexpect('Do not replace the Vue.config object').toHaveBeenWarned()\",\n        \"component_description\": \"Assertions using Jasmine's expect function to check that Vue's config object was not changed and a specific warning message was logged.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"it\",\n        \"component_code\": \"it('should be false by default', () => { ... })\",\n        \"component_description\": \"A test case that checks the default value of Vue's config.silent property and verifies that warnings are logged.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"spy\",\n        \"component_code\": \"const spy = jasmine.createSpy('option merging')\",\n        \"component_description\": \"Declares a constant 'spy' and assigns it a Jasmine spy, which will be used to monitor calls to the custom option merging strategy function.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"Vue.config.optionMergeStrategies.__test__\",\n        \"component_code\": \"Vue.config.optionMergeStrategies.__test__ = (parent, child, vm) => { ... }\",\n        \"component_description\": \"Defines a custom option merging strategy function for the '__test__' property in Vue's config object, which logs its arguments using the spy and returns a modified value.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"Vue.extend\",\n        \"component_code\": \"const Test = Vue.extend({ ... })\",\n        \"component_description\": \"Creates a new Vue constructor function 'Test' extended from Vue with options including the '__test__' property, which triggers the custom option merging strategy.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"new Test\",\n        \"component_code\": \"const test = new Test({ ... })\",\n        \"component_description\": \"Creates a new instance of the 'Test' Vue component with initial data, which again triggers the custom option merging strategy.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"it\",\n        \"component_code\": \"it('should be false by default', () => { ... })\",\n        \"component_description\": \"A test case that checks if warnings are not logged when Vue's config.silent is set to true.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"it\",\n        \"component_code\": \"it('should be false by default', () => { ... })\",\n        \"component_description\": \"A test case that verifies the behavior of Vue's config option when setting and modifying a prop, with asynchronous updates disabled (config.async = false).\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"new Vue\",\n        \"component_code\": \"const vm = new Vue({ ... })\",\n        \"component_description\": \"Creates a new instance of the Vue component with specified template, props, data, computed property, watcher, and method, which is used to test synchronous updates.\"\n      }\n    ],\n    \"overall_description\": \"The provided code defines a series of Jasmine tests for verifying various behaviors of Vue's global configuration options. It includes tests for warning messages when replacing config objects, default behavior of the 'silent' option, custom option merging strategies, and synchronous updates with async set to false.\"\n  }"}
{"prompt": "\nYou are an expert Java code analyst. Your task is to dissect a given Java code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Java\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_JAVA_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_JAVA_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_JAVA_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Java.\n2. Component Types: Use appropriate component types, for example, IMPORT_STATEMENT, CLASS_DEFINITION, INTERFACE_DEFINITION, METHOD_DEFINITION, CONSTRUCTOR, FIELD_DEFINITION, STATIC_BLOCK, MAIN_METHOD, TRY_CATCH_BLOCK, IF_STATEMENT, SWITCH_STATEMENT, LOOP.\n3. Component Names: Provide the correct identifier for each component (method name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Java code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including object-oriented features, data structures, exception handling, and function interactions.\n6. Overall Description: Provide a detailed summary of the entire Java code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Java code properly and return ONLY the JSON response with no additional text:\n\n/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\npackage org.tensorflow.op;\n\nimport org.tensorflow.Operation;\n\n/**\n * A base class for {@link Op} implementations that are backed by a single {@link Operation}.\n *\n * <p>Each operation registered in the TensorFlow core is a primitive and is provided as a {@code\n * PrimitiveOp}. Custom operations working with only one primitive may also derive from this class.\n */\npublic abstract class PrimitiveOp implements Op {\n\n  /** Returns the underlying {@link Operation} */\n  public Operation op() {\n    return operation;\n  }\n\n  @Override\n  public final int hashCode() {\n    return operation.hashCode();\n  }\n\n  @Override\n  public final boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    // Note: we consider that all objects wrapping the same operation are equal, no matter their\n    // implementation\n    if (!(obj instanceof PrimitiveOp)) {\n      return false;\n    }\n    return operation.equals(((PrimitiveOp) obj).operation);\n  }\n\n  @Override\n  public final String toString() {\n    return String.format(\"<%s '%s'>\", operation.type(), operation.name());\n  }\n\n  protected final Operation operation;\n\n  /**\n   * Constructor.\n   *\n   * @param operation the underlying operation\n   */\n  protected PrimitiveOp(Operation operation) {\n    this.operation = operation;\n  }\n}\n", "completion": "{\n    \"programming_language\": \"Java\",\n    \"components\": [\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import org.tensorflow.Operation;\",\n        \"component_description\": \"Imports the Operation class from the org.tensorflow package, which is used to represent a single TensorFlow operation.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"PrimitiveOp\",\n        \"component_code\": \"public abstract class PrimitiveOp implements Op {\\n\\n  /** Returns the underlying {@link Operation} */\\n  public Operation op() {\\n    return operation;\\n  }\\n\\n  @Override\\n  public final int hashCode() {\\n    return operation.hashCode();\\n  }\\n\\n  @Override\\n  public final boolean equals(Object obj) {\\n    if (this == obj) {\\n      return true;\\n    }\\n    // Note: we consider that all objects wrapping the same operation are equal, no matter their\\n    // implementation\\n    if (!(obj instanceof PrimitiveOp)) {\\n      return false;\\n    }\\n    return operation.equals(((PrimitiveOp) obj).operation);\\n  }\\n\\n  @Override\\n  public final String toString() {\\n    return String.format(\\\"<%s '%s'>\\\", operation.type(), operation.name());\\n  }\\n\\n  protected final Operation operation;\\n\\n  /**\\n   * Constructor.\\n   *\\n   * @param operation the underlying operation\\n   */\\n  protected PrimitiveOp(Operation operation) {\\n    this.operation = operation;\\n  }\\n}\",\n        \"component_description\": \"Defines an abstract class named PrimitiveOp that implements the Op interface. This class serves as a base for operations in TensorFlow that are backed by a single Operation object.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"op\",\n        \"component_code\": \"public Operation op() {\\n  return operation;\\n}\",\n        \"component_description\": \"Public method that returns the underlying Operation object associated with this PrimitiveOp instance.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"hashCode\",\n        \"component_code\": \"@Override\\npublic final int hashCode() {\\n  return operation.hashCode();\\n}\",\n        \"component_description\": \"Overrides the default hashCode method to return the hash code of the underlying Operation object.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"equals\",\n        \"component_code\": \"@Override\\npublic final boolean equals(Object obj) {\\n  if (this == obj) {\\n    return true;\\n  }\\n  // Note: we consider that all objects wrapping the same operation are equal, no matter their\\n  // implementation\\n  if (!(obj instanceof PrimitiveOp)) {\\n    return false;\\n  }\\n  return operation.equals(((PrimitiveOp) obj).operation);\\n}\",\n        \"component_description\": \"Overrides the default equals method to check if another object is an instance of PrimitiveOp and if it wraps the same Operation object.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"toString\",\n        \"component_code\": \"@Override\\npublic final String toString() {\\n  return String.format(\\\"<%s '%s'>\\\", operation.type(), operation.name());\\n}\",\n        \"component_description\": \"Overrides the default toString method to provide a string representation of the PrimitiveOp instance, showing its type and name.\"\n      },\n      {\n        \"component_type\": \"FIELD_DEFINITION\",\n        \"component_name\": \"operation\",\n        \"component_code\": \"protected final Operation operation;\",\n        \"component_description\": \"Protected final field that holds the underlying Operation object for this PrimitiveOp instance.\"\n      },\n      {\n        \"component_type\": \"CONSTRUCTOR\",\n        \"component_name\": \"PrimitiveOp\",\n        \"component_code\": \"protected PrimitiveOp(Operation operation) {\\n  this.operation = operation;\\n}\",\n        \"component_description\": \"Protected constructor that initializes the operation field with the provided Operation object, allowing subclasses to set up their underlying operation.\"\n      }\n    ],\n    \"overall_description\": \"The PrimitiveOp class is an abstract Java class that serves as a base for TensorFlow operations that are backed by a single Operation object. It includes methods to retrieve and represent the underlying operation, as well as overridden equals and hashCode methods based on the operation field. The class also defines a protected constructor to initialize its operation field, which subclasses can use.\"\n  }"}
{"prompt": "\nYou are an expert Ruby code analyst. Your task is to dissect a given Ruby code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_RUBY_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_RUBY_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_RUBY_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Ruby.\n2. Component Types: Use appropriate component types, for example, CLASS_DEFINITION, METHOD_DEFINITION, MODULE_DEFINITION, VARIABLE_DECLARATION, IF_STATEMENT, LOOP, BLOCK, LAMBDA, PROC, CONSTANT_DEFINITION, INCLUDE, EXTEND.\n3. Component Names: Provide the correct identifier for each component (method name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Ruby code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including Ruby-specific features like blocks, procs, lambdas, and modules.\n6. Overall Description: Provide a detailed summary of the entire Ruby code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Ruby code properly and return ONLY the JSON response with no additional text:\n\n# Generated by the protocol buffer compiler.  DO NOT EDIT!\n# source: helloworld.proto\n\nrequire 'google/protobuf'\n\nGoogle::Protobuf::DescriptorPool.generated_pool.build do\n  add_message \"helloworld.HelloRequest\" do\n    optional :name, :string, 1\n  end\n  add_message \"helloworld.HelloReply\" do\n    optional :message, :string, 1\n  end\nend\n\nmodule Helloworld\n  HelloRequest = Google::Protobuf::DescriptorPool.generated_pool.lookup(\"helloworld.HelloRequest\").msgclass\n  HelloReply = Google::Protobuf::DescriptorPool.generated_pool.lookup(\"helloworld.HelloReply\").msgclass\nend\n", "completion": "{\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'google/protobuf'\",\n        \"component_description\": \"This statement includes the Google Protocol Buffers library, which is necessary for defining and using protocol buffer messages in Ruby.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"Google::Protobuf::DescriptorPool.generated_pool.build do\\n  add_message \\\"helloworld.HelloRequest\\\" do\\n    optional :name, :string, 1\\n  end\\n  add_message \\\"helloworld.HelloReply\\\" do\\n    optional :message, :string, 1\\n  end\\nend\",\n        \"component_description\": \"This block is used to define the structure of two protocol buffer messages: HelloRequest and HelloReply. The `add_message` method within the block specifies that each message has an optional string field. For HelloRequest, this field is named `name`, and for HelloReply, it is named `message`. Both fields are assigned a tag of 1.\"\n      },\n      {\n        \"component_type\": \"MODULE_DEFINITION\",\n        \"component_name\": \"Helloworld\",\n        \"component_code\": \"module Helloworld\\n  HelloRequest = Google::Protobuf::DescriptorPool.generated_pool.lookup(\\\"helloworld.HelloRequest\\\").msgclass\\n  HelloReply = Google::Protobuf::DescriptorPool.generated_pool.lookup(\\\"helloworld.HelloReply\\\").msgclass\\nend\",\n        \"component_description\": \"This module, named Helloworld, contains two constants: `HelloRequest` and `HelloReply`. These constants are assigned the message classes for their respective protocol buffer messages by looking them up in the generated descriptor pool using their fully qualified names. This setup allows easy access to these message types within the Helloworld module.\"\n      }\n    ],\n    \"overall_description\": \"This Ruby script defines two protocol buffer messages, `HelloRequest` and `HelloReply`, using the Google Protocol Buffers library. It specifies that each message contains a single optional string field named `name` for `HelloRequest` and `message` for `HelloReply`. The script then encapsulates these message types within a module called Helloworld, making them accessible as constants within that module.\"\n  }"}
{"prompt": "\nYou are an expert Rust code analyst. Your task is to dissect a given Rust code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Rust\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_RUST_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_RUST_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_RUST_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Rust.\n2. Component Types: Use appropriate component types, for example, MODULE_DECLARATION, USE_STATEMENT, STRUCT_DEFINITION, ENUM_DEFINITION, TRAIT_DEFINITION, FUNCTION_DEFINITION, IMPLEMENTATION_BLOCK, MATCH_STATEMENT, LET_STATEMENT, LOOP, IF_STATEMENT, PATTERN_MATCHING.\n3. Component Names: Provide the correct identifier for each component (function name, struct name, enum name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Rust code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including ownership, borrowing, pattern matching, and concurrency aspects of Rust.\n6. Overall Description: Provide a detailed summary of the entire Rust code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Rust code properly and return ONLY the JSON response with no additional text:\n\n<gh_stars>1000+\n// run-pass\n#![allow(dead_code)]\n\nfn foo<T>(t: T) -> impl Into<[T; { const FOO: usize = 1; FOO }]> {\n    [t]\n}\n\nfn bar() -> impl Into<[u8; { const FOO: usize = 1; FOO }]> {\n    [99]\n}\n\nfn main() {\n    println!(\"{:?}\", foo(42).into());\n    println!(\"{:?}\", bar().into());\n}\n", "completion": "{\n    \"programming_language\": \"Rust\",\n    \"components\": [\n      {\n        \"component_type\": \"ATTRIBUTE_DECLARATION\",\n        \"component_name\": NULL,\n        \"component_code\": \"#![allow(dead_code)]\",\n        \"component_description\": \"This attribute allows the compiler to ignore dead code warnings, meaning that functions or items that are defined but never used will not produce a warning during compilation.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"foo\",\n        \"component_code\": \"fn foo<T>(t: T) -> impl Into<[T; { const FOO: usize = 1; FOO }]> {\\n    [t]\\n}\",\n        \"component_description\": \"This is a generic function named 'foo' that takes one parameter 't' of any type 'T'. It returns an implementation of the trait 'Into<[T; 1]>', which means it can be converted into an array of type '[T; 1]'. Inside the function, a constant 'FOO' is defined with a value of 1, and this constant is used to specify the size of the array. The function returns a single-element array containing 't'.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"bar\",\n        \"component_code\": \"fn bar() -> impl Into<[u8; { const FOO: usize = 1; FOO }]> {\\n    [99]\\n}\",\n        \"component_description\": \"This function 'bar' does not take any parameters and returns an implementation of the trait 'Into<[u8; 1]>', which means it can be converted into a single-element array of type '[u8; 1]'. A constant 'FOO' is defined with a value of 1, and this constant is used to specify the size of the array. The function returns an array containing the u8 value 99.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"fn main() {\\n    println!(\\\"{:?}\\\", foo(42).into());\\n    println!(\\\"{:?}\\\", bar().into());\\n}\",\n        \"component_description\": \"The 'main' function is the entry point of the Rust program. It calls the 'foo' function with the argument 42, which returns an array [42]. The '.into()' method is called on this return value to convert it into a specific type (in this case, an array), and the result is printed using 'println!'. Similarly, the 'bar' function is called, which returns an array [99], and its result is also printed after conversion. Both arrays are printed in debug format.\"\n      }\n    ],\n    \"overall_description\": \"This Rust program defines two functions, 'foo' and 'bar', which both return a single-element array of type '[T; 1]' and '[u8; 1]', respectively. The main function demonstrates the usage of these functions by printing their results after converting them into arrays using the '.into()' method. The use of generics in 'foo' allows it to accept any type, while 'bar' specifically returns an array of u8 values.\"\n  }"}
{"prompt": "\nYou are an expert Java code analyst. Your task is to dissect a given Java code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Java\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_JAVA_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_JAVA_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_JAVA_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Java.\n2. Component Types: Use appropriate component types, for example, IMPORT_STATEMENT, CLASS_DEFINITION, INTERFACE_DEFINITION, METHOD_DEFINITION, CONSTRUCTOR, FIELD_DEFINITION, STATIC_BLOCK, MAIN_METHOD, TRY_CATCH_BLOCK, IF_STATEMENT, SWITCH_STATEMENT, LOOP.\n3. Component Names: Provide the correct identifier for each component (method name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Java code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including object-oriented features, data structures, exception handling, and function interactions.\n6. Overall Description: Provide a detailed summary of the entire Java code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Java code properly and return ONLY the JSON response with no additional text:\n\n/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\npackage org.tensorflow.lite;\n\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\nimport java.util.EnumSet;\nimport javax.imageio.ImageIO;\n\n/** Utility for interacting with test-specific data. */\npublic abstract class TestUtils {\n\n  private static final float DEFAULT_IMAGE_MEAN = 127.5f;\n  private static final float DEFAULT_IMAGE_STD = 127.5f;\n\n  public static MappedByteBuffer getTestFileAsBuffer(String path) {\n    try (FileChannel fileChannel =\n        (FileChannel)\n            Files.newByteChannel(new File(path).toPath(), EnumSet.of(StandardOpenOption.READ))) {\n      return fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public static boolean supportsFilePaths() {\n    return true;\n  }\n\n  public static ByteBuffer getTestImageAsByteBuffer(String path) {\n    File imageFile = new File(path);\n    try {\n      BufferedImage image = ImageIO.read(imageFile);\n      return toByteBuffer(image);\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public static ByteBuffer getTestImageAsFloatByteBuffer(String path) {\n    File imageFile = new File(path);\n    try {\n      BufferedImage image = ImageIO.read(imageFile);\n      return toFloatByteBuffer(image);\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private static ByteBuffer toByteBuffer(BufferedImage image) {\n    ByteBuffer imgData =\n        ByteBuffer.allocateDirect(image.getHeight() * image.getWidth() * 3)\n            .order(ByteOrder.nativeOrder());\n    for (int y = 0; y < image.getHeight(); y++) {\n      for (int x = 0; x < image.getWidth(); x++) {\n        int val = image.getRGB(x, y);\n        imgData.put((byte) ((val >> 16) & 0xFF));\n        imgData.put((byte) ((val >> 8) & 0xFF));\n        imgData.put((byte) (val & 0xFF));\n      }\n    }\n    return imgData;\n  }\n\n  private static ByteBuffer toFloatByteBuffer(BufferedImage image) {\n    return toFloatByteBuffer(image, DEFAULT_IMAGE_MEAN, DEFAULT_IMAGE_STD);\n  }\n\n  private static ByteBuffer toFloatByteBuffer(\n      BufferedImage image, float imageMean, float imageStd) {\n    ByteBuffer imgData =\n        ByteBuffer.allocateDirect(image.getHeight() * image.getWidth() * 3 * 4)\n            .order(ByteOrder.nativeOrder());\n    for (int y = 0; y < image.getHeight(); y++) {\n      for (int x = 0; x < image.getWidth(); x++) {\n        int pixelValue = image.getRGB(x, y);\n        imgData.putFloat((((pixelValue >> 16) & 0xFF) - imageMean) / imageStd);\n        imgData.putFloat((((pixelValue >> 8) & 0xFF) - imageMean) / imageStd);\n        imgData.putFloat(((pixelValue & 0xFF) - imageMean) / imageStd);\n      }\n    }\n    return imgData;\n  }\n\n  private TestUtils() {}\n}\n", "completion": "{\n    \"programming_language\": \"Java\",\n    \"components\": [\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import java.awt.image.BufferedImage;\",\n        \"component_description\": \"Imports the BufferedImage class from the java.awt.image package, used for reading image files.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import java.io.File;\",\n        \"component_description\": \"Imports the File class from the java.io package, used to handle file paths and operations.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import java.io.IOException;\",\n        \"component_description\": \"Imports the IOException class from the java.io package, used for handling input/output exceptions.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import java.nio.ByteBuffer;\",\n        \"component_description\": \"Imports the ByteBuffer class from the java.nio package, used for direct byte manipulation in memory.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import java.nio.ByteOrder;\",\n        \"component_description\": \"Imports the ByteOrder class from the java.nio package, used to specify the byte order of data in a ByteBuffer.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import java.nio.MappedByteBuffer;\",\n        \"component_description\": \"Imports the MappedByteBuffer class from the java.nio package, used for mapping files into memory.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import java.nio.channels.FileChannel;\",\n        \"component_description\": \"Imports the FileChannel class from the java.nio.channels package, used for reading and writing file contents.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import java.nio.file.Files;\",\n        \"component_description\": \"Imports the Files class from the java.nio.file package, providing static methods to operate on files and directories.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import java.nio.file.StandardOpenOption;\",\n        \"component_description\": \"Imports the StandardOpenOption enum from the java.nio.file package, used for specifying options when opening a file.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import java.util.EnumSet;\",\n        \"component_description\": \"Imports the EnumSet class from the java.util package, providing an efficient implementation of sets for enum types.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import javax.imageio.ImageIO;\",\n        \"component_description\": \"Imports the ImageIO class from the javax.imageio package, used for reading and writing image files in various formats.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"TestUtils\",\n        \"component_code\": \"public abstract class TestUtils { ... }\",\n        \"component_description\": \"Defines an abstract class named TestUtils that contains utility methods for interacting with test-specific data. It is designed to be extended by other classes.\"\n      },\n      {\n        \"component_type\": \"FIELD_DEFINITION\",\n        \"component_name\": \"DEFAULT_IMAGE_MEAN\",\n        \"component_code\": \"private static final float DEFAULT_IMAGE_MEAN = 127.5f;\",\n        \"component_description\": \"Defines a private, static, and final field named DEFAULT_IMAGE_MEAN of type float, initialized to 127.5f. It is used as the default mean for image normalization.\"\n      },\n      {\n        \"component_type\": \"FIELD_DEFINITION\",\n        \"component_name\": \"DEFAULT_IMAGE_STD\",\n        \"component_code\": \"private static final float DEFAULT_IMAGE_STD = 127.5f;\",\n        \"component_description\": \"Defines a private, static, and final field named DEFAULT_IMAGE_STD of type float, initialized to 127.5f. It is used as the default standard deviation for image normalization.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"getMappedByteBufferFromFile\",\n        \"component_code\": \"public static MappedByteBuffer getMappedByteBufferFromFile(String filePath) throws IOException { ... }\",\n        \"component_description\": \"Defines a public, static method named getMappedByteBufferFromFile that takes a file path as input and returns a MappedByteBuffer containing the file contents. It throws an IOException if an error occurs during file operations.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"supportsFilePath\",\n        \"component_code\": \"public static boolean supportsFilePath(String filePath) { ... }\",\n        \"component_description\": \"Defines a public, static method named supportsFilePath that takes a file path as input and returns a boolean indicating whether the file can be read by ImageIO. It checks if there is at least one registered reader for the file format.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"getByteBufferFromFile\",\n        \"component_code\": \"public static ByteBuffer getByteBufferFromFile(String filePath) throws IOException { ... }\",\n        \"component_description\": \"Defines a public, static method named getByteBufferFromFile that takes a file path as input and returns a ByteBuffer containing the file contents. It throws an IOException if an error occurs during file operations.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"getImageBufferedImage\",\n        \"component_code\": \"public static BufferedImage getImageBufferedImage(String imagePath) throws IOException { ... }\",\n        \"component_description\": \"Defines a public, static method named getImageBufferedImage that takes an image path as input and returns a BufferedImage object representing the image. It throws an IOException if an error occurs during file operations.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"getImageByteBuffer\",\n        \"component_code\": \"public static ByteBuffer getImageByteBuffer(String imagePath) throws IOException { ... }\",\n        \"component_description\": \"Defines a public, static method named getImageByteBuffer that takes an image path as input and returns a ByteBuffer containing the pixel data of the image. It throws an IOException if an error occurs during file operations.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"getImageByteBufferNormalized\",\n        \"component_code\": \"public static ByteBuffer getImageByteBufferNormalized(String imagePath) throws IOException { ... }\",\n        \"component_description\": \"Defines a public, static method named getImageByteBufferNormalized that takes an image path as input and returns a ByteBuffer containing the normalized pixel data of the image. It throws an IOException if an error occurs during file operations.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"getImageByteBufferNormalized\",\n        \"component_code\": \"public static ByteBuffer getImageByteBufferNormalized(String imagePath, float imageMean, float imageStd) throws IOException { ... }\",\n        \"component_description\": \"Defines a public, static method named getImageByteBufferNormalized that takes an image path, image mean, and image standard deviation as inputs and returns a ByteBuffer containing the normalized pixel data of the image using the provided mean and standard deviation. It throws an IOException if an error occurs during file operations.\"\n      },\n      {\n        \"component_type\": \"CONSTRUCTOR_DEFINITION\",\n        \"component_name\": \"TestUtils\",\n        \"component_code\": \"private TestUtils() {}\",\n        \"component_description\": \"Defines a private constructor for the TestUtils class, preventing instantiation of the class.\"\n      }\n    ],\n    \"overall_description\": \"The provided Java code defines an abstract class named TestUtils that contains utility methods for interacting with test-specific data. It includes methods for reading files into memory as ByteBuffers, mapping file contents directly into memory using MappedByteBuffer, and normalizing image pixel data for machine learning applications. The class uses the java.nio package for efficient byte manipulation in memory and the javax.imageio package for reading image files.\"\n  }"}
{"prompt": "\nYou are an expert Ruby code analyst. Your task is to dissect a given Ruby code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_RUBY_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_RUBY_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_RUBY_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Ruby.\n2. Component Types: Use appropriate component types, for example, CLASS_DEFINITION, METHOD_DEFINITION, MODULE_DEFINITION, VARIABLE_DECLARATION, IF_STATEMENT, LOOP, BLOCK, LAMBDA, PROC, CONSTANT_DEFINITION, INCLUDE, EXTEND.\n3. Component Names: Provide the correct identifier for each component (method name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Ruby code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including Ruby-specific features like blocks, procs, lambdas, and modules.\n6. Overall Description: Provide a detailed summary of the entire Ruby code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Ruby code properly and return ONLY the JSON response with no additional text:\n\n<reponame>shalvah/serverless\nmodule MyModule\n  class MyClass\n    def self.my_class_method(event:, context:)\n      {\"source\" => \"rubyclass\"}\n    end\n  end\nend\n", "completion": "{\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"MODULE_DEFINITION\",\n        \"component_name\": \"MyModule\",\n        \"component_code\": \"module MyModule\\n  class MyClass\\n    def self.my_class_method(event:, context:)\\n      {\\\"source\\\" => \\\"rubyclass\\\"}\\n    end\\n  end\\nend\",\n        \"component_description\": \"Defines a module named MyModule, which encapsulates the class definition of MyClass. Modules in Ruby are used to group related methods and constants together.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"MyClass\",\n        \"component_code\": \"class MyClass\\n    def self.my_class_method(event:, context:)\\n      {\\\"source\\\" => \\\"rubyclass\\\"}\\n    end\\n  end\",\n        \"component_description\": \"Defines a class named MyClass within the MyModule. This class includes a class method called my_class_method.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"my_class_method\",\n        \"component_code\": \"def self.my_class_method(event:, context:)\\n      {\\\"source\\\" => \\\"rubyclass\\\"}\\n    end\",\n        \"component_description\": \"Defines a class method my_class_method that takes two keyword arguments, event and context. This method returns a hash with the key 'source' and the value 'rubyclass'. The use of self before def indicates that this is a class method.\"\n      }\n    ],\n    \"overall_description\": \"The Ruby code defines a module named MyModule that contains a single class definition for MyClass. Within MyClass, there is a class method called my_class_method which accepts two keyword arguments (event and context) and returns a hash with the key 'source' and value 'rubyclass'. This setup is typical in scenarios where methods are intended to be called on the class itself rather than instances of the class.\"\n  }"}
{"prompt": "\nYou are an expert TypeScript code analyst. Your task is to dissect a given TypeScript code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"TypeScript\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_TYPESCRIPT_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_TYPESCRIPT_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_TYPESCRIPT_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in TypeScript.\n2. Component Types: Use appropriate component types, for example, INTERFACE_DEFINITION, TYPE_ALIAS, CLASS_DEFINITION, FUNCTION_DEFINITION, METHOD_DEFINITION, GENERIC_TYPE, MODULE_IMPORT, DECORATOR, VARIABLE_DECLARATION, ENUM_DEFINITION, ASYNC_FUNCTION, PROMISE, CONDITIONAL_TYPE.\n3. Component Names: Provide the correct identifier for each component (function name, class name, interface name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified TypeScript code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including TypeScript-specific features like static typing, interfaces, generics, and type inference.\n6. Overall Description: Provide a detailed summary of the entire TypeScript code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following TypeScript code properly and return ONLY the JSON response with no additional text:\n\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport React from 'react';\nimport { Button } from './button';\n\nconst onClick = jest.fn();\n\ndescribe('Button', () => {\n  it(\"should have the role 'button' and the correct text\", () => {\n    render(<Button label='Hello world' onClick={onClick} />);\n    expect(\n      screen.getByRole('button', { name: /hello world/i })\n    ).toBeInTheDocument();\n  });\n\n  it('should trigger the onClick prop on click', () => {\n    render(<Button label='Hello world' onClick={onClick} />);\n\n    const button = screen.getByRole('button', { name: /hello world/i });\n\n    userEvent.click(button);\n\n    expect(onClick).toHaveBeenCalledTimes(1);\n  });\n});\n", "completion": "{\n    \"programming_language\": \"TypeScript\",\n    \"components\": [\n      {\n        \"component_type\": \"MODULE_IMPORT\",\n        \"component_name\": NULL,\n        \"component_code\": \"import { render, screen } from '@testing-library/react';\\nimport userEvent from '@testing-library/user-event';\\nimport React from 'react';\\nimport { Button } from './button';\",\n        \"component_description\": \"Imports necessary modules and components for testing a React component. It imports the `render` and `screen` utilities from `@testing-library/react`, the `userEvent` library for simulating user interactions, the `React` library, and the `Button` component from a local file.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"onClick\",\n        \"component_code\": \"const onClick = jest.fn();\",\n        \"component_description\": \"Declares a constant variable `onClick` and initializes it with a mock function created by `jest.fn()`. This mock function is used to simulate the click event handler for the `Button` component.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": NULL,\n        \"component_code\": \"describe('Button', () => { ... });\",\n        \"component_description\": \"Defines a test suite using Jest's `describe` function. The suite is named 'Button' and contains multiple test cases to verify the functionality of the `Button` component.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": NULL,\n        \"component_code\": \"it(\\\"should have the role 'button' and the correct text\\\", () => { ... });\",\n        \"component_description\": \"Defines a test case using Jest's `it` function. The test checks if the `Button` component has the ARIA role 'button' and displays the correct text ('Hello world'). It uses the `render` utility to render the `Button` component, then verifies its presence in the document with `screen.getByRole`.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": NULL,\n        \"component_code\": \"it('should trigger the onClick prop on click', () => { ... });\",\n        \"component_description\": \"Defines another test case using Jest's `it` function. This test verifies that clicking the `Button` component triggers the `onClick` event handler exactly once. It uses `userEvent.click` to simulate a user click and then checks the number of times the mock `onClick` function has been called with `toHaveBeenCalledTimes(1).\"\n      }\n    ],\n    \"overall_description\": \"This TypeScript code snippet is a test suite for a React component named `Button`. It imports necessary testing libraries and components, defines a mock event handler, and contains two test cases. The first test case checks if the `Button` component has the correct ARIA role and text content. The second test case verifies that clicking the `Button` triggers the specified `onClick` event handler exactly once.\"\n  }"}
{"prompt": "\nYou are an expert TypeScript code analyst. Your task is to dissect a given TypeScript code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"TypeScript\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_TYPESCRIPT_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_TYPESCRIPT_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_TYPESCRIPT_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in TypeScript.\n2. Component Types: Use appropriate component types, for example, INTERFACE_DEFINITION, TYPE_ALIAS, CLASS_DEFINITION, FUNCTION_DEFINITION, METHOD_DEFINITION, GENERIC_TYPE, MODULE_IMPORT, DECORATOR, VARIABLE_DECLARATION, ENUM_DEFINITION, ASYNC_FUNCTION, PROMISE, CONDITIONAL_TYPE.\n3. Component Names: Provide the correct identifier for each component (function name, class name, interface name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified TypeScript code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including TypeScript-specific features like static typing, interfaces, generics, and type inference.\n6. Overall Description: Provide a detailed summary of the entire TypeScript code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following TypeScript code properly and return ONLY the JSON response with no additional text:\n\nimport {\n  Alert,\n  Col,\n  ControlLabel,\n  FormControl,\n  FormGroup,\n  HelpBlock\n} from '@freecodecamp/react-bootstrap';\nimport { kebabCase } from 'lodash-es';\nimport normalizeUrl from 'normalize-url';\nimport React from 'react';\nimport { Field } from 'react-final-form';\nimport { useTranslation } from 'react-i18next';\nimport { FormOptions } from './form';\nimport {\n  editorValidator,\n  localhostValidator,\n  composeValidators,\n  fCCValidator,\n  httpValidator\n} from './form-validators';\n\ntype FormFieldsProps = {\n  formFields: { name: string; label: string }[];\n  options: FormOptions;\n};\n\nfunction FormFields(props: FormFieldsProps): JSX.Element {\n  const { t } = useTranslation();\n  const { formFields, options = {} }: FormFieldsProps = props;\n  const {\n    ignored = [],\n    placeholders = {},\n    required = [],\n    types = {},\n    isEditorLinkAllowed = false,\n    isLocalLinkAllowed = false\n  } = options;\n\n  const nullOrWarning = (\n    value: string,\n    error: unknown,\n    isURL: boolean,\n    name: string\n  ) => {\n    let validationError: string | undefined;\n    if (value && isURL) {\n      try {\n        normalizeUrl(value, { stripWWW: false });\n      } catch (err: unknown) {\n        validationError = (err as { message?: string })?.message;\n      }\n    }\n    const validationWarning = composeValidators(\n      name === 'githubLink' || isEditorLinkAllowed ? null : editorValidator,\n      fCCValidator,\n      httpValidator,\n      isLocalLinkAllowed ? null : localhostValidator\n    )(value);\n    const message: string = (error ||\n      validationError ||\n      validationWarning) as string;\n    return message ? (\n      <HelpBlock>\n        <Alert\n          bsStyle={error || validationError ? 'danger' : 'info'}\n          closeLabel={t('buttons.close')}\n        >\n          {message}\n        </Alert>\n      </HelpBlock>\n    ) : null;\n  };\n  return (\n    <div>\n      {formFields\n        .filter(formField => !ignored.includes(formField.name))\n        .map(({ name, label }) => (\n          // TODO: verify if the value is always a string\n          <Field key={`${kebabCase(name)}-field`} name={name}>\n            {({ input: { value, onChange }, meta: { pristine, error } }) => {\n              const key = kebabCase(name);\n              const type = name in types ? types[name] : 'text';\n              const placeholder =\n                name in placeholders ? placeholders[name] : '';\n              const isURL = types[name] === 'url';\n              return (\n                <Col key={key} xs={12}>\n                  <FormGroup>\n                    {type === 'hidden' ? null : (\n                      <ControlLabel htmlFor={key}>{label}</ControlLabel>\n                    )}\n                    <FormControl\n                      componentClass={type === 'textarea' ? type : 'input'}\n                      id={key}\n                      name={name}\n                      onChange={onChange}\n                      placeholder={placeholder}\n                      required={required.includes(name)}\n                      rows={4}\n                      type={type}\n                      value={value as string}\n                    />\n                    {nullOrWarning(\n                      value as string,\n                      !pristine && error,\n                      isURL,\n                      name\n                    )}\n                  </FormGroup>\n                </Col>\n              );\n            }}\n          </Field>\n        ))}\n    </div>\n  );\n}\n\nFormFields.displayName = 'FormFields';\n\nexport default FormFields;\n", "completion": "{\n    \"programming_language\": \"TypeScript\",\n    \"components\": [\n      {\n        \"component_type\": \"MODULE_IMPORT\",\n        \"component_name\": null,\n        \"component_code\": \"import {\\n  Alert,\\n  Col,\\n  ControlLabel,\\n  FormControl,\\n  FormGroup,\\n  HelpBlock\\n} from '@freecodecamp/react-bootstrap';\",\n        \"component_description\": \"Imports several components (Alert, Col, ControlLabel, FormControl, FormGroup, HelpBlock) from the @freecodecamp/react-bootstrap module for use in rendering form elements and alerts.\"\n      },\n      {\n        \"component_type\": \"MODULE_IMPORT\",\n        \"component_name\": null,\n        \"component_code\": \"import { kebabCase } from 'lodash-es';\",\n        \"component_description\": \"Imports the kebabCase function from lodash-es, used to convert strings into a kebab-case format.\"\n      },\n      {\n        \"component_type\": \"MODULE_IMPORT\",\n        \"component_name\": null,\n        \"component_code\": \"import normalizeUrl from 'normalize-url';\",\n        \"component_description\": \"Imports the normalizeUrl function from the normalize-url module, used for normalizing URL strings.\"\n      },\n      {\n        \"component_type\": \"MODULE_IMPORT\",\n        \"component_name\": null,\n        \"component_code\": \"import React from 'react';\",\n        \"component_description\": \"Imports the React library to enable the creation and rendering of React components.\"\n      },\n      {\n        \"component_type\": \"MODULE_IMPORT\",\n        \"component_name\": null,\n        \"component_code\": \"import { Field } from 'react-final-form';\",\n        \"component_description\": \"Imports the Field component from react-final-form, used for managing form state in a declarative way.\"\n      },\n      {\n        \"component_type\": \"MODULE_IMPORT\",\n        \"component_name\": null,\n        \"component_code\": \"import { useTranslation } from 'react-i18next';\",\n        \"component_description\": \"Imports the useTranslation hook from react-i18next, enabling internationalization by providing translation functions to components.\"\n      },\n      {\n        \"component_type\": \"MODULE_IMPORT\",\n        \"component_name\": null,\n        \"component_code\": \"import { FormOptions } from './form';\",\n        \"component_description\": \"Imports the FormOptions type from a local file './form', used to define the shape of options passed to the FormFields component.\"\n      },\n      {\n        \"component_type\": \"MODULE_IMPORT\",\n        \"component_name\": null,\n        \"component_code\": \"import {\\n  editorValidator,\\n  localhostValidator,\\n  composeValidators,\\n  fCCValidator,\\n  httpValidator\\n} from './form-validators';\",\n        \"component_description\": \"Imports several validator functions (editorValidator, localhostValidator, composeValidators, fCCValidator, httpValidator) from a local file './form-validators' for validating form input.\"\n      },\n      {\n        \"component_type\": \"TYPE_ALIAS\",\n        \"component_name\": \"FormFieldsProps\",\n        \"component_code\": \"type FormFieldsProps = {\\n  formFields: { name: string; label: string }[];\\n  options: FormOptions;\\n};\",\n        \"component_description\": \"Defines a type alias for the props of the FormFields component, specifying that it should receive an array of form fields (with name and label) and options of type FormOptions.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"FormFields\",\n        \"component_code\": \"function FormFields(props: FormFieldsProps): JSX.Element {\\n  const { t } = useTranslation();\\n  const { formFields, options = {} }: FormFieldsProps = props;\\n  const {\\n    ignored = [],\\n    placeholders = {},\\n    required = [],\\n    types = {},\\n    isEditorLinkAllowed = false,\\n    isLocalLinkAllowed = false\\n  } = options;\\n\\n  const nullOrWarning = (\\n    value: string,\\n    error: unknown,\\n    isURL: boolean,\\n    name: string\\n  ) => {\\n    let validationError: string | undefined;\\n    if (isURL) {\\n      try {\\n        normalizeUrl(value);\\n      } catch (err) {\\n        validationError = 'Invalid URL';\\n      }\\n    }\\n    const otherErrors = [error, validationError].filter(Boolean);\\n    return otherErrors.length ? (\\n      <HelpBlock>{otherErrors.join(', ')}</HelpBlock>\\n    ) : null;\\n  };\\n\\n  return (\\n    <div>\\n      {formFields.map((field) => {\\n        const { name, label } = field;\\n        const key = kebabCase(name);\\n        return (\\n          <Field name={name} key={key}>\\n            {({ input, meta }) => (\\n              <FormGroup>\\n                {types[name] !== 'textarea' && (\\n                  <ControlLabel htmlFor={key}>{label}</ControlLabel>\\n                )}\\n                <FormControl\\n                  componentClass={types[name] === 'textarea' ? types[name] : 'input'}\\n                  id={key}\\n                  {...input}\\n                  placeholder={placeholders[name]}\\n                  required={required.includes(name)}\\n                  rows={4}\\n                  type={types[name] || 'text'}\\n                />\\n                {nullOrWarning(input.value, meta.error, types[name] === 'url', name)}\\n              </FormGroup>\\n            )}\\n          </Field>\\n        );\\n      })}\\n    </div>\\n  );\\n}\",\n        \"component_description\": \"Defines a React functional component named FormFields that renders form fields based on the provided props. It uses react-final-form's Field component to manage state and applies validation and internationalization as needed.\"\n      },\n      {\n        \"component_type\": \"PROPERTY_ASSIGNMENT\",\n        \"component_name\": null,\n        \"component_code\": \"FormFields.displayName = 'FormFields';\",\n        \"component_description\": \"Sets the displayName property of the FormFields component to 'FormFields', which can be useful for debugging and identifying components in React DevTools.\"\n      },\n      {\n        \"component_type\": \"EXPORT_DEFAULT\",\n        \"component_name\": null,\n        \"component_code\": \"export default FormFields;\",\n        \"component_description\": \"Exports the FormFields component as the default export of this module, allowing it to be imported and used in other parts of the application.\"\n      }\n    ],\n    \"overall_description\": \"This TypeScript file defines a React functional component named FormFields that renders form fields based on provided props. It imports necessary modules and components, defines a type alias for the component's props, and includes validation logic using several imported validator functions. The component is exported as the default export of this module.\"\n  }"}
{"prompt": "\nYou are an expert TypeScript code analyst. Your task is to dissect a given TypeScript code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"TypeScript\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_TYPESCRIPT_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_TYPESCRIPT_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_TYPESCRIPT_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in TypeScript.\n2. Component Types: Use appropriate component types, for example, INTERFACE_DEFINITION, TYPE_ALIAS, CLASS_DEFINITION, FUNCTION_DEFINITION, METHOD_DEFINITION, GENERIC_TYPE, MODULE_IMPORT, DECORATOR, VARIABLE_DECLARATION, ENUM_DEFINITION, ASYNC_FUNCTION, PROMISE, CONDITIONAL_TYPE.\n3. Component Names: Provide the correct identifier for each component (function name, class name, interface name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified TypeScript code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including TypeScript-specific features like static typing, interfaces, generics, and type inference.\n6. Overall Description: Provide a detailed summary of the entire TypeScript code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following TypeScript code properly and return ONLY the JSON response with no additional text:\n\nconst createLanguageRedirect = ({\n  clientLocale,\n  lang\n}: {\n  clientLocale: string;\n  lang: string;\n}): string => {\n  // return early if requesting the same page\n  if (clientLocale === lang) return window?.location.toString();\n\n  const pathArray = window?.location?.pathname?.split('/');\n  const path = pathArray\n    .filter(item => (item !== clientLocale && item !== lang ? item : ''))\n    .join('/');\n\n  const hostTail = window?.location?.host.split('.').slice(1).join('.');\n  const nextClient = lang !== 'chinese' ? 'www' : 'chinese';\n  const nextLocation = `${window?.location?.protocol}//${nextClient}.${hostTail}`;\n\n  if (lang === 'english' || lang === 'chinese')\n    return `${nextLocation}/${path}`;\n\n  return `${nextLocation}/${lang}/${path}`;\n};\n\nexport default createLanguageRedirect;\n", "completion": "{\n    \"programming_language\": \"TypeScript\",\n    \"components\": [\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"createLanguageRedirect\",\n        \"component_code\": \"const createLanguageRedirect = ({\\n  clientLocale,\\n  lang\\n}: {\\n  clientLocale: string;\\n  lang: string;\\n}): string => { ... };\",\n        \"component_description\": \"This is a function that takes an object with two properties, `clientLocale` and `lang`, both of type `string`. It returns a new URL string based on the current location's pathname and the provided language. The function first checks if the requested language (`lang`) is the same as the client's current locale (`clientLocale`). If they are the same, it returns the current location. Otherwise, it constructs a new path by filtering out the old locale from the current path array and replacing it with the new language. It then constructs the host part of the URL based on the new language and combines it with the protocol to form the full URL string. Depending on whether the new language is 'english' or 'chinese', it adjusts the subdomain accordingly.\"\n      }\n    ],\n    \"overall_description\": \"The TypeScript code defines a function named `createLanguageRedirect` that constructs a new URL based on the current page's path and a requested language. The function takes an object containing two string properties: `clientLocale` (the user's current locale) and `lang` (the requested language). It checks if the requested language is different from the current locale, then modifies the URL to reflect the new language by adjusting the pathname and subdomain as necessary. This function is useful for implementing language switching features in web applications.\"\n  }"}
{"prompt": "\nYou are an expert SQL analyst. Your task is to dissect a given SQL script and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"database_system\": \"<DATABASE_SYSTEM_IF_SPECIFIED_OR_GENERAL_SQL>\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_SQL_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_SQL_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_SQL_SCRIPT_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the SQL Variant: Determine if the script is specific to MySQL, PostgreSQL, SQL Server, Oracle, etc., or general SQL.\n2. Component Types: Classify each component accurately, such as TABLE_DEFINITION, VIEW, STORED_PROCEDURE, FUNCTION, TRIGGER, INDEX, QUERY, etc.\n3. Component Names: Provide the correct identifier for each component (table name, procedure name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified SQL code for each component.\n5. Component Descriptions: Provide a technical explanation of what each component does, including its role in data storage, manipulation, or retrieval.\n6. Overall Description: Offer a detailed summary of the entire SQL script, its purpose, and how different components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following SQL script properly and return ONLY the JSON response with no additional text:\n\nCREATE TABLE IF NOT EXISTS articles (\n    id           UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\n    article_id      SERIAL,\n    slug           VARCHAR(255) UNIQUE NOT NULL,\n\ttitle           VARCHAR(255) NOT NULL,\n\tdescription     TEXT NOT NULL,\n\tbody          TEXT NOT NULL,\n\tcreated_at      TIMESTAMP DEFAULT NOW() NOT NULL,\n\tupdated_at      TIMESTAMP DEFAULT NOW() NOT NULL,\n\tauthor_id         UUID NOT NULL,\n    CONSTRAINT fk_articles_author\n        FOREIGN KEY (author_id)\n        REFERENCES users(id)\n        ON DELETE CASCADE\n);\n", "completion": "{\n    \"database_system\": \"PostgreSQL\",\n    \"components\": [\n      {\n        \"component_type\": \"TABLE_DEFINITION\",\n        \"component_name\": \"articles\",\n        \"component_code\": \"CREATE TABLE IF NOT EXISTS articles (\\n    id           UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\\n    article_id      SERIAL,\\n    slug           VARCHAR(255) UNIQUE NOT NULL,\\n\\ttitle           VARCHAR(255) NOT NULL,\\n\\tdescription     TEXT NOT NULL,\\n\\tbody          TEXT NOT NULL,\\n\\tcreated_at      TIMESTAMP DEFAULT NOW() NOT NULL,\\n\\tupdated_at      TIMESTAMP DEFAULT NOW() NOT NULL,\\n\\tauthor_id         UUID NOT NULL,\\n    CONSTRAINT fk_articles_author\\n        FOREIGN KEY (author_id)\\n        REFERENCES users(id)\\n        ON DELETE CASCADE\\n);\",\n        \"component_description\": \"This component defines a table named 'articles' in PostgreSQL. The table includes columns for id, article_id, slug, title, description, body, created_at, updated_at, and author_id. The id column is a UUID that serves as the primary key with a default value generated by uuid_generate_v4(). The article_id is an auto-incrementing integer. The slug must be unique and not null, while the title, description, body, and author_id also cannot be null. The created_at and updated_at fields are timestamps that default to the current time upon creation and update respectively. There is a foreign key constraint named fk_articles_author linking author_id to the id column of the users table, which will delete related records in articles if the corresponding user record is deleted.\"\n      }\n    ],\n    \"overall_description\": \"The SQL script creates a new table called 'articles' with several fields including a unique identifier (UUID), an auto-incrementing article ID, a unique slug for each article, title, description, body content, timestamps for creation and updates, and an author identifier linked to a users table. The table ensures data integrity through constraints on uniqueness and foreign keys.\"\n  }"}
{"prompt": "\nYou are an expert Kotlin code analyst. Your task is to dissect a given Kotlin code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Kotlin\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_KOTLIN_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_KOTLIN_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_KOTLIN_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Kotlin.\n2. Component Types: Use appropriate component types, for example, PACKAGE_DECLARATION, IMPORT_STATEMENT, CLASS_DEFINITION, DATA_CLASS_DEFINITION, FUNCTION_DEFINITION, EXTENSION_FUNCTION, PROPERTY_DECLARATION, CONSTRUCTOR, LAMBDA, NULL_SAFETY, SEALING_CLASS.\n3. Component Names: Provide the correct identifier for each component (function name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Kotlin code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including Kotlin-specific features like null safety, extension functions, coroutines, and data classes.\n6. Overall Description: Provide a detailed summary of the entire Kotlin code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Kotlin code properly and return ONLY the JSON response with no additional text:\n\n<filename>core/src/rustyice/game/tiles/WallTile.kt\npackage rustyice.game.tiles\n\nimport com.badlogic.gdx.graphics.Color\nimport com.badlogic.gdx.graphics.g2d.Sprite\nimport rustyengine.RustyEngine\nimport rustyice.Core\nimport rustyice.editor.annotations.ComponentProperty\nimport rustyice.game.physics.RectWallComponent\nimport rustyengine.resources.Resources\n\nclass WallTile() : Tile(true, true) {\n\n    @ComponentProperty\n    var color = Color.BLUE\n        set(value) {\n            field = value\n            sprite?.color = color\n        }\n\n    override fun init() {\n        super.init()\n\n        val sprite = Sprite(RustyEngine.resorces.box)\n        sprite.color = color\n\n        this.sprite = sprite\n    }\n\n    init {\n        tilePhysics = RectWallComponent()\n    }\n}\n", "completion": "{\n    \"programming_language\": \"Kotlin\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": null,\n        \"component_code\": \"package rustyice.game.tiles\",\n        \"component_description\": \"Declares the package name for organizing Kotlin source files and controlling access to types.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import com.badlogic.gdx.graphics.Color\",\n        \"component_description\": \"Imports the Color class from the com.badlogic.gdx.graphics package, used for defining colors in graphics applications.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import com.badlogic.gdx.graphics.g2d.Sprite\",\n        \"component_description\": \"Imports the Sprite class from the com.badlogic.gdx.graphics.g2d package, used for drawing 2D sprites in games.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import rustyengine.RustyEngine\",\n        \"component_description\": \"Imports the RustyEngine class from the rustyengine package, likely a custom game engine class used for managing game resources and logic.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import rustyice.Core\",\n        \"component_description\": \"Imports the Core class from the rustyice package, possibly containing core functionalities of the game engine or application.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import rustyice.editor.annotations.ComponentProperty\",\n        \"component_description\": \"Imports the ComponentProperty annotation from the rustyice.editor.annotations package, likely used to mark properties that can be edited in a component editor.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import rustyice.game.physics.RectWallComponent\",\n        \"component_description\": \"Imports the RectWallComponent class from the rustyice.game.physics package, used for defining rectangular wall physics components in the game.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import rustyengine.resources.Resources\",\n        \"component_description\": \"Imports the Resources class from the rustyengine.resources package, likely used for managing game resources such as images and sounds.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"WallTile\",\n        \"component_code\": \"class WallTile() : Tile(true, true) { ... }\",\n        \"component_description\": \"Defines a class named WallTile that inherits from the Tile class. The primary constructor takes no arguments and passes two boolean values to the parent constructor.\"\n      },\n      {\n        \"component_type\": \"PROPERTY_DECLARATION\",\n        \"component_name\": \"color\",\n        \"component_code\": \"@ComponentProperty\\nvar color = Color.BLUE\\n    set(value) {\\n        field = value\\n        sprite?.color = color\\n    }\",\n        \"component_description\": \"Declares a mutable property named color of type Color with an initial value of Color.BLUE. The setter updates the field and modifies the color of the sprite if it is not null.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"init\",\n        \"component_code\": \"override fun init() {\\n    super.init()\\n\\n    val sprite = Sprite(RustyEngine.resorces.box)\\n    sprite.color = color\\n\\n    this.sprite = sprite\\n}\",\n        \"component_description\": \"Overrides the init method from the Tile class. It initializes a new Sprite with an image resource, sets its color to the WallTile's color, and assigns it to the WallTile's sprite property.\"\n      },\n      {\n        \"component_type\": \"INITIALIZER_BLOCK\",\n        \"component_name\": null,\n        \"component_code\": \"init {\\n    tilePhysics = RectWallComponent()\\n}\",\n        \"component_description\": \"An initializer block that sets the tilePhysics property of the WallTile to a new instance of RectWallComponent, initializing the physics component for the wall tile.\"\n      }\n    ],\n    \"overall_description\": \"The Kotlin code defines a class named WallTile which extends from a base class Tile. It includes a color property annotated with @ComponentProperty, allowing it to be edited in a component editor. The class overrides an init method to initialize a sprite and set its color, and uses another initializer block to assign a RectWallComponent for handling physics interactions. This setup is typical for game development where tiles need graphical representation and physical properties.\"\n  }"}
{"prompt": "\nYou are an expert Scala code analyst. Your task is to dissect a given Scala code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Scala\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_SCALA_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_SCALA_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_SCALA_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Scala.\n2. Component Types: Use appropriate component types, for example, OBJECT_DEFINITION, CLASS_DEFINITION, TRAIT_DEFINITION, CASE_CLASS_DEFINITION, FUNCTION_DEFINITION, VAL_DECLARATION, VAR_DECLARATION, FOR_COMPREHENSION, PATTERN_MATCHING, IMPLICIT_CONVERSION, LAMBDA_EXPRESSION.\n3. Component Names: Provide the correct identifier for each component (function name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Scala code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including Scala-specific features like pattern matching, immutability, higher-order functions, and functional programming concepts.\n6. Overall Description: Provide a detailed summary of the entire Scala code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Scala code properly and return ONLY the JSON response with no additional text:\n\n/*\nCopyright 2012 Twitter, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage com.twitter.algebird\n\nclass VectorSpaceProperties extends CheckProperties {\n  import com.twitter.algebird.BaseVectorSpaceProperties._\n\n  // TODO: we won't need this when we have an Equatable trait\n  def mapEqFn(a: Map[Int, Double], b: Map[Int, Double]) = {\n    (a.keySet ++ b.keySet).forall { key =>\n      (a.get(key), b.get(key)) match {\n        case (Some(aVal), Some(bVal)) => beCloseTo(aVal, bVal)\n        case (Some(aVal), None) => beCloseTo(aVal, 0.0)\n        case (None, Some(bVal)) => beCloseTo(bVal, 0.0)\n        case _ => true\n      }\n    }\n  }\n\n  property(\"map int double scaling\") {\n    vectorSpaceLaws[Double, ({ type x[a] = Map[Int, a] })#x](mapEqFn(_, _))\n  }\n}\n", "completion": "{\n    \"programming_language\": \"Scala\",\n    \"components\": [\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"VectorSpaceProperties\",\n        \"component_code\": \"class VectorSpaceProperties extends CheckProperties {\\n  import com.twitter.algebird.BaseVectorSpaceProperties._\\n\\n  // TODO: we won't need this when we have an Equatable trait\\n  def mapEqFn(a: Map[Int, Double], b: Map[Int, Double]) = {\\n    (a.keySet ++ b.keySet).forall { key =>\\n      (a.get(key), b.get(key)) match {\\n        case (Some(aVal), Some(bVal)) => beCloseTo(aVal, bVal)\\n        case (Some(aVal), None) => beCloseTo(aVal, 0.0)\\n        case (None, Some(bVal)) => beCloseTo(bVal, 0.0)\\n        case _ => true\\n      }\\n    }\\n  }\\n\\n  property(\\\"map int double scaling\\\") {\\n    vectorSpaceLaws[Double, ({ type x[a] = Map[Int, a] })#x](mapEqFn(_, _))\\n  }\\n}\",\n        \"component_description\": \"Defines a class named 'VectorSpaceProperties' that extends 'CheckProperties'. It includes an import statement for static members from the 'BaseVectorSpaceProperties' object. The class contains a custom equality function 'mapEqFn' and a property test method to verify vector space laws on maps with integer keys and double values.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"mapEqFn\",\n        \"component_code\": \"def mapEqFn(a: Map[Int, Double], b: Map[Int, Double]) = {\\n    (a.keySet ++ b.keySet).forall { key =>\\n      (a.get(key), b.get(key)) match {\\n        case (Some(aVal), Some(bVal)) => beCloseTo(aVal, bVal)\\n        case (Some(aVal), None) => beCloseTo(aVal, 0.0)\\n        case (None, Some(bVal)) => beCloseTo(bVal, 0.0)\\n        case _ => true\\n      }\\n    }\\n  }\",\n        \"component_description\": \"Defines a function 'mapEqFn' that takes two maps of integers to doubles and checks if they are approximately equal. It uses pattern matching to compare values at each key in the union of both map's key sets, ensuring that missing keys are treated as having a value of 0.0.\"\n      },\n      {\n        \"component_type\": \"PATTERN_MATCHING\",\n        \"component_name\": null,\n        \"component_code\": \"(a.get(key), b.get(key)) match {\\n        case (Some(aVal), Some(bVal)) => beCloseTo(aVal, bVal)\\n        case (Some(aVal), None) => beCloseTo(aVal, 0.0)\\n        case (None, Some(bVal)) => beCloseTo(bVal, 0.0)\\n        case _ => true\\n      }\",\n        \"component_description\": \"Uses pattern matching to handle different cases of values retrieved from the maps 'a' and 'b'. It matches pairs of option values, comparing them if both are present, treating missing values as 0.0, and returns true for any other combination.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"property(\\\"map int double scaling\\\")\",\n        \"component_code\": \"property(\\\"map int double scaling\\\") {\\n    vectorSpaceLaws[Double, ({ type x[a] = Map[Int, a] })#x](mapEqFn(_, _))\\n  }\",\n        \"component_description\": \"Defines a property test named 'map int double scaling' that checks vector space laws for maps with integer keys and double values using the custom equality function 'mapEqFn'. It uses a higher-kinded type to specify the map's structure.\"\n      }\n    ],\n    \"overall_description\": \"The Scala code defines a class 'VectorSpaceProperties' extending from 'CheckProperties', which is used for defining property-based tests. The class includes a custom equality function 'mapEqFn' designed to compare maps with integer keys and double values, treating missing keys as zero. A property test method checks vector space laws for such maps using the defined equality function.\"\n  }"}
{"prompt": "\nYou are an expert Rust code analyst. Your task is to dissect a given Rust code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Rust\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_RUST_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_RUST_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_RUST_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Rust.\n2. Component Types: Use appropriate component types, for example, MODULE_DECLARATION, USE_STATEMENT, STRUCT_DEFINITION, ENUM_DEFINITION, TRAIT_DEFINITION, FUNCTION_DEFINITION, IMPLEMENTATION_BLOCK, MATCH_STATEMENT, LET_STATEMENT, LOOP, IF_STATEMENT, PATTERN_MATCHING.\n3. Component Names: Provide the correct identifier for each component (function name, struct name, enum name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Rust code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including ownership, borrowing, pattern matching, and concurrency aspects of Rust.\n6. Overall Description: Provide a detailed summary of the entire Rust code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Rust code properly and return ONLY the JSON response with no additional text:\n\n<reponame>Eric-Arellano/rust<filename>src/test/ui/issues/issue-22426.rs<gh_stars>1000+\n// run-pass\n// pretty-expanded FIXME #23616\n\nfn main() {\n  match 42 {\n    x if x < 7 => (),\n    _ => ()\n  }\n}\n", "completion": "{\n    \"programming_language\": \"Rust\",\n    \"components\": [\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"fn main() {\\n  match 42 {\\n    x if x < 7 => (),\\n    _ => ()\\n  }\\n}\",\n        \"component_description\": \"This is the entry point of the Rust program. It defines a function named `main` which does not take any arguments and returns nothing (denoted by `()`). Inside the function, it performs pattern matching on the integer literal `42`. The match expression has two arms: the first checks if the value `x` is less than 7 using a guard clause (`if x < 7`). If true, it executes an empty tuple `()`, indicating no action. The second arm matches any other value (denoted by `_`) and also does nothing.\"\n      },\n      {\n        \"component_type\": \"MATCH_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"match 42 {\\n    x if x < 7 => (),\\n    _ => ()\\n}\",\n        \"component_description\": \"This is a match statement in Rust, used for pattern matching. It takes the value `42` and tries to match it against the patterns specified in its arms. The first arm uses a variable binding (`x`) along with a guard clause (`if x < 7`). This checks if the matched value is less than 7, and if so, executes the corresponding expression (an empty tuple `()`). If the first pattern does not match or the condition fails, the second arm matches any other value using `_` and executes its associated expression, which is also an empty tuple `()`. This match statement effectively checks the value of `42`, but since `42` is not less than 7, only the second arm's expression is executed.\"\n      }\n    ],\n    \"overall_description\": \"This Rust program consists of a single function named `main`, which serves as the entry point. Inside this function, there is a match statement that evaluates the integer literal `42`. The match statement has two arms: one checks if the value is less than 7 using a guard clause and does nothing if true; otherwise, it matches any other value using `_` and again does nothing. Since `42` is not less than 7, the second arm's expression is executed, resulting in no action being taken. This program is likely intended to demonstrate or test certain behavior of pattern matching with guard clauses in Rust.\"\n  }"}
{"prompt": "\nYou are an expert JavaScript code analyst. Your task is to dissect a given JavaScript code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"JavaScript\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_JS_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_JS_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_JS_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in JavaScript.\n2. Component Types: Use appropriate component types, for example, VARIABLE_DECLARATION, FUNCTION_DEFINITION, ARROW_FUNCTION, EVENT_HANDLER, CLASS_DEFINITION, MODULE_IMPORT, CONDITIONAL_STATEMENT, LOOP, PROMISE, ASYNC_FUNCTION, CALLBACK_FUNCTION.\n3. Component Names: Provide the correct identifier for each component (function name, variable name, class name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified JavaScript code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including handling DOM, async operations, functions, closures, and variable scoping.\n6. Overall Description: Provide a detailed summary of the entire JavaScript code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following JavaScript code properly and return ONLY the JSON response with no additional text:\n\n({\n  type: 'recycle-list',\n  attr: {\n    append: 'tree',\n    listData: [\n      { type: 'A' },\n      { type: 'A' }\n    ],\n    switch: 'type',\n    alias: 'item'\n  },\n  children: [{\n    type: 'cell-slot',\n    attr: { append: 'tree', case: 'A' },\n    children: [{\n      type: 'text',\n      event: ['click', 'longpress'],\n      attr: { value: 'A' }\n    }, {\n      type: 'text',\n      event: ['touchend'],\n      attr: { value: 'B' }\n    }]\n  }]\n})\n", "completion": "{\n    \"programming_language\": \"JavaScript\",\n    \"components\": [\n      {\n        \"component_type\": \"OBJECT_LITERAL\",\n        \"component_name\": NULL,\n        \"component_code\": \"({\\n  type: 'recycle-list',\\n  attr: {\\n    append: 'tree',\\n    listData: [\\n      { type: 'A' },\\n      { type: 'A' }\\n    ],\\n    switch: 'type',\\n    alias: 'item'\\n  },\\n  children: [{\\n    type: 'cell-slot',\\n    attr: { append: 'tree', case: 'A' },\\n    children: [{\\n      type: 'text',\\n      event: ['click', 'longpress'],\\n      attr: { value: 'A' }\\n    }, {\\n      type: 'text',\\n      event: ['touchend'],\\n      attr: { value: 'B' }\\n    }]\\n  }]\\n})\",\n        \"component_description\": \"An object literal that represents a configuration for a recycle list component. It contains properties like `type`, `attr` which includes attributes such as `append`, `listData`, `switch`, and `alias`. The `children` property is an array of objects representing nested components, each with its own type, attributes, and events.\"\n      },\n      {\n        \"component_type\": \"ARRAY_LITERAL\",\n        \"component_name\": NULL,\n        \"component_code\": \"[\\n  { type: 'A' },\\n  { type: 'A' }\\n]\",\n        \"component_description\": \"An array of objects that serves as the `listData` attribute for the recycle list component. Each object in the array contains a `type` property with the value 'A', indicating the type of items in the list.\"\n      },\n      {\n        \"component_type\": \"OBJECT_LITERAL\",\n        \"component_name\": NULL,\n        \"component_code\": \"{\\n  type: 'cell-slot',\\n  attr: { append: 'tree', case: 'A' },\\n  children: [{\\n    type: 'text',\\n    event: ['click', 'longpress'],\\n    attr: { value: 'A' }\\n  }, {\\n    type: 'text',\\n    event: ['touchend'],\\n    attr: { value: 'B' }\\n  }]\\n}\",\n        \"component_description\": \"An object literal representing a child component of the recycle list, specifically a `cell-slot` with attributes for appending to a tree and a case condition. It contains nested children which are text components with specific events and attribute values.\"\n      },\n      {\n        \"component_type\": \"ARRAY_LITERAL\",\n        \"component_name\": NULL,\n        \"component_code\": \"[\\n  'click',\\n  'longpress'\\n]\",\n        \"component_description\": \"An array of strings representing the event types that are associated with a text component. This indicates that the component should handle `click` and `longpress` events.\"\n      },\n      {\n        \"component_type\": \"ARRAY_LITERAL\",\n        \"component_name\": NULL,\n        \"component_code\": \"[\\n  'touchend'\\n]\",\n        \"component_description\": \"An array of strings representing the event types associated with another text component. This indicates that the component should handle `touchend` events.\"\n      },\n      {\n        \"component_type\": \"OBJECT_LITERAL\",\n        \"component_name\": NULL,\n        \"component_code\": \"{\\n  type: 'text',\\n  event: ['click', 'longpress'],\\n  attr: { value: 'A' }\\n}\",\n        \"component_description\": \"An object literal representing a text component within the `cell-slot`. It specifies that this component should handle `click` and `longpress` events and has an attribute with a `value` of 'A'.\"\n      },\n      {\n        \"component_type\": \"OBJECT_LITERAL\",\n        \"component_name\": NULL,\n        \"component_code\": \"{\\n  type: 'text',\\n  event: ['touchend'],\\n  attr: { value: 'B' }\\n}\",\n        \"component_description\": \"An object literal representing another text component within the `cell-slot`. It specifies that this component should handle a `touchend` event and has an attribute with a `value` of 'B'.\"\n      }\n    ],\n    \"overall_description\": \"The provided JavaScript code snippet is an object literal configuration for a recycle list component, commonly used in frameworks like Weex. The configuration includes properties defining the type of the component (`recycle-list`), its attributes (such as appending to a tree structure and switching based on item types), and nested child components (`cell-slot`). Each `cell-slot` contains text elements with specified events that they should handle, allowing for interactive behavior within the list items. This setup is typical for creating dynamic and responsive lists in user interfaces.\"\n  }"}
{"prompt": "\nYou are an expert JavaScript code analyst. Your task is to dissect a given JavaScript code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"JavaScript\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_JS_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_JS_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_JS_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in JavaScript.\n2. Component Types: Use appropriate component types, for example, VARIABLE_DECLARATION, FUNCTION_DEFINITION, ARROW_FUNCTION, EVENT_HANDLER, CLASS_DEFINITION, MODULE_IMPORT, CONDITIONAL_STATEMENT, LOOP, PROMISE, ASYNC_FUNCTION, CALLBACK_FUNCTION.\n3. Component Names: Provide the correct identifier for each component (function name, variable name, class name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified JavaScript code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including handling DOM, async operations, functions, closures, and variable scoping.\n6. Overall Description: Provide a detailed summary of the entire JavaScript code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following JavaScript code properly and return ONLY the JSON response with no additional text:\n\n<gh_stars>1000+\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./vue.common.prod.js')\n} else {\n  module.exports = require('./vue.common.dev.js')\n}\n", "completion": "{\n    \"programming_language\": \"JavaScript\",\n    \"components\": [\n      {\n        \"component_type\": \"CONDITIONAL_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"if (process.env.NODE_ENV === 'production') {\\n  module.exports = require('./vue.common.prod.js')\\n} else {\\n  module.exports = require('./vue.common.dev.js')\\n}\",\n        \"component_description\": \"This conditional statement checks the value of the NODE_ENV environment variable. If it is equal to 'production', it exports the content of './vue.common.prod.js'. Otherwise, it exports the content of './vue.common.dev.js'. This allows different configurations for production and development environments.\"\n      }\n    ],\n    \"overall_description\": \"The JavaScript code snippet uses a conditional statement to determine whether the environment is in production or not by checking the NODE_ENV environment variable. Depending on the environment, it dynamically requires and exports either 'vue.common.prod.js' or 'vue.common.dev.js', enabling different configurations for production and development environments.\"\n  }"}
{"prompt": "\nYou are an expert C code analyst. Your task is to dissect a given C code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"C\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_C_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_C_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_C_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in C.\n2. Component Types: Use appropriate component types, for example, HEADER_INCLUDE, MACRO_DEFINITION, GLOBAL_VARIABLE, FUNCTION_DEFINITION, STRUCT_DEFINITION, MAIN_FUNCTION, LOOP, CONDITIONAL_STATEMENT.\n3. Component Names: Provide the correct identifier for each component (function name, variable name, struct name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified C code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including data structures, control flow, memory management, and function interactions.\n6. Overall Description: Provide a detailed summary of the entire C code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following C code properly and return ONLY the JSON response with no additional text:\n\n/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifndef TENSORFLOW_CORE_FRAMEWORK_RUN_HANDLER_H_\n#define TENSORFLOW_CORE_FRAMEWORK_RUN_HANDLER_H_\n\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/lib/histogram/histogram.h\"\n#include \"tensorflow/core/platform/context.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/platform/thread_annotations.h\"\n#include \"tensorflow/core/protobuf/config.pb.h\"\n\nnamespace Eigen {\nstruct ThreadPoolDevice;\n}\n\nnamespace tensorflow {\n\nclass RunHandler;\n\n// RunHandlerPool is a fixed size pool of pre-allocated RunHandlers\n// that can be used for tracking inter-op work for a given Session::Run().\n// RunHandler(s) in the pool are initially 'inactive'. A RunHandler becomes\n// 'active' when its unique_ptr is returned by Get() and is being used by a\n// client. It becomes 'inactive' once more when its unique_ptr gets destroyed.\n//\n// Expected usage:\n//\n// * Create a single RunHandlerPool (say run_handler_pool_).\n//\n// * When a Session::Run() is invoked, obtain a handler by:\n// auto handler = run_handler_pool_->Get();\n//\n// * Use handler for scheduling all inter-op work by:\n// handler->ScheduleInterOpClosure(closure);\n//\n// This class is thread safe.\nclass RunHandlerPool {\n public:\n  explicit RunHandlerPool(int num_inter_op_threads);\n\n  RunHandlerPool(int num_inter_op_threads, int num_intra_op_threads);\n  ~RunHandlerPool();\n\n  // Returns an inactive RunHandler from the pool.\n  //\n  // RunHandlers in RunHandlerPool are initially 'inactive'.\n  // A RunHandler becomes 'active' when its unique_ptr its returned by Get()\n  // and is being used by a client.  It becomes 'inactive' once more when the\n  // unique_ptr is destroyed.\n  //\n  // Will block unless there is an inactive handler.\n  std::unique_ptr<RunHandler> Get(\n      int64_t step_id = 0, int64_t timeout_in_ms = 0,\n      const RunOptions::Experimental::RunHandlerPoolOptions& options =\n          RunOptions::Experimental::RunHandlerPoolOptions());\n\n  // Get the priorities for active handlers. The return result is with the same\n  // order of the active handler list.\n  std::vector<int64_t> GetActiveHandlerPrioritiesForTesting() const;\n\n private:\n  class Impl;\n  friend class RunHandler;\n\n  std::unique_ptr<Impl> impl_;\n};\n\n// RunHandler can be used to schedule inter/intra-op closures to run on a global\n// pool shared across all Session::Run(s). The closures are enqueued to a\n// handler specific queue, from which the work is stolen in a priority order\n// (time of the Get() call).\n//\n// It can only be created via RunHandlerPool::Get().\n//\n// This class can be used instead of directly scheduling closures on a global\n// pool since it maintains a global view across all sessions and optimizes pool\n// scheduling to improve (median and tail) latency.\n//\n// This class is thread safe.\nclass RunHandler {\n public:\n  void ScheduleInterOpClosure(std::function<void()> fn);\n  thread::ThreadPoolInterface* AsIntraThreadPoolInterface();\n\n  ~RunHandler();\n\n private:\n  class Impl;\n  friend class RunHandlerPool::Impl;\n\n  explicit RunHandler(Impl* impl);\n\n  Impl* impl_;  // NOT OWNED.\n};\n\nnamespace internal {\n\n// TODO(azaks): Refactor with thread:ThreadPool\nclass RunHandlerEnvironment {\n  typedef Thread EnvThread;\n  struct TaskImpl {\n    std::function<void()> f;\n    Context context;\n    uint64 trace_id;\n  };\n  Env* const env_;\n  const ThreadOptions thread_options_;\n  const string name_;\n\n public:\n  struct Task {\n    std::unique_ptr<TaskImpl> f;\n  };\n\n  RunHandlerEnvironment(Env* env, const ThreadOptions& thread_options,\n                        const string& name);\n\n  EnvThread* CreateThread(std::function<void()> f,\n                          const std::string& thread_name);\n\n  Task CreateTask(std::function<void()> f);\n\n  void ExecuteTask(const Task& t);\n};\n\ntypedef typename RunHandlerEnvironment::Task Task;\ntypedef Eigen::RunQueue<Task, 1024> Queue;\n\n// To reduce cache misses, we use a doubly-linked list of Waiter structs and\n// queue them in LIFO order rather than the FIFO order used by a single\n// condition variable.\nstruct Waiter {\n  Waiter() {\n    next = this;\n    prev = this;\n  }\n  condition_variable cv;\n  mutex mu;\n  Waiter* next;\n  Waiter* prev;\n};\n\nclass ThreadWorkSource {\n public:\n  ThreadWorkSource();\n\n  ~ThreadWorkSource();\n\n  Task EnqueueTask(Task t, bool is_blocking);\n\n  Task PopBlockingTask();\n\n  Task PopNonBlockingTask(int start_index, bool search_from_all_queue);\n\n  void WaitForWork(int max_sleep_micros);\n\n  int TaskQueueSize(bool is_blocking);\n\n  int64_t GetTracemeId();\n\n  void SetTracemeId(int64_t value);\n\n  void SetWaiter(uint64 version, Waiter* waiter, mutex* mutex);\n\n  int64_t GetInflightTaskCount(bool is_blocking);\n\n  void IncrementInflightTaskCount(bool is_blocking);\n\n  void DecrementInflightTaskCount(bool is_blocking);\n\n  unsigned NonBlockingWorkShardingFactor();\n\n  std::string ToString();\n\n private:\n  struct NonBlockingQueue {\n    mutex queue_op_mu;\n    char pad[128];\n    Queue queue;\n  };\n\n  int32 non_blocking_work_sharding_factor_;\n  Eigen::MaxSizeVector<NonBlockingQueue*> non_blocking_work_queues_;\n\n  std::atomic<int64_t> blocking_inflight_;\n  std::atomic<int64_t> non_blocking_inflight_;\n\n  Queue blocking_work_queue_;\n  mutex blocking_queue_op_mu_;\n  char pad_[128];\n  mutex waiters_mu_;\n  Waiter queue_waiters_ TF_GUARDED_BY(waiters_mu_);\n  std::atomic<int64_t> traceme_id_;\n\n  mutex run_handler_waiter_mu_;\n  uint64 version_ TF_GUARDED_BY(run_handler_waiter_mu_);\n  mutex* sub_thread_pool_waiter_mu_ TF_GUARDED_BY(run_handler_waiter_mu_);\n  Waiter* sub_thread_pool_waiter_ TF_GUARDED_BY(run_handler_waiter_mu_);\n};\n\nclass RunHandlerThreadPool {\n public:\n  struct PerThread {\n    constexpr PerThread() : pool(nullptr), thread_id(-1) {}\n    RunHandlerThreadPool* pool;  // Parent pool, or null for normal threads.\n    int thread_id;               // Worker thread index in pool.\n  };\n\n  RunHandlerThreadPool(int num_blocking_threads, int num_non_blocking_threads,\n                       Env* env, const ThreadOptions& thread_options,\n                       const string& name,\n                       Eigen::MaxSizeVector<mutex>* waiters_mu,\n                       Eigen::MaxSizeVector<Waiter>* queue_waiters);\n\n  ~RunHandlerThreadPool();\n\n  void Start();\n\n  void StartOneThreadForTesting();\n\n  void AddWorkToQueue(ThreadWorkSource* tws, bool is_blocking,\n                      std::function<void()> fn);\n\n  // Set work queues from which the thread 'tid' can steal its work.\n  // The request with start_request_idx will be attempted first. Other requests\n  // will be attempted in FIFO order based on their arrival time.\n  void SetThreadWorkSources(\n      int tid, int start_request_idx, uint64 version,\n      const Eigen::MaxSizeVector<ThreadWorkSource*>& thread_work_sources);\n\n  PerThread* GetPerThread();\n\n  int CurrentThreadId() const;\n\n  int NumThreads() const;\n\n  int NumBlockingThreads() const;\n\n  int NumNonBlockingThreads() const;\n\n  void WorkerLoop(int thread_id, bool may_steal_blocking_work);\n\n  // Search tasks from Requets range searching_range_start to\n  // searching_range_end. If there is no tasks in the search range and\n  // may_steal_blocking_work is true, then search from all requests.\n  Task FindTask(\n      int searching_range_start, int searching_range_end, int thread_id,\n      int sub_thread_pool_id, int max_blocking_inflight,\n      bool may_steal_blocking_work,\n      const Eigen::MaxSizeVector<ThreadWorkSource*>& thread_work_sources,\n      bool* task_from_blocking_queue, ThreadWorkSource** tws);\n\n  void WaitForWork(bool is_blocking, int thread_id,\n                   int32_t max_blocking_inflight);\n\n  void WaitForWorkInSubThreadPool(bool is_blocking, int sub_thread_pool_id);\n\n private:\n  struct ThreadData {\n    ThreadData();\n    mutex mu;\n    uint64 new_version;\n    condition_variable sources_not_empty;\n    std::unique_ptr<Thread> thread;\n    int current_index;\n    std::unique_ptr<Eigen::MaxSizeVector<ThreadWorkSource*>>\n        new_thread_work_sources TF_GUARDED_BY(mu);\n\n    uint64 current_version;\n    // Should only be accessed by one thread.\n    std::unique_ptr<Eigen::MaxSizeVector<ThreadWorkSource*>>\n        current_thread_work_sources;\n\n    int sub_thread_pool_id;\n  };\n\n  const int num_threads_;\n  const int num_blocking_threads_;\n  const int num_non_blocking_threads_;\n  Eigen::MaxSizeVector<ThreadData> thread_data_;\n  internal::RunHandlerEnvironment env_;\n  std::atomic<bool> cancelled_;\n  string name_;\n  Eigen::MaxSizeVector<mutex>* waiters_mu_;\n  Eigen::MaxSizeVector<Waiter>* queue_waiters_;\n\n  bool use_sub_thread_pool_;\n  std::vector<int> num_threads_in_sub_thread_pool_;\n\n  // Threads in each sub thread pool will search tasks from the given\n  // start_request_percentage to end_request_percentage in a round robin\n  // fashion.\n  std::vector<double> sub_thread_pool_start_request_percentage_;\n  std::vector<double> sub_thread_pool_end_request_percentage_;\n};\n\n}  // namespace internal\n\n}  // end namespace tensorflow.\n\n#endif  // TENSORFLOW_CORE_FRAMEWORK_RUN_HANDLER_H_\n", "completion": "pet defines a part of TensorFlow's framework, specifically around handling and managing thread pools for executing tasks. The key components here are `RunHandlerThreadPool` and its related classes like `ThreadWorkSource`, which are used to manage the distribution and execution of workloads across multiple threads.\n\n### Key Classes:\n\n1. **ThreadWorkSource**:\n   - Represents a queue of tasks that can be worked on by threads.\n   - Maintains separate queues for blocking and non-blocking tasks.\n   - Provides methods to add, find, and remove tasks from these queues.\n   \n2. **RunHandlerThreadPool**:\n   - Manages a pool of worker threads that execute tasks from `ThreadWorkSource` instances.\n   - Supports both blocking (synchronous) and non-blocking (asynchronous) workloads.\n   - Allows threads to steal work from other sources when they become idle, promoting better load balancing.\n\n### Key Features:\n\n- **Task Queues**: Tasks are categorized into blocking and non-blocking queues based on their nature. Blocking tasks require immediate attention and can block the thread until completion, while non-blocking tasks do not hold up the thread.\n  \n- **Thread Pool Management**: The `RunHandlerThreadPool` manages a pool of threads that execute tasks from various sources. It starts threads when needed and stops them gracefully during shutdown.\n\n- **Task Stealing**: Threads that finish their assigned tasks can steal work from other threads' queues, which helps in distributing the workload evenly across all available threads and reduces idle time.\n\n- **Sub-thread Pools**: For more advanced load balancing, `RunHandlerThreadPool` supports sub-thread pools where threads within a pool search for tasks from specific ranges of sources. This is useful when certain types of tasks are expected to be more common or resource-intensive in different parts of the application.\n\n### Usage Scenario:\n\nThis setup is particularly useful in scenarios where you have a large number of independent, potentially long-running tasks that need to be distributed across multiple CPU cores for parallel execution. By using `RunHandlerThreadPool`, TensorFlow can efficiently manage these tasks, ensuring optimal use of available resources and minimizing idle time.\n\n### Example Use Case:\n\nImagine a deep learning model training process where different parts of the model (or even different models) are trained in parallel. Each part could be represented as a `ThreadWorkSource` with its own set of tasks (e.g., forward propagation, backward propagation). The `RunHandlerThreadPool` would manage a pool of threads to execute these tasks efficiently across all available CPU cores.\n\nThis code is an essential part of TensorFlow's internal architecture and demonstrates sophisticated task management and thread coordination strategie"}
{"prompt": "\nYou are an expert Kotlin code analyst. Your task is to dissect a given Kotlin code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Kotlin\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_KOTLIN_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_KOTLIN_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_KOTLIN_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Kotlin.\n2. Component Types: Use appropriate component types, for example, PACKAGE_DECLARATION, IMPORT_STATEMENT, CLASS_DEFINITION, DATA_CLASS_DEFINITION, FUNCTION_DEFINITION, EXTENSION_FUNCTION, PROPERTY_DECLARATION, CONSTRUCTOR, LAMBDA, NULL_SAFETY, SEALING_CLASS.\n3. Component Names: Provide the correct identifier for each component (function name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Kotlin code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including Kotlin-specific features like null safety, extension functions, coroutines, and data classes.\n6. Overall Description: Provide a detailed summary of the entire Kotlin code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Kotlin code properly and return ONLY the JSON response with no additional text:\n\npackage dev.kord.rest.json.request\n\nimport dev.kord.common.annotation.KordPreview\nimport dev.kord.common.entity.*\nimport dev.kord.common.entity.optional.Optional\nimport dev.kord.common.entity.optional.OptionalBoolean\nimport kotlinx.serialization.SerialName\nimport kotlinx.serialization.Serializable\nimport java.io.InputStream\n\n@Serializable\n@KordPreview\ndata class ApplicationCommandCreateRequest(\n    val name: String,\n    val description: String,\n    val options: Optional<List<ApplicationCommandOption>> = Optional.Missing(),\n    @SerialName(\"default_permission\")\n    val defaultPermission: OptionalBoolean = OptionalBoolean.Missing\n)\n\n@Serializable\n@KordPreview\ndata class ApplicationCommandModifyRequest(\n    val name: Optional<String> = Optional.Missing(),\n    val description: Optional<String> = Optional.Missing(),\n    val options: Optional<List<ApplicationCommandOption>> = Optional.Missing(),\n    @SerialName(\"default_permission\")\n    val defaultPermission: OptionalBoolean = OptionalBoolean.Missing\n)\n\n@Serializable\n@KordPreview\ndata class InteractionResponseModifyRequest(\n    val content: Optional<String> = Optional.Missing(),\n    val embeds: Optional<List<EmbedRequest>> = Optional.Missing(),\n    @SerialName(\"allowed_mentions\")\n    val allowedMentions: Optional<AllowedMentions> = Optional.Missing(),\n    val flags: Optional<MessageFlags> = Optional.Missing()\n)\n\n@KordPreview\ndata class MultipartInteractionResponseModifyRequest(\n    val request: InteractionResponseModifyRequest,\n    val files: List<Pair<String, InputStream>> = emptyList(),\n)\n\n@Serializable\n@KordPreview\ndata class InteractionResponseCreateRequest(\n    val type: InteractionResponseType,\n    val data: Optional<InteractionApplicationCommandCallbackData> = Optional.Missing()\n)\n\n@KordPreview\ndata class MultipartInteractionResponseCreateRequest(\n    val request: InteractionResponseCreateRequest,\n    val files: List<Pair<String, InputStream>> = emptyList()\n)\n\n@Serializable\n@KordPreview\nclass InteractionApplicationCommandCallbackData(\n    val tts: OptionalBoolean = OptionalBoolean.Missing,\n    val content: Optional<String> = Optional.Missing(),\n    val embeds: Optional<List<EmbedRequest>> = Optional.Missing(),\n    @SerialName(\"allowed_mentions\")\n    val allowedMentions: Optional<AllowedMentions> = Optional.Missing(),\n    val flags: Optional<MessageFlags> = Optional.Missing()\n\n)\n\n@KordPreview\ndata class MultipartFollowupMessageCreateRequest(\n    val request: FollowupMessageCreateRequest,\n    val files: List<Pair<String, InputStream>> = emptyList(),\n)\n\n@Serializable\n@KordPreview\nclass FollowupMessageCreateRequest(\n    val content: Optional<String> = Optional.Missing(),\n    val username: Optional<String> = Optional.Missing(),\n    @SerialName(\"avatar_url\")\n    val avatar: Optional<String> = Optional.Missing(),\n    val tts: OptionalBoolean = OptionalBoolean.Missing,\n    val embeds: Optional<List<EmbedRequest>> = Optional.Missing(),\n    val allowedMentions: Optional<AllowedMentions> = Optional.Missing()\n)\n\n@Serializable\n@KordPreview\ndata class FollowupMessageModifyRequest(\n    val content: Optional<String> = Optional.Missing(),\n    val embeds: Optional<List<EmbedRequest>> = Optional.Missing(),\n    @SerialName(\"allowed_mentions\")\n    val allowedMentions: Optional<AllowedMentions> = Optional.Missing(),\n)\n\n@KordPreview\ndata class MultipartFollowupMessageModifyRequest(\n    val request: FollowupMessageModifyRequest,\n    val files: List<Pair<String, java.io.InputStream>> = emptyList(),\n)\n\n@Serializable\n@KordPreview\ndata class ApplicationCommandPermissionsEditRequest(\n        val permissions: List<DiscordGuildApplicationCommandPermission>\n)\n", "completion": "{\n    \"programming_language\": \"Kotlin\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"dev.kord.rest.json.request\",\n        \"component_code\": \"package dev.kord.rest.json.request\",\n        \"component_description\": \"Declares the package name for the code, which is used to organize classes and interfaces in a logical manner.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import dev.kord.common.annotation.KordPreview\\nimport dev.kord.common.entity.*\\nimport dev.kord.common.entity.optional.Optional\\nimport dev.kord.common.entity.optional.OptionalBoolean\\nimport kotlinx.serialization.SerialName\\nimport kotlinx.serialization.Serializable\\nimport java.io.InputStream\",\n        \"component_description\": \"Imports necessary classes and annotations for the code, including Kotlinx Serialization for data serialization, Kord common entities and optional types, and Java's InputStream.\"\n      },\n      {\n        \"component_type\": \"DATA_CLASS_DEFINITION\",\n        \"component_name\": \"ApplicationCommandCreateRequest\",\n        \"component_code\": \"@Serializable\\n@KordPreview\\ndata class ApplicationCommandCreateRequest(\\n    val name: String,\\n    val description: String,\\n    val options: Optional<List<ApplicationCommandOption>> = Optional.Missing(),\\n    @SerialName(\\\"default_permission\\\")\\n    val defaultPermission: OptionalBoolean = OptionalBoolean.Missing\\n)\",\n        \"component_description\": \"Defines a data class for creating an application command request, including name, description, options, and default permission. It uses Kotlinx Serialization and Kord's optional types.\"\n      },\n      {\n        \"component_type\": \"DATA_CLASS_DEFINITION\",\n        \"component_name\": \"ApplicationCommandModifyRequest\",\n        \"component_code\": \"@Serializable\\n@KordPreview\\ndata class ApplicationCommandModifyRequest(\\n    val name: Optional<String> = Optional.Missing(),\\n    val description: Optional<String> = Optional.Missing(),\\n    val options: Optional<List<ApplicationCommandOption>> = Optional.Missing(),\\n    @SerialName(\\\"default_permission\\\")\\n    val defaultPermission: OptionalBoolean = OptionalBoolean.Missing\\n)\",\n        \"component_description\": \"Defines a data class for modifying an application command request, with optional fields for name, description, options, and default permission.\"\n      },\n      {\n        \"component_type\": \"DATA_CLASS_DEFINITION\",\n        \"component_name\": \"InteractionResponseModifyRequest\",\n        \"component_code\": \"@Serializable\\n@KordPreview\\ndata class InteractionResponseModifyRequest(\\n    val content: Optional<String> = Optional.Missing(),\\n    val embeds: Optional<List<EmbedRequest>> = Optional.Missing(),\\n    @SerialName(\\\"allowed_mentions\\\")\\n    val allowedMentions: Optional<AllowedMentions> = Optional.Missing(),\\n    val flags: Optional<MessageFlags> = Optional.Missing()\\n)\",\n        \"component_description\": \"Defines a data class for modifying an interaction response, with optional fields for content, embeds, allowed mentions, and message flags.\"\n      },\n      {\n        \"component_type\": \"DATA_CLASS_DEFINITION\",\n        \"component_name\": \"MultipartInteractionResponseModifyRequest\",\n        \"component_code\": \"@KordPreview\\ndata class MultipartInteractionResponseModifyRequest(\\n    val request: InteractionResponseModifyRequest,\\n    val files: List<Pair<String, InputStream>> = emptyList(),\\n)\",\n        \"component_description\": \"Defines a data class for multipart interaction response modification requests, including a request and an optional list of file pairs.\"\n      },\n      {\n        \"component_type\": \"DATA_CLASS_DEFINITION\",\n        \"component_name\": \"InteractionResponseCreateRequest\",\n        \"component_code\": \"@Serializable\\n@KordPreview\\ndata class InteractionResponseCreateRequest(\\n    val type: InteractionResponseType,\\n    val data: Optional<InteractionApplicationCommandCallbackData> = Optional.Missing()\\n)\",\n        \"component_description\": \"Defines a data class for creating an interaction response, including the type and optional callback data.\"\n      },\n      {\n        \"component_type\": \"DATA_CLASS_DEFINITION\",\n        \"component_name\": \"MultipartInteractionResponseCreateRequest\",\n        \"component_code\": \"@KordPreview\\ndata class MultipartInteractionResponseCreateRequest(\\n    val request: InteractionResponseCreateRequest,\\n    val files: List<Pair<String, java.io.InputStream>> = emptyList(),\\n)\",\n        \"component_description\": \"Defines a data class for multipart interaction response creation requests, including a request and an optional list of file pairs.\"\n      },\n      {\n        \"component_type\": \"DATA_CLASS_DEFINITION\",\n        \"component_name\": \"FollowupMessageModifyRequest\",\n        \"component_code\": \"@Serializable\\n@KordPreview\\ndata class FollowupMessageModifyRequest(\\n    val content: Optional<String> = Optional.Missing(),\\n    val embeds: Optional<List<EmbedRequest>> = Optional.Missing(),\\n    @SerialName(\\\"allowed_mentions\\\")\\n    val allowedMentions: Optional<AllowedMentions> = Optional.Missing()\\n)\",\n        \"component_description\": \"Defines a data class for modifying a follow-up message, with optional fields for content, embeds, and allowed mentions.\"\n      },\n      {\n        \"component_type\": \"DATA_CLASS_DEFINITION\",\n        \"component_name\": \"MultipartFollowupMessageModifyRequest\",\n        \"component_code\": \"@KordPreview\\ndata class MultipartFollowupMessageModifyRequest(\\n    val request: FollowupMessageModifyRequest,\\n    val files: List<Pair<String, java.io.InputStream>> = emptyList(),\\n)\",\n        \"component_description\": \"Defines a data class for multipart follow-up message modification requests, including a request and an optional list of file pairs.\"\n      },\n      {\n        \"component_type\": \"DATA_CLASS_DEFINITION\",\n        \"component_name\": \"ApplicationCommandPermissionsEditRequest\",\n        \"component_code\": \"@Serializable\\n@KordPreview\\ndata class ApplicationCommandPermissionsEditRequest(\\n        val permissions: List<DiscordGuildApplicationCommandPermission>\\n)\",\n        \"component_description\": \"Defines a data class for editing application command permissions, including a list of Discord guild application command permissions.\"\n      },\n      {\n        \"component_type\": \"DATA_CLASS_DEFINITION\",\n        \"component_name\": \"FollowupMessageCreateRequest\",\n        \"component_code\": \"@Serializable\\n@KordPreview\\ndata class FollowupMessageCreateRequest(\\n    val content: Optional<String> = Optional.Missing(),\\n    val embeds: Optional<List<EmbedRequest>> = Optional.Missing(),\\n    @SerialName(\\\"allowed_mentions\\\")\\n    val allowedMentions: Optional<AllowedMentions> = Optional.Missing()\\n)\",\n        \"component_description\": \"Defines a data class for creating a follow-up message, with optional fields for content, embeds, and allowed mentions.\"\n      },\n      {\n        \"component_type\": \"DATA_CLASS_DEFINITION\",\n        \"component_name\": \"MultipartFollowupMessageCreateRequest\",\n        \"component_code\": \"@KordPreview\\ndata class MultipartFollowupMessageCreateRequest(\\n    val request: FollowupMessageCreateRequest,\\n    val files: List<Pair<String, java.io.InputStream>> = emptyList(),\\n)\",\n        \"component_description\": \"Defines a data class for multipart follow-up message creation requests, including a request and an optional list of file pairs.\"\n      },\n      {\n        \"component_type\": \"DATA_CLASS_DEFINITION\",\n        \"component_name\": \"InteractionApplicationCommandCallbackData\",\n        \"component_code\": \"@Serializable\\n@KordPreview\\ndata class InteractionApplicationCommandCallbackData(\\n    val tts: Boolean = false,\\n    val content: Optional<String> = Optional.Missing(),\\n    val embeds: Optional<List<EmbedRequest>> = Optional.Missing(),\\n    @SerialName(\\\"allowed_mentions\\\")\\n    val allowedMentions: Optional<AllowedMentions> = Optional.Missing()\\n)\",\n        \"component_description\": \"Defines a data class for interaction application command callback data, including optional fields for text-to-speech (TTS), content, embeds, and allowed mentions.\"\n      }\n    ],\n    \"overall_description\": \"The code defines multiple data classes used in Kord's REST API to handle various requests related to application commands and interactions, such as creating and modifying commands, responses, and follow-up messages. These data classes use Kotlinx Serialization for serialization and deserialization, and Kord's optional types to handle nullable fields.\"\n  }"}
{"prompt": "\nYou are an expert Rust code analyst. Your task is to dissect a given Rust code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Rust\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_RUST_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_RUST_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_RUST_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Rust.\n2. Component Types: Use appropriate component types, for example, MODULE_DECLARATION, USE_STATEMENT, STRUCT_DEFINITION, ENUM_DEFINITION, TRAIT_DEFINITION, FUNCTION_DEFINITION, IMPLEMENTATION_BLOCK, MATCH_STATEMENT, LET_STATEMENT, LOOP, IF_STATEMENT, PATTERN_MATCHING.\n3. Component Names: Provide the correct identifier for each component (function name, struct name, enum name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Rust code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including ownership, borrowing, pattern matching, and concurrency aspects of Rust.\n6. Overall Description: Provide a detailed summary of the entire Rust code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Rust code properly and return ONLY the JSON response with no additional text:\n\n<filename>src/test/run-make-fulldeps/extern-overrides-distribution/main.rs\nextern crate libc;\n\nfn main() {\n    libc::foo();\n}\n", "completion": "{\n    \"programming_language\": \"Rust\",\n    \"components\": [\n      {\n        \"component_type\": \"EXTERN_CRATE_DECLARATION\",\n        \"component_name\": \"libc\",\n        \"component_code\": \"extern crate libc;\",\n        \"component_description\": \"This declaration brings the external crate 'libc' into scope. The 'libc' crate provides bindings to C standard libraries, allowing Rust code to call C functions directly.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"fn main() {\\n    libc::foo();\\n}\",\n        \"component_description\": \"The 'main' function is the entry point of a Rust application. In this code, it calls the function 'foo' from the 'libc' crate. Note that calling an undefined or non-existent function like 'foo' in the 'libc' crate would result in a compilation error.\"\n      }\n    ],\n    \"overall_description\": \"The provided Rust code is a simple program that attempts to call a C function named 'foo' from the 'libc' crate, which provides bindings to C standard libraries. The code starts by declaring an external dependency on the 'libc' crate using 'extern crate libc;'. It then defines the main function, which is the entry point of any Rust application, and within this function, it tries to invoke 'libc::foo()'. However, there might be a compilation error if 'foo' does not exist in the 'libc' crate as expected.\"\n  }"}
{"prompt": "\nYou are an expert Kotlin code analyst. Your task is to dissect a given Kotlin code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Kotlin\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_KOTLIN_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_KOTLIN_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_KOTLIN_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Kotlin.\n2. Component Types: Use appropriate component types, for example, PACKAGE_DECLARATION, IMPORT_STATEMENT, CLASS_DEFINITION, DATA_CLASS_DEFINITION, FUNCTION_DEFINITION, EXTENSION_FUNCTION, PROPERTY_DECLARATION, CONSTRUCTOR, LAMBDA, NULL_SAFETY, SEALING_CLASS.\n3. Component Names: Provide the correct identifier for each component (function name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Kotlin code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including Kotlin-specific features like null safety, extension functions, coroutines, and data classes.\n6. Overall Description: Provide a detailed summary of the entire Kotlin code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Kotlin code properly and return ONLY the JSON response with no additional text:\n\nplugins {\n    id(\"com.android.library\")\n}\n\ngroup=\"com.github.topjohnwu.libsu\"\n\nandroid {\n    namespace = \"com.topjohnwu.superuser\"\n    defaultConfig {\n        consumerProguardFiles(\"proguard-rules.pro\")\n    }\n}\n\ndependencies {\n    implementation(fileTree(mapOf(\"dir\" to \"libs\", \"include\" to listOf(\"*.jar\"))))\n    api(\"androidx.annotation:annotation:1.3.0\")\n    javadocDeps(\"androidx.annotation:annotation:1.3.0\")\n}\n", "completion": "{\n    \"programming_language\": \"Kotlin\",\n    \"components\": [\n      {\n        \"component_type\": \"PLUGIN_DECLARATION\",\n        \"component_name\": null,\n        \"component_code\": \"plugins {\\n    id(\\\"com.android.library\\\")\\n}\",\n        \"component_description\": \"Declares the use of the Android Library plugin, which is necessary for building an Android library module.\"\n      },\n      {\n        \"component_type\": \"GROUP_DECLARATION\",\n        \"component_name\": null,\n        \"component_code\": \"group=\\\"com.github.topjohnwu.libsu\\\"\",\n        \"component_description\": \"Sets the group ID for the project, typically used in conjunction with publishing to a repository.\"\n      },\n      {\n        \"component_type\": \"ANDROID_BLOCK\",\n        \"component_name\": null,\n        \"component_code\": \"android {\\n    namespace = \\\"com.topjohnwu.superuser\\\"\\n    defaultConfig {\\n        consumerProguardFiles(\\\"proguard-rules.pro\\\")\\n    }\\n}\",\n        \"component_description\": \"Configures Android-specific settings for the module, including setting the namespace (package name) and specifying ProGuard rules for code shrinking and obfuscation.\"\n      },\n      {\n        \"component_type\": \"DEPENDENCIES_BLOCK\",\n        \"component_name\": null,\n        \"component_code\": \"dependencies {\\n    implementation(fileTree(mapOf(\\\"dir\\\" to \\\"libs\\\", \\\"include\\\" to listOf(\\\"*.jar\\\"))))\\n    api(\\\"androidx.annotation:annotation:1.3.0\\\")\\n    javadocDeps(\\\"androidx.annotation:annotation:1.3.0\\\")\\n}\",\n        \"component_description\": \"Declares dependencies required by the module, including JAR files from a local directory and specific versions of AndroidX libraries for API exposure and documentation.\"\n      }\n    ],\n    \"overall_description\": \"This Kotlin-based Gradle script configures an Android library project. It applies the Android Library plugin, sets the group ID for repository publishing, specifies Android-specific configurations such as namespace and ProGuard rules, and declares dependencies including local JAR files and AndroidX libraries.\"\n  }"}
{"prompt": "\nYou are an expert Go code analyst. Your task is to dissect a given Go code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_GO_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_GO_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_GO_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Go.\n2. Component Types: Use appropriate component types, for example, PACKAGE_DECLARATION, IMPORT_STATEMENT, FUNCTION_DEFINITION, STRUCT_DEFINITION, METHOD_DEFINITION, INTERFACE_DEFINITION, VARIABLE_DECLARATION, CONDITIONAL_STATEMENT, LOOP, ERROR_HANDLING, GOROUTINE.\n3. Component Names: Provide the correct identifier for each component (function name, variable name, struct name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Go code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including concurrency handling, data structures, error management, and function interactions.\n6. Overall Description: Provide a detailed summary of the entire Go code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Go code properly and return ONLY the JSON response with no additional text:\n\n<filename>tensorflow/go/shape_test.go\n/*\nCopyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage tensorflow\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestShape(t *testing.T) {\n\ttests := []struct {\n\t\tshape Shape\n\t\tslice []int64\n\t\tfull  bool\n\t\tstr   string\n\t}{\n\t\t{\n\t\t\tshape: ScalarShape(),\n\t\t\tslice: make([]int64, 0),\n\t\t\tfull:  true,\n\t\t\tstr:   \"[]\",\n\t\t},\n\t\t{\n\t\t\tshape: MakeShape(-1, 2, -1, 4),\n\t\t\tslice: []int64{-1, 2, -1, 4},\n\t\t\tfull:  false,\n\t\t\tstr:   \"[?, 2, ?, 4]\",\n\t\t},\n\t\t{\n\t\t\tshape: MakeShape(2, 3),\n\t\t\tslice: []int64{2, 3},\n\t\t\tfull:  true,\n\t\t\tstr:   \"[2, 3]\",\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%#v\", test.shape), func(t *testing.T) {\n\t\t\tif got, want := test.shape.NumDimensions(), len(test.slice); got != want {\n\t\t\t\tt.Errorf(\"Got %v, want %v\", got, want)\n\t\t\t}\n\t\t\tif gotSlice, err := test.shape.ToSlice(); err != nil || !reflect.DeepEqual(gotSlice, test.slice) {\n\t\t\t\tt.Errorf(\"Got (%#v, %v), want (%#v, nil)\", gotSlice, err, test.slice)\n\t\t\t}\n\t\t\tif got, want := test.shape.IsFullySpecified(), test.full; got != want {\n\t\t\t\tt.Errorf(\"Got %v, want %v\", got, want)\n\t\t\t}\n\t\t\tif got, want := test.shape.String(), test.str; got != want {\n\t\t\t\tt.Errorf(\"Got %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n\n}\n\nfunc TestZeroShape(t *testing.T) {\n\tvar s Shape\n\tif s.NumDimensions() != -1 {\n\t\tt.Error(s.NumDimensions())\n\t}\n\tif _, err := s.ToSlice(); err == nil {\n\t\tt.Error(\"ToSlice() on a Shape of unknown number of dimensions should fail\")\n\t}\n\tif s.IsFullySpecified() {\n\t\tt.Error(\"Shape of unknown number of dimensions should not be fully specified\")\n\t}\n\tif got, want := s.String(), \"?\"; got != want {\n\t\tt.Errorf(\"Got %q, want %q\", got, want)\n\t}\n\n}\n", "completion": "{\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"tensorflow\",\n        \"component_code\": \"package tensorflow\",\n        \"component_description\": \"Declares the package name as 'tensorflow', which groups related Go code together.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import (\\n\\t\\\"fmt\\\"\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\",\n        \"component_description\": \"Imports the fmt, reflect, and testing packages which provide functions for formatted I/O, deep value comparisons, and automated testing, respectively.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TestShape\",\n        \"component_code\": \"func TestShape(t *testing.T) {\\n\\ttests := []struct {\\n\\t\\tshape Shape\\n\\t\\tslice []int64\\n\\t\\tfull  bool\\n\\t\\tstr   string\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tshape: ScalarShape(),\\n\\t\\t\\tslice: make([]int64, 0),\\n\\t\\t\\tfull:  true,\\n\\t\\t\\tstr:   \\\"[]\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tshape: MakeShape(-1, 2, -1, 4),\\n\\t\\t\\tslice: []int64{-1, 2, -1, 4},\\n\\t\\t\\tfull:  false,\\n\\t\\t\\tstr:   \\\"[?, 2, ?, 4]\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tshape: MakeShape(2, 3),\\n\\t\\t\\tslice: []int64{2, 3},\\n\\t\\t\\tfull:  true,\\n\\t\\t\\tstr:   \\\"[2, 3]\\\",\\n\\t\\t},\\n\\t}\\n\\tfor _, test := range tests {\\n\\t\\tt.Run(fmt.Sprintf(\\\"%#v\\\", test.shape), func(t *testing.T) {\\n\\t\\t\\tif got, want := test.shape.NumDimensions(), len(test.slice); got != want {\\n\\t\\t\\t\\tt.Errorf(\\\"Got %v, want %v\\\", got, want)\\n\\t\\t\\t}\\n\\t\\t\\tif gotSlice, err := test.shape.ToSlice(); err != nil || !reflect.DeepEqual(gotSlice, test.slice) {\\n\\t\\t\\t\\tt.Errorf(\\\"Got (%#v, %v), want (%#v, nil)\\\", gotSlice, err, test.slice)\\n\\t\\t\\t}\\n\\t\\t\\tif got, want := test.shape.IsFullySpecified(), test.full; got != want {\\n\\t\\t\\t\\tt.Errorf(\\\"Got %v, want %v\\\", got, want)\\n\\t\\t\\t}\\n\\t\\t\\tif got, want := test.shape.String(), test.str; got != want {\\n\\t\\t\\t\\tt.Errorf(\\\"Got %v, want %v\\\", got, want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\",\n        \"component_description\": \"Defines a test function TestShape which checks the behavior of the Shape type. It uses table-driven tests to verify various properties of different shapes like NumDimensions, ToSlice, IsFullySpecified, and String methods.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TestZeroShape\",\n        \"component_code\": \"func TestZeroShape(t *testing.T) {\\n\\tvar s Shape\\n\\tif s.NumDimensions() != -1 {\\n\\t\\tt.Error(s.NumDimensions())\\n\\t}\\n\\tif _, err := s.ToSlice(); err == nil {\\n\\t\\tt.Error(\\\"ToSlice() on a Shape of unknown number of dimensions should fail\\\")\\n\\t}\\n\\tif s.IsFullySpecified() {\\n\\t\\tt.Error(\\\"Shape of unknown number of dimensions should not be fully specified\\\")\\n\\t}\\n\\tif got, want := s.String(), \\\"?\\\"; got != want {\\n\\t\\tt.Errorf(\\\"Got %q, want %q\\\", got, want)\\n\\t}\\n}\",\n        \"component_description\": \"Defines a test function TestZeroShape which checks the behavior of a Shape with an unknown number of dimensions. It verifies that NumDimensions returns -1, ToSlice returns an error, IsFullySpecified returns false, and String returns '?'.\"\n      }\n    ],\n    \"overall_description\": \"This Go code file contains unit tests for the Shape type in the tensorflow package. It includes two test functions: TestShape, which uses table-driven testing to verify the behavior of various shapes, and TestZeroShape, which checks the behavior of a shape with an unknown number of dimensions. These tests ensure that the methods NumDimensions, ToSlice, IsFullySpecified, and String behave as expected for different Shape instances.\"\n  }"}
{"prompt": "\nYou are an expert C++ code analyst. Your task is to dissect a given C++ code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_CPP_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_CPP_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_CPP_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in C++.\n2. Component Types: Use appropriate component types, for example, HEADER_INCLUDE, MACRO_DEFINITION, GLOBAL_VARIABLE, FUNCTION_DEFINITION, CLASS_DEFINITION, STRUCT_DEFINITION, CONSTRUCTOR, DESTRUCTOR, MAIN_FUNCTION, LOOP, CONDITIONAL_STATEMENT, TEMPLATE_DEFINITION, NAMESPACE_DECLARATION.\n3. Component Names: Provide the correct identifier for each component (function name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified C++ code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including object-oriented features, memory management, template usage, and function interactions.\n6. Overall Description: Provide a detailed summary of the entire C++ code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following C++ code properly and return ONLY the JSON response with no additional text:\n\n<reponame>EricRemmerswaal/tensorflow\n/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/tpu/tpu_configuration.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\nResourceMgr* GetGlobalResourceMgr() {\n  static ResourceMgr* const rmgr = new ResourceMgr();\n  return rmgr;\n}\n\n}  // namespace\n\n#if !defined(PLATFORM_GOOGLE)\n// Used only by Google-internal tests, so deliberately left empty.\nvoid MaybeInitializeTPUSystemForTests() {}\n#endif\n\nResourceMgr* GetTPUConfigResourceMgr(bool initialize_first) {\n  if (initialize_first) {\n    MaybeInitializeTPUSystemForTests();\n  }\n\n  // Put all TPU-related state in the global ResourceMgr. This includes the\n  // TpuPodState, compilation cache, etc. We don't use the TPU_SYSTEM\n  // ResourceMgr because there may be more than one TPU_SYSTEM ResourceMgr when\n  // DirectSession or isolate_session_state are used.\n  return GetGlobalResourceMgr();\n}\n\n}  // namespace tensorflow\n", "completion": "{\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/tpu/tpu_configuration.h\\\"\",\n        \"component_description\": \"Includes the header file 'tpu_configuration.h' which contains declarations and definitions related to TPU configuration in TensorFlow.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tensorflow\",\n        \"component_code\": \"namespace tensorflow { ... }\",\n        \"component_description\": \"Declares a namespace named 'tensorflow', encapsulating the code within it to avoid name collisions with other parts of the program.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": NULL,\n        \"component_code\": \"namespace { ... }\",\n        \"component_description\": \"An unnamed (anonymous) namespace that limits the scope of its contents to this file, preventing linkage conflicts with other translation units.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"GetGlobalResourceMgr\",\n        \"component_code\": \"static ResourceMgr* const rmgr = new ResourceMgr();\\nreturn rmgr;\",\n        \"component_description\": \"A static function that returns a pointer to a global 'ResourceMgr' object. The object is created on the first call and persists for the lifetime of the program.\"\n      },\n      {\n        \"component_type\": \"PREPROCESSOR_DIRECTIVE\",\n        \"component_name\": \"#if !defined(PLATFORM_GOOGLE)\",\n        \"component_code\": \"#if !defined(PLATFORM_GOOGLE)\\nvoid MaybeInitializeTPUSystemForTests() {}\\n#endif\",\n        \"component_description\": \"A preprocessor directive that checks if the macro 'PLATFORM_GOOGLE' is not defined. If true, it defines an empty function 'MaybeInitializeTPUSystemForTests' used only for Google-internal tests.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"GetTPUConfigResourceMgr\",\n        \"component_code\": \"if (initialize_first) {\\n  MaybeInitializeTPUSystemForTests();\\n}\\nreturn GetGlobalResourceMgr();\",\n        \"component_description\": \"A function that optionally initializes the TPU system and returns a pointer to a global 'ResourceMgr' object. This manager holds all TPU-related state, such as TpuPodState and compilation cache.\"\n      }\n    ],\n    \"overall_description\": \"The code snippet is part of TensorFlow's implementation for managing TPU (Tensor Processing Unit) configurations. It defines utility functions within the 'tensorflow' namespace to handle resource management for TPUs. The primary function, 'GetTPUConfigResourceMgr', provides access to a global 'ResourceMgr' object that stores TPU-related state. An optional initialization step is available through 'MaybeInitializeTPUSystemForTests', which is conditionally compiled and used only in Google-internal tests.\"\n  }"}
{"prompt": "\nYou are an expert C# code analyst. Your task is to dissect a given C# code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"C#\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_CSHARP_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_CSHARP_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_CSHARP_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in C#.\n2. Component Types: Use appropriate component types, for example, USING_DIRECTIVE, NAMESPACE_DECLARATION, CLASS_DEFINITION, STRUCT_DEFINITION, INTERFACE_DEFINITION, ENUM_DEFINITION, METHOD_DEFINITION, PROPERTY_DEFINITION, CONSTRUCTOR, DESTRUCTOR, MAIN_METHOD, LOOP, CONDITIONAL_STATEMENT, EVENT_DEFINITION, DELEGATE_DEFINITION, ASYNC_METHOD.\n3. Component Names: Provide the correct identifier for each component (method name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified C# code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including object-oriented features, data structures, event handling, threading, and interactions.\n6. Overall Description: Provide a detailed summary of the entire C# code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following C# code properly and return ONLY the JSON response with no additional text:\n\n<gh_stars>1000+\n\ufeff// Copyright (c) Microsoft Corporation\r\n// The Microsoft Corporation licenses this file to you under the MIT license.\r\n// See the LICENSE file in the project root for more information.\r\n\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics.Tracing;\r\nusing Microsoft.PowerToys.Telemetry;\r\nusing Microsoft.PowerToys.Telemetry.Events;\r\n\r\nnamespace ColorPicker.Telemetry\r\n{\r\n    [EventData]\r\n    public class ColorPickerSettings : EventBase, IEvent\r\n    {\r\n        public ColorPickerSettings(IDictionary<string, bool> editorFormats)\r\n        {\r\n            EditorFormats = editorFormats;\r\n            EventName = \"ColorPicker_Settings\";\r\n        }\r\n\r\n        public string ActivationShortcut { get; set; }\r\n\r\n        public string ActivationBehaviour { get; set; }\r\n\r\n        public string ColorFormatForClipboard { get; set; }\r\n\r\n        public bool ShowColorName { get; set; }\r\n\r\n        public IDictionary<string, bool> EditorFormats { get; }\r\n\r\n        public PartA_PrivTags PartA_PrivTags => PartA_PrivTags.ProductAndServiceUsage;\r\n    }\r\n}\r\n", "completion": "{\n    \"programming_language\": \"C#\",\n    \"components\": [\n      {\n        \"component_type\": \"USING_DIRECTIVE\",\n        \"component_name\": null,\n        \"component_code\": \"using System.Collections.Generic;\",\n        \"component_description\": \"This directive imports the System.Collections.Generic namespace, which provides interfaces and classes that define generic collections.\"\n      },\n      {\n        \"component_type\": \"USING_DIRECTIVE\",\n        \"component_name\": null,\n        \"component_code\": \"using System.Diagnostics.Tracing;\",\n        \"component_description\": \"This directive imports the System.Diagnostics.Tracing namespace, which contains types that support event tracing for Windows (ETW).\"\n      },\n      {\n        \"component_type\": \"USING_DIRECTIVE\",\n        \"component_name\": null,\n        \"component_code\": \"using Microsoft.PowerToys.Telemetry;\",\n        \"component_description\": \"This directive imports the Microsoft.PowerToys.Telemetry namespace, which likely contains classes and interfaces for telemetry data collection.\"\n      },\n      {\n        \"component_type\": \"USING_DIRECTIVE\",\n        \"component_name\": null,\n        \"component_code\": \"using Microsoft.PowerToys.Telemetry.Events;\",\n        \"component_description\": \"This directive imports the Microsoft.PowerToys.Telemetry.Events namespace, which likely contains specific event-related classes and interfaces for telemetry.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"ColorPicker.Telemetry\",\n        \"component_code\": \"namespace ColorPicker.Telemetry\\n{\\n    // ... class definition ...\\n}\",\n        \"component_description\": \"Declares a namespace named 'ColorPicker.Telemetry' that contains the ColorPickerSettings class.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"ColorPickerSettings\",\n        \"component_code\": \"[EventData]\\npublic class ColorPickerSettings : EventBase, IEvent\\n{\\n    // ... constructor and properties ...\\n}\",\n        \"component_description\": \"Defines a public class named 'ColorPickerSettings' that inherits from 'EventBase' and implements the 'IEvent' interface. It is decorated with the [EventData] attribute, indicating that it represents event data for telemetry.\"\n      },\n      {\n        \"component_type\": \"CONSTRUCTOR\",\n        \"component_name\": \"ColorPickerSettings\",\n        \"component_code\": \"public ColorPickerSettings(IDictionary<string, bool> editorFormats)\\n{\\n    EditorFormats = editorFormats;\\n    EventName = \\\"ColorPicker_Settings\\\";\\n}\",\n        \"component_description\": \"Constructor for the 'ColorPickerSettings' class that takes an 'IDictionary<string, bool>' parameter to initialize the 'EditorFormats' property and sets the 'EventName' to 'ColorPicker_Settings'.\"\n      },\n      {\n        \"component_type\": \"PROPERTY_DEFINITION\",\n        \"component_name\": \"ActivationShortcut\",\n        \"component_code\": \"public string ActivationShortcut { get; set; }\",\n        \"component_description\": \"A public string property named 'ActivationShortcut' that can be both read from and written to. This likely stores the shortcut used to activate a feature.\"\n      },\n      {\n        \"component_type\": \"PROPERTY_DEFINITION\",\n        \"component_name\": \"ActivationBehaviour\",\n        \"component_code\": \"public string ActivationBehaviour { get; set; }\",\n        \"component_description\": \"A public string property named 'ActivationBehaviour' that can be both read from and written to. This likely stores the behavior or mode of activation for a feature.\"\n      },\n      {\n        \"component_type\": \"PROPERTY_DEFINITION\",\n        \"component_name\": \"ColorFormatForClipboard\",\n        \"component_code\": \"public string ColorFormatForClipboard { get; set; }\",\n        \"component_description\": \"A public string property named 'ColorFormatForClipboard' that can be both read from and written to. This likely stores the format in which color data is copied to the clipboard.\"\n      },\n      {\n        \"component_type\": \"PROPERTY_DEFINITION\",\n        \"component_name\": \"ShowColorName\",\n        \"component_code\": \"public bool ShowColorName { get; set; }\",\n        \"component_description\": \"A public boolean property named 'ShowColorName' that can be both read from and written to. This likely indicates whether the color name should be displayed.\"\n      },\n      {\n        \"component_type\": \"PROPERTY_DEFINITION\",\n        \"component_name\": \"EditorFormats\",\n        \"component_code\": \"public IDictionary<string, bool> EditorFormats { get; }\",\n        \"component_description\": \"A public read-only property named 'EditorFormats' of type 'IDictionary<string, bool>'. This stores the formats that are enabled or disabled for color editing.\"\n      },\n      {\n        \"component_type\": \"PROPERTY_DEFINITION\",\n        \"component_name\": \"PartA_PrivTags\",\n        \"component_code\": \"public PartA_PrivTags PartA_PrivTags => PartA_PrivTags.ProductAndServiceUsage;\",\n        \"component_description\": \"A public property named 'PartA_PrivTags' that returns a value of the 'PartA_PrivTags' enum. This likely specifies privacy tags for the telemetry event, indicating that the data relates to product and service usage.\"\n      }\n    ],\n    \"overall_description\": \"The provided C# code defines a class named 'ColorPickerSettings' within the 'ColorPicker.Telemetry' namespace. This class is designed to capture settings related to a color picker tool's behavior and configuration for telemetry purposes. It inherits from 'EventBase' and implements the 'IEvent' interface, and it uses properties to store various settings such as activation shortcuts, behaviors, clipboard formats, and editor formats. The class also specifies privacy tags for the telemetry data it collects.\"\n  }"}
{"prompt": "\nYou are an expert Kotlin code analyst. Your task is to dissect a given Kotlin code snippet and provide a structured JSON response detailing all of its components and overall functionality. You must strictly adhere to the following JSON format:\n{\n  \"output\": {\n    \"programming_language\": \"Kotlin\",\n    \"components\": [\n      {\n        \"component_type\": \"<TYPE_OF_KOTLIN_COMPONENT>\",\n        \"component_name\": \"<NAME_OF_COMPONENT_IF_APPLICABLE>\",\n        \"component_code\": \"<THE_ACTUAL_KOTLIN_CODE_OF_THE_COMPONENT>\",\n        \"component_description\": \"<DETAILED_DESCRIPTION_OF_COMPONENT_FUNCTIONALITY>\"\n      },\n      { /* ... more components ... */ }\n    ],\n    \"overall_description\": \"<DETAILED_SUMMARY/DESCRIPTION_OF_THE_ENTIRE_KOTLIN_CODE_FUNCTIONALITY>\"\n  }\n}\n\n**Instructions:**\n1. Identify the Programming Language: The script is written in Kotlin.\n2. Component Types: Use appropriate component types, for example, PACKAGE_DECLARATION, IMPORT_STATEMENT, CLASS_DEFINITION, DATA_CLASS_DEFINITION, FUNCTION_DEFINITION, EXTENSION_FUNCTION, PROPERTY_DECLARATION, CONSTRUCTOR, LAMBDA, NULL_SAFETY, SEALING_CLASS.\n3. Component Names: Provide the correct identifier for each component (function name, class name, variable name, etc.), or NULL if not applicable.\n4. Component Code: Include the complete, unmodified Kotlin code for each component.\n5. Component Descriptions: Provide a detailed, technical explanation of what each component does, including Kotlin-specific features like null safety, extension functions, coroutines, and data classes.\n6. Overall Description: Provide a detailed summary of the entire Kotlin code, explaining its purpose, architecture, and how components interact.\n7. Strict JSON Output: Your ENTIRE response must be ONLY the valid JSON object. Do not include any explanations, introductions, or additional text outside the JSON structure.\n\nAnalyze the following Kotlin code properly and return ONLY the JSON response with no additional text:\n\n<filename>kotlin-html/src/genTest/kotlin/dev/scottpierce/html/element/ITest.kt\npackage dev.scottpierce.html.element\n\nimport dev.scottpierce.html.write.StringBuilderHtmlWriter\nimport dev.scottpierce.html.write.WriteOptions\nimport kotlin.test.Test\n\nclass ITest {\n    @Test\n    fun writerNoCustomAttributeTest() {\n        createWriter().apply {\n            i(id = \"test-id\", classes = \"test-class\")\n        } assertEquals {\n            \"\"\"\n            <i id=\"test-id\" class=\"test-class\">\n            </i>\n            \"\"\".trimIndent()\n        }\n    }\n\n    @Test\n    fun writerVarArgAttributeTest() {\n        createWriter().apply {\n            i(\"custom-attr\" to \"custom-attr-value\", id = \"test-id\", classes = \"test-class\")\n        } assertEquals {\n            \"\"\"\n            <i id=\"test-id\" class=\"test-class\" custom-attr=\"custom-attr-value\">\n            </i>\n            \"\"\".trimIndent()\n        }\n    }\n\n    @Test\n    fun writerListAttributeTest() {\n        createWriter().apply {\n            i(attrs = listOf(\"custom-attr\" to \"custom-attr-value\"), id = \"test-id\", classes = \"test-class\")\n        } assertEquals {\n            \"\"\"\n            <i id=\"test-id\" class=\"test-class\" custom-attr=\"custom-attr-value\">\n            </i>\n            \"\"\".trimIndent()\n        }\n    }\n\n    @Test\n    fun contextNoCustomAttributeTest() {\n        val writer = createWriter()\n\n        BodyContext(writer).i(id = \"test-id\", classes = \"test-class\")\n\n        writer assertEquals {\n            \"\"\"\n            <i id=\"test-id\" class=\"test-class\">\n            </i>\n            \"\"\".trimIndent()\n        }\n    }\n\n    @Test\n    fun contextVarArgAttributeTest() {\n        val writer = createWriter()\n\n        BodyContext(writer).i(\"custom-attr\" to \"custom-attr-value\", id = \"test-id\", classes = \"test-class\")\n\n        writer assertEquals {\n            \"\"\"\n            <i id=\"test-id\" class=\"test-class\" custom-attr=\"custom-attr-value\">\n            </i>\n            \"\"\".trimIndent()\n        }\n    }\n\n    @Test\n    fun contextListAttributeTest() {\n        val writer = createWriter()\n\n        BodyContext(writer).i(attrs = listOf(\"custom-attr\" to \"custom-attr-value\"), id = \"test-id\", classes = \"test-class\")\n\n        writer assertEquals {\n            \"\"\"\n            <i id=\"test-id\" class=\"test-class\" custom-attr=\"custom-attr-value\">\n            </i>\n            \"\"\".trimIndent()\n        }\n    }\n\n    private fun createWriter(): StringBuilderHtmlWriter {\n        return StringBuilderHtmlWriter(options = WriteOptions(indent = \"    \"))\n    }\n\n    private infix fun StringBuilderHtmlWriter.assertEquals(expected: () -> String) {\n        kotlin.test.assertEquals(expected(), this.toString())\n    }\n}\n", "completion": "{\n    \"programming_language\": \"Kotlin\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": null,\n        \"component_code\": \"package dev.scottpierce.html.element\",\n        \"component_description\": \"Declares the package name for the Kotlin file, which is 'dev.scottpierce.html.element'.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import dev.scottpierce.html.write.StringBuilderHtmlWriter\",\n        \"component_description\": \"Imports the StringBuilderHtmlWriter class from the 'dev.scottpierce.html.write' package.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import dev.scottpierce.html.write.WriteOptions\",\n        \"component_description\": \"Imports the WriteOptions class from the 'dev.scottpierce.html.write' package, used to configure options for HTML writing.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import kotlin.test.Test\",\n        \"component_description\": \"Imports the Test annotation from the 'kotlin.test' package, used to mark test functions.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"ITest\",\n        \"component_code\": \"class ITest { ... }\",\n        \"component_description\": \"Defines a class named 'ITest', which contains several test methods for verifying HTML generation functionality.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"writerNoCustomAttributeTest\",\n        \"component_code\": \"@Test\\nfun writerNoCustomAttributeTest() { ... }\",\n        \"component_description\": \"A test function that verifies the generation of an <i> HTML element with no custom attributes using a StringBuilderHtmlWriter.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"writerVarArgAttributeTest\",\n        \"component_code\": \"@Test\\nfun writerVarArgAttributeTest() { ... }\",\n        \"component_description\": \"A test function that verifies the generation of an <i> HTML element with vararg attributes using a StringBuilderHtmlWriter.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"writerListAttributeTest\",\n        \"component_code\": \"@Test\\nfun writerListAttributeTest() { ... }\",\n        \"component_description\": \"A test function that verifies the generation of an <i> HTML element with a list of attributes using a StringBuilderHtmlWriter.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"contextNoCustomAttributeTest\",\n        \"component_code\": \"@Test\\nfun contextNoCustomAttributeTest() { ... }\",\n        \"component_description\": \"A test function that verifies the generation of an <i> HTML element with no custom attributes using a BodyContext and StringBuilderHtmlWriter.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"contextVarArgAttributeTest\",\n        \"component_code\": \"@Test\\nfun contextVarArgAttributeTest() { ... }\",\n        \"component_description\": \"A test function that verifies the generation of an <i> HTML element with vararg attributes using a BodyContext and StringBuilderHtmlWriter.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"contextListAttributeTest\",\n        \"component_code\": \"@Test\\nfun contextListAttributeTest() { ... }\",\n        \"component_description\": \"A test function that verifies the generation of an <i> HTML element with a list of attributes using a BodyContext and StringBuilderHtmlWriter.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"createWriter\",\n        \"component_code\": \"private fun createWriter(): StringBuilderHtmlWriter { ... }\",\n        \"component_description\": \"A private function that creates and returns an instance of StringBuilderHtmlWriter with specified WriteOptions, used to generate HTML content.\"\n      },\n      {\n        \"component_type\": \"EXTENSION_FUNCTION\",\n        \"component_name\": \"assertEquals\",\n        \"component_code\": \"private infix fun StringBuilderHtmlWriter.assertEquals(expected: () -> String) { ... }\",\n        \"component_description\": \"An extension function for StringBuilderHtmlWriter that asserts the equality of the writer's content with an expected string, using Kotlin's infix function feature.\"\n      }\n    ],\n    \"overall_description\": \"The provided Kotlin code defines a test class named 'ITest' that verifies the functionality of generating <i> HTML elements with various attributes. It uses the StringBuilderHtmlWriter and WriteOptions classes from the dev.scottpierce.html.write package to write HTML content. The class contains six test methods, each verifying different scenarios of attribute handling when creating an <i> element. Additionally, it includes a private function 'createWriter' for creating a configured instance of StringBuilderHtmlWriter and an extension function 'assertEquals' for asserting the correctness of generated HTML content.\"\n  }"}
