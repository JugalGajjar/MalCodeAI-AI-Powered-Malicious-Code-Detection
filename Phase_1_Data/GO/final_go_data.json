{
    "go_1": {
        "input": "/*\nCopyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage tensorflow\n\n// #include <stdlib.h>\n// #include \"tensorflow/c/c_api.h\"\n// #include \"tensorflow/c/eager/c_api.h\"\nimport \"C\"\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\n// ContextOptions contains configuration information for a session\ntype ContextOptions struct {\n\t// Config is a binary-serialized representation of the\n\t// tensorflow.ConfigProto protocol message\n\t// (https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto).\n\tConfig []byte\n\n\t// Sets the default execution mode\n\tAsync bool\n}\n\n// c converts the ContextOptions to the C API's TF_ContextOptions.\n// Caller takes ownership of returned object.\nfunc (o *ContextOptions) c() (*C.TFE_ContextOptions, error) {\n\topt := C.TFE_NewContextOptions()\n\tif o == nil {\n\t\treturn opt, nil\n\t}\n\n\tif sz := len(o.Config); sz > 0 {\n\t\tstatus := newStatus()\n\t\tcConfig := C.CBytes(o.Config)\n\t\tC.TFE_ContextOptionsSetConfig(opt, cConfig, C.size_t(sz), status.c)\n\t\tC.free(cConfig)\n\t\tif err := status.Err(); err != nil {\n\t\t\tC.TFE_DeleteContextOptions(opt)\n\t\t\treturn nil, fmt.Errorf(\"invalid ContextOptions.Config: %v\", err)\n\t\t}\n\t}\n\n\tvar async uint8\n\tif o.Async {\n\t\tasync = 1\n\t}\n\tC.TFE_ContextOptionsSetAsync(opt, C.uchar(async))\n\n\treturn opt, nil\n}\n\n// Context for executing operations eagerly.\n//\n// A Context allows operations to be executed immediately. It encapsulates\n// information such as the available devices, resource manager etc. It also\n// allows the user to configure execution using a ConfigProto, as they can\n// configure a Session when executing a Graph.\ntype Context struct {\n\tc *C.TFE_Context\n}\n\n// NewContext creates a new context for eager execution.\n// options may be nil to use the default options.\nfunc NewContext(options *ContextOptions) (*Context, error) {\n\tstatus := newStatus()\n\tcOpt, err := options.c()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer C.TFE_DeleteContextOptions(cOpt)\n\tcContext := C.TFE_NewContext(cOpt, status.c)\n\tif err := status.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := &Context{c: cContext}\n\truntime.SetFinalizer(c, (*Context).finalizer)\n\treturn c, nil\n}\n\nfunc (c *Context) finalizer() {\n\tC.TFE_DeleteContext(c.c)\n}\n\n// ListDevices returns the list of devices associated with a Context.\nfunc (c *Context) ListDevices() ([]Device, error) {\n\tstatus := newStatus()\n\tdevicesList := C.TFE_ContextListDevices(c.c, status.c)\n\tif err := status.Err(); err != nil {\n\t\treturn nil, fmt.Errorf(\"SessionListDevices() failed: %v\", err)\n\t}\n\tdefer C.TF_DeleteDeviceList(devicesList)\n\treturn deviceSliceFromDeviceList(devicesList)\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"tensorflow\",\n        \"component_code\": \"package tensorflow\",\n        \"component_description\": \"Declares the package name as 'tensorflow'.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import \\\"C\\\"\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"runtime\\\"\\n)\",\n        \"component_description\": \"Imports C for Cgo, and Go's fmt and runtime packages.\"\n      },\n      {\n        \"component_type\": \"STRUCT_DEFINITION\",\n        \"component_name\": \"ContextOptions\",\n        \"component_code\": \"type ContextOptions struct {\\n\\tConfig []byte\\n\\tAsync bool\\n}\",\n        \"component_description\": \"Defines a struct 'ContextOptions' with fields for Config (a byte slice) and Async (a boolean).\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"c\",\n        \"component_code\": \"func (o *ContextOptions) c() (*C.TFE_ContextOptions, error) { ... }\",\n        \"component_description\": \"Method 'c' converts a ContextOptions to the C API's TFE_ContextOptions. It handles memory allocation and configuration settings.\"\n      },\n      {\n        \"component_type\": \"STRUCT_DEFINITION\",\n        \"component_name\": \"Context\",\n        \"component_code\": \"type Context struct {\\n\\tc *C.TFE_Context\\n}\",\n        \"component_description\": \"Defines a struct 'Context' with a pointer to the C API's TFE_Context, used for eager execution of operations.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"NewContext\",\n        \"component_code\": \"func NewContext(options *ContextOptions) (*Context, error) { ... }\",\n        \"component_description\": \"Function 'NewContext' creates a new Context for eager execution. It uses the provided options to configure the context and sets up finalizers for resource cleanup.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"finalizer\",\n        \"component_code\": \"func (c *Context) finalizer() { ... }\",\n        \"component_description\": \"Method 'finalizer' is called by the garbage collector to clean up the C API's TFE_Context associated with a Context instance.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"ListDevices\",\n        \"component_code\": \"func (c *Context) ListDevices() ([]Device, error) { ... }\",\n        \"component_description\": \"Method 'ListDevices' returns the list of devices associated with a Context. It retrieves and converts device information from the C API.\"\n      }\n    ],\n    \"overall_description\": \"The Go code defines a package 'tensorflow' for managing TensorFlow contexts and operations in eager execution mode. It includes structs for configuration (ContextOptions) and execution context (Context). The package provides methods to create and configure contexts, list devices, and manage resources such as memory and objects from the C API of TensorFlow.\"\n  }\n}"
    },
    "go_3": {
        "input": "<filename>tensorflow/go/shape_test.go\n/*\nCopyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage tensorflow\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestShape(t *testing.T) {\n\ttests := []struct {\n\t\tshape Shape\n\t\tslice []int64\n\t\tfull  bool\n\t\tstr   string\n\t}{\n\t\t{\n\t\t\tshape: ScalarShape(),\n\t\t\tslice: make([]int64, 0),\n\t\t\tfull:  true,\n\t\t\tstr:   \"[]\",\n\t\t},\n\t\t{\n\t\t\tshape: MakeShape(-1, 2, -1, 4),\n\t\t\tslice: []int64{-1, 2, -1, 4},\n\t\t\tfull:  false,\n\t\t\tstr:   \"[?, 2, ?, 4]\",\n\t\t},\n\t\t{\n\t\t\tshape: MakeShape(2, 3),\n\t\t\tslice: []int64{2, 3},\n\t\t\tfull:  true,\n\t\t\tstr:   \"[2, 3]\",\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%#v\", test.shape), func(t *testing.T) {\n\t\t\tif got, want := test.shape.NumDimensions(), len(test.slice); got != want {\n\t\t\t\tt.Errorf(\"Got %v, want %v\", got, want)\n\t\t\t}\n\t\t\tif gotSlice, err := test.shape.ToSlice(); err != nil || !reflect.DeepEqual(gotSlice, test.slice) {\n\t\t\t\tt.Errorf(\"Got (%#v, %v), want (%#v, nil)\", gotSlice, err, test.slice)\n\t\t\t}\n\t\t\tif got, want := test.shape.IsFullySpecified(), test.full; got != want {\n\t\t\t\tt.Errorf(\"Got %v, want %v\", got, want)\n\t\t\t}\n\t\t\tif got, want := test.shape.String(), test.str; got != want {\n\t\t\t\tt.Errorf(\"Got %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n\n}\n\nfunc TestZeroShape(t *testing.T) {\n\tvar s Shape\n\tif s.NumDimensions() != -1 {\n\t\tt.Error(s.NumDimensions())\n\t}\n\tif _, err := s.ToSlice(); err == nil {\n\t\tt.Error(\"ToSlice() on a Shape of unknown number of dimensions should fail\")\n\t}\n\tif s.IsFullySpecified() {\n\t\tt.Error(\"Shape of unknown number of dimensions should not be fully specified\")\n\t}\n\tif got, want := s.String(), \"?\"; got != want {\n\t\tt.Errorf(\"Got %q, want %q\", got, want)\n\t}\n\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"tensorflow\",\n        \"component_code\": \"package tensorflow\",\n        \"component_description\": \"Declares the package name as 'tensorflow', which groups related Go code together.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import (\\n\\t\\\"fmt\\\"\\n\\t\\\"reflect\\\"\\n\\t\\\"testing\\\"\\n)\",\n        \"component_description\": \"Imports the fmt, reflect, and testing packages which provide functions for formatted I/O, deep value comparisons, and automated testing, respectively.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TestShape\",\n        \"component_code\": \"func TestShape(t *testing.T) {\\n\\ttests := []struct {\\n\\t\\tshape Shape\\n\\t\\tslice []int64\\n\\t\\tfull  bool\\n\\t\\tstr   string\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tshape: ScalarShape(),\\n\\t\\t\\tslice: make([]int64, 0),\\n\\t\\t\\tfull:  true,\\n\\t\\t\\tstr:   \\\"[]\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tshape: MakeShape(-1, 2, -1, 4),\\n\\t\\t\\tslice: []int64{-1, 2, -1, 4},\\n\\t\\t\\tfull:  false,\\n\\t\\t\\tstr:   \\\"[?, 2, ?, 4]\\\",\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tshape: MakeShape(2, 3),\\n\\t\\t\\tslice: []int64{2, 3},\\n\\t\\t\\tfull:  true,\\n\\t\\t\\tstr:   \\\"[2, 3]\\\",\\n\\t\\t},\\n\\t}\\n\\tfor _, test := range tests {\\n\\t\\tt.Run(fmt.Sprintf(\\\"%#v\\\", test.shape), func(t *testing.T) {\\n\\t\\t\\tif got, want := test.shape.NumDimensions(), len(test.slice); got != want {\\n\\t\\t\\t\\tt.Errorf(\\\"Got %v, want %v\\\", got, want)\\n\\t\\t\\t}\\n\\t\\t\\tif gotSlice, err := test.shape.ToSlice(); err != nil || !reflect.DeepEqual(gotSlice, test.slice) {\\n\\t\\t\\t\\tt.Errorf(\\\"Got (%#v, %v), want (%#v, nil)\\\", gotSlice, err, test.slice)\\n\\t\\t\\t}\\n\\t\\t\\tif got, want := test.shape.IsFullySpecified(), test.full; got != want {\\n\\t\\t\\t\\tt.Errorf(\\\"Got %v, want %v\\\", got, want)\\n\\t\\t\\t}\\n\\t\\t\\tif got, want := test.shape.String(), test.str; got != want {\\n\\t\\t\\t\\tt.Errorf(\\\"Got %v, want %v\\\", got, want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\",\n        \"component_description\": \"Defines a test function TestShape which checks the behavior of the Shape type. It uses table-driven tests to verify various properties of different shapes like NumDimensions, ToSlice, IsFullySpecified, and String methods.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TestZeroShape\",\n        \"component_code\": \"func TestZeroShape(t *testing.T) {\\n\\tvar s Shape\\n\\tif s.NumDimensions() != -1 {\\n\\t\\tt.Error(s.NumDimensions())\\n\\t}\\n\\tif _, err := s.ToSlice(); err == nil {\\n\\t\\tt.Error(\\\"ToSlice() on a Shape of unknown number of dimensions should fail\\\")\\n\\t}\\n\\tif s.IsFullySpecified() {\\n\\t\\tt.Error(\\\"Shape of unknown number of dimensions should not be fully specified\\\")\\n\\t}\\n\\tif got, want := s.String(), \\\"?\\\"; got != want {\\n\\t\\tt.Errorf(\\\"Got %q, want %q\\\", got, want)\\n\\t}\\n}\",\n        \"component_description\": \"Defines a test function TestZeroShape which checks the behavior of a Shape with an unknown number of dimensions. It verifies that NumDimensions returns -1, ToSlice returns an error, IsFullySpecified returns false, and String returns '?'.\"\n      }\n    ],\n    \"overall_description\": \"This Go code file contains unit tests for the Shape type in the tensorflow package. It includes two test functions: TestShape, which uses table-driven testing to verify the behavior of various shapes, and TestZeroShape, which checks the behavior of a shape with an unknown number of dimensions. These tests ensure that the methods NumDimensions, ToSlice, IsFullySpecified, and String behave as expected for different Shape instances.\"\n  }\n}"
    },
    "go_5": {
        "input": "<gh_stars>1000+\n// Code generated by \"stringer -type attr\"; DO NOT EDIT.\n\npackage template\n\nimport \"strconv\"\n\nconst _attr_name = \"attrNoneattrScriptattrScriptTypeattrStyleattrURLattrSrcset\"\n\nvar _attr_index = [...]uint8{0, 8, 18, 32, 41, 48, 58}\n\nfunc (i attr) String() string {\n\tif i >= attr(len(_attr_index)-1) {\n\t\treturn \"attr(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n\treturn _attr_name[_attr_index[i]:_attr_index[i+1]]\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"template\",\n        \"component_code\": \"package template\",\n        \"component_description\": \"Declares the package name as 'template', which is used to group related functions and types together.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": \"strconv\",\n        \"component_code\": \"import \\\"strconv\\\"\",\n        \"component_description\": \"Imports the 'strconv' package, which provides functions for converting between strings and other data types, such as integers and booleans.\"\n      },\n      {\n        \"component_type\": \"CONSTANT_DECLARATION\",\n        \"component_name\": \"_attr_name\",\n        \"component_code\": \"const _attr_name = \\\"attrNoneattrScriptattrScriptTypeattrStyleattrURLattrSrcset\\\"\",\n        \"component_description\": \"Declares a constant string '_attr_name' containing concatenated attribute names, used for mapping attribute identifiers to their respective string representations.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"_attr_index\",\n        \"component_code\": \"var _attr_index = [...]uint8{0, 8, 18, 32, 41, 48, 58}\",\n        \"component_description\": \"Declares a variable '_attr_index' as an array of uint8 values representing the starting indices of each attribute name within the '_attr_name' string.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"String\",\n        \"component_code\": \"func (i attr) String() string {\\n\\tif i >= attr(len(_attr_index)-1) {\\n\\t\\treturn \\\"attr(\\\" + strconv.FormatInt(int64(i), 10) + \\\")\\\"\\n\\t}\\n\\treturn _attr_name[_attr_index[i]:_attr_index[i+1]]\\n}\",\n        \"component_description\": \"Defines a method 'String' for the receiver type 'attr'. It returns the string representation of an attribute based on its index. If the index is out of bounds, it returns a formatted string indicating the integer value of the attribute.\"\n      }\n    ],\n    \"overall_description\": \"This Go code snippet defines a package named 'template' that includes a method for converting an attribute identifier to its corresponding string name. It uses constants and arrays to map indices to specific attribute names. The 'String' method checks if the provided index is within bounds and returns the appropriate attribute name or a formatted integer value if out of bounds.\"\n  }\n}"
    },
    "go_6": {
        "input": "package p2\n\ntype Twoer interface {\n\tPackageTwoMeth()\n}\n\nfunc F() string               {}\nfunc G() Twoer                {}\nfunc NewError(s string) error {}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"p2\",\n        \"component_code\": \"package p2\",\n        \"component_description\": \"Declares the package name as 'p2'. All files in the same directory must have the same package declaration.\"\n      },\n      {\n        \"component_type\": \"INTERFACE_DEFINITION\",\n        \"component_name\": \"Twoer\",\n        \"component_code\": \"type Twoer interface {\\n\\tPackageTwoMeth()\\n}\",\n        \"component_description\": \"Defines an interface named 'Twoer' with a single method 'PackageTwoMeth()'. Any type that implements this method is considered to satisfy the 'Twoer' interface.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"F\",\n        \"component_code\": \"func F() string               {}\",\n        \"component_description\": \"Defines a function named 'F' that returns a string. The function body is currently empty, so it does not perform any operations and will result in a compilation error due to the missing return statement.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"G\",\n        \"component_code\": \"func G() Twoer                {}\",\n        \"component_description\": \"Defines a function named 'G' that returns a value of type 'Twoer'. The function body is currently empty, so it does not perform any operations and will result in a compilation error due to the missing return statement.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"NewError\",\n        \"component_code\": \"func NewError(s string) error {}\",\n        \"component_description\": \"Defines a function named 'NewError' that takes a single parameter 's' of type 'string' and returns an 'error'. The function body is currently empty, so it does not perform any operations and will result in a compilation error due to the missing return statement.\"\n      }\n    ],\n    \"overall_description\": \"The provided Go code snippet defines a package named 'p2', which includes an interface 'Twoer' with one method, and three functions: 'F', 'G', and 'NewError'. The function 'F' is intended to return a string, while 'G' should return a value implementing the 'Twoer' interface. The 'NewError' function is meant to create and return an error based on the input string 's'. However, all functions are incomplete as they lack proper implementations and return statements, leading to compilation errors.\"\n  }\n}"
    },
    "go_7": {
        "input": "<filename>test/varinit.go<gh_stars>1000+\n// run\n\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Test var x = x + 1 works.\n\npackage main\n\nfunc main() {\n\tvar x int = 1\n\tif x != 1 {\n\t\tprint(\"found \", x, \", expected 1\\n\")\n\t\tpanic(\"fail\")\n\t}\n\t{\n\t\tvar x int = x + 1\n\t\tif x != 2 {\n\t\t\tprint(\"found \", x, \", expected 2\\n\")\n\t\t\tpanic(\"fail\")\n\t\t}\n\t}\n\t{\n\t\tx := x + 1\n\t\tif x != 2 {\n\t\t\tprint(\"found \", x, \", expected 2\\n\")\n\t\t\tpanic(\"fail\")\n\t\t}\n\t}\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"package main\\n\",\n        \"component_description\": \"Declares the package name as 'main', which is required for standalone executable programs in Go.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"func main() {\\n\\tvar x int = 1\\n\\tif x != 1 {\\n\\t\\tprint(\\\"found \\\", x, \\\", expected 1\\\\n\\\")\\n\\t\\tpanic(\\\"fail\\\")\\n\\t}\\n\\t{\\n\\t\\tvar x int = x + 1\\n\\t\\tif x != 2 {\\n\\t\\t\\tprint(\\\"found \\\", x, \\\", expected 2\\\\n\\\")\\n\\t\\t\\tpanic(\\\"fail\\\")\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\tx := x + 1\\n\\t\\tif x != 2 {\\n\\t\\t\\tprint(\\\"found \\\", x, \\\", expected 2\\\\n\\\")\\n\\t\\t\\tpanic(\\\"fail\\\")\\n\\t\\t}\\n\\t}\\n}\",\n        \"component_description\": \"Defines the main function where the program execution begins. It tests variable initialization and scoping rules in Go.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"x\",\n        \"component_code\": \"var x int = 1\\n\",\n        \"component_description\": \"Declares a variable 'x' of type integer and initializes it with the value 1. This is in the main function scope.\"\n      },\n      {\n        \"component_type\": \"CONDITIONAL_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"if x != 1 {\\n\\tprint(\\\"found \\\", x, \\\", expected 1\\\\n\\\")\\n\\tpanic(\\\"fail\\\")\\n}\",\n        \"component_description\": \"Checks if the value of 'x' is not equal to 1. If true, it prints an error message and panics, terminating the program.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": null,\n        \"component_code\": \"{\\n\\tvar x int = x + 1\\n\\tif x != 2 {\\n\\t\\tprint(\\\"found \\\", x, \\\", expected 2\\\\n\\\")\\n\\t\\tpanic(\\\"fail\\\")\\n\\t}\\n}\",\n        \"component_description\": \"A new block scope is created where a new variable 'x' of type integer is declared and initialized with the value of the outer 'x' plus one. It then checks if this new 'x' is not equal to 2, printing an error message and panicking if true.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"x\",\n        \"component_code\": \"var x int = x + 1\\n\",\n        \"component_description\": \"Declares a new variable 'x' in the inner block scope, shadowing the outer 'x'. It is initialized with the value of the outer 'x' plus one.\"\n      },\n      {\n        \"component_type\": \"CONDITIONAL_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"if x != 2 {\\n\\tprint(\\\"found \\\", x, \\\", expected 2\\\\n\\\")\\n\\tpanic(\\\"fail\\\")\\n}\",\n        \"component_description\": \"Checks if the value of the inner 'x' is not equal to 2. If true, it prints an error message and panics, terminating the program.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": null,\n        \"component_code\": \"{\\n\\tx := x + 1\\n\\tif x != 2 {\\n\\t\\tprint(\\\"found \\\", x, \\\", expected 2\\\\n\\\")\\n\\t\\tpanic(\\\"fail\\\")\\n\\t}\\n}\",\n        \"component_description\": \"Another block scope is created where a new variable 'x' of type integer is declared using short declaration syntax and initialized with the value of the outer 'x' plus one. It then checks if this new 'x' is not equal to 2, printing an error message and panicking if true.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"x\",\n        \"component_code\": \"x := x + 1\\n\",\n        \"component_description\": \"Uses short declaration syntax to declare a new variable 'x' in the inner block scope, shadowing the outer 'x'. It is initialized with the value of the outer 'x' plus one.\"\n      },\n      {\n        \"component_type\": \"CONDITIONAL_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"if x != 2 {\\n\\tprint(\\\"found \\\", x, \\\", expected 2\\\\n\\\")\\n\\tpanic(\\\"fail\\\")\\n}\",\n        \"component_description\": \"Checks if the value of the inner 'x' is not equal to 2. If true, it prints an error message and panics, terminating the program.\"\n      }\n    ],\n    \"overall_description\": \"The Go code defines a main function that tests variable initialization and scoping rules. It first initializes a variable 'x' with the value 1 in the main function scope. It then checks if this value is correct. Next, it enters two nested blocks where it re-declares 'x' using both var declaration (shadowing the outer 'x') and short declaration syntax. In each block, it checks if the newly declared 'x' has been correctly initialized to 2 by adding 1 to the previous scope's 'x'. If any check fails, it prints an error message and panics.\"\n  }\n}"
    },
    "go_8": {
        "input": "// run\n\n// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// gc used to overflow a counter when a variable was\n// mentioned 256 times, and generate stack corruption.\n\npackage main\n\nfunc main() {\n\tF(1)\n}\n\nfunc F(arg int) {\n\tvar X interface{}\n\t_ = X // used once\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0 // used 32 times\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0 // used 64 times\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0 // used 96 times\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0 // used 128 times\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0 // used 200 times\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0\n\tX = 0 // used 256 times\n\tif arg != 1 {\n\t\tpanic(\"argument was changed\")\n\t}\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"package main\\n\",\n        \"component_description\": \"Declares the package name as 'main', which is the entry point for a Go application.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"func main() {\\n\\tF(1)\\n}\\n\",\n        \"component_description\": \"Defines the main function, which is the starting point of the program. It calls the function F with the argument 1.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"F\",\n        \"component_code\": \"func F(arg int) {\\n\\tvar X interface{}\\n\\t_ = X // used once\\n\\tX = 0\\n\\t/* ... repeated assignments to X ... */\\n\\tif arg != 1 {\\n\\t\\tpanic(\\\"argument was changed\\\")\\n\\t}\\n}\\n\",\n        \"component_description\": \"Defines a function F that takes an integer argument. It includes multiple assignments to the variable X of type interface{}. The purpose is to test if assigning to a variable more than 256 times in a single function causes any issues. Includes a conditional statement to check if the argument has been altered, and if so, it panics with an error message.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"X\",\n        \"component_code\": \"var X interface{}\\n\",\n        \"component_description\": \"Declares a variable X of type interface{} within the function F. This allows X to hold values of any data type.\"\n      },\n      {\n        \"component_type\": \"STATEMENT\",\n        \"component_name\": \"_ = X\",\n        \"component_code\": \"_ = X // used once\\n\",\n        \"component_description\": \"A blank identifier assignment to X, indicating that the value of X is intentionally unused. This line marks the first use of X in the function.\"\n      },\n      {\n        \"component_type\": \"STATEMENT\",\n        \"component_name\": \"X = 0\",\n        \"component_code\": \"X = 0\\n\",\n        \"component_description\": \"Assigns the integer value 0 to X. This assignment is repeated multiple times within the function F.\"\n      },\n      {\n        \"component_type\": \"IF_STATEMENT\",\n        \"component_name\": \"if arg != 1\",\n        \"component_code\": \"if arg != 1 {\\n\\tpanic(\\\"argument was changed\\\")\\n}\\n\",\n        \"component_description\": \"An if statement that checks whether the argument passed to the function F is not equal to 1. If true, it calls panic with a message indicating that the argument was changed.\"\n      }\n    ],\n    \"description\": \"This Go program tests whether assigning to a variable more than 256 times in a single function causes any issues. The main function calls another function F with the argument 1, and within F, the variable X is repeatedly assigned the value 0. After all assignments, there is a conditional check to ensure that the argument has not been changed.\"\n  }\n}"
    },
    "go_9": {
        "input": "// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport \"plugin\"\n\nfunc main() {\n\tp, err := plugin.Open(\"plugin.so\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tsym, err := p.Lookup(\"Foo\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tf := sym.(func() int)\n\tif f() != 42 {\n\t\tpanic(\"expected f() == 42\")\n\t}\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"package main\\n\",\n        \"component_description\": \"Declares the package name as 'main', which is the entry point of a Go application.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": \"plugin\",\n        \"component_code\": \"import \\\"plugin\\\"\\n\",\n        \"component_description\": \"Imports the 'plugin' package, which provides facilities for loading and using shared libraries that contain Go code.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"func main() {\\n\\tp, err := plugin.Open(\\\"plugin.so\\\")\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\n\\tsym, err := p.Lookup(\\\"Foo\\\")\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\tf := sym.(func() int)\\n\\tif f() != 42 {\\n\\t\\tpanic(\\\"expected f() == 42\\\")\\n\\t}\\n}\",\n        \"component_description\": \"Defines the main function, which is the entry point of the application. It attempts to load a shared library named 'plugin.so' and look up a symbol named 'Foo'. If any errors occur during this process or if the result of calling 'Foo' does not equal 42, it panics with an error message.\"\n      },\n      {\n        \"component_type\": \"ERROR_HANDLING\",\n        \"component_name\": null,\n        \"component_code\": \"if err != nil {\\n\\tpanic(err)\\n}\",\n        \"component_description\": \"Checks for errors returned by the plugin.Open function and panics if an error is present, terminating the program with a detailed error message.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"Lookup\",\n        \"component_code\": \"sym, err := p.Lookup(\\\"Foo\\\")\\nif err != nil {\\n\\tpanic(err)\\n}\",\n        \"component_description\": \"Calls the Lookup method on the plugin object 'p' to find a symbol named 'Foo'. If an error occurs during this lookup, it is handled by panicking with the error message.\"\n      },\n      {\n        \"component_type\": \"TYPE_ASSERTION\",\n        \"component_name\": null,\n        \"component_code\": \"f := sym.(func() int)\",\n        \"component_description\": \"Performs a type assertion on 'sym' to assert that it is of type func() int. This allows the symbol to be treated as a function that returns an integer.\"\n      },\n      {\n        \"component_type\": \"CONDITIONAL_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"if f() != 42 {\\n\\tpanic(\\\"expected f() == 42\\\")\\n}\",\n        \"component_description\": \"Evaluates the result of calling the function 'f'. If the result does not equal 42, it panics with an error message indicating that the expected value was not met.\"\n      }\n    ],\n    \"overall_description\": \"The Go code defines a main package and imports the plugin package to load and use shared libraries. The main function attempts to open a shared library named 'plugin.so', look up a symbol named 'Foo', and assert that it is a function returning an integer. It then calls this function and checks if its result equals 42, panicking with error messages if any step fails.\"\n  }\n}"
    },
    "go_10": {
        "input": "// compile\n\n// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This is a test case for issue 788.\n\npackage main\n\nfunc main() {\n\tvar a [1]complex64\n\n\tt := a[0]\n\t_ = real(t) // this works\n\n\t_ = real(a[0]) // this doesn't\n}\n\n// bug275.go:17: internal compiler error: subnode not addable\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"package main\\n\",\n        \"component_description\": \"Declares the package name as 'main', which is the entry point for Go programs.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"func main() {\\n\\tvar a [1]complex64\\n\\n\\tt := a[0]\\n\\t_ = real(t) // this works\\n\\n\\t_ = real(a[0]) // this doesn't\\n}\",\n        \"component_description\": \"Defines the main function, which is the entry point of the Go program. It declares an array 'a' of one element of type complex64. It then assigns the first (and only) element of 'a' to variable 't'. The real part of 't' is accessed and ignored using the blank identifier '_'. However, accessing the real part of 'a[0]' directly results in an internal compiler error.\"\n      }\n    ],\n    \"overall_description\": \"The Go code defines a simple main function that demonstrates an issue with the Go compiler. It declares an array of one complex64 element and attempts to access its real part using two different methods. While accessing the real part through an intermediary variable 't' works, directly accessing the real part of the array element results in an internal compiler error, which is indicated by a comment at the end of the code.\"\n  }\n}"
    },
    "go_11": {
        "input": "// compile\n\n// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Issue 7742: cannot use &autotmp_0001 (type *map[string]string) as type *string in function argument\n\npackage main\n\nvar (\n\tm map[string]string\n\tv string\n)\n\nfunc main() {\n\tm[v], _ = v, v\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"package main\\n\",\n        \"component_description\": \"Declares the package name as 'main', which is required for standalone executable programs in Go.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"m\",\n        \"component_code\": \"var (\\n\\tm map[string]string\\n\\tv string\\n)\",\n        \"component_description\": \"Declares a variable 'm' as a map with keys of type string and values of type string. This is used to store key-value pairs.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"v\",\n        \"component_code\": \"var (\\n\\tm map[string]string\\n\\tv string\\n)\",\n        \"component_description\": \"Declares a variable 'v' as a string. This variable is used as both the key and value in the map 'm'.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"func main() {\\n\\tm[v], _ = v, v\\n}\",\n        \"component_description\": \"Defines the main function, which is the entry point of the Go program. It assigns the value of 'v' to the key 'v' in the map 'm'. The assignment returns two values (the second being an error which is ignored due to the underscore '_').\"\n      }\n    ],\n    \"overall_description\": \"The provided Go code declares a package named 'main' and includes two variable declarations: a map 'm' with string keys and values, and a string 'v'. The main function assigns the value of 'v' to itself as a key in the map 'm', ignoring any potential error returned by the assignment. This snippet does not handle concurrency or use any external packages.\"\n  }\n}"
    },
    "go_12": {
        "input": "// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage iface_i\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n}\n\nfunc (t *T) M() {\n}\n\n// *T implements I\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"iface_i\",\n        \"component_code\": \"package iface_i\\n\",\n        \"component_description\": \"Declares the package name as 'iface_i', which organizes the code into a single unit of distribution.\"\n      },\n      {\n        \"component_type\": \"INTERFACE_DEFINITION\",\n        \"component_name\": \"I\",\n        \"component_code\": \"type I interface {\\n\\tM()\\n}\\n\",\n        \"component_description\": \"Defines an interface type named 'I' with a single method signature 'M()' that takes no parameters and returns nothing. This interface is used to specify the behavior of types that implement it.\"\n      },\n      {\n        \"component_type\": \"STRUCT_DEFINITION\",\n        \"component_name\": \"T\",\n        \"component_code\": \"type T struct {\\n}\\n\",\n        \"component_description\": \"Defines a struct type named 'T' with no fields. This struct is intended to be used as a concrete implementation of the interface 'I'.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"M\",\n        \"component_code\": \"func (t *T) M() {\\n}\\n\",\n        \"component_description\": \"Defines a method named 'M' for the pointer receiver '*T', which is a concrete implementation of the method declared in the interface 'I'. The current implementation does nothing.\"\n      }\n    ],\n    \"overall_description\": \"The Go code defines a package named 'iface_i' that contains an interface 'I' with a single method 'M()'. A struct type 'T' is also defined, and it implements the interface 'I' by providing a concrete definition of the method 'M()' for pointer receivers of type '*T'. The current implementation of 'M()' is empty.\"\n  }\n}"
    },
    "go_13": {
        "input": "// run\n\n// Test for 6g register move bug.  The optimizer gets confused\n// about 32- vs 64-bit moves during splitContractIndex.\n\n// Issue 3918.\n\npackage main\n\nfunc main() {\n\tconst c = 0x123400005678\n\tindex, offset := splitContractIndex(c)\n\tif index != (c&0xffffffff)>>5 || offset != c+1 {\n\t\tprintln(\"BUG\", index, offset)\n\t}\n}\n\nfunc splitContractIndex(ce uint64) (index uint32, offset uint64) {\n\th := uint32(ce)\n\treturn h >> 5, ce + 1\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"package main\",\n        \"component_description\": \"Declares the package name as 'main', which is the entry point of a Go application.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"func main() {\\n\\tconst c = 0x123400005678\\n\\tindex, offset := splitContractIndex(c)\\n\\tif index != (c&0xffffffff)>>5 || offset != c+1 {\\n\\t\\tprintln(\\\"BUG\\\", index, offset)\\n\\t}\\n}\",\n        \"component_description\": \"Defines the main function, the entry point of the Go program. It initializes a constant 'c' with a specific hexadecimal value, calls 'splitContractIndex', and checks if the returned values match expected results, printing \\\"BUG\\\" along with the index and offset if they do not.\"\n      },\n      {\n        \"component_type\": \"CONSTANT_DECLARATION\",\n        \"component_name\": \"c\",\n        \"component_code\": \"const c = 0x123400005678\",\n        \"component_description\": \"Declares a constant 'c' of type uint64 with the hexadecimal value 0x123400005678, used for testing purposes.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_CALL\",\n        \"component_name\": \"splitContractIndex\",\n        \"component_code\": \"index, offset := splitContractIndex(c)\",\n        \"component_description\": \"Calls the function 'splitContractIndex' with the constant 'c' as an argument and assigns its return values to variables 'index' and 'offset'.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"index\",\n        \"component_code\": \"index, offset := splitContractIndex(c)\",\n        \"component_description\": \"Declares a variable 'index' of type uint32 to store the first return value from 'splitContractIndex'.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"offset\",\n        \"component_code\": \"index, offset := splitContractIndex(c)\",\n        \"component_description\": \"Declares a variable 'offset' of type uint64 to store the second return value from 'splitContractIndex'.\"\n      },\n      {\n        \"component_type\": \"CONDITIONAL_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"if index != (c&0xffffffff)>>5 || offset != c+1 {\\n\\t\\tprintln(\\\"BUG\\\", index, offset)\\n\\t}\",\n        \"component_description\": \"Evaluates a condition to check if 'index' or 'offset' do not match the expected values. If either condition is true, it prints \\\"BUG\\\" followed by the actual 'index' and 'offset' values.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"splitContractIndex\",\n        \"component_code\": \"func splitContractIndex(ce uint64) (index uint32, offset uint64) {\\n\\th := uint32(ce)\\n\\treturn h >> 5, ce + 1\\n}\",\n        \"component_description\": \"Defines a function 'splitContractIndex' that takes an argument 'ce' of type uint64 and returns two values: 'index' of type uint32 and 'offset' of type uint64. It performs a bitwise shift operation on the lower 32 bits of 'ce' to calculate 'index', and increments 'ce' by 1 to calculate 'offset'.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"h\",\n        \"component_code\": \"h := uint32(ce)\",\n        \"component_description\": \"Declares a variable 'h' of type uint32, initialized with the lower 32 bits of the argument 'ce'.\"\n      },\n      {\n        \"component_type\": \"RETURN_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"return h >> 5, ce + 1\",\n        \"component_description\": \"Returns two values from the function: 'index' calculated as 'h' right-shifted by 5 bits, and 'offset' calculated as 'ce' incremented by 1.\"\n      }\n    ],\n    \"overall_description\": \"The Go code is a test script designed to verify correct behavior of bit manipulation operations in the compiler. It defines a main function that initializes a constant with a specific value, calls a custom function to split this value into an index and offset, and checks if these values match expected results. If not, it prints a bug message. The 'splitContractIndex' function performs bitwise operations to derive the return values from the input argument.\"\n  }\n}"
    },
    "go_14": {
        "input": "// Test data - not compiled.\n\npackage test_package\n\nfunc init() {}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"test_package\",\n        \"component_code\": \"package test_package\\n\",\n        \"component_description\": \"Declares the package name as 'test_package'. In Go, every source file belongs to a package.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"init\",\n        \"component_code\": \"func init() {}\\n\",\n        \"component_description\": \"Defines an init function that is automatically called when the test_package package is imported. This function can be used for initialization of package-level variables or setup tasks, and it runs before the main function.\"\n      }\n    ],\n    \"overall_description\": \"The Go code defines a package named 'test_package' and includes an empty init function. The purpose of this code is to set up any necessary initializations when the package is imported into another program. However, since the init function is empty, it does not perform any specific actions at this time.\"\n  }\n}"
    },
    "go_15": {
        "input": "// compile\n\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nfunc f0() {\n\tconst x = 0;\n}\n\n\nfunc f1() {\n\tx := 0;\n\t_ = x;\n}\n\n\nfunc main() {\n\tf0();\n\tf1();\n}\n\n/*\nuetli:~/Source/go1/test/bugs gri$ 6g bug094.go && 6l bug094.6 && 6.out\nbug094.go:11: left side of := must be a name\nbad top\n.   LITERAL-I0 l(343)\nbug094.go:11: fatal error: walktype: top=3 LITERAL\nuetli:~/Source/go1/test/bugs gri$\n*/\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"package main\\n\",\n        \"component_description\": \"Declares the package name as 'main', which is the entry point for a Go application.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"f0\",\n        \"component_code\": \"func f0() {\\n\\tconst x = 0;\\n}\\n\",\n        \"component_description\": \"Defines a function named 'f0' that does not take any parameters and returns nothing. Inside the function, it declares a constant variable 'x' with a value of 0.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"f1\",\n        \"component_code\": \"func f1() {\\n\\tx := 0;\\n\\t_ = x;\\n}\\n\",\n        \"component_description\": \"Defines a function named 'f1' that does not take any parameters and returns nothing. Inside the function, it declares a variable 'x' with a value of 0 using short declaration syntax (:=). The underscore assignment '_ = x;' is used to suppress the compiler warning about the variable being declared but not used.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"func main() {\\n\\tf0();\\n\\tf1();\\n}\\n\",\n        \"component_description\": \"Defines the 'main' function, which is the entry point of the Go program. It calls two other functions: 'f0()' and 'f1()'.\"\n      }\n    ],\n    \"overall_description\": \"This Go code defines a simple main package with three functions: f0, f1, and main. The function f0 declares a constant variable x with a value of 0. The function f1 declares a local variable x with a value of 0 and uses the blank identifier to suppress the 'variable declared but not used' warning. The main function calls both f0 and f1 in sequence.\"\n  }\n}"
    },
    "go_16": {
        "input": "<reponame>Havoc-OS/androidprebuilts_go_linux-x86\n// compile\n\n// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// PR61253: gccgo incorrectly parsed the\n// `RecvStmt = ExpressionList \"=\" RecvExpr` production.\n\npackage main\n\nfunc main() {\n\tc := make(chan int)\n\tv := new(int)\n\tb := new(bool)\n\tselect {\n\tcase (*v), (*b) = <-c:\n\t}\n\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"package main\",\n        \"component_description\": \"Declares the package name as 'main', which is required for an executable Go program.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"func main() {\\n\\tc := make(chan int)\\n\\tv := new(int)\\n\\tb := new(bool)\\n\\tselect {\\n\\tcase (*v), (*b) = <-c:\\n\\t}\\n}\",\n        \"component_description\": \"Defines the 'main' function, which is the entry point of a Go application. Inside this function, a channel of integers is created using make, and two pointers to int and bool are initialized using new. The select statement waits for a value on the channel and assigns it to the dereferenced values of v and b.\"\n      },\n      {\n        \"component_type\": \"CHANNEL_DECLARATION\",\n        \"component_name\": \"c\",\n        \"component_code\": \"c := make(chan int)\",\n        \"component_description\": \"Declares and initializes a bidirectional channel 'c' that can transmit integer values. The make function is used to create the channel.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"v\",\n        \"component_code\": \"v := new(int)\",\n        \"component_description\": \"Declares a variable 'v' and assigns it the address of a newly allocated int zero value, using the new function.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"b\",\n        \"component_code\": \"b := new(bool)\",\n        \"component_description\": \"Declares a variable 'b' and assigns it the address of a newly allocated bool zero value, using the new function.\"\n      },\n      {\n        \"component_type\": \"SELECT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"select {\\n\\tcase (*v), (*b) = <-c:\\n}\",\n        \"component_description\": \"A select statement that waits for communication on one of several channels. In this case, it listens to the channel 'c' and upon receiving a value, assigns the received integer to the dereferenced value of v and attempts to assign another (possibly non-existent) value to the dereferenced value of b. However, since only one value is sent through an int channel, the second assignment will result in a runtime panic if there's no second value being received.\"\n      }\n    ],\n    \"overall_description\": \"The provided Go code defines a main package with a main function that initializes a channel and two pointers to int and bool. It uses a select statement to wait for a value from the channel, which is then assigned to the dereferenced values of the pointers. However, due to the nature of the channel being an integer type, attempting to receive more than one value will result in a panic.\"\n  }\n}"
    },
    "go_18": {
        "input": "<gh_stars>1000+\n// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage a\n\nimport (\n\t\"unsafe\"\n)\n\nfunc recurse(i int, s []byte) byte {\n\ts[0] = byte(i)\n\tif i == 0 {\n\t\treturn s[i]\n\t} else {\n\t\tvar a [1024]byte\n\t\tr := recurse(i-1, a[:])\n\t\treturn r + a[0]\n\t}\n}\n\n//go:uintptrescapes\nfunc F1(a uintptr) {\n\tvar s [16]byte\n\trecurse(4096, s[:])\n\t*(*int)(unsafe.Pointer(a)) = 42\n}\n\n//go:uintptrescapes\nfunc F2(a ...uintptr) {\n\tvar s [16]byte\n\trecurse(4096, s[:])\n\t*(*int)(unsafe.Pointer(a[0])) = 42\n}\n\ntype t struct{}\n\nfunc GetT() *t {\n\treturn &t{}\n}\n\n//go:uintptrescapes\nfunc (*t) M1(a uintptr) {\n\tvar s [16]byte\n\trecurse(4096, s[:])\n\t*(*int)(unsafe.Pointer(a)) = 42\n}\n\n//go:uintptrescapes\nfunc (*t) M2(a ...uintptr) {\n\tvar s [16]byte\n\trecurse(4096, s[:])\n\t*(*int)(unsafe.Pointer(a[0])) = 42\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"a\",\n        \"component_code\": \"package a\\n\",\n        \"component_description\": \"Declares the package name as 'a'. All files in the same directory with this declaration belong to the same package.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"import (\\n\\t\\\"unsafe\\\"\\n)\\n\",\n        \"component_description\": \"Imports the 'unsafe' package, which provides low-level pointer manipulation capabilities. This is generally used for performance optimizations and interfacing with C code.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"recurse\",\n        \"component_code\": \"func recurse(i int, s []byte) byte {\\n\\ts[0] = byte(i)\\n\\tif i == 0 {\\n\\t\\treturn s[i]\\n\\t} else {\\n\\t\\tvar a [1024]byte\\n\\t\\tr := recurse(i-1, a[:])\\n\\t\\treturn r + a[0]\\n\\t}\\n}\\n\",\n        \"component_description\": \"A recursive function that modifies the first byte of the provided byte slice 's' to the value of 'i'. It then recursively calls itself with decremented 'i' and a new 1024-byte array. The recursion stops when 'i' reaches 0, returning the initial value of 's[0]'. Otherwise, it returns the sum of the recursive call result and the first byte of the local array 'a'.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"F1\",\n        \"component_code\": \"//go:uintptrescapes\\nfunc F1(a uintptr) {\\n\\tvar s [16]byte\\n\\trecurse(4096, s[:])\\n\\t*(*int)(unsafe.Pointer(a)) = 42\\n}\\n\",\n        \"component_description\": \"Function 'F1' takes a single 'uintptr' argument. It declares a 16-byte array and calls the recursive function 'recurse' with an initial value of 4096 and a slice of the array. Using unsafe pointer manipulation, it then assigns the integer value 42 to the memory location pointed to by 'a'. The '//go:uintptrescapes' directive indicates that the function may escape uintptr arguments to the heap or to OS resources.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"F2\",\n        \"component_code\": \"//go:uintptrescapes\\nfunc F2(a ...uintptr) {\\n\\tvar s [16]byte\\n\\trecurse(4096, s[:])\\n\\t*(*int)(unsafe.Pointer(a[0])) = 42\\n}\\n\",\n        \"component_description\": \"Function 'F2' is a variadic function that takes one or more 'uintptr' arguments. It declares a 16-byte array and calls the recursive function 'recurse' with an initial value of 4096 and a slice of the array. Using unsafe pointer manipulation, it then assigns the integer value 42 to the memory location pointed to by the first element of 'a'. The '//go:uintptrescapes' directive indicates that the function may escape uintptr arguments to the heap or to OS resources.\"\n      },\n      {\n        \"component_type\": \"STRUCT_DEFINITION\",\n        \"component_name\": \"t\",\n        \"component_code\": \"type t struct{}\\n\",\n        \"component_description\": \"Defines an empty struct type named 't'.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"GetT\",\n        \"component_code\": \"func GetT() *t {\\n\\treturn &t{}\\n}\\n\",\n        \"component_description\": \"Function 'GetT' returns a pointer to an instance of struct type 't'.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"M1\",\n        \"component_code\": \"//go:uintptrescapes\\nfunc (*t) M1(a uintptr) {\\n\\tvar s [16]byte\\n\\trecurse(4096, s[:])\\n\\t*(*int)(unsafe.Pointer(a)) = 42\\n}\\n\",\n        \"component_description\": \"Method 'M1' is defined on a pointer receiver of type 't'. It takes a single 'uintptr' argument. Similar to 'F1', it declares a 16-byte array and calls the recursive function 'recurse' with an initial value of 4096 and a slice of the array. Using unsafe pointer manipulation, it then assigns the integer value 42 to the memory location pointed to by 'a'. The '//go:uintptrescapes' directive indicates that the method may escape uintptr arguments to the heap or to OS resources.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"M2\",\n        \"component_code\": \"//go:uintptrescapes\\nfunc (*t) M2(a ...uintptr) {\\n\\tvar s [16]byte\\n\\trecurse(4096, s[:])\\n\\t*(*int)(unsafe.Pointer(a[0])) = 42\\n}\\n\",\n        \"component_description\": \"Method 'M2' is defined on a pointer receiver of type 't'. It takes one or more 'uintptr' arguments. Similar to 'F2', it declares a 16-byte array and calls the recursive function 'recurse' with an initial value of 4096 and a slice of the array. Using unsafe pointer manipulation, it then assigns the integer value 42 to the memory location pointed to by the first element of 'a'. The '//go:uintptrescapes' directive indicates that the method may escape uintptr arguments to the heap or to OS resources.\"\n      }\n    ],\n    \"overall_description\": \"The provided Go code defines a package named 'main' (implied) containing various functions and methods that demonstrate the use of recursive calls, unsafe pointer manipulation, and variadic functions. The code includes a recursive function 'recurse' used by three different functions ('F1', 'F2') and two methods ('M1', 'M2') to perform operations on memory locations pointed to by uintptr arguments. These functions and methods also utilize a struct type 't'. The '//go:uintptrescapes' directive is used in the functions and methods to indicate that they may escape uintptr arguments, suggesting potential use of these pointers beyond their local scope.\"\n  }\n}"
    },
    "go_19": {
        "input": "// compile\n\n// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Issue 13821.  Compiler rejected \"bool(true)\" as not a constant.\n\npackage p\n\nconst (\n\tA = true\n\tB = bool(A)\n\tC = bool(true)\n)\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"p\",\n        \"component_code\": \"package p\",\n        \"component_description\": \"Declares the package name as 'p'. In Go, all source files in a directory together form a single package. The package 'main' is special because it defines a standalone executable program.\"\n      },\n      {\n        \"component_type\": \"CONST_DECLARATION\",\n        \"component_name\": \"A\",\n        \"component_code\": \"const (\\n\\tA = true\\n\\tB = bool(A)\\n\\tC = bool(true)\\n)\",\n        \"component_description\": \"Declares constant 'A' with the boolean value true. Constants in Go are declared using the 'const' keyword and must be assigned a compile-time constant expression.\"\n      },\n      {\n        \"component_type\": \"CONST_DECLARATION\",\n        \"component_name\": \"B\",\n        \"component_code\": \"const (\\n\\tA = true\\n\\tB = bool(A)\\n\\tC = bool(true)\\n)\",\n        \"component_description\": \"Declares constant 'B' by explicitly casting the boolean constant 'A' to a boolean type. This demonstrates that even though 'A' is already of type boolean, it can be cast to ensure its type explicitly.\"\n      },\n      {\n        \"component_type\": \"CONST_DECLARATION\",\n        \"component_name\": \"C\",\n        \"component_code\": \"const (\\n\\tA = true\\n\\tB = bool(A)\\n\\tC = bool(true)\\n)\",\n        \"component_description\": \"Declares constant 'C' with the boolean value true, explicitly casting a literal boolean value to a boolean type. This example highlights that literals can also be cast to their own types.\"\n      }\n    ],\n    \"overall_description\": \"This Go code snippet defines a package named 'p' and declares three constants: A, B, and C. All three constants are of the boolean type with values set to true. The declaration demonstrates constant casting in Go, where even though the value is already of the target type, it can be explicitly cast. This snippet also addresses an issue in the Go compiler (Issue 13821) that incorrectly rejected 'bool(true)' as not a constant expression.\"\n  }\n}"
    },
    "go_21": {
        "input": "// run\n\n// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport \"fmt\"\n\nvar s string\n\nfunc accum(args ...interface{}) {\n\ts += fmt.Sprintln(args...)\n}\n\nfunc f(){\n\tv := 0.0\n\tfor i := 0; i < 3; i++ {\n\t\tv += 0.1\n\t\tdefer accum(v)\n\t}\n}\n\nfunc main() {\n\tf()\n\tif s != \"0.30000000000000004\\n0.2\\n0.1\\n\" {\n\t\tprintln(\"BUG: defer\")\n\t\tprint(s)\n\t}\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"package main\",\n        \"component_description\": \"Declares the package name as 'main', which is the entry point for a Go application.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": \"fmt\",\n        \"component_code\": \"import \\\"fmt\\\"\",\n        \"component_description\": \"Imports the 'fmt' package, which provides formatted I/O functions similar to C's printf and scanf.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"s\",\n        \"component_code\": \"var s string\",\n        \"component_description\": \"Declares a global variable 's' of type string, which will be used to accumulate formatted strings.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"accum\",\n        \"component_code\": \"func accum(args ...interface{}) { s += fmt.Sprintln(args...) }\",\n        \"component_description\": \"Defines a variadic function 'accum' that takes any number of arguments, formats them using 'fmt.Sprintln', and appends the result to the global string variable 's'.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"f\",\n        \"component_code\": \"func f(){ v := 0.0 for i := 0; i < 3; i++ { v += 0.1 defer accum(v) } }\",\n        \"component_description\": \"Defines a function 'f' that initializes a variable 'v' to 0.0, iterates three times, incrementing 'v' by 0.1 in each iteration, and defers the execution of 'accum' with the current value of 'v'. Due to the nature of floating-point arithmetic, the values passed to 'accum' are not what one might expect.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"func main() { f() if s != \\\"0.30000000000000004\\\\n0.2\\\\n0.1\\\\n\\\" { println(\\\"BUG: defer\\\") print(s) } }\",\n        \"component_description\": \"Defines the entry point 'main' function, which calls 'f', checks if the global string 's' matches the expected output after all deferred calls to 'accum' have executed, and prints an error message if it does not.\"\n      }\n    ],\n    \"overall_description\": \"The Go program demonstrates the use of variadic functions, deferred function execution, and floating-point arithmetic precision issues. The main function calls 'f', which uses a loop to increment a floating-point variable and defers its value to be accumulated into a global string. Due to floating-point arithmetic imprecision, the actual values passed to the accumulator differ from the expected ones, leading to an output that is checked against a specific string pattern.\"\n  }\n}"
    },
    "go_22": {
        "input": "<filename>test/fixedbugs/bug407.dir/one.go<gh_stars>1000+\n// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage one\n\n// Issue 2877\ntype T struct {\n\tf func(t *T, arg int)\n\tg func(t T, arg int)\n}\n\nfunc (t *T) foo(arg int) {}\nfunc (t T) goo(arg int) {}\n\nfunc (t *T) F() { t.f = (*T).foo }\nfunc (t *T) G() { t.g = T.goo }\n\n\n\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"one\",\n        \"component_code\": \"package one\\n\",\n        \"component_description\": \"Declares the package name as 'one', which is used to group related Go source files together.\"\n      },\n      {\n        \"component_type\": \"STRUCT_DEFINITION\",\n        \"component_name\": \"T\",\n        \"component_code\": \"type T struct {\\n\\tf func(t *T, arg int)\\n\\tg func(t T, arg int)\\n}\",\n        \"component_description\": \"Defines a struct named 'T' with two fields: 'f' and 'g'. Both are function types where 'f' takes a pointer to 'T' and an integer, while 'g' takes a value of 'T' and an integer.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"foo\",\n        \"component_code\": \"func (t *T) foo(arg int) {}\",\n        \"component_description\": \"Defines a method 'foo' that is associated with the pointer receiver of type 'T'. It takes an integer argument but does not perform any operations.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"goo\",\n        \"component_code\": \"func (t T) goo(arg int) {}\",\n        \"component_description\": \"Defines a method 'goo' that is associated with the value receiver of type 'T'. It takes an integer argument but does not perform any operations.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"F\",\n        \"component_code\": \"func (t *T) F() { t.f = (*T).foo }\",\n        \"component_description\": \"Defines a method 'F' that is associated with the pointer receiver of type 'T'. It assigns the function 'foo' to the field 'f' of the struct. This binds 'foo' as the implementation for 'f' using the pointer receiver.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"G\",\n        \"component_code\": \"func (t *T) G() { t.g = T.goo }\",\n        \"component_description\": \"Defines a method 'G' that is associated with the pointer receiver of type 'T'. It assigns the function 'goo' to the field 'g' of the struct. This binds 'goo' as the implementation for 'g' using the value receiver.\"\n      }\n    ],\n    \"overall_description\": \"The Go code defines a package named 'one' containing a struct 'T' with two fields that are function types. The struct also includes two methods, 'foo' and 'goo', which do not perform any operations but are used to demonstrate method receivers in Go. Additionally, there are two more methods, 'F' and 'G', which assign the methods 'foo' and 'goo' to the respective fields of the struct 'T'. This code is likely a test case or example illustrating the use of function types and method receivers in Go.\"\n  }\n}"
    },
    "go_23": {
        "input": "<filename>test/fixedbugs/issue15071.dir/main.go\n// run\n\n// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport \"os\"\nimport \"./exp\"\n\nfunc main() {\n\t_ = exp.Exported(len(os.Args))\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"package main\",\n        \"component_description\": \"Declares the package name as 'main', which is the entry point of a Go application.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import \\\"os\\\"\",\n        \"component_description\": \"Imports the standard library package 'os' to interact with the operating system, such as accessing command-line arguments.\"\n      },\n      {\n        \"component_type\": \"IMPORT_STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"import \\\"./exp\\\"\",\n        \"component_description\": \"Imports a local package named 'exp' from the current directory. This package likely contains additional functionality used by the main program.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"func main() {\\n\\t_ = exp.Exported(len(os.Args))\\n}\",\n        \"component_description\": \"Defines the 'main' function, which is the entry point of the Go application. It calls the 'Exported' function from the imported 'exp' package, passing the number of command-line arguments as an argument. The result of this call is discarded using a blank identifier (_).\"\n      }\n    ],\n    \"overall_description\": \"The provided Go code defines a simple main function that imports two packages: 'os' for accessing operating system functionality and './exp' for additional exported functionalities. The main function calculates the number of command-line arguments passed to the program using len(os.Args) and passes this value to an 'Exported' function from the 'exp' package. The result of the function call is not used, as indicated by the blank identifier (_). This code serves as a minimal example demonstrating package imports and function calls in Go.\"\n  }\n}"
    },
    "go_24": {
        "input": "// run\n\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nfunc main() {\n\tvar len int;\t// len should not be a keyword - this doesn't compile\n\t_ = len;\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Go\",\n    \"components\": [\n      {\n        \"component_type\": \"PACKAGE_DECLARATION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"package main\\n\",\n        \"component_description\": \"Declares the package name as 'main', which is the entry point for a Go application.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"func main() {\\n\\tvar len int;\\t// len should not be a keyword - this doesn't compile\\n\\t_ = len;\\n}\",\n        \"component_description\": \"Defines the 'main' function, which is the entry point of the program. It attempts to declare a variable named 'len', but since 'len' is a built-in function in Go, this code will not compile.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"len\",\n        \"component_code\": \"var len int;\",\n        \"component_description\": \"Declares an integer variable named 'len'. This declaration fails to compile because 'len' is a reserved keyword in Go, used as a built-in function to determine the length of slices, maps, strings, etc.\"\n      },\n      {\n        \"component_type\": \"STATEMENT\",\n        \"component_name\": null,\n        \"component_code\": \"_ = len;\",\n        \"component_description\": \"Assigns the value of 'len' to the blank identifier '_', which discards the value. This line is technically valid but serves no purpose in this context due to the previous compilation error.\"\n      }\n    ],\n    \"overall_description\": \"The Go code attempts to declare a package named 'main' and define its entry point, the 'main' function. Inside the 'main' function, it tries to declare an integer variable named 'len', which conflicts with the built-in 'len' function in Go. This results in a compilation error, making the code non-functional.\"\n  }\n}"
    }
}