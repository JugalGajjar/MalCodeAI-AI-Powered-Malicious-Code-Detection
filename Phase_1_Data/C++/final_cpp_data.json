{
    "cpp_3": {
        "input": "<filename>tensorflow/c/tf_shape.cc<gh_stars>1000+\n/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/c/tf_shape.h\"\n\n#include <stdint.h>\n\n#include \"tensorflow/c/tf_shape_internal.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n\nextern \"C\" {\n\nTF_Shape* TF_NewShape() {\n  return tensorflow::wrap(new tensorflow::PartialTensorShape());\n}\n\nint TF_ShapeDims(const TF_Shape* shape) {\n  return tensorflow::unwrap(shape)->dims();\n}\n\nint64_t TF_ShapeDimSize(const TF_Shape* shape, int d) {\n  return tensorflow::unwrap(shape)->dim_size(d);\n}\n\nvoid TF_DeleteShape(TF_Shape* shape) { delete tensorflow::unwrap(shape); }\n\n}  // end extern \"C\"\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/c/tf_shape.h\\\"\",\n        \"component_description\": \"Includes the TensorFlow C API header file for tensor shapes.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <stdint.h>\",\n        \"component_description\": \"Includes the standard integer types header file, providing fixed-width integer types.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/c/tf_shape_internal.h\\\"\",\n        \"component_description\": \"Includes an internal TensorFlow C API header file for tensor shape operations.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/framework/tensor_shape.h\\\"\",\n        \"component_description\": \"Includes the core framework's tensor shape definition from TensorFlow.\"\n      },\n      {\n        \"component_type\": \"EXTERNAL_C_LINKAGE\",\n        \"component_name\": NULL,\n        \"component_code\": \"extern \\\"C\\\" { ... }\",\n        \"component_description\": \"Declares all contained functions with C linkage to ensure they can be called from C code without name mangling.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TF_NewShape\",\n        \"component_code\": \"TF_Shape* TF_NewShape() { return tensorflow::wrap(new tensorflow::PartialTensorShape()); }\",\n        \"component_description\": \"Creates a new instance of TensorFlow's PartialTensorShape and returns it wrapped as a TF_Shape pointer, facilitating memory management in C.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TF_ShapeDims\",\n        \"component_code\": \"int TF_ShapeDims(const TF_Shape* shape) { return tensorflow::unwrap(shape)->dims(); }\",\n        \"component_description\": \"Returns the number of dimensions in the given tensor shape by unwrapping the TF_Shape pointer to access the underlying PartialTensorShape object.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TF_ShapeDimSize\",\n        \"component_code\": \"int64_t TF_ShapeDimSize(const TF_Shape* shape, int d) { return tensorflow::unwrap(shape)->dim_size(d); }\",\n        \"component_description\": \"Returns the size of the specified dimension in the given tensor shape. The function unwraps the TF_Shape pointer to interact with the PartialTensorShape object.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TF_DeleteShape\",\n        \"component_code\": \"void TF_DeleteShape(TF_Shape* shape) { delete tensorflow::unwrap(shape); }\",\n        \"component_description\": \"Deletes a tensor shape by unwrapping the TF_Shape pointer to access and destroy the underlying PartialTensorShape object, managing memory appropriately.\"\n      }\n    ],\n    \"overall_description\": \"The code provides a C API for TensorFlow's tensor shapes. It includes functions to create and delete shapes, as well as to query their dimensions and sizes. The use of extern \\\"C\\\" ensures compatibility with C, and the wrap/unwrap functions manage the conversion between the C and C++ representations of tensor shapes.\"\n  }\n}"
    },
    "cpp_5": {
        "input": "/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/c/experimental/ops/gen/cpp/renderers/cpp_file_renderer.h\"\n\n#include \"tensorflow/c/experimental/ops/gen/common/view_util.h\"\n#include \"tensorflow/c/experimental/ops/gen/cpp/renderers/op_renderer.h\"\n#include \"tensorflow/c/experimental/ops/gen/cpp/views/op_view.h\"\n\nnamespace tensorflow {\nnamespace generator {\nnamespace cpp {\n\nstatic const char *copyright =\n    R\"(\n/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n)\";\n\nstatic const char *machine_generated =\n    \"// This file is MACHINE GENERATED! Do not edit.\";\n\nCppFileRenderer::CppFileRenderer(RendererContext context,\n                                 const std::vector<OpView> &ops)\n    : Renderer(context),\n      guard_(context),\n      name_space_(context),\n      includes_(context),\n      ops_(ops) {}\n\nvoid CppFileRenderer::Render() {\n  CodeLines(copyright);\n  BlankLine();\n  CodeLine(machine_generated);\n  BlankLine();\n\n  if (context_.mode == RendererContext::kHeader) {\n    guard_.Open();\n  } else {\n    includes_.SelfHeader();\n  }\n\n  includes_.Headers();\n  name_space_.Open();\n  BlankLine();\n\n  for (const OpView &op : ops_) {\n    OpRenderer(context_, op).Render();\n  }\n\n  name_space_.Close();\n  if (context_.mode == RendererContext::kHeader) {\n    guard_.Close();\n  }\n}\n\n}  // namespace cpp\n}  // namespace generator\n}  // namespace tensorflow\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/c/experimental/ops/gen/cpp/renderers/cpp_file_renderer.h\\\"\",\n        \"component_description\": \"Includes the header file for the CppFileRenderer class, which is essential for rendering C++ files from operation views.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/c/experimental/ops/gen/common/view_util.h\\\"\",\n        \"component_description\": \"Includes utility functions for handling views, which are used to represent operations in a structured way.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/c/experimental/ops/gen/cpp/renderers/op_renderer.h\\\"\",\n        \"component_description\": \"Includes the header file for the OpRenderer class, which is responsible for rendering individual operations into C++ code.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/c/experimental/ops/gen/cpp/views/op_view.h\\\"\",\n        \"component_description\": \"Includes the header file for the OpView class, which represents a view of an operation in the system.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tensorflow\",\n        \"component_code\": \"namespace tensorflow {\",\n        \"component_description\": \"Declares the 'tensorflow' namespace to encapsulate code related to TensorFlow operations and utilities.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"generator\",\n        \"component_code\": \"namespace generator {\",\n        \"component_description\": \"Declares the 'generator' namespace within 'tensorflow', which contains code for generating C++ files from operation views.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"cpp\",\n        \"component_code\": \"namespace cpp {\",\n        \"component_description\": \"Declares the 'cpp' namespace within 'generator', which specifically handles rendering operations into C++ code.\"\n      },\n      {\n        \"component_type\": \"GLOBAL_VARIABLE\",\n        \"component_name\": \"copyright\",\n        \"component_code\": \"static const char *copyright = R\\\"( ... )\\\";\",\n        \"component_description\": \"Defines a static string containing the copyright notice for the generated files, which is included at the top of each file.\"\n      },\n      {\n        \"component_type\": \"GLOBAL_VARIABLE\",\n        \"component_name\": \"machine_generated\",\n        \"component_code\": \"static const char *machine_generated = \\\"// This file is MACHINE GENERATED! Do not edit.\\\";\",\n        \"component_description\": \"Defines a static string indicating that the file was automatically generated and should not be manually edited.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"CppFileRenderer\",\n        \"component_code\": \"class CppFileRenderer : public Renderer { ... };\",\n        \"component_description\": \"Defines the CppFileRenderer class, which inherits from the Renderer class. It is responsible for rendering a complete C++ file based on a set of operation views.\"\n      },\n      {\n        \"component_type\": \"CONSTRUCTOR\",\n        \"component_name\": \"CppFileRenderer\",\n        \"component_code\": \"CppFileRenderer(RendererContext context, const std::vector<OpView> &ops);\",\n        \"component_description\": \"Constructor for the CppFileRenderer class that initializes it with a rendering context and a vector of operation views.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"Render\",\n        \"component_code\": \"void Render() { ... }\",\n        \"component_description\": \"Method to render the C++ file. It writes the copyright notice, machine-generated warning, include guards (for headers), headers, namespace opening tag, individual operations using OpRenderer, and namespace closing tag.\"\n      }\n    ],\n    \"overall_description\": \"The provided C++ code defines a component for generating C++ files from operation views in the TensorFlow project. The CppFileRenderer class handles the complete rendering process, including writing copyright notices, machine-generated warnings, include guards (for header files), headers, namespace declarations, and individual operations using the OpRenderer class. This ensures that generated files are correctly formatted and encapsulated within appropriate namespaces.\"\n  }\n}"
    },
    "cpp_7": {
        "input": "<reponame>EricRemmerswaal/tensorflow\n/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/tpu/tpu_configuration.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\nResourceMgr* GetGlobalResourceMgr() {\n  static ResourceMgr* const rmgr = new ResourceMgr();\n  return rmgr;\n}\n\n}  // namespace\n\n#if !defined(PLATFORM_GOOGLE)\n// Used only by Google-internal tests, so deliberately left empty.\nvoid MaybeInitializeTPUSystemForTests() {}\n#endif\n\nResourceMgr* GetTPUConfigResourceMgr(bool initialize_first) {\n  if (initialize_first) {\n    MaybeInitializeTPUSystemForTests();\n  }\n\n  // Put all TPU-related state in the global ResourceMgr. This includes the\n  // TpuPodState, compilation cache, etc. We don't use the TPU_SYSTEM\n  // ResourceMgr because there may be more than one TPU_SYSTEM ResourceMgr when\n  // DirectSession or isolate_session_state are used.\n  return GetGlobalResourceMgr();\n}\n\n}  // namespace tensorflow\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/tpu/tpu_configuration.h\\\"\",\n        \"component_description\": \"Includes the header file 'tpu_configuration.h' which contains declarations and definitions related to TPU configuration in TensorFlow.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tensorflow\",\n        \"component_code\": \"namespace tensorflow { ... }\",\n        \"component_description\": \"Declares a namespace named 'tensorflow', encapsulating the code within it to avoid name collisions with other parts of the program.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": NULL,\n        \"component_code\": \"namespace { ... }\",\n        \"component_description\": \"An unnamed (anonymous) namespace that limits the scope of its contents to this file, preventing linkage conflicts with other translation units.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"GetGlobalResourceMgr\",\n        \"component_code\": \"static ResourceMgr* const rmgr = new ResourceMgr();\\nreturn rmgr;\",\n        \"component_description\": \"A static function that returns a pointer to a global 'ResourceMgr' object. The object is created on the first call and persists for the lifetime of the program.\"\n      },\n      {\n        \"component_type\": \"PREPROCESSOR_DIRECTIVE\",\n        \"component_name\": \"#if !defined(PLATFORM_GOOGLE)\",\n        \"component_code\": \"#if !defined(PLATFORM_GOOGLE)\\nvoid MaybeInitializeTPUSystemForTests() {}\\n#endif\",\n        \"component_description\": \"A preprocessor directive that checks if the macro 'PLATFORM_GOOGLE' is not defined. If true, it defines an empty function 'MaybeInitializeTPUSystemForTests' used only for Google-internal tests.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"GetTPUConfigResourceMgr\",\n        \"component_code\": \"if (initialize_first) {\\n  MaybeInitializeTPUSystemForTests();\\n}\\nreturn GetGlobalResourceMgr();\",\n        \"component_description\": \"A function that optionally initializes the TPU system and returns a pointer to a global 'ResourceMgr' object. This manager holds all TPU-related state, such as TpuPodState and compilation cache.\"\n      }\n    ],\n    \"overall_description\": \"The code snippet is part of TensorFlow's implementation for managing TPU (Tensor Processing Unit) configurations. It defines utility functions within the 'tensorflow' namespace to handle resource management for TPUs. The primary function, 'GetTPUConfigResourceMgr', provides access to a global 'ResourceMgr' object that stores TPU-related state. An optional initialization step is available through 'MaybeInitializeTPUSystemForTests', which is conditionally compiled and used only in Google-internal tests.\"\n  }\n}"
    },
    "cpp_11": {
        "input": "<gh_stars>1000+\n/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/lite/schema/builtin_ops_list/generator.h\"\n\n#include <iostream>\n\n#include \"tensorflow/lite/schema/schema_generated.h\"\n\nnamespace tflite {\nnamespace builtin_ops_list {\n\nconst char kFileHeader[] = R\"(\n/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// DO NOT EDIT MANUALLY: This file is automatically generated by\n// `tensorflow/lite/schema/builtin_ops_list/generator.cc`.\n\n)\";\n\nbool IsValidInputEnumName(const std::string& name) {\n  const char* begin = name.c_str();\n  const char* ch = begin;\n  while (*ch != '\\0') {\n    // If it's not the first character, expect an underscore.\n    if (ch != begin) {\n      if (*ch != '_') {\n        return false;\n      }\n      ++ch;\n    }\n\n    // Expecting a word with upper case letters or digits, like \"CONV\",\n    // \"CONV2D\", \"2D\"...etc.\n    bool empty = true;\n    while (isupper(*ch) || isdigit(*ch)) {\n      // It's not empty if at least one character is consumed.\n      empty = false;\n      ++ch;\n    }\n    if (empty) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool GenerateHeader(std::ostream& os) {\n  auto enum_names = tflite::EnumNamesBuiltinOperator();\n\n  os << kFileHeader;\n\n  // Check if all the input enum names are valid.\n  for (auto enum_value : EnumValuesBuiltinOperator()) {\n    std::string enum_name = enum_names[enum_value];\n    if (!IsValidInputEnumName(enum_name)) {\n      std::cerr << \"Invalid input enum name: \" << enum_name << std::endl;\n      return false;\n    }\n  }\n\n  for (auto enum_value : EnumValuesBuiltinOperator()) {\n    std::string enum_name = enum_names[enum_value];\n    // Skip pseudo-opcodes that aren't real ops.\n    if (enum_name == \"CUSTOM\" ||\n        enum_name == \"PLACEHOLDER_FOR_GREATER_OP_CODES\" ||\n        enum_name == \"DELEGATE\") {\n      continue;\n    }\n    // Skip ops that aren't declared in builtin_op_kernels.h.\n    if (enum_name == \"CALL\" || enum_name == \"CONCAT_EMBEDDINGS\") {\n      continue;\n    }\n    os << \"TFLITE_OP(Register_\" << enum_name << \")\\n\";\n  }\n  return true;\n}\n\n}  // namespace builtin_ops_list\n}  // namespace tflite\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/lite/schema/builtin_ops_list/generator.h\\\"\",\n        \"component_description\": \"Includes the header file for the generator, which likely contains declarations and definitions used in this source file.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <iostream>\",\n        \"component_description\": \"Includes the standard input-output stream library, allowing the use of std::cerr for error messages.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/lite/schema/schema_generated.h\\\"\",\n        \"component_description\": \"Includes a generated header file from TensorFlow Lite's schema, which contains definitions for various data structures and functions related to the schema.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tflite\",\n        \"component_code\": \"namespace tflite { ... }\",\n        \"component_description\": \"Declares a namespace named 'tflite', which is used to encapsulate TensorFlow Lite-related code, preventing name collisions.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"builtin_ops_list\",\n        \"component_code\": \"namespace builtin_ops_list { ... }\",\n        \"component_description\": \"Declares a nested namespace named 'builtin_ops_list' within the 'tflite' namespace, specifically for handling built-in operator lists.\"\n      },\n      {\n        \"component_type\": \"GLOBAL_VARIABLE\",\n        \"component_name\": \"kFileHeader\",\n        \"component_code\": \"const char kFileHeader[] = R\\\"(...)\\\"\",\n        \"component_description\": \"A global constant character array containing the file header comment, including copyright and licensing information. It is used to prepend a standard comment block to generated files.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"IsValidInputEnumName\",\n        \"component_code\": \"bool IsValidInputEnumName(const std::string& name) { ... }\",\n        \"component_description\": \"A function that checks if a given string (representing an enum name) is valid according to specific rules: it must consist of words in uppercase letters or digits, separated by underscores. Returns true if the name is valid, false otherwise.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"GenerateHeader\",\n        \"component_code\": \"bool GenerateHeader(std::ostream& os) { ... }\",\n        \"component_description\": \"A function that generates a header file content into an output stream. It validates enum names, skips pseudo-opcodes and certain operators, and writes specific macro invocations to the output stream for valid operator names.\"\n      }\n    ],\n    \"overall_description\": \"This C++ code defines a generator within the TensorFlow Lite framework for producing header files related to built-in operator lists. It includes necessary headers, defines constants and functions within nested namespaces 'tflite::builtin_ops_list', and provides functionality to validate enum names and generate macro invocations based on valid operators, excluding certain pseudo-opcodes and specific operators.\"\n  }\n}"
    },
    "cpp_12": {
        "input": "/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/c/tf_status.h\"\n\n#include \"tensorflow/c/tf_status_internal.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/status.h\"\n\nusing ::tensorflow::Status;\nusing ::tensorflow::error::Code;\nusing ::tensorflow::errors::IOError;\n\nTF_Status* TF_NewStatus() { return new TF_Status; }\n\nvoid TF_DeleteStatus(TF_Status* s) { delete s; }\n\nvoid TF_SetStatus(TF_Status* s, TF_Code code, const char* msg) {\n  if (code == TF_OK) {\n    s->status = Status::OK();\n    return;\n  }\n  s->status = Status(static_cast<Code>(code), tensorflow::StringPiece(msg));\n}\n\nvoid TF_SetPayload(TF_Status* s, const char* key, const char* value) {\n  s->status.SetPayload(key, value);\n}\n\nvoid TF_SetStatusFromIOError(TF_Status* s, int error_code,\n                             const char* context) {\n  // TODO(mihaimaruseac): Handle windows when changing its filesystem\n  s->status = IOError(context, error_code);\n}\n\nTF_Code TF_GetCode(const TF_Status* s) {\n  return static_cast<TF_Code>(s->status.code());\n}\n\nconst char* TF_Message(const TF_Status* s) {\n  return s->status.error_message().c_str();\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/c/tf_status.h\\\"\",\n        \"component_description\": \"Includes the header file that declares the functions and types used for managing TensorFlow status objects.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/c/tf_status_internal.h\\\"\",\n        \"component_description\": \"Includes internal header file that contains declarations specific to the implementation details of TensorFlow status objects.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/platform/errors.h\\\"\",\n        \"component_description\": \"Includes a header file that provides error-handling utilities for TensorFlow, such as IO errors and other error codes.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/platform/status.h\\\"\",\n        \"component_description\": \"Includes the core status handling mechanism used by TensorFlow to manage various states of execution, such as success or failure.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": NULL,\n        \"component_code\": \"using ::tensorflow::Status;\\nusing ::tensorflow::error::Code;\\nusing ::tensorflow::errors::IOError;\",\n        \"component_description\": \"Brings in specific classes and namespaces from the TensorFlow library to avoid prefixing them with their full namespace path, making the code cleaner.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TF_NewStatus\",\n        \"component_code\": \"TF_Status* TF_NewStatus() { return new TF_Status; }\",\n        \"component_description\": \"Function to create a new TensorFlow status object. It allocates memory for a TF_Status instance and returns a pointer to it.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TF_DeleteStatus\",\n        \"component_code\": \"void TF_DeleteStatus(TF_Status* s) { delete s; }\",\n        \"component_description\": \"Function to delete a TensorFlow status object. It deallocates the memory associated with the provided TF_Status instance, preventing memory leaks.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TF_SetStatus\",\n        \"component_code\": \"void TF_SetStatus(TF_Status* s, TF_Code code, const char* msg) {\\n  if (code == TF_OK) {\\n    s->status = Status::OK();\\n    return;\\n  }\\n  s->status = Status(static_cast<Code>(code), tensorflow::StringPiece(msg));\\n}\",\n        \"component_description\": \"Function to set the status of a TensorFlow status object. It updates the TF_Status instance with a given code and message, converting the provided TF_Code to an internal Code type if necessary.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TF_SetPayload\",\n        \"component_code\": \"void TF_SetPayload(TF_Status* s, const char* key, const char* value) {\\n  s->status.SetPayload(key, value);\\n}\",\n        \"component_description\": \"Function to set a payload on the status object. It associates additional information (key-value pair) with the status, which can be used for error logging or debugging.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TF_SetStatusFromIOError\",\n        \"component_code\": \"void TF_SetStatusFromIOError(TF_Status* s, int error_code,\\n                             const char* context) {\\n  // TODO(mihaimaruseac): Handle windows when changing its filesystem\\n  s->status = IOError(context, error_code);\\n}\",\n        \"component_description\": \"Function to set the status of a TensorFlow status object based on an IO error. It sets the status to reflect an IO error with the given context and error code.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TF_GetCode\",\n        \"component_code\": \"TF_Code TF_GetCode(const TF_Status* s) {\\n  return static_cast<TF_Code>(s->status.code());\\n}\",\n        \"component_description\": \"Function to retrieve the code from a TensorFlow status object. It returns the error code, casting it from the internal Code type to the external TF_Code type.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TF_Message\",\n        \"component_code\": \"const char* TF_Message(const TF_Status* s) {\\n  return s->status.error_message().c_str();\\n}\",\n        \"component_description\": \"Function to retrieve the error message from a TensorFlow status object. It returns a C-style string containing the error message associated with the status.\"\n      }\n    ],\n    \"overall_description\": \"This C++ code snippet provides functions for creating, destroying, and manipulating TensorFlow status objects. These objects are used to handle and communicate errors or states within TensorFlow operations. The code includes functions to set and retrieve status codes, messages, and payloads, as well as to initialize and clean up status objects. It uses internal TensorFlow error handling mechanisms and types, making it integral to the operation of TensorFlow's C API.\"\n  }\n}"
    },
    "cpp_13": {
        "input": "<reponame>EricRemmerswaal/tensorflow\n/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/c/experimental/ops/nn_ops.h\"\n\n#include <pybind11/stl.h>\n\n#include <memory>\n\n#include \"absl/types/span.h\"\n#include \"pybind11/pybind11.h\"\n#include \"tensorflow/c/eager/abstract_context.h\"\n#include \"tensorflow/c/eager/abstract_tensor_handle.h\"\n#include \"tensorflow/python/lib/core/pybind11_status.h\"\n\nusing tensorflow::AbstractContext;\nusing tensorflow::AbstractTensorHandle;\n\nnamespace tensorflow {\nPYBIND11_MODULE(_nn_ops, m) {\n  m.def(\"relu\",\n        [](AbstractContext* ctx, AbstractTensorHandle* a, const char* name) {\n          int num_outputs = 1;\n          AbstractTensorHandle* output;\n          if (!name) {\n            name = \"Relu\";\n          }\n          MaybeRaiseRegisteredFromStatus(ops::Relu(ctx, a, &output, name));\n          return output;\n        });\n\n  m.def(\n      \"sparse_softmax_cross_entropy_with_logits\",\n      [](AbstractContext* ctx, AbstractTensorHandle* features,\n         AbstractTensorHandle* labels, const char* name) {\n        int num_outputs = 2;\n        AbstractTensorHandle* loss;\n        AbstractTensorHandle* backprop;\n        if (!name) {\n          name = \"SparseSoftmaxCrossEntropyWithLogits\";\n        }\n        MaybeRaiseRegisteredFromStatus(ops::SparseSoftmaxCrossEntropyWithLogits(\n            ctx, features, labels, &loss, &backprop, name));\n        return loss;  // Only return the loss vals, not the backprop.\n      });\n}\n}  // namespace tensorflow\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/c/experimental/ops/nn_ops.h\\\"\",\n        \"component_description\": \"Includes the header file for TensorFlow's Neural Network operations, providing declarations of functions and classes used in neural network computations.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <pybind11/stl.h>\",\n        \"component_description\": \"Includes the pybind11 header for STL (Standard Template Library) support, enabling conversions between Python and C++ containers.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <memory>\",\n        \"component_description\": \"Includes the memory header, providing smart pointers like std::unique_ptr or std::shared_ptr for automatic memory management.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"absl/types/span.h\\\"\",\n        \"component_description\": \"Includes the absl span header, providing a lightweight view over a contiguous sequence of objects. Used for efficient array manipulation.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"pybind11/pybind11.h\\\"\",\n        \"component_description\": \"Includes the main pybind11 header, enabling seamless interoperability between Python and C++ by exposing C++ types in Python and vice versa.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/c/eager/abstract_context.h\\\"\",\n        \"component_description\": \"Includes the header file for TensorFlow's abstract execution context, providing an interface for managing resources in eager mode.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/c/eager/abstract_tensor_handle.h\\\"\",\n        \"component_description\": \"Includes the header file for TensorFlow's abstract tensor handle, providing an interface to manage and manipulate tensors in eager mode.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/python/lib/core/pybind11_status.h\\\"\",\n        \"component_description\": \"Includes the header file for handling status codes in pybind11, providing utilities to convert TensorFlow's Status objects into Python exceptions.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_USING\",\n        \"component_name\": \"tensorflow::AbstractContext\",\n        \"component_code\": \"using tensorflow::AbstractContext;\",\n        \"component_description\": \"Brings the AbstractContext type from the tensorflow namespace into the current scope, allowing it to be used without prefixing it with 'tensorflow::'.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_USING\",\n        \"component_name\": \"tensorflow::AbstractTensorHandle\",\n        \"component_code\": \"using tensorflow::AbstractTensorHandle;\",\n        \"component_description\": \"Brings the AbstractTensorHandle type from the tensorflow namespace into the current scope, allowing it to be used without prefixing it with 'tensorflow::'.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tensorflow\",\n        \"component_code\": \"namespace tensorflow { ... }\",\n        \"component_description\": \"Declares a namespace named 'tensorflow', encapsulating all subsequent declarations within this block to prevent name clashes with other libraries.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": NULL,\n        \"component_code\": \"PYBIND11_MODULE(_nn_ops, m) { ... }\",\n        \"component_description\": \"Defines a Python module named '_nn_ops' using pybind11. This module exposes C++ functions to be used in Python, specifically neural network operations.\"\n      },\n      {\n        \"component_type\": \"LAMBDA_FUNCTION\",\n        \"component_name\": \"relu\",\n        \"component_code\": \"[](AbstractContext* ctx, AbstractTensorHandle* a, const char* name) { ... }\",\n        \"component_description\": \"A lambda function that implements the ReLU (Rectified Linear Unit) activation function. It takes an execution context and input tensor handle, applies the ReLU operation, and returns the output tensor handle.\"\n      },\n      {\n        \"component_type\": \"LAMBDA_FUNCTION\",\n        \"component_name\": \"sparse_softmax_cross_entropy_with_logits\",\n        \"component_code\": \"[](AbstractContext* ctx, AbstractTensorHandle* features, AbstractTensorHandle* labels, const char* name) { ... }\",\n        \"component_description\": \"A lambda function that computes the sparse softmax cross entropy with logits. It takes an execution context, feature tensor handle, label tensor handle, and optionally a name, then calculates the loss and backpropagation tensors, returning only the loss tensor.\"\n      }\n    ],\n    \"overall_description\": \"The C++ code defines a Python module named '_nn_ops' using pybind11, which exposes neural network operations to Python. It includes headers for TensorFlow's neural network operations, pybind11 bindings, and other necessary utilities. The module contains two functions: 'relu', which applies the ReLU activation function to an input tensor, and 'sparse_softmax_cross_entropy_with_logits', which computes the loss and backpropagation tensors for sparse softmax cross entropy.\"\n  }\n}"
    },
    "cpp_15": {
        "input": "/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/lite/profiling/platform_profiler.h\"\n\n#include <memory>\n\n#include \"tensorflow/lite/core/api/profiler.h\"\n\n#if defined(__ANDROID__)\n#include \"tensorflow/lite/profiling/atrace_profiler.h\"\n#elif defined(__APPLE__)\n#include \"TargetConditionals.h\"\n#if TARGET_OS_IOS\n#define SIGNPOST_PLATFORM_PROFILER\n#include \"tensorflow/lite/profiling/signpost_profiler.h\"\n#endif\n#endif\n\nnamespace tflite {\nnamespace profiling {\n\nstd::unique_ptr<tflite::Profiler> MaybeCreatePlatformProfiler() {\n#if defined(__ANDROID__)\n  return MaybeCreateATraceProfiler();\n#elif defined(SIGNPOST_PLATFORM_PROFILER)\n  return MaybeCreateSignpostProfiler();\n#else\n  return nullptr;\n#endif\n}\n\n}  // namespace profiling\n}  // namespace tflite\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/lite/profiling/platform_profiler.h\\\"\",\n        \"component_description\": \"Includes the header file for the platform profiler, which provides declarations necessary for creating and using a platform-specific profiler.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <memory>\",\n        \"component_description\": \"Includes the C++ standard library's memory management utilities, specifically smart pointers like unique_ptr.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/lite/core/api/profiler.h\\\"\",\n        \"component_description\": \"Includes the header file for the TensorFlow Lite profiler API, which provides the Profiler class interface and related functionalities.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/lite/profiling/atrace_profiler.h\\\"\",\n        \"component_description\": \"Includes the header file for the ATrace profiler, which provides platform-specific profiling on Android systems using Google's ATrace.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/lite/profiling/signpost_profiler.h\\\"\",\n        \"component_description\": \"Includes the header file for the Signpost profiler, which provides platform-specific profiling on iOS systems using Apple's Signposts.\"\n      },\n      {\n        \"component_type\": \"MACRO_DEFINITION\",\n        \"component_name\": \"SIGNPOST_PLATFORM_PROFILER\",\n        \"component_code\": \"#define SIGNPOST_PLATFORM_PROFILER\",\n        \"component_description\": \"Defines a macro to indicate that the platform supports signpost profiling, which is used in iOS environments.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tflite\",\n        \"component_code\": \"namespace tflite {\",\n        \"component_description\": \"Declares the 'tflite' namespace, encapsulating all TensorFlow Lite related functionalities and classes within this namespace.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"profiling\",\n        \"component_code\": \"namespace profiling {\",\n        \"component_description\": \"Declares the 'profiling' namespace within the 'tflite' namespace, specifically for encapsulating all profiling related functionalities and classes.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"MaybeCreatePlatformProfiler\",\n        \"component_code\": \"std::unique_ptr<tflite::Profiler> MaybeCreatePlatformProfiler() { ... }\",\n        \"component_description\": \"Defines a function that attempts to create a platform-specific profiler. Depending on the compilation environment (Android or iOS), it may create an ATrace profiler or a Signpost profiler respectively, otherwise returning nullptr.\"\n      }\n    ],\n    \"overall_description\": \"The provided C++ code is part of TensorFlow Lite's profiling infrastructure. It includes necessary headers and defines a function to conditionally create a platform-specific profiler based on the compilation environment. The profilers are used for performance monitoring and debugging applications that run on different platforms (Android or iOS). The use of namespaces 'tflite' and 'profiling' helps in organizing and encapsulating the related functionalities, preventing naming conflicts.\"\n  }\n}"
    },
    "cpp_17": {
        "input": "<gh_stars>1000+\n/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifdef INTEL_MKL\n\n#include \"tensorflow/core/util/mkl_util.h\"\n\nnamespace tensorflow {\n\nbool AreWeightsFrozen() {\n  static bool weights_const = false;\n  static absl::once_flag once;\n  absl::call_once(once, [&] {\n    TF_CHECK_OK(ReadBoolFromEnvVar(\"TF_ONEDNN_ASSUME_FROZEN_WEIGHTS\",\n                                   /*default_value*/ false, &weights_const));\n  });\n  return weights_const;\n}\n}  // namespace tensorflow\n#endif  // INTEL_MKL\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": \"tensorflow/core/util/mkl_util.h\",\n        \"component_code\": \"#include \\\"tensorflow/core/util/mkl_util.h\\\"\",\n        \"component_description\": \"Includes the MKL utility header file which likely contains declarations and definitions related to Intel Math Kernel Library (MKL) utilities used by TensorFlow.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tensorflow\",\n        \"component_code\": \"namespace tensorflow {\\n...\\n}\",\n        \"component_description\": \"Declares the start of the 'tensorflow' namespace, encapsulating all subsequent declarations and definitions within this scope to avoid naming conflicts with other code.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"AreWeightsFrozen\",\n        \"component_code\": \"bool AreWeightsFrozen() {\\n  static bool weights_const = false;\\n  static absl::once_flag once;\\n  absl::call_once(once, [&] {\\n    TF_CHECK_OK(ReadBoolFromEnvVar(\\\"TF_ONEDNN_ASSUME_FROZEN_WEIGHTS\\\",\\n                                   /*default_value*/ false, &weights_const));\\n  });\\n  return weights_const;\\n}\",\n        \"component_description\": \"Defines a function named AreWeightsFrozen which checks if the weights are considered frozen. It uses a static boolean variable 'weights_const' to store this state. The function ensures that the environment variable read operation is performed only once using absl::call_once with an absl::once_flag, ensuring thread safety and efficiency. If the TF_ONEDNN_ASSUME_FROZEN_WEIGHTS environment variable is set to true, it will mark weights as frozen; otherwise, they remain unfrozen by default.\"\n      }\n    ],\n    \"overall_description\": \"The provided C++ code snippet defines a utility function within the TensorFlow namespace to determine whether model weights are considered frozen based on an environment variable. It includes the necessary MKL utility header and uses Google's Abseil library features (absl::once_flag and absl::call_once) to ensure that the check is performed only once, even in a multithreaded context. The function reads from an environment variable named TF_ONEDNN_ASSUME_FROZEN_WEIGHTS to set the state of 'weights_const', which it returns.\"\n  }\n}"
    },
    "cpp_18": {
        "input": "/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/compiler/xla/python/python_ref_manager.h\"\n\n#include \"absl/container/inlined_vector.h\"\n\nnamespace xla {\n\nnamespace py = pybind11;\n\nPythonRefManager::ManagedPyObjects::ManagedPyObjects(\n    PythonRefManager* manager, absl::Span<pybind11::object> objects)\n    : manager_(manager) {\n  objects_.reserve(objects.size());\n  for (pybind11::object& object : objects) {\n    objects_.push_back(std::move(object));\n  }\n}\n\nPythonRefManager::ManagedPyObjects::~ManagedPyObjects() {\n  if (manager_ && !objects_.empty()) {\n    manager_->AddGarbage(absl::MakeSpan(objects_));\n  }\n}\n\nstd::shared_ptr<PythonRefManager::ManagedPyObjects>\nPythonRefManager::ManageReference(py::object object) {\n  return std::make_shared<ManagedPyObjects>(this,\n                                            absl::Span<py::object>(&object, 1));\n}\n\nstd::shared_ptr<PythonRefManager::ManagedPyObjects>\nPythonRefManager::ManageReferences(absl::Span<py::object> objects) {\n  return std::make_shared<ManagedPyObjects>(this, objects);\n}\n\nvoid PythonRefManager::AddGarbage(absl::Span<py::object> garbage) {\n  absl::MutexLock lock(&mu_);\n  // We want to collect arbitrary python garbage (e.g., buffers) aggressively.\n  garbage_count_.fetch_add(100, std::memory_order_relaxed);\n  for (py::object& o : garbage) {\n    python_garbage_.push_back(std::move(o));\n  }\n}\n\nvoid PythonRefManager::AddGarbage(\n    absl::Span<std::pair<PyCodeObject*, int> const> garbage) {\n  absl::MutexLock lock(&mu_);\n  // We don't care about collecting stack frame objects often. We grab a lot of\n  // tracebacks and the code objects are most likely live for the entire\n  // process.\n  garbage_count_.fetch_add(1, std::memory_order_relaxed);\n  for (const auto& o : garbage) {\n    python_garbage_.push_back(py::reinterpret_steal<py::object>(\n        reinterpret_cast<PyObject*>(o.first)));\n  }\n}\n\nvoid PythonRefManager::CollectGarbage() {\n  // TODO(phawkins): we should CHECK(PyGILState_Check());\n  std::deque<pybind11::object> garbage;\n  {\n    absl::MutexLock lock(&mu_);\n    garbage_count_ = 0;\n    garbage.swap(python_garbage_);\n  }\n  // We defer deleting garbage until the lock is released. It's possible that\n  // deleting garbage will lead to more Python garbage being added; if we held\n  // the lock we would deadlock because absl::Mutex is not reentrant.\n}\n\nPythonRefManager* GlobalPyRefManager() {\n  static PythonRefManager* static_ref_manager = new PythonRefManager();\n  return static_ref_manager;\n}\n\n}  // namespace xla\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/compiler/xla/python/python_ref_manager.h\\\"\",\n        \"component_description\": \"Includes the header file for the PythonRefManager class, which defines the interface and functionality related to managing Python references.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"absl/container/inlined_vector.h\\\"\",\n        \"component_description\": \"Includes the header file for the absl::InlinedVector container, used in the ManagedPyObjects class to store Python objects.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"xla\",\n        \"component_code\": \"namespace xla {\",\n        \"component_description\": \"Declares the 'xla' namespace, which encapsulates all the code within it, preventing name clashes with other parts of the program.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_ALIAS\",\n        \"component_name\": \"py\",\n        \"component_code\": \"namespace py = pybind11;\",\n        \"component_description\": \"Creates an alias 'py' for the 'pybind11' namespace, making it easier to reference pybind11 classes and functions.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"ManagedPyObjects\",\n        \"component_code\": \"class ManagedPyObjects {\\n  // class definition\\n}\",\n        \"component_description\": \"Defines a nested class within PythonRefManager that manages a collection of Python objects. It stores references to these objects and ensures they are properly managed by the PythonRefManager.\"\n      },\n      {\n        \"component_type\": \"CONSTRUCTOR\",\n        \"component_name\": \"ManagedPyObjects\",\n        \"component_code\": \"PythonRefManager::ManagedPyObjects::ManagedPyObjects(PythonRefManager* manager, absl::Span<pybind11::object> objects)\\n    : manager_(manager) {\\n  objects_.reserve(objects.size());\\n  for (pybind11::object& object : objects) {\\n    objects_.push_back(std::move(object));\\n  }\\n}\",\n        \"component_description\": \"Constructor for ManagedPyObjects that initializes it with a reference to its manager and a list of Python objects. It reserves space in the objects_ vector to avoid reallocations and moves each object into the vector.\"\n      },\n      {\n        \"component_type\": \"DESTRUCTOR\",\n        \"component_name\": \"~ManagedPyObjects\",\n        \"component_code\": \"PythonRefManager::ManagedPyObjects::~ManagedPyObjects() {\\n  if (manager_ && !objects_.empty()) {\\n    manager_->AddGarbage(absl::MakeSpan(objects_));\\n  }\\n}\",\n        \"component_description\": \"Destructor for ManagedPyObjects that, when the object is destroyed, checks if there are any Python objects managed by it. If so, it passes them to the manager's AddGarbage method for cleanup.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"ManageReference\",\n        \"component_code\": \"std::shared_ptr<PythonRefManager::ManagedPyObjects> PythonRefManager::ManageReference(py::object object) {\\n  return std::make_shared<ManagedPyObjects>(this, absl::Span<py::object>(&object, 1));\\n}\",\n        \"component_description\": \"A method of PythonRefManager that takes a single pybind11 object and returns a shared pointer to a new ManagedPyObjects instance managing this object. It uses std::make_shared for efficient memory allocation.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"ManageReferences\",\n        \"component_code\": \"std::shared_ptr<PythonRefManager::ManagedPyObjects> PythonRefManager::ManageReferences(absl::Span<py::object> objects) {\\n  return std::make_shared<ManagedPyObjects>(this, objects);\\n}\",\n        \"component_description\": \"A method of PythonRefManager that takes a span of pybind11 objects and returns a shared pointer to a new ManagedPyObjects instance managing these objects. It also uses std::make_shared for efficient memory allocation.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"AddGarbage\",\n        \"component_code\": \"void PythonRefManager::AddGarbage(absl::Span<pybind11::object> objects) {\\n  // method implementation\\n}\",\n        \"component_description\": \"A method of PythonRefManager that adds a list of pybind11 objects to the internal garbage list, which are then managed and eventually deleted by the manager. The actual implementation is not provided in the given code snippet.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"CollectGarbage\",\n        \"component_code\": \"void PythonRefManager::CollectGarbage() {\\n  // method implementation\\n}\",\n        \"component_description\": \"A method of PythonRefManager that handles the deletion of all managed Python objects stored in the garbage list. The actual implementation is not provided in the given code snippet, but it likely involves clearing the list and releasing references to the objects.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"GlobalPyRefManager\",\n        \"component_code\": \"PythonRefManager* GlobalPyRefManager() {\\n  static PythonRefManager* static_ref_manager = new PythonRefManager();\\n  return static_ref_manager;\\n}\",\n        \"component_description\": \"A function that provides a global instance of the PythonRefManager class. It uses a static local pointer to ensure only one instance is created, adhering to the Singleton pattern.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": NULL,\n        \"component_code\": \"}  // namespace xla\",\n        \"component_description\": \"Closes the 'xla' namespace declaration, indicating that all subsequent code is no longer part of this namespace.\"\n      }\n    ],\n    \"overall_description\": \"The provided C++ code snippet defines a PythonRefManager class within the 'xla' namespace, which manages Python references using pybind11. The manager provides methods to add and manage Python objects, ensuring they are properly deleted when no longer needed. A global instance of this manager is available through the GlobalPyRefManager function.\"\n  }\n}"
    },
    "cpp_19": {
        "input": "/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/lite/tools/verifier_internal.h\"\n\n#include \"tensorflow/lite/schema/schema_generated.h\"\n\nnamespace tflite {\nnamespace internal {\n\n// Verifies flatbuffer format of the model contents and returns the in-memory\n// model.\nconst Model* VerifyFlatBufferAndGetModel(const void* buf, size_t len) {\n  ::flatbuffers::Verifier verifier(static_cast<const uint8_t*>(buf), len);\n  if (VerifyModelBuffer(verifier)) {\n    return ::tflite::GetModel(buf);\n  } else {\n    return nullptr;\n  }\n}\n\n}  // namespace internal\n}  // namespace tflite\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/lite/tools/verifier_internal.h\\\"\",\n        \"component_description\": \"Includes the header file for internal verifier functions and definitions used by TensorFlow Lite.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/lite/schema/schema_generated.h\\\"\",\n        \"component_description\": \"Includes the generated schema header file which contains the FlatBuffer model schema for TensorFlow Lite.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tflite\",\n        \"component_code\": \"namespace tflite {\",\n        \"component_description\": \"Declares a namespace named 'tflite' to encapsulate TensorFlow Lite related code, avoiding name conflicts with other libraries.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"internal\",\n        \"component_code\": \"namespace internal {\",\n        \"component_description\": \"Declares an inner namespace named 'internal' within the 'tflite' namespace to encapsulate internal implementations and utilities.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"VerifyFlatBufferAndGetModel\",\n        \"component_code\": \"const Model* VerifyFlatBufferAndGetModel(const void* buf, size_t len) {\\n  ::flatbuffers::Verifier verifier(static_cast<const uint8_t*>(buf), len);\\n  if (VerifyModelBuffer(verifier)) {\\n    return ::tflite::GetModel(buf);\\n  } else {\\n    return nullptr;\\n  }\\n}\",\n        \"component_description\": \"Defines a function named 'VerifyFlatBufferAndGetModel' that takes a buffer and its length as arguments. It verifies the FlatBuffer format of the model contents using a flatbuffers::Verifier object. If the verification is successful, it returns the in-memory model by calling ::tflite::GetModel(buf). Otherwise, it returns nullptr.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": NULL,\n        \"component_code\": \"}  // namespace internal\",\n        \"component_description\": \"Closes the 'internal' namespace declaration.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": NULL,\n        \"component_code\": \"}  // namespace tflite\",\n        \"component_description\": \"Closes the 'tflite' namespace declaration.\"\n      }\n    ],\n    \"overall_description\": \"The C++ code defines a function within the 'tflite::internal' namespace that verifies the FlatBuffer format of TensorFlow Lite model contents and returns the in-memory representation of the model if the verification is successful. The code includes necessary header files for internal verifier functions and schema definitions, ensuring encapsulation through namespace declarations.\"\n  }\n}"
    },
    "cpp_20": {
        "input": "/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/tfrt/run_handler_thread_pool/run_handler_util.h\"\n\n#include <vector>\n\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/test.h\"\n\nnamespace tfrt {\nnamespace tf {\nnamespace {\n\nTEST(RunHandlerUtilTest, TestParamFromEnvWithDefault) {\n  std::vector<double> result = ParamFromEnvWithDefault(\n      \"RUN_HANDLER_TEST_ENV\", std::vector<double>{0, 0, 0});\n  EXPECT_EQ(result.size(), 3);\n  EXPECT_EQ(result[0], 0);\n  EXPECT_EQ(result[1], 0);\n  EXPECT_EQ(result[2], 0);\n\n  std::vector<int> result2 = ParamFromEnvWithDefault(\"RUN_HANDLER_TEST_ENV\",\n                                                     std::vector<int>{0, 0, 0});\n  EXPECT_EQ(result2.size(), 3);\n  EXPECT_EQ(result2[0], 0);\n  EXPECT_EQ(result2[1], 0);\n  EXPECT_EQ(result2[2], 0);\n\n  bool result3 =\n      ParamFromEnvBoolWithDefault(\"RUN_HANDLER_TEST_ENV_BOOL\", false);\n  EXPECT_EQ(result3, false);\n\n  // Set environment variable.\n  EXPECT_EQ(setenv(\"RUN_HANDLER_TEST_ENV\", \"1,2,3\", true), 0);\n  result = ParamFromEnvWithDefault(\"RUN_HANDLER_TEST_ENV\",\n                                   std::vector<double>{0, 0, 0});\n  EXPECT_EQ(result.size(), 3);\n  EXPECT_EQ(result[0], 1);\n  EXPECT_EQ(result[1], 2);\n  EXPECT_EQ(result[2], 3);\n  result2 = ParamFromEnvWithDefault(\"RUN_HANDLER_TEST_ENV\",\n                                    std::vector<int>{0, 0, 0});\n  EXPECT_EQ(result.size(), 3);\n  EXPECT_EQ(result2[0], 1);\n  EXPECT_EQ(result2[1], 2);\n  EXPECT_EQ(result2[2], 3);\n\n  EXPECT_EQ(setenv(\"RUN_HANDLER_TEST_ENV_BOOL\", \"true\", true), 0);\n  result3 = ParamFromEnvBoolWithDefault(\"RUN_HANDLER_TEST_ENV_BOOL\", false);\n  EXPECT_EQ(result3, true);\n}\n\n}  // namespace\n}  // namespace tf\n}  // namespace tfrt\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/tfrt/run_handler_thread_pool/run_handler_util.h\\\"\",\n        \"component_description\": \"Includes the header file containing declarations and definitions required for run handler utility functions.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <vector>\",\n        \"component_description\": \"Includes the standard library vector header, which is used to create dynamic arrays of elements.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/lib/strings/strcat.h\\\"\",\n        \"component_description\": \"Includes a string concatenation utility from TensorFlow's core library, likely for efficient string manipulations.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/platform/env.h\\\"\",\n        \"component_description\": \"Includes the environment interface header that provides platform-specific functionalities such as file system operations and environment variable handling.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/platform/logging.h\\\"\",\n        \"component_description\": \"Includes a logging utility from TensorFlow's core library, used for outputting log messages at various severity levels.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/platform/test.h\\\"\",\n        \"component_description\": \"Includes the testing framework header that provides macros and functions to write test cases in Google Test style.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tfrt\",\n        \"component_code\": \"namespace tfrt {\",\n        \"component_description\": \"Opens the 'tfrt' namespace, which likely contains components related to TensorFlow Runtime functionalities.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tf\",\n        \"component_code\": \"namespace tf {\",\n        \"component_description\": \"Nested within the 'tfrt' namespace, opens the 'tf' namespace that may contain TensorFlow-specific components or utilities.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": NULL,\n        \"component_code\": \"namespace {\",\n        \"component_description\": \"Opens an unnamed namespace to enclose internal implementations that are not intended for external use, ensuring name uniqueness and preventing linkage conflicts.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"TestParamFromEnvWithDefault\",\n        \"component_code\": \"TEST(RunHandlerUtilTest, TestParamFromEnvWithDefault) {\\n  std::vector<double> result = ParamFromEnvWithDefault(\\n      \\\"RUN_HANDLER_TEST_ENV\\\", std::vector<double>{0, 0, 0});\\n  EXPECT_EQ(result.size(), 3);\\n  EXPECT_EQ(result[0], 0);\\n  EXPECT_EQ(result[1], 0);\\n  EXPECT_EQ(result[2], 0);\\n\\n  std::vector<int> result2 = ParamFromEnvWithDefault(\\\"RUN_HANDLER_TEST_ENV\\\",\\n                                                     std::vector<int>{0, 0, 0});\\n  EXPECT_EQ(result2.size(), 3);\\n  EXPECT_EQ(result2[0], 0);\\n  EXPECT_EQ(result2[1], 0);\\n  EXPECT_EQ(result2[2], 0);\\n\\n  bool result3 =\\n      ParamFromEnvBoolWithDefault(\\\"RUN_HANDLER_TEST_ENV_BOOL\\\", false);\\n  EXPECT_EQ(result3, false);\\n\\n  // Set environment variable.\\n  EXPECT_EQ(setenv(\\\"RUN_HANDLER_TEST_ENV\\\", \\\"1,2,3\\\", true), 0);\\n  result = ParamFromEnvWithDefault(\\\"RUN_HANDLER_TEST_ENV\\\",\\n                                   std::vector<double>{0, 0, 0});\\n  EXPECT_EQ(result.size(), 3);\\n  EXPECT_EQ(result[0], 1);\\n  EXPECT_EQ(result[1], 2);\\n  EXPECT_EQ(result[2], 3);\\n  result2 = ParamFromEnvWithDefault(\\\"RUN_HANDLER_TEST_ENV\\\",\\n                                    std::vector<int>{0, 0, 0});\\n  EXPECT_EQ(result.size(), 3);\\n  EXPECT_EQ(result2[0], 1);\\n  EXPECT_EQ(result2[1], 2);\\n  EXPECT_EQ(result2[2], 3);\\n\\n  EXPECT_EQ(setenv(\\\"RUN_HANDLER_TEST_ENV_BOOL\\\", \\\"true\\\", true), 0);\\n  result3 = ParamFromEnvBoolWithDefault(\\\"RUN_HANDLER_TEST_ENV_BOOL\\\", false);\\n  EXPECT_EQ(result3, false);\\n}\",\n        \"component_description\": \"Defines a test case named 'TestParamFromEnvWithDefault' within the Google Test framework. It tests the utility functions 'ParamFromEnvWithDefault' and 'ParamFromEnvBoolWithDefault' to ensure they correctly retrieve parameters from environment variables with default fallback values. The function also sets environment variables using 'setenv' and verifies that the retrieved parameter values match the expected results.\"\n      }\n    ],\n    \"overall_description\": \"The provided C++ code is a test case designed to verify the functionality of utility functions responsible for retrieving parameters from environment variables with specified default values. It includes necessary headers for TensorFlow's core functionalities, logging, and testing, as well as standard library utilities like vector. The test case is encapsulated within nested namespaces 'tfrt' and 'tf', ensuring that it operates in a controlled scope without external name conflicts.\"\n  }\n}"
    },
    "cpp_21": {
        "input": "/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/tfrt/run_handler_thread_pool/run_handler_util.h\"\n\n#include <cmath>\n\n#include \"tensorflow/core/lib/strings/numbers.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/str_util.h\"\n\nnamespace tfrt {\nnamespace tf {\n\ndouble ParamFromEnvWithDefault(const char* var_name, double default_value) {\n  const char* val = std::getenv(var_name);\n  double num;\n  return (val && tensorflow::strings::safe_strtod(val, &num)) ? num\n                                                              : default_value;\n}\n\nstd::vector<double> ParamFromEnvWithDefault(const char* var_name,\n                                            std::vector<double> default_value) {\n  const char* val = std::getenv(var_name);\n  if (!val) {\n    return default_value;\n  }\n  std::vector<std::string> splits = tensorflow::str_util::Split(val, \",\");\n  std::vector<double> result;\n  result.reserve(splits.size());\n  for (auto& split : splits) {\n    double num;\n    if (tensorflow::strings::safe_strtod(split, &num)) {\n      result.push_back(num);\n    } else {\n      LOG(ERROR) << \"Wrong format for \" << var_name << \". Use default value.\";\n      return default_value;\n    }\n  }\n  return result;\n}\n\nstd::vector<int> ParamFromEnvWithDefault(const char* var_name,\n                                         std::vector<int> default_value) {\n  const char* val = std::getenv(var_name);\n  if (!val) {\n    return default_value;\n  }\n  std::vector<std::string> splits = tensorflow::str_util::Split(val, \",\");\n  std::vector<int> result;\n  result.reserve(splits.size());\n  for (auto& split : splits) {\n    int num;\n    if (tensorflow::strings::safe_strto32(split, &num)) {\n      result.push_back(num);\n    } else {\n      LOG(ERROR) << \"Wrong format for \" << var_name << \". Use default value.\";\n      return default_value;\n    }\n  }\n  return result;\n}\n\nbool ParamFromEnvBoolWithDefault(const char* var_name, bool default_value) {\n  const char* val = std::getenv(var_name);\n  return (val) ? tensorflow::str_util::Lowercase(val) == \"true\" : default_value;\n}\n\n}  // namespace tf\n}  // namespace tfrt\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/tfrt/run_handler_thread_pool/run_handler_util.h\\\"\",\n        \"component_description\": \"Includes the header file for the run handler utility functions.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <cmath>\",\n        \"component_description\": \"Includes the cmath library, which provides mathematical functions and constants.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/lib/strings/numbers.h\\\"\",\n        \"component_description\": \"Includes the TensorFlow strings numbers utility header for converting strings to numeric values safely.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/platform/logging.h\\\"\",\n        \"component_description\": \"Includes the TensorFlow logging header, which provides utilities for logging messages with different severity levels.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/platform/str_util.h\\\"\",\n        \"component_description\": \"Includes the TensorFlow string utility header for various string manipulation functions.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tfrt\",\n        \"component_code\": \"namespace tfrt {\",\n        \"component_description\": \"Declares a namespace named 'tfrt' which likely contains components related to TensorFlow Runtime functionalities.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tf\",\n        \"component_code\": \"namespace tf {\",\n        \"component_description\": \"Nested within the 'tfrt' namespace, declares a namespace named 'tf', which likely contains TensorFlow-specific components.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"ParamFromEnvWithDefault\",\n        \"component_code\": \"double ParamFromEnvWithDefault(const char* var_name, double default_value) {\\n  const char* val = std::getenv(var_name);\\n  double num;\\n  return (val && tensorflow::strings::safe_strtod(val, &num)) ? num\\n                                                              : default_value;\\n}\",\n        \"component_description\": \"Function that retrieves a double value from an environment variable. If the environment variable does not exist or cannot be converted to a double, it returns the provided default value.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"ParamFromEnvWithDefault\",\n        \"component_code\": \"std::vector<double> ParamFromEnvWithDefault(const char* var_name,\\n                                            std::vector<double> default_value) {\\n  const char* val = std::getenv(var_name);\\n  if (!val) {\\n    return default_value;\\n  }\\n  std::vector<std::string> splits = tensorflow::str_util::Split(val, \\\",\\\");\\n  std::vector<double> result;\\n  result.reserve(splits.size());\\n  for (auto& split : splits) {\\n    double num;\\n    if (tensorflow::strings::safe_strtod(split, &num)) {\\n      result.push_back(num);\\n    } else {\\n      LOG(ERROR) << \\\"Wrong format for \\\" << var_name << \\\". Use default value.\\\";\\n      return default_value;\\n    }\\n  }\\n  return result;\\n}\",\n        \"component_description\": \"Function that retrieves a vector of doubles from an environment variable. The values are expected to be comma-separated. If the environment variable does not exist or any value cannot be converted, it logs an error and returns the provided default vector.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"ParamFromEnvWithDefault\",\n        \"component_code\": \"std::vector<int> ParamFromEnvWithDefault(const char* var_name,\\n                                         std::vector<int> default_value) {\\n  const char* val = std::getenv(var_name);\\n  if (!val) {\\n    return default_value;\\n  }\\n  std::vector<std::string> splits = tensorflow::str_util::Split(val, \\\",\\\");\\n  std::vector<int> result;\\n  result.reserve(splits.size());\\n  for (auto& split : splits) {\\n    int num;\\n    if (tensorflow::strings::safe_strto32(split, &num)) {\\n      result.push_back(num);\\n    } else {\\n      LOG(ERROR) << \\\"Wrong format for \\\" << var_name << \\\". Use default value.\\\";\\n      return default_value;\\n    }\\n  }\\n  return result;\\n}\",\n        \"component_description\": \"Function that retrieves a vector of integers from an environment variable. The values are expected to be comma-separated. If the environment variable does not exist or any value cannot be converted, it logs an error and returns the provided default vector.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tf\",\n        \"component_code\": \"}  // namespace tf\",\n        \"component_description\": \"Closes the 'tf' namespace declaration.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tfrt\",\n        \"component_code\": \"}  // namespace tfrt\",\n        \"component_description\": \"Closes the 'tfrt' namespace declaration.\"\n      }\n    ],\n    \"overall_description\": \"This C++ code snippet defines utility functions for retrieving configuration parameters from environment variables, with default values provided in case of missing or invalid data. The functions are encapsulated within the namespaces 'tfrt' and 'tf', indicating they are part of a larger TensorFlow Runtime system.\"\n  }\n}"
    },
    "cpp_22": {
        "input": "/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/device.h\"\n\n#include \"tensorflow/core/framework/device_factory.h\"\n#include \"tensorflow/core/framework/op_segment.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/random.h\"\n#include \"tensorflow/core/platform/types.h\"\n\nnamespace tensorflow {\n\nDevice::Device(Env* env, const DeviceAttributes& device_attributes)\n    : DeviceBase(env), device_attributes_(device_attributes) {\n  CHECK(DeviceNameUtils::ParseFullName(name(), &parsed_name_))\n      << \"Invalid device name: \" << name();\n  rmgr_ = new ResourceMgr(parsed_name_.job);\n}\n\nDevice::~Device() {\n  if (rmgr_ != nullptr) {\n    DeleteResourceMgr();\n  }\n}\n\nvoid Device::Sync(const DoneCallback& done) { done(Sync()); }\n\n// static\nDeviceAttributes Device::BuildDeviceAttributes(\n    const string& name, DeviceType device, Bytes memory_limit,\n    const DeviceLocality& locality, const string& physical_device_desc) {\n  DeviceAttributes da;\n  da.set_name(name);\n  do {\n    da.set_incarnation(random::New64());\n  } while (da.incarnation() == 0);  // This proto field must not be zero\n  da.set_device_type(device.type());\n  da.set_memory_limit(memory_limit.value());\n  *da.mutable_locality() = locality;\n  da.set_physical_device_desc(physical_device_desc);\n  da.set_xla_global_id(-1);  // Unknown / not set\n  return da;\n}\n\nbool Device::IsRemoteCallAllowed() const {\n  auto& type = parsed_name_.type;\n  if (type == \"TPU\") {\n    return true;\n  }\n  if (type == \"TPU_SYSTEM\") {\n    return true;\n  }\n  if (type == \"CPU\") {\n    return true;\n  }\n  if (type == \"GPU\") {\n    return true;\n  }\n  if (DeviceFactory::IsPluggableDevice(type)) {\n    return true;\n  }\n  return false;\n}\n\n}  // namespace tensorflow\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/framework/device.h\\\"\",\n        \"component_description\": \"Includes the header file for the Device class, defining its interface and functionality.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/framework/device_factory.h\\\"\",\n        \"component_description\": \"Includes the header file for device factory functionalities used in device creation and management.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/framework/op_segment.h\\\"\",\n        \"component_description\": \"Includes the header file for operation segment functionalities, which might be used for managing operations on devices.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/platform/errors.h\\\"\",\n        \"component_description\": \"Includes error handling utilities used throughout the code to manage and report errors.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/platform/logging.h\\\"\",\n        \"component_description\": \"Includes logging functionalities for outputting messages related to device operations and management.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/platform/random.h\\\"\",\n        \"component_description\": \"Includes random number generation utilities, used in the code for setting unique identifiers like device incarnations.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/core/platform/types.h\\\"\",\n        \"component_description\": \"Includes type definitions and aliases commonly used throughout TensorFlow's core components to ensure consistency in data types.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tensorflow\",\n        \"component_code\": \"namespace tensorflow { ... }\",\n        \"component_description\": \"Declares the 'tensorflow' namespace, encapsulating all related classes, functions, and variables within a single scope to prevent name clashes.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"Device\",\n        \"component_code\": \"class Device : public DeviceBase { ... };\",\n        \"component_description\": \"Defines the 'Device' class that inherits from 'DeviceBase', representing a computational device in TensorFlow. It manages resources and attributes of the device.\"\n      },\n      {\n        \"component_type\": \"CONSTRUCTOR\",\n        \"component_name\": \"Device\",\n        \"component_code\": \"Device(Env* env, const DeviceAttributes& device_attributes);\",\n        \"component_description\": \"Constructor for the 'Device' class that initializes a new device instance with given environment and attributes. It also parses the device name and sets up resource management.\"\n      },\n      {\n        \"component_type\": \"DESTRUCTOR\",\n        \"component_name\": \"~Device\",\n        \"component_code\": \"~Device();\",\n        \"component_description\": \"Destructor for the 'Device' class that cleans up resources by deleting the resource manager if it has been initialized, ensuring no memory leaks occur.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"Sync\",\n        \"component_code\": \"void Sync(const DoneCallback& done) { done(Sync()); }\",\n        \"component_description\": \"Defines a synchronization function that takes a callback to be executed once the device is synchronized. The actual synchronization logic is deferred to another 'Sync' method (presumably defined elsewhere).\"\n      },\n      {\n        \"component_type\": \"STATIC_FUNCTION_DEFINITION\",\n        \"component_name\": \"BuildDeviceAttributes\",\n        \"component_code\": \"static DeviceAttributes BuildDeviceAttributes(const string& name, DeviceType device, Bytes memory_limit, const DeviceLocality& locality, const string& physical_device_desc);\",\n        \"component_description\": \"A static member function that constructs and returns a 'DeviceAttributes' object with the specified parameters. It sets unique identifiers and other attributes to describe the device accurately.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"IsRemoteCallAllowed\",\n        \"component_code\": \"bool IsRemoteCallAllowed() const;\",\n        \"component_description\": \"Defines a function that checks whether remote calls are allowed for the current device type. It returns true if the device is of certain types like TPU, CPU, GPU, or any pluggable device.\"\n      }\n    ],\n    \"overall_description\": \"The provided C++ code defines the 'Device' class within TensorFlow's core framework, inheriting from 'DeviceBase'. This class manages the attributes and operations of a computational device. The constructor initializes the device with given environment settings and parses its name to set up resource management. The destructor ensures proper cleanup by deleting resources if necessary. Additional functionalities include synchronization mechanisms, building device attributes, and checking permissions for remote calls based on the device type.\"\n  }\n}"
    },
    "cpp_23": {
        "input": "/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <vector>\n\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n#include \"tensorflow/lite/delegates/gpu/cl/kernels/cl_test.h\"\n#include \"tensorflow/lite/delegates/gpu/common/operations.h\"\n#include \"tensorflow/lite/delegates/gpu/common/status.h\"\n#include \"tensorflow/lite/delegates/gpu/common/tasks/reduce_test_util.h\"\n\nnamespace tflite {\nnamespace gpu {\nnamespace cl {\nnamespace {\n\nTEST_F(OpenCLOperationTest, MeanHW) {\n  auto status = MeanHWTest(&exec_env_);\n  ASSERT_TRUE(status.ok()) << status.error_message();\n}\n\nTEST_F(OpenCLOperationTest, ReduceSumChannels) {\n  auto status = ReduceSumChannelsTest(&exec_env_);\n  ASSERT_TRUE(status.ok()) << status.error_message();\n}\n\nTEST_F(OpenCLOperationTest, ReduceProductChannels) {\n  auto status = ReduceProductChannelsTest(&exec_env_);\n  ASSERT_TRUE(status.ok()) << status.error_message();\n}\n\nTEST_F(OpenCLOperationTest, ReduceMaxChannels) {\n  auto status = ReduceMaxChannelsTest(&exec_env_);\n  ASSERT_TRUE(status.ok()) << status.error_message();\n}\n\nTEST_F(OpenCLOperationTest, ReduceMinChannels) {\n  auto status = ReduceMinChannelsTest(&exec_env_);\n  ASSERT_TRUE(status.ok()) << status.error_message();\n}\n\n}  // namespace\n}  // namespace cl\n}  // namespace gpu\n}  // namespace tflite\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <vector>\",\n        \"component_description\": \"Includes the vector header to use the std::vector container in the code.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <gmock/gmock.h>\",\n        \"component_description\": \"Includes the Google Mock framework for writing and using mock objects in tests.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include <gtest/gtest.h>\",\n        \"component_description\": \"Includes the Google Test framework for writing and running C++ tests.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/lite/delegates/gpu/cl/kernels/cl_test.h\\\"\",\n        \"component_description\": \"Includes a custom header file for OpenCL kernel testing within TensorFlow Lite GPU delegate.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/lite/delegates/gpu/common/operations.h\\\"\",\n        \"component_description\": \"Includes a header file defining common operations used in the TensorFlow Lite GPU delegate.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/lite/delegates/gpu/common/status.h\\\"\",\n        \"component_description\": \"Includes a header file for handling status and error messages in the TensorFlow Lite GPU delegate.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": NULL,\n        \"component_code\": \"#include \\\"tensorflow/lite/delegates/gpu/common/tasks/reduce_test_util.h\\\"\",\n        \"component_description\": \"Includes a header file with utility functions for reduce operation testing in the TensorFlow Lite GPU delegate.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tflite\",\n        \"component_code\": \"namespace tflite {\",\n        \"component_description\": \"Opens the 'tflite' namespace, encapsulating all code within this block under the 'tflite' namespace.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"gpu\",\n        \"component_code\": \"namespace gpu {\",\n        \"component_description\": \"Opens the 'gpu' namespace within the 'tflite' namespace, encapsulating all code within this block under the 'tflite::gpu' namespace.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"cl\",\n        \"component_code\": \"namespace cl {\",\n        \"component_description\": \"Opens the 'cl' namespace within the 'tflite::gpu' namespace, encapsulating all code within this block under the 'tflite::gpu::cl' namespace.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": NULL,\n        \"component_code\": \"namespace {\",\n        \"component_description\": \"Opens an unnamed namespace, providing internal linkage to all code within this block.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"MeanHW\",\n        \"component_code\": \"TEST_F(OpenCLOperationTest, MeanHW) {\\n  auto status = MeanHWTest(&exec_env_);\\n  ASSERT_TRUE(status.ok()) << status.error_message();\\n}\",\n        \"component_description\": \"Defines a test case for the 'MeanHW' operation using Google Test. It calls the 'MeanHWTest' function with 'exec_env_' as an argument and asserts that the returned status is okay, printing an error message if not.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"ReduceSumChannels\",\n        \"component_code\": \"TEST_F(OpenCLOperationTest, ReduceSumChannels) {\\n  auto status = ReduceSumChannelsTest(&exec_env_);\\n  ASSERT_TRUE(status.ok()) << status.error_message();\\n}\",\n        \"component_description\": \"Defines a test case for the 'ReduceSumChannels' operation using Google Test. It calls the 'ReduceSumChannelsTest' function with 'exec_env_' as an argument and asserts that the returned status is okay, printing an error message if not.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"ReduceProductChannels\",\n        \"component_code\": \"TEST_F(OpenCLOperationTest, ReduceProductChannels) {\\n  auto status = ReduceProductChannelsTest(&exec_env_);\\n  ASSERT_TRUE(status.ok()) << status.error_message();\\n}\",\n        \"component_description\": \"Defines a test case for the 'ReduceProductChannels' operation using Google Test. It calls the 'ReduceProductChannelsTest' function with 'exec_env_' as an argument and asserts that the returned status is okay, printing an error message if not.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"ReduceMaxChannels\",\n        \"component_code\": \"TEST_F(OpenCLOperationTest, ReduceMaxChannels) {\\n  auto status = ReduceMaxChannelsTest(&exec_env_);\\n  ASSERT_TRUE(status.ok()) << status.error_message();\\n}\",\n        \"component_description\": \"Defines a test case for the 'ReduceMaxChannels' operation using Google Test. It calls the 'ReduceMaxChannelsTest' function with 'exec_env_' as an argument and asserts that the returned status is okay, printing an error message if not.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"ReduceMinChannels\",\n        \"component_code\": \"TEST_F(OpenCLOperationTest, ReduceMinChannels) {\\n  auto status = ReduceMinChannelsTest(&exec_env_);\\n  ASSERT_TRUE(status.ok()) << status.error_message();\\n}\",\n        \"component_description\": \"Defines a test case for the 'ReduceMinChannels' operation using Google Test. It calls the 'ReduceMinChannelsTest' function with 'exec_env_' as an argument and asserts that the returned status is okay, printing an error message if not.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": NULL,\n        \"component_code\": \"}\",\n        \"component_description\": \"Closes the unnamed namespace.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"cl\",\n        \"component_code\": \"}\",\n        \"component_description\": \"Closes the 'cl' namespace.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"gpu\",\n        \"component_code\": \"}\",\n        \"component_description\": \"Closes the 'gpu' namespace.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tflite\",\n        \"component_code\": \"}\",\n        \"component_description\": \"Closes the 'tflite' namespace.\"\n      }\n    ],\n    \"overall_description\": \"This code snippet defines several test cases for different reduce operations (Mean, Sum, Product, Max, Min) in the context of OpenCL kernels within the TensorFlow Lite GPU delegate. It uses Google Test to structure these tests and asserts that the operations execute successfully by checking the returned status from each operation's corresponding test function.\"\n  }\n}"
    },
    "cpp_24": {
        "input": "<gh_stars>1000+\n/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/cc/saved_model/util.h\"\n\n#include <string>\n\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/protobuf/meta_graph.pb.h\"\n\nnamespace tensorflow {\nnamespace saved_model {\n\nstd::string GetWriteVersion(const SavedModel& saved_model) {\n  if (saved_model.meta_graphs_size() == 1 &&\n      saved_model.meta_graphs()[0].has_object_graph_def()) {\n    return \"2\";\n  }\n  return \"1\";\n}\n\n}  // namespace saved_model\n}  // namespace tensorflow\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"C++\",\n    \"components\": [\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": \"tensorflow/cc/saved_model/util.h\",\n        \"component_code\": \"#include \\\"tensorflow/cc/saved_model/util.h\\\"\",\n        \"component_description\": \"Includes the header file 'util.h' from TensorFlow's saved model utilities, which likely contains declarations and definitions related to utility functions for handling saved models.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": \"<string>\",\n        \"component_code\": \"#include <string>\",\n        \"component_description\": \"Includes the C++ Standard Library header 'string' which provides functionality for using the std::string class, used here to handle string operations.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": \"tensorflow/core/platform/errors.h\",\n        \"component_code\": \"#include \\\"tensorflow/core/platform/errors.h\\\"\",\n        \"component_description\": \"Includes the header file 'errors.h' from TensorFlow's core platform, which likely contains definitions and utilities for handling errors in a cross-platform manner.\"\n      },\n      {\n        \"component_type\": \"HEADER_INCLUDE\",\n        \"component_name\": \"tensorflow/core/protobuf/meta_graph.pb.h\",\n        \"component_code\": \"#include \\\"tensorflow/core/protobuf/meta_graph.pb.h\\\"\",\n        \"component_description\": \"Includes the header file 'meta_graph.pb.h' which contains the protocol buffer definitions for TensorFlow's MetaGraph, a serialized representation of a computation graph and its associated metadata.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"tensorflow\",\n        \"component_code\": \"namespace tensorflow { ... }\",\n        \"component_description\": \"Declares the 'tensorflow' namespace, which encapsulates all symbols provided by TensorFlow to avoid name collisions with other libraries and user-defined names.\"\n      },\n      {\n        \"component_type\": \"NAMESPACE_DECLARATION\",\n        \"component_name\": \"saved_model\",\n        \"component_code\": \"namespace saved_model { ... }\",\n        \"component_description\": \"Declares the 'saved_model' namespace within the 'tensorflow' namespace, which specifically encapsulates symbols related to TensorFlow's saved model functionality.\"\n      },\n      {\n        \"component_type\": \"FUNCTION_DEFINITION\",\n        \"component_name\": \"GetWriteVersion\",\n        \"component_code\": \"std::string GetWriteVersion(const SavedModel& saved_model) { ... }\",\n        \"component_description\": \"Defines a function 'GetWriteVersion' that takes a constant reference to a 'SavedModel' object and returns a string representing the write version of the model. The function checks if the size of meta_graphs in the saved model is 1 and if the first meta graph has an object graph definition, returning \\\"2\\\" in this case; otherwise, it returns \\\"1\\\".\"\n      }\n    ],\n    \"overall_description\": \"The C++ code snippet defines a utility function 'GetWriteVersion' within TensorFlow's 'tensorflow::saved_model' namespace. It includes necessary headers for string manipulation and error handling from TensorFlow's core platform and declares the namespaces to encapsulate its symbols. The function 'GetWriteVersion' determines the write version of a given SavedModel based on whether it contains a single meta graph with an object graph definition, indicating version 2, or otherwise defaults to version 1.\"\n  }\n}"
    }
}