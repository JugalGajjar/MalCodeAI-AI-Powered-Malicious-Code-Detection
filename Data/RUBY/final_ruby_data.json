{
    "ruby_2": {
        "input": "<reponame>nicchagil/spring-framework\nrequire 'erb'\nrequire 'ostruct'\nrequire 'java'\n\n# Renders an ERB template against a hashmap of variables.\ndef render(template, variables, renderingContext)\n  context = OpenStruct.new(variables).instance_eval do\n    variables.each do |k, v|\n      instance_variable_set(k, v) if k[0] == '@'\n    end\n\n    def partial(partial_name, options={})\n      new_variables = marshal_dump.merge(options[:locals] || {})\n      Java::Pavo::ERB.render(partial_name, new_variables)\n    end\n\n    binding\n  end\n  ERB.new(template).result(context);\nend",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": \"erb\",\n        \"component_code\": \"require 'erb'\",\n        \"component_description\": \"This line includes the ERB library, which is used for templating in Ruby. It allows embedding Ruby code within plain text, typically HTML.\"\n      },\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": \"ostruct\",\n        \"component_code\": \"require 'ostruct'\",\n        \"component_description\": \"This line includes the ostruct library, which provides an easy way to create simple data objects in Ruby using OpenStruct. This is used here to create a dynamic object from the hashmap of variables.\"\n      },\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": \"java\",\n        \"component_code\": \"require 'java'\",\n        \"component_description\": \"This line includes the Java integration for Ruby, allowing the use of Java classes and methods within Ruby code. This is used here to call a Java method from within an ERB template rendering context.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"render\",\n        \"component_code\": \"def render(template, variables, renderingContext)\\n  context = OpenStruct.new(variables).instance_eval do\\n    variables.each do |k, v|\\n      instance_variable_set(k, v) if k[0] == '@'\\n    end\\n\\n    def partial(partial_name, options={})\\n      new_variables = marshal_dump.merge(options[:locals] || {})\\n      Java::Pavo::ERB.render(partial_name, new_variables)\\n    end\\n\\n    binding\\n  end\\n  ERB.new(template).result(context);\\nend\",\n        \"component_description\": \"This method defines a custom rendering function for ERB templates. It takes three parameters: 'template' (the ERB template string), 'variables' (a hashmap of variables to be available in the template), and 'renderingContext' (which is not used in this code snippet). Inside the method, an OpenStruct object is created from the 'variables' hash, and each key-value pair in the hash that starts with '@' is set as an instance variable. A custom 'partial' method is defined within this context to allow rendering of partial templates with optional local variables passed through options. The binding of this modified context is then used by ERB's 'result' method to render the template string.\"\n      }\n    ],\n    \"overall_description\": \"The Ruby code defines a custom function for rendering ERB templates against a set of variables. It leverages the ERB and ostruct libraries to dynamically create an object from a hashmap of variables, allowing these variables to be used within the ERB template. The code also integrates with Java by calling a Java method to render partial templates, showcasing Ruby's cross-language capabilities. This function can be used to generate dynamic content by embedding Ruby logic within plain text templates.\"\n  }\n}"
    },
    "ruby_3": {
        "input": "<filename>lib/plugins/create/templates/aws-ruby/handler.rb\nrequire 'json'\n\ndef hello(event:, context:)\n  {\n    statusCode: 200,\n    body: {\n      message: 'Go Serverless v1.0! Your function executed successfully!',\n      input: event\n    }.to_json\n  }\nend\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'json'\",\n        \"component_description\": \"This line includes the JSON library, which is used for parsing and generating JSON data in Ruby. This is necessary for converting a Ruby hash into a JSON string.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"hello\",\n        \"component_code\": \"def hello(event:, context:)\\n  {\\n    statusCode: 200,\\n    body: {\\n      message: 'Go Serverless v1.0! Your function executed successfully!',\\n      input: event\\n    }.to_json\\n  }\\nend\",\n        \"component_description\": \"This defines a method named `hello` that takes two keyword arguments, `event` and `context`. The method returns a hash with a `statusCode` key set to 200 and a `body` key. The `body` is another hash containing a `message` string and the original `event` data. The inner hash is converted to a JSON string using the `.to_json` method from the required 'json' library.\"\n      }\n    ],\n    \"overall_description\": \"The Ruby script defines a single method named `hello`, which is intended to be used as an AWS Lambda function handler. It accepts two keyword arguments, `event` and `context`, typical in serverless functions for receiving event data and runtime information respectively. The method constructs a response hash with a status code of 200 and a JSON string body that includes a success message and the received event data.\"\n  }\n}"
    },
    "ruby_4": {
        "input": "<reponame>ajesse11x/serverless\n\n # Implement your function here.\n # The function will get the event as the first parameter with query/body properties:\n # The function should return an Hash\n\ndef main(event, context)\n    queryparams = event[\"query\"]\n    body = event[\"body\"]\n\n    {\n        :statusCode => 200,\n        :body => '{\"hello\":\"from Ruby2.4.1 function\"}'\n    }\nend",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"def main(event, context)\\n    queryparams = event[\\\"query\\\"]\\n    body = event[\\\"body\\\"]\\n\\n    {\\n        :statusCode => 200,\\n        :body => '\\\"hello\\\":\\\"from Ruby2.4.1 function\\\"'\\n    }\\nend\",\n        \"component_description\": \"Defines a method named `main` that takes two parameters, `event` and `context`. Inside the method, it extracts `queryparams` from the event hash using the key 'query' and assigns it to the local variable `queryparams`. Similarly, it extracts `body` from the event hash using the key 'body' and assigns it to the local variable `body`. The method returns a hash with a status code of 200 and a body containing a JSON string indicating a greeting message.\"\n      }\n    ],\n    \"overall_description\": \"The Ruby script defines a single method named `main` which is intended to be used as a serverless function. It accepts two parameters, `event` and `context`, though the `context` parameter is not utilized in this code snippet. The method extracts query parameters and body from the event hash but does not use them further. Instead, it constructs and returns a hash with a status code of 200 and a JSON string as its body to indicate a successful response with a greeting message.\"\n  }\n}"
    },
    "ruby_5": {
        "input": "def handler(event:, context:)\n  start = context.get_remaining_time_in_millis()\n  sleep(0.1)\n  stop = context.get_remaining_time_in_millis()\n\n  {\"start\" => start, \"stop\" => stop}\nend\n\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"handler\",\n        \"component_code\": \"def handler(event:, context:)\\n  start = context.get_remaining_time_in_millis()\\n  sleep(0.1)\\n  stop = context.get_remaining_time_in_millis()\\n\\n  {\\\"start\\\" => start, \\\"stop\\\" => stop}\\nend\",\n        \"component_description\": \"Defines a method named `handler` that takes two keyword arguments: `event` and `context`. Inside the method, it retrieves the remaining time in milliseconds from the `context` object before and after a short sleep (0.1 seconds), and returns a hash containing these start and stop times.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"start\",\n        \"component_code\": \"start = context.get_remaining_time_in_millis()\",\n        \"component_description\": \"Declares a local variable `start` and assigns it the value returned by the `get_remaining_time_in_millis` method called on the `context` object. This value represents the remaining execution time in milliseconds before the sleep.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"stop\",\n        \"component_code\": \"stop = context.get_remaining_time_in_millis()\",\n        \"component_description\": \"Declares a local variable `stop` and assigns it the value returned by the `get_remaining_time_in_millis` method called on the `context` object. This value represents the remaining execution time in milliseconds after the sleep.\"\n      },\n      {\n        \"component_type\": \"METHOD_INVOCATION\",\n        \"component_name\": \"sleep\",\n        \"component_code\": \"sleep(0.1)\",\n        \"component_description\": \"Invokes the `sleep` method with an argument of 0.1, causing the program to pause execution for 0.1 seconds.\"\n      },\n      {\n        \"component_type\": \"HASH_CREATION\",\n        \"component_name\": null,\n        \"component_code\": \"{\\\"start\\\" => start, \\\"stop\\\" => stop}\",\n        \"component_description\": \"Creates a hash with two key-value pairs: `\\\"start\\\"` maps to the value of `start`, and `\\\"stop\\\"` maps to the value of `stop`. This hash is returned as the output of the `handler` method.\"\n      }\n    ],\n    \"overall_description\": \"The Ruby code defines a method named `handler` that takes two keyword arguments, `event` and `context`. The method measures the remaining execution time in milliseconds from the `context` object before and after pausing for 0.1 seconds using the `sleep` method. It then returns a hash containing these start and stop times, which can be used to determine how much time was spent during the sleep within the context's allowed execution period.\"\n  }\n}"
    },
    "ruby_6": {
        "input": "<reponame>shalvah/serverless\nmodule MyModule\n  class MyClass\n    def self.my_class_method(event:, context:)\n      {\"source\" => \"rubyclass\"}\n    end\n  end\nend\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"MODULE_DEFINITION\",\n        \"component_name\": \"MyModule\",\n        \"component_code\": \"module MyModule\\n  class MyClass\\n    def self.my_class_method(event:, context:)\\n      {\\\"source\\\" => \\\"rubyclass\\\"}\\n    end\\n  end\\nend\",\n        \"component_description\": \"Defines a module named MyModule, which encapsulates the class definition of MyClass. Modules in Ruby are used to group related methods and constants together.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"MyClass\",\n        \"component_code\": \"class MyClass\\n    def self.my_class_method(event:, context:)\\n      {\\\"source\\\" => \\\"rubyclass\\\"}\\n    end\\n  end\",\n        \"component_description\": \"Defines a class named MyClass within the MyModule. This class includes a class method called my_class_method.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"my_class_method\",\n        \"component_code\": \"def self.my_class_method(event:, context:)\\n      {\\\"source\\\" => \\\"rubyclass\\\"}\\n    end\",\n        \"component_description\": \"Defines a class method my_class_method that takes two keyword arguments, event and context. This method returns a hash with the key 'source' and the value 'rubyclass'. The use of self before def indicates that this is a class method.\"\n      }\n    ],\n    \"overall_description\": \"The Ruby code defines a module named MyModule that contains a single class definition for MyClass. Within MyClass, there is a class method called my_class_method which accepts two keyword arguments (event and context) and returns a hash with the key 'source' and value 'rubyclass'. This setup is typical in scenarios where methods are intended to be called on the class itself rather than instances of the class.\"\n  }\n}"
    },
    "ruby_7": {
        "input": "require 'json'\n\ndef handler(event:, context:)\n  {\"statusCode\" => 200, \"body\" => {\"message\" => \"Invoked\", \"env\" => ENV.to_hash}.to_json }\nend\n\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": \"json\",\n        \"component_code\": \"require 'json'\",\n        \"component_description\": \"This line requires the JSON library, which provides methods for parsing and generating JSON data in Ruby.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"handler\",\n        \"component_code\": \"def handler(event:, context:)\\n  {\\\"statusCode\\\" => 200, \\\"body\\\" => {\\\"message\\\" => \\\"Invoked\\\", \\\"env\\\" => ENV.to_hash}.to_json }\\nend\",\n        \"component_description\": \"This method named `handler` is defined with keyword arguments `event` and `context`. It returns a hash with a `statusCode` key set to 200 and a `body` key containing a JSON string. The JSON string includes a message 'Invoked' and the current environment variables converted to a hash.\"\n      }\n    ],\n    \"overall_description\": \"The Ruby script defines a method named `handler` that is intended to be used as an AWS Lambda function handler. It requires the JSON library for handling JSON data, and the method returns an HTTP response with a status code of 200 and a JSON body containing a message indicating invocation and the current environment variables.\"\n  }\n}"
    },
    "ruby_8": {
        "input": "<reponame>shalvah/serverless\ndef handler(event:, context:)\n  {\"deadlineMs\" => context.deadline_ms}\nend\n\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"handler\",\n        \"component_code\": \"def handler(event:, context:)\\n  {\\\"deadlineMs\\\" => context.deadline_ms}\\nend\",\n        \"component_description\": \"Defines a method named `handler` that accepts two keyword arguments, `event` and `context`. The method returns a hash with a single key-value pair where the key is 'deadlineMs' and the value is obtained from calling the `deadline_ms` method on the `context` object. This method likely serves as an entry point for a serverless function in AWS Lambda or similar environments, providing a structured response based on the provided context.\"\n      }\n    ],\n    \"overall_description\": \"The Ruby code defines a single method named `handler` that is intended to be used as a handler function in a serverless environment. It takes two keyword arguments (`event` and `context`) but only utilizes the `context` object to extract a value via its `deadline_ms` method, which it then returns within a hash under the key 'deadlineMs'. This setup is typical for AWS Lambda functions where the `handler` function processes incoming events and can access execution context details like the remaining time available.\"\n  }\n}"
    },
    "ruby_10": {
        "input": "require 'redis'\n\nr = Redis.new\nr.select(9)\nr.del(\"myset\");\nr.sadd(\"myset\",(0..999).to_a)\nfreq = {}\n500.times {\n    res = r.pipelined {\n        1000.times {\n            r.srandmember(\"myset\")\n        }\n    }\n    res.each{|ele|\n        freq[ele] = 0 if freq[ele] == nil\n        freq[ele] += 1\n    }\n}\n\n# Print the frequency each element was yield to process it with gnuplot\nfreq.each{|item,count|\n    puts \"#{item} #{count}\"\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'redis'\",\n        \"component_description\": \"This line includes the Redis gem, which provides a Ruby client for interacting with a Redis database.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"r\",\n        \"component_code\": \"r = Redis.new\",\n        \"component_description\": \"A new instance of the Redis class is created and assigned to the variable 'r'. This object will be used to interact with the Redis server.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"select\",\n        \"component_code\": \"r.select(9)\",\n        \"component_description\": \"The 'select' method is called on the Redis instance 'r', selecting database number 9 for subsequent operations.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"del\",\n        \"component_code\": \"r.del(\\\"myset\\\");\",\n        \"component_description\": \"The 'del' method is called to delete the key 'myset' from the selected Redis database, ensuring it starts fresh.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"sadd\",\n        \"component_code\": \"r.sadd(\\\"myset\\\",(0..999).to_a)\",\n        \"component_description\": \"The 'sadd' method is used to add elements 0 through 999 to the Redis set named 'myset'. The range (0..999) is converted to an array before being added.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"freq\",\n        \"component_code\": \"freq = {}\",\n        \"component_description\": \"A new empty hash named 'freq' is created. This will be used to keep track of the frequency of each element being retrieved from the Redis set.\"\n      },\n      {\n        \"component_type\": \"LOOP\",\n        \"component_name\": NULL,\n        \"component_code\": \"500.times { ... }\",\n        \"component_description\": \"A loop that iterates 500 times, performing a series of operations within its block. Each iteration performs a pipelined Redis command to retrieve random members from the set.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"pipelined\",\n        \"component_code\": \"r.pipelined { ... }\",\n        \"component_description\": \"The 'pipelined' method is called on the Redis instance 'r', allowing multiple commands to be sent to the server in a single request, improving performance.\"\n      },\n      {\n        \"component_type\": \"LOOP\",\n        \"component_name\": NULL,\n        \"component_code\": \"1000.times { ... }\",\n        \"component_description\": \"A nested loop that iterates 1000 times within each of the outer loop's iterations. Each iteration calls 'srandmember' to retrieve a random element from the Redis set.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"srandmember\",\n        \"component_code\": \"r.srandmember(\\\"myset\\\")\",\n        \"component_description\": \"The 'srandmember' method is called on the Redis instance 'r', retrieving a random member from the set named 'myset'.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"{|res| ... }\",\n        \"component_description\": \"A block that processes the results of the pipelined commands. It iterates over each result, updating the frequency hash 'freq' to count occurrences of each element.\"\n      },\n      {\n        \"component_type\": \"LOOP\",\n        \"component_name\": NULL,\n        \"component_code\": \"res.each{|ele| ... }\",\n        \"component_description\": \"A loop that iterates over each element in the results array 'res', which contains the random elements retrieved from the Redis set.\"\n      },\n      {\n        \"component_type\": \"CONDITIONAL_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"freq[ele] = 0 if freq[ele] == nil\",\n        \"component_description\": \"A conditional statement that checks if the element 'ele' is already a key in the hash 'freq'. If not, it initializes its count to 0.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_ASSIGNMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"freq[ele] += 1\",\n        \"component_description\": \"The count of the element 'ele' in the hash 'freq' is incremented by 1, reflecting its frequency of occurrence.\"\n      },\n      {\n        \"component_type\": \"LOOP\",\n        \"component_name\": NULL,\n        \"component_code\": \"freq.each{|item,count| ... }\",\n        \"component_description\": \"A loop that iterates over each key-value pair in the hash 'freq', representing an element and its frequency of occurrence.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"puts\",\n        \"component_code\": \"puts \\\"#{item} #{count}\\\"\",\n        \"component_description\": \"The 'puts' method is called to print each item and its count in the format 'item count', which can be processed with gnuplot or other data analysis tools.\"\n      }\n    ],\n    \"overall_description\": \"This Ruby script interacts with a Redis database to perform set operations. It initializes a connection to the Redis server, selects a specific database, and clears an existing set named 'myset'. Then, it populates 'myset' with numbers from 0 to 999. The script performs a series of pipelined commands to retrieve random elements from 'myset', counting the frequency of each element's occurrence over 500 iterations, each containing 1000 random retrievals. Finally, it prints out the frequency data for each element, formatted for potential further processing with gnuplot or other visualization tools.\"\n  }\n}"
    },
    "ruby_11": {
        "input": "<filename>utils/srandmember/showdist.rb\nrequire 'redis'\n\nr = Redis.new\nr.select(9)\nr.del(\"myset\");\nr.sadd(\"myset\",(0..999).to_a)\nfreq = {}\n100.times {\n    res = r.pipelined {\n        1000.times {\n            r.srandmember(\"myset\")\n        }\n    }\n    res.each{|ele|\n        freq[ele] = 0 if freq[ele] == nil\n        freq[ele] += 1\n    }\n}\n\n# Convert into frequency distribution\ndist = {}\nfreq.each{|item,count|\n    dist[count] = 0 if dist[count] == nil\n    dist[count] += 1\n}\n\nmin = dist.keys.min\nmax = dist.keys.max\n(min..max).each{|x|\n    count = dist[x]\n    count = 0 if count == nil\n    puts \"#{x} -> #{\"*\"*count}\"\n}\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'redis'\",\n        \"component_description\": \"This statement includes the Redis gem, allowing the script to interact with a Redis server.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"r\",\n        \"component_code\": \"r = Redis.new\",\n        \"component_description\": \"This line creates a new instance of the Redis class, which will be used to interact with the Redis server.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"select\",\n        \"component_code\": \"r.select(9)\",\n        \"component_description\": \"Selects database 9 in the Redis server for subsequent operations.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"del\",\n        \"component_code\": \"r.del(\\\"myset\\\")\",\n        \"component_description\": \"Deletes the set named 'myset' from the selected database, if it exists.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"sadd\",\n        \"component_code\": \"r.sadd(\\\"myset\\\",(0..999).to_a)\",\n        \"component_description\": \"Adds elements 0 through 999 to the set named 'myset'. The (0..999).to_a creates an array of these numbers.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"freq\",\n        \"component_code\": \"freq = {}\",\n        \"component_description\": \"Initializes an empty hash to store the frequency of each element retrieved from 'myset'.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"100.times {\\n    res = r.pipelined {\\n        1000.times {\\n            r.srandmember(\\\"myset\\\")\\n        }\\n    }\\n    res.each{|ele|\\n        freq[ele] = 0 if freq[ele] == nil\\n        freq[ele] += 1\\n    }\\n}\",\n        \"component_description\": \"Executes the block of code 100 times. Inside this block, a pipelined request is made to get 1000 random members from 'myset'. The results are stored in 'res' and then each element's frequency is counted and stored in the 'freq' hash.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"dist\",\n        \"component_code\": \"dist = {}\",\n        \"component_description\": \"Initializes an empty hash to store the distribution of frequencies, i.e., how many elements have a certain frequency count.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"freq.each{|item,count|\\n    dist[count] = 0 if dist[count] == nil\\n    dist[count] += 1\\n}\",\n        \"component_description\": \"Iterates over the 'freq' hash, and for each frequency count (value), it increments the corresponding entry in the 'dist' hash, which tracks how many elements have that particular frequency.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"min\",\n        \"component_code\": \"min = dist.keys.min\",\n        \"component_description\": \"Finds and assigns the minimum key (i.e., the smallest frequency count) in the 'dist' hash to the variable 'min'.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"max\",\n        \"component_code\": \"max = dist.keys.max\",\n        \"component_description\": \"Finds and assigns the maximum key (i.e., the largest frequency count) in the 'dist' hash to the variable 'max'.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"(min..max).each{|x|\\n    count = dist[x]\\n    count = 0 if count == nil\\n    puts \\\"#{x} -> #{'*'*count}\\\"}\",\n        \"component_description\": \"Iterates over the range from 'min' to 'max', and for each frequency count, it prints a line showing that count followed by asterisks (*) representing the number of elements with that frequency. If a particular count is not present in the hash, it defaults to 0.\"\n      }\n    ],\n    \"overall_description\": \"This Ruby script interacts with a Redis server to demonstrate the distribution of random selections from a set of numbers (0-999). It initializes a set with these numbers, performs 100 trials of selecting 1000 random members each time using pipelining for efficiency, and counts the frequency of each member's selection. It then calculates and prints a frequency distribution of how often different selection frequencies occur.\"\n  }\n}"
    },
    "ruby_12": {
        "input": "# hll-err.rb - Copyright (C) 2014 <NAME>\n# BSD license, See the COPYING file for more information.\n#\n# Check error of HyperLogLog Redis implementation for different set sizes.\n\nrequire 'rubygems'\nrequire 'redis'\nrequire 'digest/sha1'\n\nr = Redis.new\nr.del('hll')\ni = 0\nwhile true do\n    100.times {\n        elements = []\n        1000.times {\n            ele = Digest::SHA1.hexdigest(i.to_s)\n            elements << ele\n            i += 1\n        }\n        r.pfadd('hll',elements)\n    }\n    approx = r.pfcount('hll')\n    abs_err = (approx-i).abs\n    rel_err = 100.to_f*abs_err/i\n    puts \"#{i} vs #{approx}: #{rel_err}%\"\nend\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'rubygems'\",\n        \"component_description\": \"This statement includes the RubyGems library, which is used to manage and load Ruby libraries.\"\n      },\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'redis'\",\n        \"component_description\": \"This statement includes the Redis gem, which allows Ruby code to interact with a Redis database server.\"\n      },\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'digest/sha1'\",\n        \"component_description\": \"This statement includes the SHA1 digest library from Ruby's standard library, which is used to generate SHA1 hashes of data.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"r\",\n        \"component_code\": \"r = Redis.new\",\n        \"component_description\": \"This line declares a variable 'r' and initializes it with a new instance of the Redis class, establishing a connection to a Redis server.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"del\",\n        \"component_code\": \"r.del('hll')\",\n        \"component_description\": \"This method call deletes the key 'hll' from the Redis database, ensuring that any existing data under this key is cleared before starting the script's operations.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"i\",\n        \"component_code\": \"i = 0\",\n        \"component_description\": \"This line declares a variable 'i' and initializes it with the integer value 0. This variable is used to keep track of the total number of unique elements added to the HyperLogLog.\"\n      },\n      {\n        \"component_type\": \"WHILE_LOOP\",\n        \"component_name\": NULL,\n        \"component_code\": \"while true do\\n    100.times {\\n        elements = []\\n        1000.times {\\n            ele = Digest::SHA1.hexdigest(i.to_s)\\n            elements << ele\\n            i += 1\\n        }\\n        r.pfadd('hll',elements)\\n    }\\n    approx = r.pfcount('hll')\\n    abs_err = (approx-i).abs\\n    rel_err = 100.to_f*abs_err/i\\n    puts \\\"#{i} vs #{approx}: #{rel_err}%\\\"\\nend\",\n        \"component_description\": \"This is an infinite loop that continuously processes batches of elements. Within this loop, a block is executed 100 times, generating and adding 1000 unique SHA1 hashes to the HyperLogLog set in Redis for each iteration. After adding these elements, it calculates the approximate count of unique elements using the pfcount method, computes both absolute and relative errors compared to the actual count 'i', and prints these values.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"100.times {\\n    elements = []\\n    1000.times {\\n        ele = Digest::SHA1.hexdigest(i.to_s)\\n        elements << ele\\n        i += 1\\n    }\\n    r.pfadd('hll',elements)\\n}\",\n        \"component_description\": \"This block is executed 100 times within the while loop. It initializes an empty array 'elements' and then in a nested block, generates 1000 unique SHA1 hashes of incrementing integers (starting from 'i'), appending each hash to the 'elements' array and incrementing 'i'. After generating all hashes, it adds them to the HyperLogLog set 'hll' in Redis using the pfadd method.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"1000.times {\\n    ele = Digest::SHA1.hexdigest(i.to_s)\\n    elements << ele\\n    i += 1\\n}\",\n        \"component_description\": \"This block is executed 1000 times within the outer block. It generates a SHA1 hash of the current value of 'i' using the Digest::SHA1.hexdigest method, appends this hash to the 'elements' array, and increments 'i' by 1.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"pfadd\",\n        \"component_code\": \"r.pfadd('hll',elements)\",\n        \"component_description\": \"This method call adds multiple elements (in this case, the array 'elements') to the HyperLogLog set named 'hll' in Redis. The pfadd command is used for adding elements to a HyperLogLog data structure in Redis.\"\n      },\n      {\n        \"component_type\": \"METHOD_CALL\",\n        \"component_name\": \"pfcount\",\n        \"component_code\": \"approx = r.pfcount('hll')\",\n        \"component_description\": \"This method call retrieves the approximate count of unique elements stored in the HyperLogLog set 'hll' from Redis and assigns this value to the variable 'approx'.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"abs_err\",\n        \"component_code\": \"abs_err = (approx-i).abs\",\n        \"component_description\": \"This line declares a variable 'abs_err' and initializes it with the absolute difference between the approximate count 'approx' and the actual count 'i'. This represents the absolute error in the HyperLogLog approximation.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"rel_err\",\n        \"component_code\": \"rel_err = 100.to_f*abs_err/i\",\n        \"component_description\": \"This line declares a variable 'rel_err' and initializes it with the relative error, calculated as the absolute error 'abs_err' divided by the actual count 'i', multiplied by 100 to express it as a percentage.\"\n      },\n      {\n        \"component_type\": \"OUTPUT_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"puts \\\"#{i} vs #{approx}: #{rel_err}%\\\"\",\n        \"component_description\": \"This statement outputs the current actual count 'i', the approximate count 'approx', and the relative error 'rel_err' as a percentage to the console. It provides a comparison between the exact number of unique elements added and the approximation provided by HyperLogLog.\"\n      }\n    ],\n    \"overall_description\": \"The Ruby script connects to a Redis server, continuously generates batches of 100,000 unique SHA1 hashes (in chunks of 1000 per iteration), adds them to a HyperLogLog set in Redis, and calculates the relative error between the actual count of unique elements added and the approximation provided by the HyperLogLog data structure. This process runs indefinitely until manually stopped.\"\n  }\n}"
    },
    "ruby_13": {
        "input": "# hll-err.rb - Copyright (C) 2014 <NAME>\n# BSD license, See the COPYING file for more information.\n#\n# This program is suited to output average and maximum errors of\n# the Redis HyperLogLog implementation in a format suitable to print\n# graphs using gnuplot.\n\nrequire 'rubygems'\nrequire 'redis'\nrequire 'digest/sha1'\n\n# Generate an array of [cardinality,relative_error] pairs\n# in the 0 - max range, with the specified step.\n#\n# 'r' is the Redis object used to perform the queries.\n# 'seed' must be different every time you want a test performed\n# with a different set. The function guarantees that if 'seed' is the\n# same, exactly the same dataset is used, and when it is different,\n# a totally unrelated different data set is used (without any common\n# element in practice).\ndef run_experiment(r,seed,max,step)\n    r.del('hll')\n    i = 0\n    samples = []\n    step = 1000 if step > 1000\n    while i < max do\n        elements = []\n        step.times {\n            ele = Digest::SHA1.hexdigest(i.to_s+seed.to_s)\n            elements << ele\n            i += 1\n        }\n        r.pfadd('hll',elements)\n        approx = r.pfcount('hll')\n        err = approx-i\n        rel_err = 100.to_f*err/i\n        samples << [i,rel_err]\n    end\n    samples\nend\n\ndef filter_samples(numsets,max,step,filter)\n    r = Redis.new\n    dataset = {}\n    (0...numsets).each{|i|\n        dataset[i] = run_experiment(r,i,max,step)\n        STDERR.puts \"Set #{i}\"\n    }\n    dataset[0].each_with_index{|ele,index|\n        if filter == :max\n            card=ele[0]\n            err=ele[1].abs\n            (1...numsets).each{|i|\n                err = dataset[i][index][1] if err < dataset[i][index][1]\n            }\n            puts \"#{card} #{err}\"\n        elsif filter == :avg\n            card=ele[0]\n            err = 0\n            (0...numsets).each{|i|\n                err += dataset[i][index][1]\n            }\n            err /= numsets\n            puts \"#{card} #{err}\"\n        elsif filter == :absavg\n            card=ele[0]\n            err = 0\n            (0...numsets).each{|i|\n                err += dataset[i][index][1].abs\n            }\n            err /= numsets\n            puts \"#{card} #{err}\"\n        elsif filter == :all\n            (0...numsets).each{|i|\n                card,err = dataset[i][index]\n                puts \"#{card} #{err}\"\n            }\n        else\n            raise \"Unknown filter #{filter}\"\n        end\n    }\nend\n\nif ARGV.length != 4\n    puts \"Usage: hll-gnuplot-graph <samples> <max> <step> (max|avg|absavg|all)\"\n    exit 1\nend\nfilter_samples(ARGV[0].to_i,ARGV[1].to_i,ARGV[2].to_i,ARGV[3].to_sym)\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"REQUIREMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'rubygems'\\nrequire 'redis'\\nrequire 'digest/sha1'\",\n        \"component_description\": \"These lines include the necessary external libraries: rubygems for managing RubyGems, redis for interacting with Redis databases, and digest/sha1 for generating SHA1 hashes.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"run_experiment\",\n        \"component_code\": \"def run_experiment(r,seed,max,step)\\n    r.del('hll')\\n    i = 0\\n    samples = []\\n    step = 1000 if step > 1000\\n    while i < max do\\n        elements = []\\n        step.times {\\n            ele = Digest::SHA1.hexdigest(i.to_s+seed.to_s)\\n            elements << ele\\n            i += 1\\n        }\\n        r.pfadd('hll',elements)\\n        approx = r.pfcount('hll')\\n        err = approx-i\\n        rel_err = 100.to_f*err/i\\n        samples << [i,rel_err]\\n    end\\n    samples\\nend\",\n        \"component_description\": \"This method performs an experiment to measure the relative error of Redis HyperLogLog implementation. It generates a dataset based on a seed and iterates up to 'max' cardinality in steps of 'step', adding elements to a HyperLogLog structure, then calculates the relative error between the actual and approximated cardinality.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"filter_samples\",\n        \"component_code\": \"def filter_samples(numsets,max,step,filter)\\n    r = Redis.new\\n    dataset = {}\\n    (0...numsets).each{|i|\\n        dataset[i] = run_experiment(r,i,max,step)\\n        STDERR.puts \\\"Set #{i}\\\"\\n    }\\n    dataset[0].each_with_index{|ele,index|\\n        if filter == :max\\n            card=ele[0]\\n            err=ele[1].abs\\n            (1...numsets).each{|i|\\n                err = dataset[i][index][1] if err < dataset[i][index][1]\\n            }\\n            puts \\\"#{card} #{err}\\\"\\n        elsif filter == :avg\\n            card=ele[0]\\n            err = 0\\n            (0...numsets).each{|i|\\n                err += dataset[i][index][1]\\n            }\\n            err /= numsets\\n            puts \\\"#{card} #{err}\\\"\\n        elsif filter == :absavg\\n            card=ele[0]\\n            err = 0\\n            (0...numsets).each{|i|\\n                err += dataset[i][index][1].abs\\n            }\\n            err /= numsets\\n            puts \\\"#{card} #{err}\\\"\\n        elsif filter == :all\\n            (0...numsets).each{|i|\\n                card,err = dataset[i][index]\\n                puts \\\"#{card} #{err}\\\"\\n            }\\n        else\\n            raise \\\"Unknown filter #{filter}\\\"\\n        end\\n    }\\nend\",\n        \"component_description\": \"This method collects and filters samples from multiple experiments. It creates a Redis connection, runs 'numsets' experiments using the run_experiment method, then processes the results based on the specified filter type (max, avg, absavg, or all) to output the cardinality and error.\"\n      },\n      {\n        \"component_type\": \"IF_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"if ARGV.length != 4\\n    puts \\\"Usage: hll-gnuplot-graph <samples> <max> <step> (max|avg|absavg|all)\\\"\\n    exit 1\\nend\",\n        \"component_description\": \"This conditional checks if the number of command-line arguments is not equal to 4. If true, it outputs a usage message and exits with an error code.\"\n      },\n      {\n        \"component_type\": \"METHOD_INVOCATION\",\n        \"component_name\": \"filter_samples\",\n        \"component_code\": \"filter_samples(ARGV[0].to_i,ARGV[1].to_i,ARGV[2].to_i,ARGV[3].to_sym)\",\n        \"component_description\": \"This line calls the filter_samples method with command-line arguments converted to integers and symbol for the filter type.\"\n      }\n    ],\n    \"overall_description\": \"The script measures the relative error of Redis HyperLogLog implementation by generating datasets based on seeds and iterating up to a specified cardinality in steps. It then processes multiple experiments' results based on the specified filter type and outputs the cardinality and error, suitable for creating graphs with gnuplot.\"\n  }\n}"
    },
    "ruby_14": {
        "input": "<gh_stars>1000+\n#!/usr/bin/env ruby\n\n# Copyright 2015 gRPC authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Sample app that connects to a 'EchoWithoutProtobuf' service.\n#\n# Usage: $ path/to/echo_client.rb\n\nthis_dir = File.expand_path(File.dirname(__FILE__))\n$LOAD_PATH.unshift(this_dir) unless $LOAD_PATH.include?(this_dir)\n\nrequire 'grpc'\nrequire 'echo_services_noprotobuf'\n\ndef main\n  stub = EchoWithoutProtobuf::Stub.new('localhost:50051', :this_channel_is_insecure)\n  user = ARGV.size > 0 ?  ARGV[0] : 'world'\n  message = stub.echo(\"hello #{user}\")\n  p \"Response: #{message}\"\nend\n\nmain\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"COMMENT\",\n        \"component_name\": null,\n        \"component_code\": \"# Sample app that connects to a 'EchoWithoutProtobuf' service.\\n#\\n# Usage: $ path/to/echo_client.rb\",\n        \"component_description\": \"A comment block providing a brief description of the script and its usage.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"this_dir\",\n        \"component_code\": \"this_dir = File.expand_path(File.dirname(__FILE__))\",\n        \"component_description\": \"Declares a variable `this_dir` that holds the absolute path of the directory containing the script file.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": null,\n        \"component_code\": \"$LOAD_PATH.unshift(this_dir) unless $LOAD_PATH.include?(this_dir)\",\n        \"component_description\": \"Adds `this_dir` to `$LOAD_PATH` if it is not already included, ensuring that local files can be required.\"\n      },\n      {\n        \"component_type\": \"REQUIRE\",\n        \"component_name\": null,\n        \"component_code\": \"require 'grpc'\",\n        \"component_description\": \"Requires the `grpc` gem, which provides gRPC bindings for Ruby.\"\n      },\n      {\n        \"component_type\": \"REQUIRE\",\n        \"component_name\": null,\n        \"component_code\": \"require 'echo_services_noprotobuf'\",\n        \"component_description\": \"Requires a custom file or library named `echo_services_noprotobuf`, likely containing definitions related to the Echo service.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"def main\\n  stub = EchoWithoutProtobuf::Stub.new('localhost:50051', :this_channel_is_insecure)\\n  user = ARGV.size > 0 ?  ARGV[0] : 'world'\\n  message = stub.echo(\\\"hello #{user}\\\")\\n  p \\\"Response: #{message}\\\"\\nend\",\n        \"component_description\": \"Defines a method `main` that sets up a gRPC client, sends an echo request with a greeting message to the server, and prints the response.\"\n      },\n      {\n        \"component_type\": \"METHOD_INVOCATION\",\n        \"component_name\": null,\n        \"component_code\": \"stub = EchoWithoutProtobuf::Stub.new('localhost:50051', :this_channel_is_insecure)\",\n        \"component_description\": \"Creates a new gRPC stub for the `EchoWithoutProtobuf` service, connecting to it on `localhost:50051` without using a secure channel.\"\n      },\n      {\n        \"component_type\": \"TERNARY_OPERATOR\",\n        \"component_name\": null,\n        \"component_code\": \"user = ARGV.size > 0 ?  ARGV[0] : 'world'\",\n        \"component_description\": \"Assigns the first command line argument to `user` if it exists; otherwise, defaults to `'world'`.\"\n      },\n      {\n        \"component_type\": \"METHOD_INVOCATION\",\n        \"component_name\": null,\n        \"component_code\": \"message = stub.echo(\\\"hello #{user}\\\")\",\n        \"component_description\": \"Invokes the `echo` method on the gRPC stub, sending a greeting message that includes the value of `user`, and assigns the response to `message`.\"\n      },\n      {\n        \"component_type\": \"METHOD_INVOCATION\",\n        \"component_name\": null,\n        \"component_code\": \"p \\\"Response: #{message}\\\"\",\n        \"component_description\": \"Prints the gRPC service's response message prefixed with 'Response: '.\"\n      },\n      {\n        \"component_type\": \"METHOD_INVOCATION\",\n        \"component_name\": null,\n        \"component_code\": \"main\",\n        \"component_description\": \"Invokes the `main` method to execute the script's main functionality.\"\n      }\n    ],\n    \"overall_description\": \"This Ruby script is a simple gRPC client application that connects to an 'EchoWithoutProtobuf' service running on localhost at port 50051. It sends a greeting message to the server, which echoes it back, and then prints the response. The script accepts an optional command line argument to customize the greeting; if no argument is provided, it defaults to 'world'.\"\n  }\n}"
    },
    "ruby_15": {
        "input": "# Generated by the protocol buffer compiler.  DO NOT EDIT!\n# source: helloworld.proto\n\nrequire 'google/protobuf'\n\nGoogle::Protobuf::DescriptorPool.generated_pool.build do\n  add_message \"helloworld.HelloRequest\" do\n    optional :name, :string, 1\n  end\n  add_message \"helloworld.HelloReply\" do\n    optional :message, :string, 1\n  end\nend\n\nmodule Helloworld\n  HelloRequest = Google::Protobuf::DescriptorPool.generated_pool.lookup(\"helloworld.HelloRequest\").msgclass\n  HelloReply = Google::Protobuf::DescriptorPool.generated_pool.lookup(\"helloworld.HelloReply\").msgclass\nend\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'google/protobuf'\",\n        \"component_description\": \"This statement includes the Google Protocol Buffers library, which is necessary for defining and using protocol buffer messages in Ruby.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"Google::Protobuf::DescriptorPool.generated_pool.build do\\n  add_message \\\"helloworld.HelloRequest\\\" do\\n    optional :name, :string, 1\\n  end\\n  add_message \\\"helloworld.HelloReply\\\" do\\n    optional :message, :string, 1\\n  end\\nend\",\n        \"component_description\": \"This block is used to define the structure of two protocol buffer messages: HelloRequest and HelloReply. The `add_message` method within the block specifies that each message has an optional string field. For HelloRequest, this field is named `name`, and for HelloReply, it is named `message`. Both fields are assigned a tag of 1.\"\n      },\n      {\n        \"component_type\": \"MODULE_DEFINITION\",\n        \"component_name\": \"Helloworld\",\n        \"component_code\": \"module Helloworld\\n  HelloRequest = Google::Protobuf::DescriptorPool.generated_pool.lookup(\\\"helloworld.HelloRequest\\\").msgclass\\n  HelloReply = Google::Protobuf::DescriptorPool.generated_pool.lookup(\\\"helloworld.HelloReply\\\").msgclass\\nend\",\n        \"component_description\": \"This module, named Helloworld, contains two constants: `HelloRequest` and `HelloReply`. These constants are assigned the message classes for their respective protocol buffer messages by looking them up in the generated descriptor pool using their fully qualified names. This setup allows easy access to these message types within the Helloworld module.\"\n      }\n    ],\n    \"overall_description\": \"This Ruby script defines two protocol buffer messages, `HelloRequest` and `HelloReply`, using the Google Protocol Buffers library. It specifies that each message contains a single optional string field named `name` for `HelloRequest` and `message` for `HelloReply`. The script then encapsulates these message types within a module called Helloworld, making them accessible as constants within that module.\"\n  }\n}"
    },
    "ruby_16": {
        "input": "#!/usr/bin/env ruby\n# -*- coding: utf-8 -*-\n\n# Copyright 2015 gRPC authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Error-throwing implementation of Route Guide service.\n#\n# Usage: $ path/to/route_guide_server.rb\n\nthis_dir = File.expand_path(File.dirname(__FILE__))\nlib_dir = File.join(File.dirname(this_dir), 'lib')\n$LOAD_PATH.unshift(lib_dir) unless $LOAD_PATH.include?(lib_dir)\n\nrequire 'grpc'\nrequire 'route_guide_services_pb'\n\ninclude Routeguide\n\ninclude GRPC::Core::StatusCodes\n\n# CanellingandErrorReturningServiceImpl provides an implementation of the RouteGuide service.\nclass CancellingAndErrorReturningServerImpl < RouteGuide::Service\n  # def get_feature\n  #   Note get_feature isn't implemented in this subclass, so the server\n  #   will get a gRPC UNIMPLEMENTED error when it's called.\n\n  def list_features(rectangle, _call)\n    raise \"string appears on the client in the 'details' field of a 'GRPC::Unknown' exception\"\n  end\n\n  def record_route(call)\n    raise GRPC::BadStatus.new_status_exception(CANCELLED)\n  end\n\n  def route_chat(notes)\n    raise GRPC::BadStatus.new_status_exception(ABORTED, details = 'arbitrary', metadata = {somekey: 'val'})\n  end\nend\n\ndef main\n  port = '0.0.0.0:50051'\n  s = GRPC::RpcServer.new\n  s.add_http2_port(port, :this_port_is_insecure)\n  GRPC.logger.info(\"... running insecurely on #{port}\")\n  s.handle(CancellingAndErrorReturningServerImpl.new)\n  s.run_till_terminated\nend\n\nmain\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"this_dir\",\n        \"component_code\": \"this_dir = File.expand_path(File.dirname(__FILE__))\",\n        \"component_description\": \"This variable stores the absolute path of the directory where the script is located.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"lib_dir\",\n        \"component_code\": \"lib_dir = File.join(File.dirname(this_dir), 'lib')\",\n        \"component_description\": \"This variable constructs the path to the 'lib' directory relative to the script's location.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"$LOAD_PATH.unshift(lib_dir) unless $LOAD_PATH.include?(lib_dir)\",\n        \"component_description\": \"This block ensures that the 'lib' directory is added to Ruby's load path if it's not already included.\"\n      },\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'grpc'\",\n        \"component_description\": \"This line requires the 'grpc' gem, which provides the necessary functionality for gRPC in Ruby.\"\n      },\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'route_guide_services_pb'\",\n        \"component_description\": \"This line requires the generated protocol buffer service code for the Route Guide service.\"\n      },\n      {\n        \"component_type\": \"MODULE_INCLUSION\",\n        \"component_name\": \"Routeguide\",\n        \"component_code\": \"include Routeguide\",\n        \"component_description\": \"This line includes the Routeguide module, making its methods and constants available in the current scope.\"\n      },\n      {\n        \"component_type\": \"MODULE_INCLUSION\",\n        \"component_name\": \"GRPC::Core::StatusCodes\",\n        \"component_code\": \"include GRPC::Core::StatusCodes\",\n        \"component_description\": \"This line includes the StatusCodes module from gRPC, making status codes available as constants.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"CancellingAndErrorReturningServerImpl\",\n        \"component_code\": \"class CancellingAndErrorReturningServerImpl < RouteGuide::Service\\n  # def get_feature\\n  #   Note get_feature isn't implemented in this subclass, so the server\\n  #   will get a gRPC UNIMPLEMENTED error when it's called.\\n\\n  def list_features(rectangle, _call)\\n    raise \\\"string appears on the client in the 'details' field of a 'GRPC::Unknown' exception\\\"\\n  end\\n\\n  def record_route(call)\\n    raise GRPC::BadStatus.new_status_exception(CANCELLED)\\n  end\\n\\n  def route_chat(notes)\\n    raise GRPC::BadStatus.new_status_exception(ABORTED, details = 'arbitrary', metadata = {somekey: 'val'})\\n  end\\nend\",\n        \"component_description\": \"This class provides an implementation of the RouteGuide service. It inherits from RouteGuide::Service and defines methods that intentionally raise errors to demonstrate error handling in gRPC.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"list_features\",\n        \"component_code\": \"def list_features(rectangle, _call)\\n    raise \\\"string appears on the client in the 'details' field of a 'GRPC::Unknown' exception\\\"\\n  end\",\n        \"component_description\": \"This method raises an exception with a custom error message when called. The error will appear in the 'details' field of a 'GRPC::Unknown' exception on the client side.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"record_route\",\n        \"component_code\": \"def record_route(call)\\n    raise GRPC::BadStatus.new_status_exception(CANCELLED)\\n  end\",\n        \"component_description\": \"This method raises a gRPC BadStatus exception with the CANCELLED status code when called, indicating that the operation was cancelled.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"route_chat\",\n        \"component_code\": \"def route_chat(notes)\\n    raise GRPC::BadStatus.new_status_exception(ABORTED, details = 'arbitrary', metadata = {somekey: 'val'})\\n  end\",\n        \"component_description\": \"This method raises a gRPC BadStatus exception with the ABORTED status code when called. It also includes custom error details and metadata.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"def main\\n  port = '0.0.0.0:50051'\\n  s = GRPC::RpcServer.new\\n  s.add_http2_port(port, :this_port_is_insecure)\\n  GRPC.logger.info(\\\"... running insecurely on #{port}\\\")\\n  s.handle(CancellingAndErrorReturningServerImpl.new)\\n  s.run_till_terminated\\nend\",\n        \"component_description\": \"This method sets up and starts the gRPC server. It configures the server to listen on port 50051, adds a handler for the CancellingAndErrorReturningServerImpl service, and runs the server until it is terminated.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"s.add_http2_port(port, :this_port_is_insecure)\",\n        \"component_description\": \"This line adds an insecure HTTP/2 port to the gRPC server. The server will listen for incoming connections on the specified port.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"GRPC.logger.info(\\\"... running insecurely on #{port}\\\")\",\n        \"component_description\": \"This line logs a message indicating that the server is running on the specified port. The server is running in an insecure mode.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"s.handle(CancellingAndErrorReturningServerImpl.new)\",\n        \"component_description\": \"This line adds a handler to the gRPC server for the CancellingAndErrorReturningServerImpl service, allowing it to handle incoming requests.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"s.run_till_terminated\",\n        \"component_description\": \"This line starts the gRPC server and keeps it running until it is terminated. The server will listen for incoming requests and handle them according to the defined service methods.\"\n      }\n    ],\n    \"overall_description\": \"The provided Ruby script sets up a gRPC server that implements the RouteGuide service. It defines a class, CancellingAndErrorReturningServerImpl, which inherits from RouteGuide::Service and intentionally raises errors in its methods to demonstrate error handling in gRPC. The main method configures the server to listen on port 50051, adds a handler for the defined service, and runs the server until it is terminated.\"\n  }\n}"
    },
    "ruby_17": {
        "input": "<filename>src/ruby/lib/grpc/logconfig.rb\n# Copyright 2015 gRPC authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# GRPC contains the General RPC module.\nmodule GRPC\n  # DefaultLogger is a module included in GRPC if no other logging is set up for\n  # it.  See ../spec/spec_helpers an example of where other logging is added.\n  module DefaultLogger\n    def logger\n      LOGGER\n    end\n\n    private\n\n    # NoopLogger implements the methods of Ruby's conventional logging interface\n    # that are actually used internally within gRPC with a noop implementation.\n    class NoopLogger\n      def info(_ignored)\n      end\n\n      def debug(_ignored)\n      end\n\n      def warn(_ignored)\n      end\n    end\n\n    LOGGER = NoopLogger.new\n  end\n\n  # Inject the noop #logger if no module-level logger method has been injected.\n  extend DefaultLogger unless methods.include?(:logger)\nend\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"MODULE_DEFINITION\",\n        \"component_name\": \"GRPC\",\n        \"component_code\": \"module GRPC\\n  # DefaultLogger is a module included in GRPC if no other logging is set up for\\n  # it.  See ../spec/spec_helpers an example of where other logging is added.\\n  module DefaultLogger\\n    def logger\\n      LOGGER\\n    end\\n\\n    private\\n\\n    # NoopLogger implements the methods of Ruby's conventional logging interface\\n    # that are actually used internally within gRPC with a noop implementation.\\n    class NoopLogger\\n      def info(_ignored)\\n      end\\n\\n      def debug(_ignored)\\n      end\\n\\n      def warn(_ignored)\\n      end\\n    end\\n\\n    LOGGER = NoopLogger.new\\n  end\\n\\n  # Inject the noop #logger if no module-level logger method has been injected.\\n  extend DefaultLogger unless methods.include?(:logger)\\nend\",\n        \"component_description\": \"This is the main GRPC module which includes a submodule named DefaultLogger. It ensures that there is always a default logging mechanism available through the logger method.\"\n      },\n      {\n        \"component_type\": \"MODULE_DEFINITION\",\n        \"component_name\": \"DefaultLogger\",\n        \"component_code\": \"module DefaultLogger\\n  def logger\\n    LOGGER\\n  end\\n\\n  private\\n\\n  # NoopLogger implements the methods of Ruby's conventional logging interface\\n  # that are actually used internally within gRPC with a noop implementation.\\n  class NoopLogger\\n    def info(_ignored)\\n    end\\n\\n    def debug(_ignored)\\n    end\\n\\n    def warn(_ignored)\\n    end\\n  end\\n\\n  LOGGER = NoopLogger.new\\nend\",\n        \"component_description\": \"This submodule defines a default logging mechanism for the GRPC module. It includes a method logger that returns an instance of NoopLogger if no other logging is set up.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"logger\",\n        \"component_code\": \"def logger\\n  LOGGER\\nend\",\n        \"component_description\": \"This method returns the LOGGER constant which holds an instance of NoopLogger, providing a default no-op logging interface for GRPC.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"NoopLogger\",\n        \"component_code\": \"class NoopLogger\\n  def info(_ignored)\\n  end\\n\\n  def debug(_ignored)\\n  end\\n\\n  def warn(_ignored)\\n  end\\nend\",\n        \"component_description\": \"This class implements a no-op logging interface with methods info, debug, and warn which do nothing. It is used as the default logger if no other logging mechanism is provided.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"info\",\n        \"component_code\": \"def info(_ignored)\\nend\",\n        \"component_description\": \"This method does nothing and serves as a placeholder for logging informational messages in a no-op manner.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"debug\",\n        \"component_code\": \"def debug(_ignored)\\nend\",\n        \"component_description\": \"This method does nothing and serves as a placeholder for logging debug information in a no-op manner.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"warn\",\n        \"component_code\": \"def warn(_ignored)\\nend\",\n        \"component_description\": \"This method does nothing and serves as a placeholder for logging warning messages in a no-op manner.\"\n      },\n      {\n        \"component_type\": \"CONSTANT_DEFINITION\",\n        \"component_name\": \"LOGGER\",\n        \"component_code\": \"LOGGER = NoopLogger.new\",\n        \"component_description\": \"This constant holds an instance of NoopLogger, which is used as the default logger for the GRPC module if no other logging mechanism is provided.\"\n      }\n    ],\n    \"overall_description\": \"The code defines a Ruby module named GRPC that includes a submodule DefaultLogger. DefaultLogger provides a no-op logging mechanism through a class named NoopLogger. The GRPC module ensures that there is always a default logger available by extending DefaultLogger unless it already has a logger method defined elsewhere. This setup allows for easy integration of other logging mechanisms while providing a fallback to a no-op logger.\"\n  }\n}"
    },
    "ruby_18": {
        "input": "# Original file comments:\n# Copyright 2015 gRPC authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nrequire 'grpc'\n\nmodule EchoWithoutProtobuf\n  # The 'echo without protobuf' service definition.\n  class Service\n\n    include GRPC::GenericService\n\n    self.marshal_class_method = :try_convert\n    self.unmarshal_class_method = :try_convert\n    self.service_name = 'EchoWithoutProtobuf'\n\n    # Request and response are plain strings\n    rpc :Echo, String, String\n  end\n\n  Stub = Service.rpc_stub_class\nend\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"MODULE_DEFINITION\",\n        \"component_name\": \"EchoWithoutProtobuf\",\n        \"component_code\": \"module EchoWithoutProtobuf\\n  # The 'echo without protobuf' service definition.\\n  class Service\\n\\n    include GRPC::GenericService\\n\\n    self.marshal_class_method = :try_convert\\n    self.unmarshal_class_method = :try_convert\\n    self.service_name = 'EchoWithoutProtobuf'\\n\\n    # Request and response are plain strings\\n    rpc :Echo, String, String\\n  end\\n\\n  Stub = Service.rpc_stub_class\\nend\",\n        \"component_description\": \"Defines a Ruby module named EchoWithoutProtobuf which contains the service definition for an echo service that does not use Protocol Buffers. The module includes a class and a stub definition.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"Service\",\n        \"component_code\": \"class Service\\n\\n    include GRPC::GenericService\\n\\n    self.marshal_class_method = :try_convert\\n    self.unmarshal_class_method = :try_convert\\n    self.service_name = 'EchoWithoutProtobuf'\\n\\n    # Request and response are plain strings\\n    rpc :Echo, String, String\\n  end\",\n        \"component_description\": \"Defines a class named Service within the EchoWithoutProtobuf module. This class includes GRPC::GenericService, setting up methods for handling request marshaling and unmarshaling using try_convert. It also defines an RPC method called Echo that takes a string as input and returns a string.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"include\",\n        \"component_code\": \"include GRPC::GenericService\",\n        \"component_description\": \"Includes the GRPC::GenericService module, providing methods for handling gRPC services without Protocol Buffers.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"marshal_class_method\",\n        \"component_code\": \"self.marshal_class_method = :try_convert\",\n        \"component_description\": \"Sets the marshal_class_method of the class to :try_convert, which is used to convert objects for sending over gRPC.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"unmarshal_class_method\",\n        \"component_code\": \"self.unmarshal_class_method = :try_convert\",\n        \"component_description\": \"Sets the unmarshal_class_method of the class to :try_convert, which is used to convert objects received from gRPC back into Ruby objects.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"service_name\",\n        \"component_code\": \"self.service_name = 'EchoWithoutProtobuf'\",\n        \"component_description\": \"Sets the service_name of the class to 'EchoWithoutProtobuf', which is used as the identifier for this gRPC service.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"rpc\",\n        \"component_code\": \"rpc :Echo, String, String\",\n        \"component_description\": \"Defines an RPC method named Echo that takes a string as input and returns a string. This method is part of the gRPC service definition.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"Stub\",\n        \"component_code\": \"Stub = Service.rpc_stub_class\",\n        \"component_description\": \"Creates a stub class for the EchoWithoutProtobuf::Service, allowing clients to interact with the gRPC service.\"\n      }\n    ],\n    \"overall_description\": \"The Ruby code defines a module named EchoWithoutProtobuf which contains a service definition for an echo service that operates without using Protocol Buffers. The service includes methods for handling request and response conversion using try_convert and defines an RPC method called Echo that takes and returns strings. A stub class is also created to facilitate client interactions with the gRPC service.\"\n  }\n}"
    },
    "ruby_19": {
        "input": "<gh_stars>1000+\n# Copyright 2017 gRPC authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# GRPC contains the General RPC module.\nmodule GRPC\n  ##\n  # Represents a registry of added interceptors available for enumeration.\n  # The registry can be used for both server and client interceptors.\n  # This class is internal to gRPC and not meant for public usage.\n  #\n  class InterceptorRegistry\n    ##\n    # An error raised when an interceptor is attempted to be added\n    # that does not extend GRPC::Interceptor\n    #\n    class DescendantError < StandardError; end\n\n    ##\n    # Initialize the registry with an empty interceptor list\n    # This is an EXPERIMENTAL API.\n    #\n    def initialize(interceptors = [])\n      @interceptors = []\n      interceptors.each do |i|\n        base = GRPC::Interceptor\n        unless i.class.ancestors.include?(base)\n          fail DescendantError, \"Interceptors must descend from #{base}\"\n        end\n        @interceptors << i\n      end\n    end\n\n    ##\n    # Builds an interception context from this registry\n    #\n    # @return [InterceptionContext]\n    #\n    def build_context\n      InterceptionContext.new(@interceptors)\n    end\n  end\nend\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"MODULE_DEFINITION\",\n        \"component_name\": \"GRPC\",\n        \"component_code\": \"module GRPC\\n  ##\\n  # Represents a registry of added interceptors available for enumeration.\\n  # The registry can be used for both server and client interceptors.\\n  # This class is internal to gRPC and not meant for public usage.\\n  #\\n  class InterceptorRegistry\\n    ##\\n    # An error raised when an interceptor is attempted to be added\\n    # that does not extend GRPC::Interceptor\\n    #\\n    class DescendantError < StandardError; end\\n\\n    ##\\n    # Initialize the registry with an empty interceptor list\\n    # This is an EXPERIMENTAL API.\\n    #\\n    def initialize(interceptors = [])\\n      @interceptors = []\\n      interceptors.each do |i|\\n        base = GRPC::Interceptor\\n        unless i.class.ancestors.include?(base)\\n          fail DescendantError, \\\"Interceptors must descend from #{base}\\\"\\n        end\\n        @interceptors << i\\n      end\\n    end\\n\\n    ##\\n    # Builds an interception context from this registry\\n    #\\n    # @return [InterceptionContext]\\n    #\\n    def build_context\\n      InterceptionContext.new(@interceptors)\\n    end\\n  end\\nend\",\n        \"component_description\": \"Defines the GRPC module which contains the InterceptorRegistry class used to manage interceptors for both server and client usage. This module is internal to gRPC.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"InterceptorRegistry\",\n        \"component_code\": \"class InterceptorRegistry\\n  ##\\n  # An error raised when an interceptor is attempted to be added\\n  # that does not extend GRPC::Interceptor\\n  #\\n  class DescendantError < StandardError; end\\n\\n  ##\\n  # Initialize the registry with an empty interceptor list\\n  # This is an EXPERIMENTAL API.\\n  #\\n  def initialize(interceptors = [])\\n    @interceptors = []\\n    interceptors.each do |i|\\n      base = GRPC::Interceptor\\n      unless i.class.ancestors.include?(base)\\n        fail DescendantError, \\\"Interceptors must descend from #{base}\\\"\\n      end\\n      @interceptors << i\\n    end\\n  end\\n\\n  ##\\n  # Builds an interception context from this registry\\n  #\\n  # @return [InterceptionContext]\\n  #\\n  def build_context\\n    InterceptionContext.new(@interceptors)\\n  end\\nend\",\n        \"component_description\": \"Defines the InterceptorRegistry class within the GRPC module. This class manages a list of interceptors and provides functionality to add them after verifying they extend from GRPC::Interceptor. It also provides a method to build an interception context using these registered interceptors.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"DescendantError\",\n        \"component_code\": \"class DescendantError < StandardError; end\",\n        \"component_description\": \"Defines the DescendantError class, a custom exception within the InterceptorRegistry class. This error is raised when an attempt is made to add an interceptor that does not inherit from GRPC::Interceptor.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"initialize\",\n        \"component_code\": \"def initialize(interceptors = [])\\n  @interceptors = []\\n  interceptors.each do |i|\\n    base = GRPC::Interceptor\\n    unless i.class.ancestors.include?(base)\\n      fail DescendantError, \\\"Interceptors must descend from #{base}\\\"\\n    end\\n    @interceptors << i\\n  end\\nend\",\n        \"component_description\": \"The initialize method for the InterceptorRegistry class sets up a new instance with an optional array of interceptors. It iterates through the provided interceptors, checks if each one is a descendant of GRPC::Interceptor, and raises a DescendantError if not. Valid interceptors are stored in an internal list.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"build_context\",\n        \"component_code\": \"def build_context\\n  InterceptionContext.new(@interceptors)\\nend\",\n        \"component_description\": \"The build_context method creates and returns a new instance of InterceptionContext, initialized with the current list of registered interceptors. This context can be used for further processing or configuration in the gRPC framework.\"\n      }\n    ],\n    \"overall_description\": \"The provided Ruby code defines the GRPC module which contains the InterceptorRegistry class designed to manage and validate a collection of interceptors. The class includes functionality to initialize with an array of valid interceptors (ensuring they inherit from GRPC::Interceptor) and build an interception context from these interceptors. A custom DescendantError is defined for handling invalid interceptor additions.\"\n  }\n}"
    },
    "ruby_20": {
        "input": "# Generated by the protocol buffer compiler.  DO NOT EDIT!\n# source: src/proto/grpc/testing/metrics.proto\n\nrequire 'google/protobuf'\n\nGoogle::Protobuf::DescriptorPool.generated_pool.build do\n  add_message \"grpc.testing.GaugeResponse\" do\n    optional :name, :string, 1\n    oneof :value do\n      optional :long_value, :int64, 2\n      optional :double_value, :double, 3\n      optional :string_value, :string, 4\n    end\n  end\n  add_message \"grpc.testing.GaugeRequest\" do\n    optional :name, :string, 1\n  end\n  add_message \"grpc.testing.EmptyMessage\" do\n  end\nend\n\nmodule Grpc\n  module Testing\n    GaugeResponse = Google::Protobuf::DescriptorPool.generated_pool.lookup(\"grpc.testing.GaugeResponse\").msgclass\n    GaugeRequest = Google::Protobuf::DescriptorPool.generated_pool.lookup(\"grpc.testing.GaugeRequest\").msgclass\n    EmptyMessage = Google::Protobuf::DescriptorPool.generated_pool.lookup(\"grpc.testing.EmptyMessage\").msgclass\n  end\nend\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"REQUIRE_STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'google/protobuf'\",\n        \"component_description\": \"This line includes the google-protobuf library, which is necessary for defining and using protocol buffers in Ruby.\"\n      },\n      {\n        \"component_type\": \"BLOCK\",\n        \"component_name\": NULL,\n        \"component_code\": \"Google::Protobuf::DescriptorPool.generated_pool.build do\\n  add_message \\\"grpc.testing.GaugeResponse\\\" do\\n    optional :name, :string, 1\\n    oneof :value do\\n      optional :long_value, :int64, 2\\n      optional :double_value, :double, 3\\n      optional :string_value, :string, 4\\n    end\\n  end\\n  add_message \\\"grpc.testing.GaugeRequest\\\" do\\n    optional :name, :string, 1\\n  end\\n  add_message \\\"grpc.testing.EmptyMessage\\\" do\\n  end\\nend\",\n        \"component_description\": \"This block is used to define protocol buffer messages within the Google::Protobuf::DescriptorPool. It defines three messages: GaugeResponse, GaugeRequest, and EmptyMessage with their respective fields.\"\n      },\n      {\n        \"component_type\": \"MESSAGE_DEFINITION\",\n        \"component_name\": \"GaugeResponse\",\n        \"component_code\": \"add_message \\\"grpc.testing.GaugeResponse\\\" do\\n  optional :name, :string, 1\\n  oneof :value do\\n    optional :long_value, :int64, 2\\n    optional :double_value, :double, 3\\n    optional :string_value, :string, 4\\n  end\\nend\",\n        \"component_description\": \"Defines a protocol buffer message named GaugeResponse with an optional string field 'name' and a oneof group 'value' which can contain either 'long_value', 'double_value', or 'string_value'.\"\n      },\n      {\n        \"component_type\": \"MESSAGE_DEFINITION\",\n        \"component_name\": \"GaugeRequest\",\n        \"component_code\": \"add_message \\\"grpc.testing.GaugeRequest\\\" do\\n  optional :name, :string, 1\\nend\",\n        \"component_description\": \"Defines a protocol buffer message named GaugeRequest with an optional string field 'name'.\"\n      },\n      {\n        \"component_type\": \"MESSAGE_DEFINITION\",\n        \"component_name\": \"EmptyMessage\",\n        \"component_code\": \"add_message \\\"grpc.testing.EmptyMessage\\\" do\\nend\",\n        \"component_description\": \"Defines an empty protocol buffer message named EmptyMessage, which contains no fields.\"\n      },\n      {\n        \"component_type\": \"MODULE_DEFINITION\",\n        \"component_name\": \"Grpc\",\n        \"component_code\": \"module Grpc\\n  module Testing\\n    GaugeResponse = Google::Protobuf::DescriptorPool.generated_pool.lookup(\\\"grpc.testing.GaugeResponse\\\").msgclass\\n    GaugeRequest = Google::Protobuf::DescriptorPool.generated_pool.lookup(\\\"grpc.testing.GaugeRequest\\\").msgclass\\n    EmptyMessage = Google::Protobuf::DescriptorPool.generated_pool.lookup(\\\"grpc.testing.EmptyMessage\\\").msgclass\\n  end\\nend\",\n        \"component_description\": \"Defines a module named Grpc which contains a nested module Testing. Within this nested module, constants GaugeResponse, GaugeRequest, and EmptyMessage are defined to reference the respective message classes from the Google::Protobuf::DescriptorPool.\"\n      },\n      {\n        \"component_type\": \"CONSTANT_DEFINITION\",\n        \"component_name\": \"GaugeResponse\",\n        \"component_code\": \"GaugeResponse = Google::Protobuf::DescriptorPool.generated_pool.lookup(\\\"grpc.testing.GaugeResponse\\\").msgclass\",\n        \"component_description\": \"Defines a constant GaugeResponse within the Grpc::Testing module that references the GaugeResponse message class from the DescriptorPool.\"\n      },\n      {\n        \"component_type\": \"CONSTANT_DEFINITION\",\n        \"component_name\": \"GaugeRequest\",\n        \"component_code\": \"GaugeRequest = Google::Protobuf::DescriptorPool.generated_pool.lookup(\\\"grpc.testing.GaugeRequest\\\").msgclass\",\n        \"component_description\": \"Defines a constant GaugeRequest within the Grpc::Testing module that references the GaugeRequest message class from the DescriptorPool.\"\n      },\n      {\n        \"component_type\": \"CONSTANT_DEFINITION\",\n        \"component_name\": \"EmptyMessage\",\n        \"component_code\": \"EmptyMessage = Google::Protobuf::DescriptorPool.generated_pool.lookup(\\\"grpc.testing.EmptyMessage\\\").msgclass\",\n        \"component_description\": \"Defines a constant EmptyMessage within the Grpc::Testing module that references the EmptyMessage class from the DescriptorPool.\"\n      }\n    ],\n    \"overall_description\": \"This Ruby code defines protocol buffer messages for use in gRPC testing, specifically GaugeResponse, GaugeRequest, and EmptyMessage. It uses the google-protobuf library to generate message classes based on these definitions. The messages are then made accessible through a nested module structure (Grpc::Testing) via constant definitions that reference the generated message classes.\"\n  }\n}"
    },
    "ruby_21": {
        "input": "#!/usr/bin/env ruby\n\n# Copyright 2015 gRPC authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Sample app that connects to an error-throwing implementation of\n# Route Guide service.\n#\n# Usage: $ path/to/route_guide_client.rb\n\nthis_dir = File.expand_path(File.dirname(__FILE__))\nlib_dir = File.join(File.dirname(this_dir), 'lib')\n$LOAD_PATH.unshift(lib_dir) unless $LOAD_PATH.include?(lib_dir)\n\nrequire 'grpc'\nrequire 'route_guide_services_pb'\n\ninclude Routeguide\n\ndef run_get_feature_expect_error(stub)\n  resp = stub.get_feature(Point.new)\nend\n\ndef run_list_features_expect_error(stub)\n  resps = stub.list_features(Rectangle.new)\n\n  # NOOP iteration to pick up error\n  resps.each { }\nend\n\ndef run_record_route_expect_error(stub)\n  stub.record_route([])\nend\n\ndef run_route_chat_expect_error(stub)\n  resps = stub.route_chat([])\n\n  # NOOP iteration to pick up error\n  resps.each { }\nend\n\ndef main\n  stub = RouteGuide::Stub.new('localhost:50051', :this_channel_is_insecure)\n\n  begin\n    run_get_feature_expect_error(stub)\n  rescue GRPC::BadStatus => e\n    puts \"===== GetFeature exception: =====\"\n    puts e.inspect\n    puts \"e.code: #{e.code}\"\n    puts \"e.details: #{e.details}\"\n    puts \"e.metadata: #{e.metadata}\"\n    puts \"=================================\"\n  end\n\n  begin\n    run_list_features_expect_error(stub)\n  rescue GRPC::BadStatus => e\n    error = true\n    puts \"===== ListFeatures exception: =====\"\n    puts e.inspect\n    puts \"e.code: #{e.code}\"\n    puts \"e.details: #{e.details}\"\n    puts \"e.metadata: #{e.metadata}\"\n    puts \"=================================\"\n  end\n\n  begin\n    run_route_chat_expect_error(stub)\n  rescue GRPC::BadStatus => e\n    puts \"==== RouteChat exception: ====\"\n    puts e.inspect\n    puts \"e.code: #{e.code}\"\n    puts \"e.details: #{e.details}\"\n    puts \"e.metadata: #{e.metadata}\"\n    puts \"=================================\"\n  end\n\n  begin\n    run_record_route_expect_error(stub)\n  rescue GRPC::BadStatus => e\n    puts \"==== RecordRoute exception: ====\"\n    puts e.inspect\n    puts \"e.code: #{e.code}\"\n    puts \"e.details: #{e.details}\"\n    puts \"e.metadata: #{e.metadata}\"\n    puts \"=================================\"\n  end\nend\n\nmain\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"this_dir\",\n        \"component_code\": \"this_dir = File.expand_path(File.dirname(__FILE__))\",\n        \"component_description\": \"Declares a variable `this_dir` and assigns it the absolute path of the directory containing the current file using `File.expand_path` and `File.dirname`.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"lib_dir\",\n        \"component_code\": \"lib_dir = File.join(File.dirname(this_dir), 'lib')\",\n        \"component_description\": \"Declares a variable `lib_dir` and assigns it the path to the 'lib' directory located one level above `this_dir` using `File.join`.\"\n      },\n      {\n        \"component_type\": \"STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"$LOAD_PATH.unshift(lib_dir) unless $LOAD_PATH.include?(lib_dir)\",\n        \"component_description\": \"Adds the `lib_dir` to `$LOAD_PATH` if it is not already included, allowing Ruby to load libraries from this directory.\"\n      },\n      {\n        \"component_type\": \"STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'grpc'\",\n        \"component_description\": \"Requires the 'grpc' library, which provides the gRPC framework for building high-performance network services in Ruby.\"\n      },\n      {\n        \"component_type\": \"STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'route_guide_services_pb'\",\n        \"component_description\": \"Requires the generated `route_guide_services_pb` file, which contains the protocol buffer service definitions for the RouteGuide service.\"\n      },\n      {\n        \"component_type\": \"STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"include Routeguide\",\n        \"component_description\": \"Includes the `Routeguide` module into the current scope, allowing its methods and constants to be used directly without prefixing them with the module name.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"run_get_feature_expect_error\",\n        \"component_code\": \"def run_get_feature_expect_error(stub)\\n  resp = stub.get_feature(Point.new)\\nend\",\n        \"component_description\": \"Defines a method `run_get_feature_expect_error` that takes a `stub` argument and calls the `get_feature` method on it with a new instance of `Point`. This is expected to raise an error, which is handled elsewhere in the code.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"run_list_features_expect_error\",\n        \"component_code\": \"def run_list_features_expect_error(stub)\\n  resps = stub.list_features(Rectangle.new)\\n\\n  # NOOP iteration to pick up error\\n  resps.each { }\\nend\",\n        \"component_description\": \"Defines a method `run_list_features_expect_error` that takes a `stub` argument and calls the `list_features` method on it with a new instance of `Rectangle`. It then iterates over the response to trigger any errors, which are handled elsewhere in the code.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"run_record_route_expect_error\",\n        \"component_code\": \"def run_record_route_expect_error(stub)\\n  stub.record_route([])\\nend\",\n        \"component_description\": \"Defines a method `run_record_route_expect_error` that takes a `stub` argument and calls the `record_route` method on it with an empty array. This is expected to raise an error, which is handled elsewhere in the code.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"run_route_chat_expect_error\",\n        \"component_code\": \"def run_route_chat_expect_error(stub)\\n  resps = stub.route_chat([])\\n\\n  # NOOP iteration to pick up error\\n  resps.each { }\\nend\",\n        \"component_description\": \"Defines a method `run_route_chat_expect_error` that takes a `stub` argument and calls the `route_chat` method on it with an empty array. It then iterates over the response to trigger any errors, which are handled elsewhere in the code.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"def main\\n  stub = RouteGuide::Stub.new('localhost:50051', :this_channel_is_insecure)\\n\\n  begin\\n    run_get_feature_expect_error(stub)\\n  rescue => e\\n    puts \\\"Error in get_feature: #{e}\\\"\\n  end\\n\\n  begin\\n    run_list_features_expect_error(stub)\\n  rescue => e\\n    puts \\\"Error in list_features: #{e}\\\"\\n  end\\n\\n  begin\\n    run_record_route_expect_error(stub)\\n  rescue => e\\n    puts \\\"Error in record_route: #{e}\\\"\\n  end\\n\\n  begin\\n    run_route_chat_expect_error(stub)\\n  rescue => e\\n    puts \\\"Error in route_chat: #{e}\\\"\\n  end\\nend\",\n        \"component_description\": \"Defines the `main` method, which creates a new `RouteGuide::Stub` connected to 'localhost:50051' with an insecure channel. It then calls each of the error-expecting methods (`run_get_feature_expect_error`, `run_list_features_expect_error`, `run_record_route_expect_error`, and `run_route_chat_expect_error`) within `begin-rescue` blocks to handle any errors that occur, printing an appropriate error message for each.\"\n      },\n      {\n        \"component_type\": \"STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"main\",\n        \"component_description\": \"Calls the `main` method to execute the program's main logic.\"\n      }\n    ],\n    \"overall_description\": \"This Ruby script sets up a gRPC client that connects to a RouteGuide server at 'localhost:50051'. It defines several methods (`run_get_feature_expect_error`, `run_list_features_expect_error`, `run_record_route_expect_error`, and `run_route_chat_expect_error`) that call the respective service methods on the server, expecting them to raise errors. The `main` method orchestrates these calls within `begin-rescue` blocks to handle any exceptions gracefully, printing error messages as needed.\"\n  }\n}"
    },
    "ruby_22": {
        "input": "<gh_stars>1000+\n#!/usr/bin/env ruby\n\n# Copyright 2015 gRPC authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Sample app that helps validate RpcServer without protobuf serialization.\n#\n# Usage: $ path/to/noproto_server.rb\n\nthis_dir = File.expand_path(File.dirname(__FILE__))\nlib_dir = File.join(File.dirname(this_dir), 'lib')\n$LOAD_PATH.unshift(lib_dir) unless $LOAD_PATH.include?(lib_dir)\n\nrequire 'grpc'\nrequire 'optparse'\n\n# a simple non-protobuf message class.\nclass NoProtoMsg\n  def self.marshal(_o)\n    ''\n  end\n\n  def self.unmarshal(_o)\n    NoProtoMsg.new\n  end\nend\n\n# service the uses the non-protobuf message class.\nclass NoProtoService\n  include GRPC::GenericService\n  rpc :AnRPC, NoProtoMsg, NoProtoMsg\nend\n\n# an implementation of the non-protobuf service.\nclass NoProto < NoProtoService\n  def initialize(_default_var = 'ignored')\n  end\n\n  def an_rpc(req, _call)\n    GRPC.logger.info('echo service received a request')\n    req\n  end\nend\n\ndef load_test_certs\n  this_dir = File.expand_path(File.dirname(__FILE__))\n  data_dir = File.join(File.dirname(this_dir), 'spec/testdata')\n  files = ['ca.pem', 'server1.key', 'server1.pem']\n  files.map { |f| File.open(File.join(data_dir, f)).read }\nend\n\ndef test_server_creds\n  certs = load_test_certs\n  GRPC::Core::ServerCredentials.new(\n    nil, [{ private_key: certs[1], cert_chain: certs[2] }], false)\nend\n\ndef main\n  options = {\n    'host' => 'localhost:9090',\n    'secure' => false\n  }\n  OptionParser.new do |opts|\n    opts.banner = 'Usage: [--host <hostname>:<port>] [--secure|-s]'\n    opts.on('--host HOST', '<hostname>:<port>') do |v|\n      options['host'] = v\n    end\n    opts.on('-s', '--secure', 'access using test creds') do |v|\n      options['secure'] = v\n    end\n  end.parse!\n\n  s = GRPC::RpcServer.new\n  if options['secure']\n    s.add_http2_port(options['host'], test_server_creds)\n    GRPC.logger.info(\"... running securely on #{options['host']}\")\n  else\n    s.add_http2_port(options['host'], :this_port_is_insecure)\n    GRPC.logger.info(\"... running insecurely on #{options['host']}\")\n  end\n\n  s.handle(NoProto)\n  s.run_till_terminated\nend\n\nmain\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"this_dir\",\n        \"component_code\": \"this_dir = File.expand_path(File.dirname(__FILE__))\",\n        \"component_description\": \"This line declares a variable `this_dir` and assigns it the absolute path of the directory containing the current file.\"\n      },\n      {\n        \"component_type\": \"VARIABLE_DECLARATION\",\n        \"component_name\": \"lib_dir\",\n        \"component_code\": \"lib_dir = File.join(File.dirname(this_dir), 'lib')\",\n        \"component_description\": \"This line declares a variable `lib_dir` and assigns it the path to the 'lib' directory relative to `this_dir`. It uses `File.join` to construct the full path.\"\n      },\n      {\n        \"component_type\": \"STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"$LOAD_PATH.unshift(lib_dir) unless $LOAD_PATH.include?(lib_dir)\",\n        \"component_description\": \"This line adds `lib_dir` to the beginning of the `$LOAD_PATH` array if it is not already included. This ensures that Ruby can find and load files located in the 'lib' directory.\"\n      },\n      {\n        \"component_type\": \"REQUIRE\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'grpc'\",\n        \"component_description\": \"This line requires the `grpc` gem, which provides gRPC functionalities for Ruby applications.\"\n      },\n      {\n        \"component_type\": \"REQUIRE\",\n        \"component_name\": NULL,\n        \"component_code\": \"require 'optparse'\",\n        \"component_description\": \"This line requires the `optparse` library, which is used to parse command-line options in Ruby scripts.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"NoProtoMsg\",\n        \"component_code\": \"class NoProtoMsg\\n  def self.marshal(_o)\\n    ''\\n  end\\n\\n  def self.unmarshal(_o)\\n    NoProtoMsg.new\\n  end\\nend\",\n        \"component_description\": \"This class `NoProtoMsg` is a simple non-protobuf message class. It defines two class methods: `marshal`, which returns an empty string, and `unmarshal`, which creates a new instance of `NoProtoMsg`. These methods are placeholders for handling serialization and deserialization without using protobuf.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"NoProtoService\",\n        \"component_code\": \"class NoProtoService\\n  include GRPC::GenericService\\n  rpc :AnRPC, NoProtoMsg, NoProtoMsg\\nend\",\n        \"component_description\": \"This class `NoProtoService` defines a gRPC service that uses the non-protobuf message class `NoProtoMsg`. It includes `GRPC::GenericService`, which provides generic gRPC functionalities. The `rpc` method defines an RPC called `AnRPC` that takes and returns an instance of `NoProtoMsg`.\"\n      },\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"NoProto\",\n        \"component_code\": \"class NoProto < NoProtoService\\n  def initialize(_default_var = 'ignored')\\n  end\\n\\n  def an_rpc(req, _call)\\n    GRPC.logger.info('echo service received a request')\\n    req\\n  end\\nend\",\n        \"component_description\": \"This class `NoProto` inherits from `NoProtoService`. It implements the `an_rpc` method, which is called when the `AnRPC` RPC is invoked. The method logs an informational message and returns the request object `req`, effectively echoing the received message.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"load_test_certs\",\n        \"component_code\": \"def load_test_certs\\n  this_dir = File.expand_path(File.dirname(__FILE__))\\n  data_dir = File.join(File.dirname(this_dir), 'spec/testdata')\\n  files = ['ca.pem', 'server1.key', 'server1.pem']\\n  files.map { |f| File.open(File.join(data_dir, f)).read }\\nend\",\n        \"component_description\": \"This method `load_test_certs` loads test certificates from the 'spec/testdata' directory. It constructs the path to each certificate file and reads their contents into an array.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"test_server_creds\",\n        \"component_code\": \"def test_server_creds\\n  # This method is not defined in the provided code snippet, but it should use `load_test_certs` to return server credentials.\\nend\",\n        \"component_description\": \"This method (not fully shown) is intended to create and return gRPC server credentials using the certificates loaded by `load_test_certs`. However, its implementation is not provided in the given code snippet.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"main\",\n        \"component_code\": \"def main\\n  s.add_http2_port(options['host'], :this_port_is_insecure)\\n  GRPC.logger.info(\\\"... running insecurely on #{options['host']}\\\")\\nend\",\n        \"component_description\": \"This method `main` sets up and starts the gRPC server. It adds an HTTP/2 port to the server, specifying whether the connection is secure or not based on command-line options. It logs a message indicating where the server is running.\"\n      },\n      {\n        \"component_type\": \"STATEMENT\",\n        \"component_name\": NULL,\n        \"component_code\": \"main\",\n        \"component_description\": \"This line calls the `main` method to execute the setup and start of the gRPC server when the script runs.\"\n      }\n    ],\n    \"overall_description\": \"The provided Ruby script sets up a simple gRPC server that uses non-protobuf message handling. It defines a custom message class `NoProtoMsg`, a service `NoProtoService` with an RPC method, and its implementation in `NoProto`. The script also includes methods to load test certificates and set up the server securely or insecurely based on command-line options.\"\n  }\n}"
    },
    "ruby_24": {
        "input": "<gh_stars>1000+\n#!/usr/bin/env ruby\n\n# Copyright 2016 gRPC authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Histogram class for use in performance testing and measurement\n\nrequire 'thread'\n\nclass Histogram\n  # Determine the bucket index for a given value\n  # @param {number} value The value to check\n  # @return {number} The bucket index\n  def bucket_for(value)\n    (Math.log(value)/Math.log(@multiplier)).to_i\n  end\n  # Initialize an empty histogram\n  # @param {number} resolution The resolution of the histogram\n  # @param {number} max_possible The maximum value for the histogram\n  def initialize(resolution, max_possible)\n    @lock = Mutex.new\n    @resolution=resolution\n    @max_possible=max_possible\n    @sum=0\n    @sum_of_squares=0\n    @multiplier=1+resolution\n    @count=0\n    @min_seen=max_possible\n    @max_seen=0\n    @buckets=Array.new(bucket_for(max_possible)+1, 0)\n  end\n  # Add a value to the histogram. This updates all statistics with the new\n  # value. Those statistics should not be modified except with this function\n  # @param {number} value The value to add\n  def add(value)\n    @sum += value\n    @sum_of_squares += value * value\n    @count += 1\n    if value < @min_seen\n      @min_seen = value\n    end\n    if value > @max_seen\n      @max_seen = value\n    end\n    @buckets[bucket_for(value)] += 1\n  end\n  def minimum\n    @min_seen\n  end\n  def maximum\n    @max_seen\n  end\n  def sum\n    @sum\n  end\n  def sum_of_squares\n    @sum_of_squares\n  end\n  def count\n    @count\n  end\n  def contents\n    @buckets\n  end\n\n  def merge(hist)\n    @lock.synchronize do\n      @min_seen = hist.min_seen\n      @max_seen = hist.max_seen\n      @sum += hist.sum\n      @sum_of_squares += hist.sum_of_squares\n      @count += hist.count\n      received_bucket = hist.bucket.to_a\n      @buckets = @buckets.map.with_index{ |m,i| m + received_bucket[i].to_i }\n    end\n  end\nend\n",
        "output": "{\n  \"output\": {\n    \"programming_language\": \"Ruby\",\n    \"components\": [\n      {\n        \"component_type\": \"CLASS_DEFINITION\",\n        \"component_name\": \"Histogram\",\n        \"component_code\": \"class Histogram\\n  # Determine the bucket index for a given value\\n  # @param {number} value The value to check\\n  # @return {number} The bucket index\\n  def bucket_for(value)\\n    (Math.log(value)/Math.log(@multiplier)).to_i\\n  end\\n  # Initialize an empty histogram\\n  # @param {number} resolution The resolution of the histogram\\n  # @param {number} max_possible The maximum value for the histogram\\n  def initialize(resolution, max_possible)\\n    @lock = Mutex.new\\n    @resolution=resolution\\n    @max_possible=max_possible\\n    @sum=0\\n    @sum_of_squares=0\\n    @multiplier=1+resolution\\n    @count=0\\n    @min_seen=max_possible\\n    @max_seen=0\\n    @buckets=Array.new(bucket_for(max_possible)+1, 0)\\n  end\\n  # Add a value to the histogram. This updates all statistics with the new\\n  # value. Those statistics should not be modified except with this function\\n  # @param {number} value The value to add\\n  def add(value)\\n    @sum += value\\n    @sum_of_squares += value * value\\n    @count += 1\\n    if value < @min_seen\\n      @min_seen = value\\n    end\\n    if value > @max_seen\\n      @max_seen = value\\n    end\\n    @buckets[bucket_for(value)] += 1\\n  end\\ndef minimum\\n    @min_seen\\n  end\\ndef maximum\\n    @max_seen\\n  end\\ndef sum\\n    @sum\\n  end\\ndef sum_of_squares\\n    @sum_of_squares\\n  end\\ndef count\\n    @count\\n  end\\ndef contents\\n    @buckets\\n  end\\n\\ndef merge(hist)\\n    @lock.synchronize do\\n      @min_seen = hist.min_seen\\n      @max_seen = hist.max_seen\\n      @sum += hist.sum\\n      @sum_of_squares += hist.sum_of_squares\\n      @count += hist.count\\n      received_bucket = hist.bucket.to_a\\n      @buckets = @buckets.map.with_index{ |m,i| m + received_bucket[i].to_i }\\n    end\\n  end\\nend\",\n        \"component_description\": \"Defines a Histogram class used for performance testing and measurement. It includes methods to add values, calculate statistics, determine bucket indices, merge with another histogram, and retrieve various statistical data.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"bucket_for\",\n        \"component_code\": \"def bucket_for(value)\\n  (Math.log(value)/Math.log(@multiplier)).to_i\\nend\",\n        \"component_description\": \"Determines the bucket index for a given value using logarithmic calculations based on the histogram's resolution.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"initialize\",\n        \"component_code\": \"def initialize(resolution, max_possible)\\n  @lock = Mutex.new\\n  @resolution=resolution\\n  @max_possible=max_possible\\n  @sum=0\\n  @sum_of_squares=0\\n  @multiplier=1+resolution\\n  @count=0\\n  @min_seen=max_possible\\n  @max_seen=0\\n  @buckets=Array.new(bucket_for(max_possible)+1, 0)\\nend\",\n        \"component_description\": \"Initializes a new Histogram instance with specified resolution and maximum possible value. Sets up necessary internal variables and initializes buckets.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"add\",\n        \"component_code\": \"def add(value)\\n  @sum += value\\n  @sum_of_squares += value * value\\n  @count += 1\\n  if value < @min_seen\\n    @min_seen = value\\n  end\\n  if value > @max_seen\\n    @max_seen = value\\n  end\\n  @buckets[bucket_for(value)] += 1\\nend\",\n        \"component_description\": \"Adds a new value to the histogram, updating sum, sum of squares, count, minimum, maximum values, and increments the appropriate bucket.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"minimum\",\n        \"component_code\": \"def minimum\\n  @min_seen\\nend\",\n        \"component_description\": \"Returns the minimum value recorded in the histogram.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"maximum\",\n        \"component_code\": \"def maximum\\n  @max_seen\\nend\",\n        \"component_description\": \"Returns the maximum value recorded in the histogram.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"sum\",\n        \"component_code\": \"def sum\\n  @sum\\nend\",\n        \"component_description\": \"Returns the total sum of all values added to the histogram.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"sum_of_squares\",\n        \"component_code\": \"def sum_of_squares\\n  @sum_of_squares\\nend\",\n        \"component_description\": \"Returns the sum of squares of all values added to the histogram.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"count\",\n        \"component_code\": \"def count\\n  @count\\nend\",\n        \"component_description\": \"Returns the total number of values added to the histogram.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"contents\",\n        \"component_code\": \"def contents\\n  @buckets\\nend\",\n        \"component_description\": \"Returns an array representing the counts in each bucket of the histogram.\"\n      },\n      {\n        \"component_type\": \"METHOD_DEFINITION\",\n        \"component_name\": \"merge\",\n        \"component_code\": \"def merge(hist)\\n  @lock.synchronize do\\n    @min_seen = hist.min_seen\\n    @max_seen = hist.max_seen\\n    @sum += hist.sum\\n    @sum_of_squares += hist.sum_of_squares\\n    @count += hist.count\\n    received_bucket = hist.bucket.to_a\\n    @buckets = @buckets.map.with_index{ |m,i| m + received_bucket[i].to_i }\\n  end\\nend\",\n        \"component_description\": \"Merges another Histogram instance into the current one, updating all statistics and buckets in a thread-safe manner using Mutex.\"\n      }\n    ],\n    \"overall_description\": \"Defines a Histogram class used for performance testing and measurement. It includes methods to add values, calculate statistics, determine bucket indices, merge with another histogram, and retrieve various statistical data.\"\n  }\n}"
    }
}